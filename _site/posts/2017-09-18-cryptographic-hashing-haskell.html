<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">

  <head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# article: http://ogp.me/ns/article#">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0" />
  <!-- MUST in hex format, may the same as header-color. This color is for android chrome browser. -->
  <meta name="theme-color" content="#5c6bc0">

  <!-- Metadata. -->
  <meta name="keywords" content="haskell,blog,bigmoon" />
  <title>Haskell で暗号学的ハッシュを扱う</title>
  <meta name="description" content="Great original post: CRYPTOGRAPHIC HASHING IN HASKELL..
2017年 9月 18日 Michael Snoyman
cryptonite は現在、Haskell で暗号を扱う際のデファクトスタンダードです。 一般的に安全な乱数、共通鍵・公開鍵暗号、MAC (メッセー">
  <link rel="canonical" href="../posts/2017-09-18-cryptographic-hashing-haskell.html">
  <link rel="alternate" type="application/atom+xml" title="Haskell で暗号学的ハッシュを扱う" href="../feed.xml" />
  <link rel="shortcut icon" href="../images/favicon.ico" />
  <meta name="google-site-verification" content="X2YNboLvzw3_bclXLMvohyJDqj68D06_hPDMukRbgTs" />

  <!-- Stylesheets. -->
  <link rel="stylesheet" href="../lib/materialize/css/materialize.min.css" />
  <link rel="stylesheet" href="../css/main.css" />
  <link media="all" rel="stylesheet" type="text/css" href="../lib/mdi/css/materialdesignicons.min.css" />
  <link rel="stylesheet" href="../lib/material-scrolltop/material-scrolltop.css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" />

  <!-- OGP -->
  <meta property="og:title" content="Haskell で暗号学的ハッシュを扱う" />
  <meta property="og:type" content="article" />
  <meta property="og:url" content="/posts/2017-09-18-cryptographic-hashing-haskell.html" />
  <!-- <meta property="og:image" content=" サムネイル画像の URL" /> -->
  <meta property="og:site_name" content="Haskell で暗号学的ハッシュを扱う" />
  <meta property="og:description" content="Great original post: CRYPTOGRAPHIC HASHING IN HASKELL..
2017年 9月 18日 Michael Snoyman
cryptonite は現在、Haskell で暗号を扱う際のデファクトスタンダードです。 一般的に安全な乱数、共通鍵・公開鍵暗号、MAC (メッセー" />

  <meta name="twitter:card" content="summary" />
  <!-- <meta name="twitter:site" content="@[ Twitter ID]" /> -->
  <!-- <meta name="twitter:player" content="@[ Twitter ID]" /> -->

  <noscript>
  <div class="notice-warning noscript">You don't have javascript enabled. Good luck! :(</div>
</noscript>

<!--[if IE]>
  <div class="notice-warning">Oh, you are using Internet Explorer! Good luck... :(</div>
<![endif]-->

</head>


  <body>

    <header class="site-header">
      <nav class="nav-extended indigo lighten-1">
        <div class="nav-wrapper">
  <a href="../"><span class="site-title">BIG MOON</span></a>
  <a href="#" data-activates="mobile-navbar" class="button-collapse">
    <i class="mdi mdi-menu white-text"></i>
  </a>

  <ul id="nav-mobile" class="right hide-on-med-and-down">
    <li>
      <a href="../" class="white-text">
        <i class="mdi mdi-home left indigo-text text-lighten-3"></i>
        Home
      </a>
    </li>
    <li>
      <a href="../about.html" class="white-text">
        <i class="mdi mdi-account-circle left indigo-text text-lighten-3"></i>
        About
      </a>
    </li>
    <li>
      <a href="../stack/" class="white-text">
        <i class="mdi mdi-checkerboard left indigo-text text-lighten-3"></i>
        Stack
      </a>
    </li>
    <li>
      <a href="../archive.html" class="white-text">
        <i class="mdi mdi-archive left indigo-text text-lighten-3"></i>
        Archive
      </a>
    </li>
    <li>
      <a href="../feed.xml" class="white-text">
        <i class="mdi mdi-rss left indigo-text text-lighten-3"></i>
        Feed
      </a>
    </li>
  </ul>

  <ul class="side-nav" id="mobile-navbar">
    <li>
      <a href="../" class="waves-effect waves-teal black-text">
        <i class="mdi mdi-home left green-text"></i>
        Home
      </a>
    </li>
    <li>
      <a href="../about.html" class="navbar-text-colour-mobile">
        <i class="mdi mdi-account-circle left blue-text"></i>
        About
      </a>
    </li>
    <li>
      <a href="../stack/" class="navbar-text-colour-mobile">
        <i class="mdi mdi-checkerboard left blue-text"></i>
        Stack
      </a>
    </li>
    <li>
      <a href="../archive.html" class="navbar-text-colour-mobile">
        <i class="mdi mdi-archive left blue-text"></i>
        Archive
      </a>
    </li>
    <li>
      <a href="../feed.xml" class="navbar-text-colour-mobile">
        <i class="mdi mdi-rss left red-text"></i>
        Feed
      </a>
    </li>
  </ul>
</div>

      </nav>
    </header>

    <div class="site-container" id="tab-main">
      <div class="wrapper">
        <div class="post-ribbon"></div>

<div class="container post-container">
  <div class="post-page card-panel z-depth-2">
    <div class="post-section">

      <p class="grey-text">
        <i class="mdi mdi-calendar"></i>&nbsp;
        Posted on September 18, 2017
        
          &nbsp;&nbsp;<i class="mdi mdi-account-circle"></i>&nbsp;
          translated by pythonissam
        
        
          &nbsp;&nbsp;<i class="mdi mdi-account-circle"></i>&nbsp;
          author by Michael Snoyman
        
        &nbsp;
        
          <i class="mdi mdi-folder"></i>&nbsp;
          <span class="capitalize"></span>
          <!-- &emsp;<i class="mdi mdi-refresh"></i>&nbsp;UPDATE: {% if page.update %}{{ page.update | date: "%b %-d, %Y" }}{% else %}{{ page.last_modified_at | date: "%b %-d, %Y" }}{% endif %} -->
        
      </p>

      <div class="post-header">
        <h1 class="post-title">Haskell で暗号学的ハッシュを扱う</h1>

        
          <i class="post-tag mdi mdi-tag-multiple waves-effect waves-light"></i>
          <div class="chip"><a href="../tags/fpcomplete.html">fpcomplete</a>, <a href="../tags/%E7%BF%BB%E8%A8%B3.html">翻訳</a></div>
        
      </div>

      <article class="post-content">
        <p>Great original post: <a href="https://www.fpcomplete.com/blog/2017/09/cryptographic-hashing-haskell">CRYPTOGRAPHIC HASHING IN HASKELL.</a>.</p>
<p>2017年 9月 18日 Michael Snoyman</p>
<p><a href="https://www.stackage.org/package/cryptonite">cryptonite</a> は現在、Haskell で暗号を扱う際のデファクトスタンダードです。 一般的に安全な乱数、共通鍵・公開鍵暗号、MAC (メッセージ認証符号)等をサポートしていて、その中には今日の話題、暗号学的ハッシュも含まれています。</p>
<p>まず、ハッシュ関数について軽く説明しましょう。ハッシュ関数とは、任意長のデータを固定長のデータに変換するものです。暗号学的ハッシュ関数は、暗号を扱う上で望ましい性質をそなえたハッシュ関数です (詳しくは <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">Wikipedia</a> を参照)。 一般的な暗号学的ハッシュ関数の使われ方の一例として、ダウンロードされたファイルが改ざんされていないことを保証するための、チェックサムを提供する、というものがあります。 今日使われている暗号学的ハッシュ関数には、SHA256、Skein512、そしてまぁ、ちょっと古いですが MD5 などがあります。</p>
<p><code>cryptonite</code> は <a href="https://www.stackage.org/package/memory">memory</a> というライブラリの一番上の階層にあります。この <code>memory</code> ライブラリは、Byte 配列を扱うための型クラスと便利な関数を提供しています。 「全て <code>ByteString</code> でいいのでは?」と思うかもしれませんが、後ほどこの型クラスの便利さを示します。</p>
<!--more-->
<p>一旦これら 2つのライブラリに慣れれば、簡単に使いこなすことができます。 ですが、API のドキュメントを見るだけでは、部分部分がどう組み合わさるのか理解するのは至難の技です。特に、どこで明示的な型シグネチャが必要になるのかの理解が難しい。 この記事では、理解に必要な部分について1つ1つの簡単な例を、実行可能なコードで紹介します。 読み進める中で、API のドキュメントについてざっくりと理解していってください。</p>
<p>この記事のコードの例は、全て <code>Stack</code> のスクリプトインタプリタ機能を使っています。 まず <code>Stack</code> を<a href="https://haskell-lang.org/get-started">インストール</a>して、次の手順で実行してください。</p>
<ul>
<li><code>Main.hs</code> にコードをコピペする</li>
<li><code>stack Main.hs</code> を実行</li>
</ul>
<h2 id="基本的な型クラス">基本的な型クラス</h2>
<p>文字列っぽい型を扱うのは慣れているでしょう? 正格・遅延評価される <code>ByteString</code> や <code>Text</code> や普通の <code>String</code> などです。 正格なバイトシーケンスを表現する際、<code>Data.ByteString.ByteString</code> を思い浮かべるのではないでしょうか。 しかし、これから見るように、バイトシーケンスとして扱いたい型はいろいろ見つかります。</p>
<p><code>memory</code> はこの要望に答えるべく、以下の 2つの型クラスを定義しています。</p>
<ul>
<li><code>ByteArrayAccess</code> ある型のバイトへ、読み取り専用のアクセスを提供</li>
<li><code>ByteArray</code> 読み / 書きのアクセスを提供する。<code>ByteArrayAccess</code> の子クラス</li>
</ul>
<p>例えば、以下に示すコードは、意味もなく <code>ByteString</code> と <code>Byte</code> の変換をしています。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteArray</span> <span class="kw">as</span> <span class="dt">BA</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">import</span> <span class="dt">Data.ByteString</span> (<span class="dt">ByteString</span>)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString</span> <span class="kw">as</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  B.writeFile <span class="st">&quot;test.txt&quot;</span> <span class="st">&quot;This is a test&quot;</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  byteString <span class="ot">&lt;-</span> B.readFile <span class="st">&quot;test.txt&quot;</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  <span class="kw">let</span><span class="ot"> bytes ::</span> <span class="dt">BA.Bytes</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">      bytes <span class="fu">=</span> BA.convert byteString</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">  print bytes</a></code></pre></div>
<p><code>bytestring</code> ライブラリを使ってファイルの入出力から話を始めたのは、<a href="http://www.snoyman.com/blog/2016/12/beware-of-readfile">入出力は bytestring でやるべき</a> だからです。 <code>convert</code>関数を使うと、<code>ByteString</code> を <code>Bytes</code> に変換することができます。</p>
<p><strong>練習問題</strong> 上の2つの型クラスの説明を踏まえて <code>convert</code> の型シグネチャは何だと思いますか? 答えは<a href="https://www.stackage.org/haddock/lts-9.4/memory-0.14.7/Data-ByteArray.html#v:convert">こちら</a>。</p>
<p><code>bytes</code> の値につけた、明示的な型シグネチャに気がつきましたか? えーと、<code>memory</code> と <code>cryptonite</code> を使っていく上で、これは大事です。 こうして、よく GHC に、型推論についてのヒントを与えてやらないといけなくなります。 なぜなら、これらのライブラリの中のかなり多くの関数が、具体的な型ではなく、型クラスを使っているからです。</p>
<p>さて、<code>ByteArrayAccess</code> に属する型の例をお見せしましたが、それは<code>ByteArray</code> についての例ではありませんでした。 今は型クラスを分ける意味が分からないかもしれませんが、実際にハッシュを使う段階で、型クラスを分けることの利点が見えてくると思います。 ちょっと待ってくださいね。</p>
<h3 id="なぜ違う型があるのか">なぜ違う型があるのか</h3>
<p>当然、<code>memory</code> の中になぜ <code>Bytes</code> という型があるのか、疑問に思う人もいるでしょうね。 <code>ByteString</code> と同じじゃないの? ってね。 まぁ違うんですけどね。 <code>Bytes</code> はメモリスライスのオフセットと長さを追跡しないことで、メモリのオーバーヘッドを小さくしています。 その代わりに、<code>Bytes</code> の値をスライスすることは許されません。 言い換えれば、<code>Bytes</code> に関する <code>drop</code>関数は、バッファの新しいコピーを作らなければならないということです。</p>
<p>まぁつまり、これはパフォーマンスの問題です。暗号を扱うライブラリは、一般的にパフォーマンスを重視する必要がありますからね。</p>
<p>また別の <code>memory</code> のおもしろい型に、<a href="https://www.stackage.org/haddock/lts-9.4/memory-0.14.7/Data-ByteArray.html#t:ScrubbedBytes"><code>ScrubbedBytes</code></a> というものがあります。 この型は、3つの特別な性質を有しています。 <code>Haddock</code> によると、</p>
<ul>
<li>スコープの範囲から出るとゴシゴシされる</li>
<li><code>Show</code> インスタンスは、中身を何1つとして出力しない</li>
<li>定数時間の <code>Eq</code> インスタンス</li>
</ul>
<p>つまり、これらの性質は何か機密性の高いデータを扱うとき、ありふれた脆弱性をいくつも塞いでくれるものです。</p>
<p>うん、コードがあまりない説明になりましたね。 もっと楽しいことをしよう!</p>
<h2 id="base16-エンコードデコード">Base16 エンコード/デコード</h2>
<p>ユーザの入力を、Base16 (16進数) に変換してみましょう。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteArray</span>          <span class="kw">as</span> <span class="dt">BA</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">import</span>           <span class="dt">Data.ByteArray.Encoding</span> (convertToBase, <span class="dt">Base</span> (<span class="dt">Base16</span>))</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Data.ByteString</span>         (<span class="dt">ByteString</span>)</a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Data.Text.Encoding</span>      (encodeUtf8)</a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.IO</span>            <span class="kw">as</span> <span class="dt">TIO</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">System.IO</span>               (hFlush, stdout)</a>
<a class="sourceLine" id="cb2-9" data-line-number="9"></a>
<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">  putStr <span class="st">&quot;Enter some text: &quot;</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13">  hFlush stdout</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">  text <span class="ot">&lt;-</span> TIO.getLine</a>
<a class="sourceLine" id="cb2-15" data-line-number="15">  <span class="kw">let</span> bs <span class="fu">=</span> encodeUtf8 text</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">  putStrLn <span class="fu">$</span> <span class="st">&quot;You entered: &quot;</span> <span class="fu">++</span> show bs</a>
<a class="sourceLine" id="cb2-17" data-line-number="17">  <span class="kw">let</span> encoded <span class="fu">=</span> convertToBase <span class="dt">Base16</span><span class="ot"> bs ::</span> <span class="dt">ByteString</span></a>
<a class="sourceLine" id="cb2-18" data-line-number="18">  putStrLn <span class="fu">$</span> <span class="st">&quot;Converted to base 16: &quot;</span> <span class="fu">++</span> show encoded</a></code></pre></div>
<p><code>convertToBase</code> は、どんな <code>ByteArrayAccess</code> も、与えられた基数を使って <code>ByteArray</code> に変換することができます。Base16 以外の基数には、Base64 などがあります。</p>
<p>見てお分かりの通り、上の例では明示的に <code>ByteString</code> の型シグネチャを指定する必要がありました。なぜならそうしなければ、GHC が<code>ByteArrayAccess</code> のインスタンスの内、どれを使うべきなのか判断できないからです。</p>
<p>既にお分かりかもしれませんが、全く逆の変換を行う、<code>convertFromBase</code>関数も存在します。 この関数は、入力のフォーマットが正しくなかった場合にも対応できるように、<code>Either String ByteArray</code> の値を返します。</p>
<p><strong>練習問題</strong> 入力に対して、Base16 のデコードを行うプログラムを書いてください (解答はすぐ下)。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteArray</span>          <span class="kw">as</span> <span class="dt">BA</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">import</span>           <span class="dt">Data.ByteArray.Encoding</span> (convertFromBase, <span class="dt">Base</span> (<span class="dt">Base16</span>))</a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Data.ByteString</span>         (<span class="dt">ByteString</span>)</a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Data.Text.Encoding</span>      (encodeUtf8)</a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.IO</span>            <span class="kw">as</span> <span class="dt">TIO</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">System.IO</span>               (hFlush, stdout)</a>
<a class="sourceLine" id="cb3-9" data-line-number="9"></a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12">  putStr <span class="st">&quot;Enter some hexadecimal text: &quot;</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13">  hFlush stdout</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">  text <span class="ot">&lt;-</span> TIO.getLine</a>
<a class="sourceLine" id="cb3-15" data-line-number="15">  <span class="kw">let</span> bs <span class="fu">=</span> encodeUtf8 text</a>
<a class="sourceLine" id="cb3-16" data-line-number="16">  putStrLn <span class="fu">$</span> <span class="st">&quot;You entered: &quot;</span> <span class="fu">++</span> show bs</a>
<a class="sourceLine" id="cb3-17" data-line-number="17">  <span class="kw">case</span> convertFromBase <span class="dt">Base16</span> bs <span class="kw">of</span></a>
<a class="sourceLine" id="cb3-18" data-line-number="18">    <span class="dt">Left</span> e <span class="ot">-&gt;</span> error <span class="fu">$</span> <span class="st">&quot;Invalid input: &quot;</span> <span class="fu">++</span> e</a>
<a class="sourceLine" id="cb3-19" data-line-number="19">    <span class="dt">Right</span> decoded <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb3-20" data-line-number="20">      putStrLn <span class="fu">$</span> <span class="st">&quot;Converted from base 16: &quot;</span> <span class="fu">++</span> show (<span class="ot">decoded ::</span> <span class="dt">ByteString</span>)</a></code></pre></div>
<p><em>練習問題</em> Base16 の入力を、Base64 のエンコードに変換するプログラムを書いてください。</p>
<h2 id="正格な-bytestring-のハッシュ">正格な <code>ByteString</code> のハッシュ</h2>
<p>よし、<code>memory</code> ライブラリに関する説明はもう十分でしょう。 これからは実際に暗号的なものをやっていきます。ユーザの入力を、SHA256 のハッシュ値 (ダイジェスト) に変換してみましょう。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Crypto.Hash</span>             (hash, <span class="dt">SHA256</span> (..), <span class="dt">Digest</span>)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="kw">import</span>           <span class="dt">Data.ByteString</span>         (<span class="dt">ByteString</span>)</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Data.Text.Encoding</span>      (encodeUtf8)</a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.IO</span>            <span class="kw">as</span> <span class="dt">TIO</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="kw">import</span>           <span class="dt">System.IO</span>               (hFlush, stdout)</a>
<a class="sourceLine" id="cb4-8" data-line-number="8"></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-10" data-line-number="10">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11">  putStr <span class="st">&quot;Enter some text: &quot;</span></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">  hFlush stdout</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">  text <span class="ot">&lt;-</span> TIO.getLine</a>
<a class="sourceLine" id="cb4-14" data-line-number="14">  <span class="kw">let</span> bs <span class="fu">=</span> encodeUtf8 text</a>
<a class="sourceLine" id="cb4-15" data-line-number="15">  putStrLn <span class="fu">$</span> <span class="st">&quot;You entered: &quot;</span> <span class="fu">++</span> show bs</a>
<a class="sourceLine" id="cb4-16" data-line-number="16">  <span class="kw">let</span><span class="ot"> digest ::</span> <span class="dt">Digest</span> <span class="dt">SHA256</span></a>
<a class="sourceLine" id="cb4-17" data-line-number="17">      digest <span class="fu">=</span> hash bs</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">  putStrLn <span class="fu">$</span> <span class="st">&quot;SHA256 hash: &quot;</span> <span class="fu">++</span> show digest</a></code></pre></div>
<p>たった今、<code>ByteString</code> (かもしくは <code>ByteArrayAccess</code> のインスタンス) を <code>Digest SHA256</code> に変換するために <code>hash</code> 関数を使いました。 実際、SHA256 以外のハッシュアルゴリズムも指定することができます。</p>
<p>今回の例では、<code>Digest SHA256</code> という型シグネチャが大事でした。GHC にどんなハッシュを使うのか知らせるためです。しかし次の例では、その代わりの関数が登場します。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Crypto.Hash</span>             (hashWith, <span class="dt">SHA256</span> (..))</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="kw">import</span>           <span class="dt">Data.ByteString</span>         (<span class="dt">ByteString</span>)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Data.Text.Encoding</span>      (encodeUtf8)</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.IO</span>            <span class="kw">as</span> <span class="dt">TIO</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="kw">import</span>           <span class="dt">System.IO</span>               (hFlush, stdout)</a>
<a class="sourceLine" id="cb5-8" data-line-number="8"></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">  putStr <span class="st">&quot;Enter some text: &quot;</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">  hFlush stdout</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">  text <span class="ot">&lt;-</span> TIO.getLine</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">  <span class="kw">let</span> bs <span class="fu">=</span> encodeUtf8 text</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">  putStrLn <span class="fu">$</span> <span class="st">&quot;You entered: &quot;</span> <span class="fu">++</span> show bs</a>
<a class="sourceLine" id="cb5-16" data-line-number="16">  <span class="kw">let</span> digest <span class="fu">=</span> hashWith <span class="dt">SHA256</span> bs</a>
<a class="sourceLine" id="cb5-17" data-line-number="17">  putStrLn <span class="fu">$</span> <span class="st">&quot;SHA256 hash: &quot;</span> <span class="fu">++</span> show digest</a></code></pre></div>
<p><code>Digest</code> の <code>Show</code> インスタンスは、ダイジェストを16進数 (Base16) で表示します。これはいいですね。 しかし、これをBase64 で表示したい欲求にかられたらどうでしょう? 考えてみましょう。 <code>Digest</code> は <code>ByteArrayAccess</code> のインスタンスです。なので、<code>convertToBase</code> を使うことができます (そして、<code>Digest</code> は <code>ByteArray</code>のインスタンスではありません。そうしてしまったら問題が生じるのですが、それはなぜでしょうか? 行き詰まったら、<a href="https://www.stackage.org/haddock/lts-9.3/cryptonite-0.23/Crypto-Hash.html#v:digestFromByteString">この関数のドキュメント</a>を読んでみましょう。答えが載っています。)。</p>
<p><strong>練習問題</strong> ダイジェストを Base64 でエンコードされた文字列として出力してみましょう (答えはすぐ下)。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Crypto.Hash</span>             (hashWith, <span class="dt">SHA256</span> (..))</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="kw">import</span>           <span class="dt">Data.ByteString</span>         (<span class="dt">ByteString</span>)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Data.ByteArray.Encoding</span> (convertToBase, <span class="dt">Base</span> (<span class="dt">Base64</span>))</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Data.Text.Encoding</span>      (encodeUtf8)</a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.IO</span>            <span class="kw">as</span> <span class="dt">TIO</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">System.IO</span>               (hFlush, stdout)</a>
<a class="sourceLine" id="cb6-9" data-line-number="9"></a>
<a class="sourceLine" id="cb6-10" data-line-number="10"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">  putStr <span class="st">&quot;Enter some text: &quot;</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  hFlush stdout</a>
<a class="sourceLine" id="cb6-14" data-line-number="14">  text <span class="ot">&lt;-</span> TIO.getLine</a>
<a class="sourceLine" id="cb6-15" data-line-number="15">  <span class="kw">let</span> bs <span class="fu">=</span> encodeUtf8 text</a>
<a class="sourceLine" id="cb6-16" data-line-number="16">  putStrLn <span class="fu">$</span> <span class="st">&quot;You entered: &quot;</span> <span class="fu">++</span> show bs</a>
<a class="sourceLine" id="cb6-17" data-line-number="17">  <span class="kw">let</span> digest <span class="fu">=</span> convertToBase <span class="dt">Base64</span> (hashWith <span class="dt">SHA256</span> bs)</a>
<a class="sourceLine" id="cb6-18" data-line-number="18">  putStrLn <span class="fu">$</span> <span class="st">&quot;SHA256 hash: &quot;</span> <span class="fu">++</span> show (<span class="ot">digest ::</span> <span class="dt">ByteString</span>)</a></code></pre></div>
<p><code>digest</code> が <code>ByteString</code> であることを明確にするために、型シグネチャが必要な理由を押さえてください。</p>
<h2 id="マッチするファイルがあるかどうか調べる">マッチするファイルがあるかどうか調べる</h2>
<p>ここにちょっとしたプログラムがあります。ユーザはコマンドライン引数として、複数個のファイル名を渡します。そして、プログラムは同一の内容の全てのファイルのリストを表示します (少なくとも、SHA256 のハッシュ値がマッチするファイルを。それと、以下の定義には、メモリの効率がよろしくない部分があります。見つけてみてください。この点についてはまた後述します)。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Crypto.Hash</span>             (<span class="dt">Digest</span>, <span class="dt">SHA256</span>, hash)</a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString</span>         <span class="kw">as</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Data.Foldable</span>           (forM_)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Data.Map.Strict</span>         (<span class="dt">Map</span>)</a>
<a class="sourceLine" id="cb7-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span>         <span class="kw">as</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">System.Environment</span>      (getArgs)</a>
<a class="sourceLine" id="cb7-9" data-line-number="9"></a>
<a class="sourceLine" id="cb7-10" data-line-number="10"><span class="ot">readFile' ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Map</span> (<span class="dt">Digest</span> <span class="dt">SHA256</span>) [FilePath])</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">readFile' fp <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-12" data-line-number="12">  bs <span class="ot">&lt;-</span> B.readFile fp</a>
<a class="sourceLine" id="cb7-13" data-line-number="13">  <span class="kw">let</span> digest <span class="fu">=</span> hash bs <span class="co">-- notice lack of type signature :)</span></a>
<a class="sourceLine" id="cb7-14" data-line-number="14">  return <span class="fu">$</span> Map.singleton digest [fp]</a>
<a class="sourceLine" id="cb7-15" data-line-number="15"></a>
<a class="sourceLine" id="cb7-16" data-line-number="16"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-17" data-line-number="17">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-18" data-line-number="18">  args <span class="ot">&lt;-</span> getArgs</a>
<a class="sourceLine" id="cb7-19" data-line-number="19">  m <span class="ot">&lt;-</span> Map.unionsWith (<span class="fu">++</span>) <span class="fu">&lt;$&gt;</span> mapM readFile' args</a>
<a class="sourceLine" id="cb7-20" data-line-number="20">  forM_ (Map.toList m) <span class="fu">$</span> \(digest, files) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-21" data-line-number="21">    <span class="kw">case</span> files <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-22" data-line-number="22">      [] <span class="ot">-&gt;</span> error <span class="st">&quot;can never happen&quot;</span></a>
<a class="sourceLine" id="cb7-23" data-line-number="23">      [_] <span class="ot">-&gt;</span> return () <span class="co">-- only one file</span></a>
<a class="sourceLine" id="cb7-24" data-line-number="24">      <span class="co">--                                     unwords :: [String] -&gt; String</span></a>
<a class="sourceLine" id="cb7-25" data-line-number="25">      _ <span class="ot">-&gt;</span> putStrLn <span class="fu">$</span> show digest <span class="fu">++</span> <span class="st">&quot;: &quot;</span> <span class="fu">++</span> unwords (map show files)</a></code></pre></div>
<p><strong>練習問題</strong> コマンドライン引数として与えられた全てのファイルの SHA256 ハッシュ値を表示するプログラムを書いてください。</p>
<p><strong>質問</strong> 上のコードの、どこが非効率的なのでしょうか? 答えは次の章にあります。</p>
<h2 id="より効率的なファイルハッシュ">より効率的なファイルハッシュ</h2>
<p>もしもハッシュ関数を使わなければ、さっきのプログラムの実装は、それぞれのファイルの中身をメモリ上に一度に展開するか、O(n^2) のペアの比較をするような変なものになっていたでしょう。 さっきのハッシュを使った実装は、それよりも良い実装です。しかし、まだ問題があります。 <code>Data.ByteString.readFile</code>を使っているので、際限なくメモリを使ってしまう可能性があります。 <code>cryptonite-conduit</code> を使うと、ファイルの内容全てをもっと効率良くハッシュできます。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Crypto.Hash</span>         (<span class="dt">Digest</span>, <span class="dt">SHA256</span>, hash)</a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="kw">import</span>           <span class="dt">Crypto.Hash.Conduit</span> (hashFile)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Data.Foldable</span>       (forM_)</a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Data.Map.Strict</span>     (<span class="dt">Map</span>)</a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span>     <span class="kw">as</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">System.Environment</span>  (getArgs)</a>
<a class="sourceLine" id="cb8-9" data-line-number="9"></a>
<a class="sourceLine" id="cb8-10" data-line-number="10"><span class="ot">readFile' ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Map</span> (<span class="dt">Digest</span> <span class="dt">SHA256</span>) [FilePath])</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">readFile' fp <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">  digest <span class="ot">&lt;-</span> hashFile fp</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">  return <span class="fu">$</span> Map.singleton digest [fp]</a>
<a class="sourceLine" id="cb8-14" data-line-number="14"></a>
<a class="sourceLine" id="cb8-15" data-line-number="15"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-17" data-line-number="17">  args <span class="ot">&lt;-</span> getArgs</a>
<a class="sourceLine" id="cb8-18" data-line-number="18">  m <span class="ot">&lt;-</span> Map.unionsWith (<span class="fu">++</span>) <span class="fu">&lt;$&gt;</span> mapM readFile' args</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">  forM_ (Map.toList m) <span class="fu">$</span> \(digest, files) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-20" data-line-number="20">    <span class="kw">case</span> files <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-21" data-line-number="21">      [] <span class="ot">-&gt;</span> error <span class="st">&quot;can never happen&quot;</span></a>
<a class="sourceLine" id="cb8-22" data-line-number="22">      [_] <span class="ot">-&gt;</span> return () <span class="co">-- only one file</span></a>
<a class="sourceLine" id="cb8-23" data-line-number="23">      _ <span class="ot">-&gt;</span> putStrLn <span class="fu">$</span> show digest <span class="fu">++</span> <span class="st">&quot;: &quot;</span> <span class="fu">++</span> unwords (map show files)</a></code></pre></div>
<p>かなりシンプルな変更です (というか、こっちの方が少し読みやすいのではないでしょうか)。 さらに、かなりメモリ効率の良いコードになりました(ファイル数に対して線形時間、ファイルサイズに対しては定数時間です)。</p>
<h2 id="ストリームハッシュ">ストリーム・ハッシュ</h2>
<p><code>conduit</code> と聞いて、耳か目が即座に反応したかもしれません。 質問された体で答えましょう。 はい、ハッシュに関してもストリーミング処理ができます。ここに、URL とファイルパスを受け取って、その URL の response body の中身をファイルパスに書きこみ、SHA256 でダイジェストを表示するプログラムがあります。 そして、それぞれのデータチャンクを 1回しか参照しないのがいいですね。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Crypto.Hash</span>         (<span class="dt">Digest</span>, <span class="dt">SHA256</span>, hash)</a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="kw">import</span> <span class="dt">Crypto.Hash.Conduit</span> (sinkHash)</a>
<a class="sourceLine" id="cb9-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Network.HTTP.Simple</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="kw">import</span> <span class="dt">System.Environment</span>  (getArgs)</a>
<a class="sourceLine" id="cb9-8" data-line-number="8"></a>
<a class="sourceLine" id="cb9-9" data-line-number="9"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-11" data-line-number="11">  args <span class="ot">&lt;-</span> getArgs</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">  (url, fp) <span class="ot">&lt;-</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13">    <span class="kw">case</span> args <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-14" data-line-number="14">      [x, y] <span class="ot">-&gt;</span> return (x, y)</a>
<a class="sourceLine" id="cb9-15" data-line-number="15">      _ <span class="ot">-&gt;</span> error <span class="fu">$</span> <span class="st">&quot;Expected: URL FILEPATH&quot;</span></a>
<a class="sourceLine" id="cb9-16" data-line-number="16">  req <span class="ot">&lt;-</span> parseRequest url</a>
<a class="sourceLine" id="cb9-17" data-line-number="17">  digest <span class="ot">&lt;-</span> runResourceT <span class="fu">$</span> httpSink req <span class="fu">$</span> \_res <span class="ot">-&gt;</span> getZipSink <span class="fu">$</span></a>
<a class="sourceLine" id="cb9-18" data-line-number="18">    <span class="dt">ZipSink</span> (sinkFile fp) <span class="fu">*&gt;</span></a>
<a class="sourceLine" id="cb9-19" data-line-number="19">    <span class="dt">ZipSink</span> sinkHash</a>
<a class="sourceLine" id="cb9-20" data-line-number="20">  print (<span class="ot">digest ::</span> <span class="dt">Digest</span> <span class="dt">SHA256</span>)</a></code></pre></div>
<p><code>conduit</code> にできるなら、もちろんあなたにもできるはずです。 <code>conduit</code> を使わずに、<code>hashFile</code> を実装してみましょう。 こうすることで、ハッシュの API の内部がいくらか分かります。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Crypto.Hash</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="kw">import</span> <span class="dt">System.Environment</span>  (getArgs)</a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="kw">import</span> <span class="dt">System.IO</span> (withBinaryFile, <span class="dt">IOMode</span> (<span class="dt">ReadMode</span>))</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Data.Foldable</span> (forM_)</a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString</span> <span class="kw">as</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8"></a>
<a class="sourceLine" id="cb10-9" data-line-number="9"><span class="ot">hashFile ::</span> <span class="dt">HashAlgorithm</span> ha <span class="ot">=&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Digest</span> ha)</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">hashFile fp <span class="fu">=</span> withBinaryFile fp <span class="dt">ReadMode</span> <span class="fu">$</span> \h <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb10-11" data-line-number="11">  <span class="kw">let</span> loop context <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-12" data-line-number="12">        chunk <span class="ot">&lt;-</span> B.hGetSome h <span class="dv">4096</span></a>
<a class="sourceLine" id="cb10-13" data-line-number="13">        <span class="kw">if</span> B.null chunk</a>
<a class="sourceLine" id="cb10-14" data-line-number="14">          <span class="kw">then</span> return <span class="fu">$</span> hashFinalize context</a>
<a class="sourceLine" id="cb10-15" data-line-number="15">          <span class="kw">else</span> loop <span class="fu">$!</span> hashUpdate context chunk</a>
<a class="sourceLine" id="cb10-16" data-line-number="16">   <span class="kw">in</span> loop hashInit</a>
<a class="sourceLine" id="cb10-17" data-line-number="17"></a>
<a class="sourceLine" id="cb10-18" data-line-number="18"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb10-19" data-line-number="19">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-20" data-line-number="20">  args <span class="ot">&lt;-</span> getArgs</a>
<a class="sourceLine" id="cb10-21" data-line-number="21">  forM_ args <span class="fu">$</span> \fp <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-22" data-line-number="22">    digest <span class="ot">&lt;-</span> hashFile fp</a>
<a class="sourceLine" id="cb10-23" data-line-number="23">    putStrLn <span class="fu">$</span> show (<span class="ot">digest ::</span> <span class="dt">Digest</span> <span class="dt">SHA256</span>) <span class="fu">++</span> <span class="st">&quot;  &quot;</span> <span class="fu">++</span> fp</a></code></pre></div>
<p>この実装では <code>Crypto.Hash</code> で提供されている純粋なハッシュ更新用関数を使っています。 今回の場合、いくつかバッファのコピーをスキップすることで、もう少し効率の良い実装を可能にする、可変ハッシュの関数を使うことができます。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Crypto.Hash</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Crypto.Hash.IO</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5"><span class="kw">import</span> <span class="dt">System.Environment</span>  (getArgs)</a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="kw">import</span> <span class="dt">System.IO</span> (withBinaryFile, <span class="dt">IOMode</span> (<span class="dt">ReadMode</span>))</a>
<a class="sourceLine" id="cb11-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Data.Foldable</span> (forM_)</a>
<a class="sourceLine" id="cb11-8" data-line-number="8"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString</span> <span class="kw">as</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9"></a>
<a class="sourceLine" id="cb11-10" data-line-number="10"><span class="ot">hashFile ::</span> <span class="dt">HashAlgorithm</span> ha <span class="ot">=&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Digest</span> ha)</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">hashFile fp <span class="fu">=</span> withBinaryFile fp <span class="dt">ReadMode</span> <span class="fu">$</span> \h <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-12" data-line-number="12">  context <span class="ot">&lt;-</span> hashMutableInit</a>
<a class="sourceLine" id="cb11-13" data-line-number="13">  <span class="kw">let</span> loop <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-14" data-line-number="14">        chunk <span class="ot">&lt;-</span> B.hGetSome h <span class="dv">4096</span></a>
<a class="sourceLine" id="cb11-15" data-line-number="15">        <span class="kw">if</span> B.null chunk</a>
<a class="sourceLine" id="cb11-16" data-line-number="16">          <span class="kw">then</span> hashMutableFinalize context</a>
<a class="sourceLine" id="cb11-17" data-line-number="17">          <span class="kw">else</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-18" data-line-number="18">            hashMutableUpdate context chunk</a>
<a class="sourceLine" id="cb11-19" data-line-number="19">            loop</a>
<a class="sourceLine" id="cb11-20" data-line-number="20">  loop</a>
<a class="sourceLine" id="cb11-21" data-line-number="21"></a>
<a class="sourceLine" id="cb11-22" data-line-number="22"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb11-23" data-line-number="23">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-24" data-line-number="24">  args <span class="ot">&lt;-</span> getArgs</a>
<a class="sourceLine" id="cb11-25" data-line-number="25">  forM_ args <span class="fu">$</span> \fp <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-26" data-line-number="26">    digest <span class="ot">&lt;-</span> hashFile fp</a>
<a class="sourceLine" id="cb11-27" data-line-number="27">    putStrLn <span class="fu">$</span> show (<span class="ot">digest ::</span> <span class="dt">Digest</span> <span class="dt">SHA256</span>) <span class="fu">++</span> <span class="st">&quot;  &quot;</span> <span class="fu">++</span> fp</a></code></pre></div>
<p><strong>練習問題</strong> 遅延入出力と <code>hashlazy</code>関数を使って、<code>hashFile</code> を実装してください (遅延入出力を支持しているわけじゃないですよ。)。</p>
      </article>

      
      </div>
    </div>

    <footer class="page-footer indigo lighten-1">

  <div class="footer-copyright">

    <div class="container">
      CopyRight © 2017 BIGMOON All Rights Reserved.&nbsp;
      Site proudly generated by <a class="red-text text-accent-1" href="http://jaspervdj.be/hakyll">Hakyll</a>,&nbsp;
      original Jekyll theme by <a class="red-text text-accent-1" href="https://github.com/mumuxme/materialize-jekyll">mumuxme</a>.
    </div>

  </div>

</footer>


    <!-- scrolltop button -->
    <button class="material-scrolltop waves-effect waves-light hide-on-small-only" type="button">
      <i class="mdi mdi-arrow-up-bold small white-text"></i>
    </button>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-19322672-9"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-19322672-9');
    </script>

    <!-- jquery -->
    <script type="text/javascript" src="../lib/jquery-min.js"></script>
    <!-- materialize -->
    <script src="../lib/materialize/js/materialize.min.js"></script>
    <!-- <\!-- Material ScrollTop plugin -\-> -->
    <script src="../lib/material-scrolltop/material-scrolltop.js"></script>
    <!-- main -->
    <script src="../js/init.js"></script>
    <script src="../js/main.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/haskell.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>

</html>
