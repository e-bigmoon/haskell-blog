<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">

  <head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# article: http://ogp.me/ns/article#">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0" />
  <!-- MUST in hex format, may the same as header-color. This color is for android chrome browser. -->
  <meta name="theme-color" content="#5c6bc0">

  <!-- Metadata. -->
  <meta name="keywords" content="haskell,blog,bigmoon" />
  <title>Megaparsec tutorial from IH book (翻訳)</title>
  <meta name="description" content="Great original post: Megaparsec tutorial from IH book
この Megaparsec のチュートリアルは、元々は Intermediate Haskell という本の１つの章のために書かれました。 ここ一年で本が進展していないため、 他の著者は私がスタンドアロンのチュー">
  <link rel="canonical" href="../../posts/2019/07-14-megaparsec-tutorial.html">
  <link rel="alternate" type="application/atom+xml" title="Megaparsec tutorial from IH book (翻訳)" href="../../feed.xml" />
  <link rel="shortcut icon" href="../../images/favicon.ico" />
  <meta name="google-site-verification" content="X2YNboLvzw3_bclXLMvohyJDqj68D06_hPDMukRbgTs" />

  <!-- Stylesheets. -->
  <link rel="stylesheet" href="../../lib/materialize/css/materialize.min.css" />
  <link rel="stylesheet" href="../../css/main.css" />
  <link media="all" rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/MaterialDesign-Webfont/3.3.92/css/materialdesignicons.min.css" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="../../lib/material-scrolltop/material-scrolltop.css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/agate.min.css" />
  

  <!-- OGP -->
  <meta property="og:title" content="Megaparsec tutorial from IH book (翻訳)" />
  <meta property="og:type" content="article" />
  <meta property="og:url" content="/posts/2019/07-14-megaparsec-tutorial.html" />
  <!-- <meta property="og:image" content=" サムネイル画像の URL" /> -->
  <meta property="og:site_name" content="Megaparsec tutorial from IH book (翻訳)" />
  <meta property="og:description" content="Great original post: Megaparsec tutorial from IH book
この Megaparsec のチュートリアルは、元々は Intermediate Haskell という本の１つの章のために書かれました。 ここ一年で本が進展していないため、 他の著者は私がスタンドアロンのチュー" />

  <meta name="twitter:card" content="summary" />
  <!-- <meta name="twitter:site" content="@[ Twitter ID]" /> -->
  <!-- <meta name="twitter:player" content="@[ Twitter ID]" /> -->

  <noscript>
  <div class="notice-warning noscript">You don't have javascript enabled. Good luck! :(</div>
</noscript>

<!--[if IE]>
  <div class="notice-warning">Oh, you are using Internet Explorer! Good luck... :(</div>
<![endif]-->

</head>


  <body>
    <header class="site-header">
      <nav class="nav-extended indigo lighten-1">
        <div class="nav-wrapper">
  <a href="../../"><span class="site-title">BIGMOON Haskeller's BLOG</span></a>
  <a href="#" data-activates="mobile-navbar" class="button-collapse">
    <i class="mdi mdi-menu white-text"></i>
  </a>

  <ul id="nav-mobile" class="right hide-on-med-and-down">
    <li>
      <a href="../../" class="white-text">
        <i class="mdi mdi-home left indigo-text text-lighten-3"></i>
        Home
      </a>
    </li>
    <li>
      <a href="../../about.html" class="white-text">
        <i class="mdi mdi-account-circle left indigo-text text-lighten-3"></i>
        About
      </a>
    </li>
    <li>
      <a href="../../stack/" class="white-text">
        <i class="mdi mdi-wrench left indigo-text text-lighten-3"></i>
        Development
      </a>
    </li>
    <li>
      <a href="../../quiz/index.html" class="white-text">
        <i class="mdi mdi-comment-question-outline left indigo-text text-lighten-3"></i>
        Quiz
      </a>
    </li>
    <li>
      <a href="../../libraries/" class="white-text">
        <i class="mdi mdi-package-variant left indigo-text text-lighten-3"></i>
        Libraries
      </a>
    </li>
    <li>
      <a href="../../yesod/" class="white-text">
        <i class="mdi mdi-earth left indigo-text text-lighten-3"></i>
        Yesod
      </a>
    </li>
    <li>
      <a href="../../contact.html" class="white-text">
        <i class="mdi mdi-lead-pencil left indigo-text text-lighten-3"></i>
        Contact
      </a>
    </li>
    <li>
      <a href="../../feed.xml" class="white-text">
        <i class="mdi mdi-rss left indigo-text text-lighten-3"></i>
        Feed
      </a>
    </li>
  </ul>

  <ul class="side-nav" id="mobile-navbar">
    <li>
      <a href="../../" class="waves-effect waves-teal black-text">
        <i class="mdi mdi-home left green-text"></i>
        Home
      </a>
    </li>
    <li>
      <a href="../../about.html" class="navbar-text-colour-mobile">
        <i class="mdi mdi-account-circle left blue-text"></i>
        About
      </a>
    </li>
    <li>
      <a href="../../stack/" class="navbar-text-colour-mobile">
        <i class="mdi mdi-wrench left blue-text"></i>
        Development
      </a>
    </li>
    <li>
      <a href="../../quiz/" class="navbar-text-colour-mobile">
        <i class="mdi mdi-comment-question-outline left blue-text"></i>
        Quiz
      </a>
    </li>
    <li>
      <a href="../../libraries/" class="navbar-text-colour-mobile">
        <i class="mdi mdi-package-variant left blue-text"></i>
        Libraries
      </a>
    </li>
    <li>
      <a href="../../yesod/" class="navbar-text-colour-mobile">
        <i class="mdi mdi-earth left blue-text"></i>
        Yesod
      </a>
    </li>
    <li>
      <a href="../../contact.html" class="navbar-text-colour-mobile">
        <i class="mdi mdi-lead-pencil left blue-text"></i>
        Contact
      </a>
    </li>
  </ul>
</div>

      </nav>
    </header>

    <div class="site-container" id="tab-main">
      <div class="wrapper">
        <div class="post-ribbon"></div>

<div class="container post-container">
  <div class="post-page card-panel z-depth-2">
    <div class="post-section">

      <p class="grey-text">
        <i class="mdi mdi-calendar"></i>&nbsp;
        Posted on July 14, 2019
        
          &nbsp;&nbsp;<i class="mdi mdi-account-circle"></i>&nbsp;
          translated by Wataru Yamada
        
        
          &nbsp;&nbsp;<i class="mdi mdi-account-circle"></i>&nbsp;
          authored by Mark Karpov
        
        &nbsp;
        
          <i class="mdi mdi-folder"></i>&nbsp;
          <span class="capitalize"></span>
          <!-- &emsp;<i class="mdi mdi-refresh"></i>&nbsp;UPDATE: {% if page.update %}{{ page.update | date: "%b %-d, %Y" }}{% else %}{{ page.last_modified_at | date: "%b %-d, %Y" }}{% endif %} -->
        
      </p>

      <div class="post-header">
        <h1 class="post-title">Megaparsec tutorial from IH book (翻訳)</h1>

        <div class="row">
        
          <div class="col s6">
            <i class="post-tag mdi mdi-tag-multiple waves-effect waves-light"></i>
            <div class="chip"><a title="All pages tagged 'megaparsec'." href="../../tags/megaparsec.html">megaparsec</a>, <a title="All pages tagged 'package'." href="../../tags/package.html">package</a>, <a title="All pages tagged '翻訳'." href="../../tags/%E7%BF%BB%E8%A8%B3.html">翻訳</a></div>
          </div>
        

          <div class="col s6">
            <div style="position: relative; top: 70px;">
            <div class="fixed-action-btn horizontal" style="position: absolute; display: inline-block; right: 24px;">
  <a class="btn-floating btn-large red">
    <i class="large material-icons">share</i>
  </a>
  <ul>
    <li>
      <a class="btn-floating waves-effect waves-light blue tooltipped" data-position="bottom" data-delay="20" data-tooltip="Share on Twitter" href="https://twitter.com/intent/tweet?text=Megaparsec tutorial from IH book (翻訳)&url=https://haskell.e-bigmoon.com/posts/2019/07-14-megaparsec-tutorial.html"><i class="mdi mdi-twitter white-text"></i></a>
    </li>
    <li>
      <a class="btn-floating waves-effect waves-light indigo tooltipped" data-position="bottom" data-delay="20" data-tooltip="Share on Facebook" href="https://facebook.com/sharer.php?u=https://haskell.e-bigmoon.com/posts/2019/07-14-megaparsec-tutorial.html"><i class="mdi mdi-facebook white-text"></i></a>
    </li>
    <li>
      <a class="btn-floating waves-effect waves-light red tooltipped" data-position="bottom" data-delay="20" data-tooltip="Share on Google+" href="https://plus.google.com/share?url=https://haskell.e-bigmoon.com/posts/2019/07-14-megaparsec-tutorial.html"><i class="mdi mdi-google-plus white-text"></i></a>
    </li>
  </ul>
</div>
            </div>
          </div>
        </div>
      </div>

      <article class="post-content">
        <p>Great original post: <a href="https://markkarpov.com/megaparsec/megaparsec.html">Megaparsec tutorial from IH book</a></p>
<p>この Megaparsec のチュートリアルは、元々は <a href="https://intermediatehaskell.com/">Intermediate Haskell</a> という本の１つの章のために書かれました。 ここ一年で本が進展していないため、 他の著者は私がスタンドアロンのチュートリアルとしてテキストを公表し、 人々が少なくとも私たちの仕事のこの部分から恩恵を受けることができるようにする ことに同意しました。</p>
<!--more-->
<ul>
<li><a href="#ParsecT"><code>ParsecT</code> と <code>Parsec</code> モナド</a></li>
<li><a href="#Character">文字 とバイナリストリーム</a></li>
<li><a href="#MonaAp">モナディック構文とアプリカティブ構文</a></li>
<li><a href="#Eof"><code>Eof</code> による入力の強制消費</a></li>
<li><a href="#Alt">選択肢を使った動作</a></li>
<li><a href="#Try"><code>try</code> によるバックトラックの制御</a></li>
<li><a href="#Debug">パーサのデバッグ</a></li>
<li><a href="#Label">ラベル付けと隠蔽</a></li>
<li><a href="#Run">パーサの実行</a></li>
<li><a href="#MonadParsec"><code>MonadParsec</code> 型クラス</a></li>
<li><a href="#Lexing">字句解析</a>
<ul>
<li><a href="#White">空白</a></li>
<li><a href="#Char">文字と文字列リテラル</a></li>
<li><a href="#Numbers">数字</a></li>
</ul></li>
<li><a href="#lookAhead"><code>notFollowedBy</code> と <code>lookAhead</code></a></li>
<li><a href="#Expr">式のパース</a></li>
<li><a href="#Indentation">Indentation-sensitiveなパース</a>
<ul>
<li><a href="#nonIndented"><code>nonIndented</code> と <code>indentBlock</code></a></li>
<li><a href="#SimpleIndented">単純なインデントされたリスト</a></li>
<li><a href="#NestedIndented">ネストされたインデントのあるリスト</a></li>
<li><a href="#LineFolds">折り返しの追加</a></li>
</ul></li>
<li><a href="#Efficient">効率のよいパーサを書く</a></li>
<li><a href="#Error">パースエラー</a>
<ul>
<li><a href="#ErrDef">パースエラーの定義</a></li>
<li><a href="#SigErr">パースエラーを通知する方法</a></li>
<li><a href="#DispErr">パースエラーの表示</a></li>
<li><a href="#CatchErr">パーサ実行時にパースエラーをキャッチする</a></li>
<li><a href="#Control">パースエラー位置のコントロール</a></li>
<li><a href="#Multi">複数のパースエラーを報告する</a></li>
</ul></li>
<li><a href="#Testing">Megaparsecパーサのテスト</a></li>
<li><a href="#CustomInput">カスタム入力ストリームの操作</a></li>
</ul>
<p>「例：あなた自身のパーサコンビネータを書く」の章で開発されたトイパーサコンビネータは、実際の使用には適していないので、 同じ問題を解決するHaskellエコシステムのライブラリを見ていきましょう。 そして、それらがなすさまざまなトレードオフに注意してください。</p>
<ul>
<li><p><a href="https://hackage.haskell.org/package/parsec">parsec</a> は長い間 Haskellの「デフォルト」のパーサライブラリでした。このライブラリは、エラーメッセージの品質に焦点を当てていると言われています。ただし、テストカバレッジは良くなく、現在メンテナンスモードになっています。</p></li>
<li><p><a href="https://hackage.haskell.org/package/attoparsec">attoparsec</a> は、パフォーマンスを重視した堅牢で高速なパーサライブラリです。このリストの中で、インクリメンタルパージングを完全にサポートしているのはこれだけです。欠点はエラーメッセージの質が悪いこと、モナド変換子として使用できないこと、および入力ストリームとして使用できる型の組み合わせが限られていることです。</p></li>
<li><p><a href="https://hackage.haskell.org/package/trifecta">trifecta</a> は優れたエラーメッセージを特徴としていますが、あまり文書化されておらず、理解するのが難しいです。 <code>String</code> と <code>ByteString</code> はそのままではパースできますが、<code>Text</code> はパースできません。</p></li>
<li><p><a href="https://hackage.haskell.org/package/megaparsec">megaparsec</a> は、ここ数年で積極的に開発されてきた <code>parsec</code> のフォークです。現在のバージョンは、速度、柔軟性、パースエラーの品質の間で素晴らしいバランスを取ろうとしました。 <code>parsec</code> の非公式の後継者として、<code>parsec</code> ライブラリを使用したことがあるか、チュートリアルを読んだことがあるユーザにとっては慣習的でなじみのあるものです。</p></li>
</ul>
<p>これらすべてのライブラリを網羅しようとするのは現実的ではないため、 <code>megaparsec</code> に焦点を当てます。より正確には、この本が出版される時までにはほとんどどこでも古いバージョンに取って代わるであろうバージョン8をカバーするつもりです。</p>
<p><a name="ParsecT"></a></p>
<h2 id="parsect-と-parsec-モナド">ParsecT と Parsec モナド</h2>
<p><code>ParsecT</code>は、主要なパーサモナド変換子であり、<code>megaparsec</code> の中心的なデータ型です。 <code>ParsecT e s m a</code> は、次のようにパラメータ化されています。</p>
<ul>
<li><p><code>e</code> はエラーメッセージのカスタムコンポーネントの型です。もし私たちが何もカスタムを望まないのであれば（そして今のところ私たちはしません）、 <code>Data.Void</code> モジュールの <code>Void</code> を使うだけです。</p></li>
<li><p><code>s</code> は入力ストリームの型です。 <code>megaparsec</code> は、<code>String</code>、正格または遅延 <code>Text</code> 、 正格または遅延 <code>ByteStrings</code> をそのまま使用して動作します。カスタム入力ストリームを扱うことも可能です。</p></li>
<li><p><code>m</code> は <code>ParsecT</code> モナド変換子の内部モナドです。</p></li>
<li><p><code>a</code> はパース結果であるモナディック値です。</p></li>
</ul>
<p>ほとんどの場合、<code>m</code> は <code>Identity</code> に他ならないので、<code>Parsec</code> 型シノニムは非常に便利です。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">type</span> <span class="dt">Parsec</span> e s a <span class="ot">=</span> <span class="dt">ParsecT</span> e s <span class="dt">Identity</span> a</span></code></pre></div>
<p><code>Parsec</code> は、単なる <code>ParsecT</code>の変換子を使わないバージョンです。</p>
<p><code>megaparsec</code> のモナド変換子と MTL のモナド変換子およびクラスの間の類似点を示すこともできます。 確かに、<code>MonadState</code> や <code>MonadReader</code> などの型クラスと目的が似ている <code>MonadParsec</code> 型クラスがあります。 後で <code>MonadParsec</code> に戻り、詳細について説明します。</p>
<p>カスタムした型シノニムを定義することは <code>megaparsec</code> を使ってパーサを書くことを始める最も良い方法です。 これは次の2つの理由から良い考えです。</p>
<ul>
<li><p>あなたのパーサモナドとして <code>Parser</code> があれば、<code>Parser Int</code> のようなトップレベルのシグネチャを追加することがより簡単になります。シグネチャがないと、<code>e</code> のようなものが曖昧になることがよくあります。これはライブラリの多相APIの反面です。</p></li>
<li><p>すべての型変数を具体的な方に固定して操作すると、GHCの最適化が大幅に向上します。パーサが多相性を保っている場合、GHCは最適化の観点からそれほど多くのことはできません。<code>megaparsec</code> APIは多相ですが、エンドユーザーは具体的にパーサモナドの型を固定することが予想されます。そのため、インライン展開と、ほとんどの関数の定義がインターフェイスファイルと呼ばれるファイルに出力されているという事実により、GHCは非常に効率的な非多相的なコードを生成できます。</p></li>
</ul>
<p>次のように型シノニム（通常は <code>Parser</code> と呼ばれる）を定義しましょう。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a>ype <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Void</span> <span class="dt">Text</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="co">--                   ^    ^</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="co">--                   |    ┗━━━━┓</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="co">-- カスタムエラーコンポーネント  入力ストリームの型</span></span></code></pre></div>
<p>カスタムパースエラーを扱い始めるまでは、この章で <code>Parser</code>が表示されているときは、この型を想定してください。</p>
<p><a name="Character"></a></p>
<h2 id="文字とバイナリストリーム">文字とバイナリストリーム</h2>
<p><code>megaparsec</code> は、5種類の入力ストリーム（<code>String</code>、正格または遅延 <code>Text</code> 、 正格または遅延 <code>ByteStrings</code>）をそのまま使用できると言われています。 これが可能なのは、ライブラリでこれらの型が <code>Stream</code> 型クラスのインスタンスになっているからです。 <code>Stream</code> 型クラスはそれぞれのデータ型が <code>megaparsec</code> のパーサへの入力として使用するために必要な関数を抽象化したものです。</p>
<p>シンプルにしたバージョンの <code>Stream</code> は、次のようになります。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">class</span> <span class="dt">Stream</span> s <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>  <span class="kw">type</span> <span class="dt">Token</span><span class="ot">  s ::</span> <span class="op">*</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>  <span class="kw">type</span> <span class="dt">Tokens</span><span class="ot"> s ::</span> <span class="op">*</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="ot">  take1_ ::</span> s <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Token</span> s, s) <span class="co">-- aka uncons</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="ot">  tokensToChunk ::</span> <span class="dt">Proxy</span> s <span class="ot">-&gt;</span> [<span class="dt">Token</span> s] <span class="ot">-&gt;</span> <span class="dt">Tokens</span> s</span></code></pre></div>
<p>実際の <code>Stream</code> の定義にはもっと多くのメソッドがありますが、それらを知ることはライブラリを使うために必要ではありません。</p>
<p>型クラスには2つの型関数が関連付けられています。</p>
<ul>
<li><p>ストリーム <code>s</code> における <code>Token s</code> は単一トークンの型です。一般的な例は <code>Char</code> と <code>Word8</code> ですが、カスタムストリームのために何か他のものになるかもしれません。</p></li>
<li><p>ストリーム <code>s</code> における <code>Tokens s</code> はストリームの「チャンク」の型です。チャンクの概念はパフォーマンス上の理由から導入されただけです。確かに、トークンのリスト <code>[Token s]</code> と同型であるストリームの一部のより効率的な表現が可能です。例えば、 <code>Text</code> 型の入力ストリームは <code>Tokens s ~ Text</code> であり、<code>Text</code> のチャンクは <code>Text</code> です。型の等価性 <code>Tokens s ~ s</code> はしばしば成り立ちますが、 <code>Tokens s</code> と <code>s</code> はカスタムストリームでは異なる可能性があるため、<code>megaparsec</code> ではこれらの型を分離します。</p></li>
</ul>
<p>デフォルトの入力ストリームの型を以下の表に示します。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><code>s</code></th>
<th style="text-align: left;"><code>Token s</code></th>
<th style="text-align: left;"><code>Tokens s</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>String</code></td>
<td style="text-align: left;"><code>Char</code></td>
<td style="text-align: left;"><code>String</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">正格 <code>Text</code></td>
<td style="text-align: left;"><code>Char</code></td>
<td style="text-align: left;">正格 <code>Text</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">遅延 <code>Text</code></td>
<td style="text-align: left;"><code>Char</code></td>
<td style="text-align: left;">遅延 <code>Text</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">正格 <code>ByteString</code></td>
<td style="text-align: left;"><code>Word8</code></td>
<td style="text-align: left;">正格 <code>ByteString</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">遅延 <code>ByteString</code></td>
<td style="text-align: left;"><code>Word8</code></td>
<td style="text-align: left;">遅延 <code>ByteString</code></td>
</tr>
</tbody>
</table>
<p><code>Token</code> および <code>Tokens</code> 型関数は <code>megaparsec</code> API の型にて 多く出現するため、慣れることが重要です。</p>
<p>お気づきかもしれませんが、デフォルト入力ストリームを<code>Token</code>型でグループ化すると、2つのグループになります。</p>
<ul>
<li><p><code>Token s ~ Char</code> となる文字ストリーム : <code>String</code> および 正格・遅延 <code>Text</code>。</p></li>
<li><p><code>Token s ~ Word8</code> となるバイナリストリーム : 正格・遅延 <code>ByteString</code>。</p></li>
</ul>
<p><code>megaparsec</code> では、それぞれの型の入力ストリームに対して同じパーサをコーディングする必要はないことがわかりました。 (<code>attoparsec</code> ライブラリではする必要があります) しかし、それぞれの <code>Token s</code> ごとに異なるコードが必要です。</p>
<ul>
<li><p>文字ストリームの共通のコンビネータを得るには、<code>Text.Megaparsec.Char</code> モジュールをインポートしてください。</p></li>
<li><p>バイナリストリームで同じようにするには、<code>Text.Megaparsec.Byte</code>をインポートします。</p></li>
</ul>
<p>これらのモジュールには、次のような2つの類似したヘルパーパーサのセットが含まれています。</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Name</strong></th>
<th style="text-align: left;"><code>Text.Megaparsec.Char</code></th>
<th style="text-align: left;"><code>Text.Megaparsec.Byte</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>newline</code></td>
<td style="text-align: left;"><code>(MonadParsec e s m, Token s ~ Char) =&gt; m (Token s)</code></td>
<td style="text-align: left;"><code>(MonadParsec e s m, Token s ~ Word8) =&gt; m (Token s)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>eol</code></td>
<td style="text-align: left;"><code>(MonadParsec e s m, Token s ~ Char) =&gt; m (Tokens s)</code></td>
<td style="text-align: left;"><code>(MonadParsec e s m, Token s ~ Word8) =&gt; m (Tokens s)</code></td>
</tr>
</tbody>
</table>
<p>このモジュールを構築するプリミティブをいくつか紹介しましょう。そうすれば、これから使用するツールを理解できます。</p>
<p>最初のプリミティブは<code>token</code>と呼ばれ、<code>Token s</code>をパースすることができます。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="ot">token ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb4-2"><a href="#cb4-2"></a>  <span class="ot">=&gt;</span> (<span class="dt">Token</span> s <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a)</span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="co">-- ^ Matching function for the token to parse</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>  <span class="ot">-&gt;</span> <span class="dt">Set</span> (<span class="dt">ErrorItem</span> (<span class="dt">Token</span> s))</span>
<span id="cb4-5"><a href="#cb4-5"></a>     <span class="co">-- ^ Expected items (in case of an error)</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>  <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p><code>token</code> の最初の引数はパースしたいトークンのマッチング関数です。 関数が<code>Just</code>で何かを返す場合、その値はパース結果になります。 <code>Nothing</code> はパーサがトークンを受理しなかったことによりプリミティブが失敗したこと示します。</p>
<p>2番目の引数は、（<code>container</code>パッケージの）<code>Set</code> であり、失敗した場合にユーザーに表示されるすべての予想されるErrorItemを含みます。 パースエラーについて議論するときに、<code>ErrorItem</code> 型を詳しく調べます。</p>
<p>トークンがどのように機能するのかをよりよく理解するために、 <code>Text.Megaparsec</code> モジュールの定義を見てみましょう。 これにはあらゆる種類の入力ストリームで 機能するコンビネータが含まれています。 <code>satisfy</code>はかなり一般的なコンビネータです。 マッチさせたいトークンを与えると <code>True</code> を返す述語を与え、 パーサは結果を返します。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="ot">satisfy ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb5-2"><a href="#cb5-2"></a>  <span class="ot">=&gt;</span> (<span class="dt">Token</span> s <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="co">-- ^ Predicate to apply</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>  <span class="ot">-&gt;</span> m (<span class="dt">Token</span> s)</span>
<span id="cb5-4"><a href="#cb5-4"></a>satisfy f <span class="ot">=</span> token testToken Set.empty</span>
<span id="cb5-5"><a href="#cb5-5"></a>  <span class="kw">where</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>    testToken x <span class="ot">=</span> <span class="kw">if</span> f x <span class="kw">then</span> <span class="dt">Just</span> x <span class="kw">else</span> <span class="dt">Nothing</span></span></code></pre></div>
<p><code>testToken</code> は <code>Bool</code> を返す関数 <code>f</code> を 期待するトークン <code>Maybe (Token s)</code> を返す関数に変えます。 <code>satisfy</code> では、 一致すると予想される正確なトークン列がわからないため、 2番目の引数として <code>Set.empty</code> を渡します。</p>
<p><code>satisfy</code> を理解するために、機能するか見てみましょう。 パーサで遊ぶためには、それを実行するヘルパー関数が必要です。 GHCiでテストするために <code>megaparsec</code> は <code>parseTest</code> を提供します。</p>
<p>まず、GHCiを起動していくつかのモジュールをインポートしましょう。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1"></a>λ<span class="op">&gt;</span> <span class="ex">import</span> Text.Megaparsec</span>
<span id="cb6-2"><a href="#cb6-2"></a>λ<span class="op">&gt;</span> <span class="ex">import</span> Text.Megaparsec.Char</span>
<span id="cb6-3"><a href="#cb6-3"></a>λ<span class="op">&gt;</span> <span class="ex">import</span> Data.Text (Text)</span>
<span id="cb6-4"><a href="#cb6-4"></a>λ<span class="op">&gt;</span> <span class="ex">import</span> Data.Void</span></code></pre></div>
<p>パーサの型のあいまいさを解決するために、 使用する <code>Parser</code> 型シノニムを追加します。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1"></a>λ<span class="op">&gt;</span> <span class="bu">type</span> Parser = Parsec Void Text</span></code></pre></div>
<p>また、文字列リテラルを <code>Text</code> の値として使用できるように、<code>OverloadedStrings</code> 言語拡張を有効にする必要があります。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1"></a>λ<span class="op">&gt;</span> :<span class="ex">set</span> -XOverloadedStrings</span>
<span id="cb8-2"><a href="#cb8-2"></a></span>
<span id="cb8-3"><a href="#cb8-3"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (satisfy (== <span class="st">'a'</span>) :: <span class="ex">Parser</span> Char) <span class="st">&quot;&quot;</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="ex">1</span>:1:</span>
<span id="cb8-5"><a href="#cb8-5"></a>  <span class="kw">|</span></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="ex">1</span> <span class="kw">|</span> <span class="op">&lt;</span><span class="ex">empty</span> line<span class="op">&gt;</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>  <span class="kw">|</span> ^</span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="ex">unexpected</span> end of input</span>
<span id="cb8-9"><a href="#cb8-9"></a></span>
<span id="cb8-10"><a href="#cb8-10"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (satisfy (== <span class="st">'a'</span>) :: <span class="ex">Parser</span> Char) <span class="st">&quot;a&quot;</span></span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="st">'a'</span></span>
<span id="cb8-12"><a href="#cb8-12"></a></span>
<span id="cb8-13"><a href="#cb8-13"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (satisfy (== <span class="st">'a'</span>) :: <span class="ex">Parser</span> Char) <span class="st">&quot;b&quot;</span></span>
<span id="cb8-14"><a href="#cb8-14"></a><span class="ex">1</span>:1:</span>
<span id="cb8-15"><a href="#cb8-15"></a>  <span class="kw">|</span></span>
<span id="cb8-16"><a href="#cb8-16"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">b</span></span>
<span id="cb8-17"><a href="#cb8-17"></a>  <span class="kw">|</span> ^</span>
<span id="cb8-18"><a href="#cb8-18"></a><span class="ex">unexpected</span> <span class="st">'b'</span></span>
<span id="cb8-19"><a href="#cb8-19"></a></span>
<span id="cb8-20"><a href="#cb8-20"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (satisfy (<span class="op">&gt;</span> <span class="st">'c'</span>) :: <span class="ex">Parser</span> Char) <span class="st">&quot;a&quot;</span></span>
<span id="cb8-21"><a href="#cb8-21"></a><span class="ex">1</span>:1:</span>
<span id="cb8-22"><a href="#cb8-22"></a>  <span class="kw">|</span></span>
<span id="cb8-23"><a href="#cb8-23"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">a</span></span>
<span id="cb8-24"><a href="#cb8-24"></a>  <span class="kw">|</span> ^</span>
<span id="cb8-25"><a href="#cb8-25"></a><span class="ex">unexpected</span> <span class="st">'a'</span></span>
<span id="cb8-26"><a href="#cb8-26"></a></span>
<span id="cb8-27"><a href="#cb8-27"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (satisfy (<span class="op">&gt;</span> <span class="st">'c'</span>) :: <span class="ex">Parser</span> Char) <span class="st">&quot;d&quot;</span></span>
<span id="cb8-28"><a href="#cb8-28"></a><span class="st">'d'</span></span></code></pre></div>
<p><code>satisfy</code> の多相性により、 <code>parseTest</code> は <code>MonadParsec e s m</code> で <code>e</code> と <code>s</code> に何を使うべきかわからないため、 アノテーション <code>:: Parser Char</code> は必要です (<code>m</code> はこれらのヘルパーにより <code>Identity</code> と仮定されます)。 型シグネチャを持つ既存のパーサを使う場合、 パーサの型を明示的に説明する必要はありません。</p>
<p>うまくいきそうです。 <code>satisfy</code> の問題は、 それが失敗したときに何が期待されるのかを述べないということです。 なぜなら、 <code>satisfy</code> の呼び出し元が提供する関数を分析することができないからです。 あまり一般的ではないですが、 もっと有用なエラーメッセージを生成することができる 他のコンビネータがあります。 例えば、<code>single</code> (<code>Text.Megaparsec.Byte</code> と <code>Text.Megaparsec.Char</code> では <code>char</code> と呼ばれる型制約のあるシノニムを使用する) は特定のトークン値にマッチします。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1"></a><span class="ex">single</span> :: MonadParsec e s m</span>
<span id="cb9-2"><a href="#cb9-2"></a>  =<span class="op">&gt;</span> <span class="ex">Token</span> s           -- ^ Token to match</span>
<span id="cb9-3"><a href="#cb9-3"></a>  <span class="ex">-</span><span class="op">&gt;</span> m (Token s)</span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="ex">single</span> t = token testToken expected</span>
<span id="cb9-5"><a href="#cb9-5"></a>  <span class="ex">where</span></span>
<span id="cb9-6"><a href="#cb9-6"></a>    <span class="ex">testToken</span> x = if x == t then Just x else Nothing</span>
<span id="cb9-7"><a href="#cb9-7"></a>    <span class="ex">expected</span>    = E.singleton (Tokens (t:<span class="kw">|</span>[]))</span></code></pre></div>
<p><code>Tokens</code> 値コンストラクタは、前に説明した型関数 <code>Tokens</code> と何の共通点もありません。 実際、 <code>Tokens</code> は <code>ErrorItem</code> のコンストラクタの1つであり、 一致すると予想される具体的なトークン列 を指定するために使用されます。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (char <span class="st">'a'</span> :: Parser Char) <span class="st">&quot;b&quot;</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="ex">1</span>:1:</span>
<span id="cb10-3"><a href="#cb10-3"></a>  <span class="kw">|</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">b</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>  <span class="kw">|</span> ^</span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="ex">unexpected</span> <span class="st">'b'</span></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="ex">expecting</span> <span class="st">'a'</span></span>
<span id="cb10-8"><a href="#cb10-8"></a></span>
<span id="cb10-9"><a href="#cb10-9"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (char <span class="st">'a'</span> :: Parser Char) <span class="st">&quot;a&quot;</span></span>
<span id="cb10-10"><a href="#cb10-10"></a><span class="st">'a'</span></span></code></pre></div>
<p>以下のようにの改行を定義できます。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1"></a><span class="ex">newline</span> :: (MonadParsec e s m, Token s ~ Char) =<span class="op">&gt;</span> <span class="ex">m</span> (Token s)</span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="ex">newline</span> = single <span class="st">'\n'</span></span></code></pre></div>
<p>2つ目のプリミティブは<code>tokens</code>と呼ばれ、 <code>Tokens s</code> をパースすることを可能にします。 つまり、入力の固定されたチャンクに一致させるために使用できます。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1"></a><span class="ex">tokens</span> :: MonadParsec e s m</span>
<span id="cb12-2"><a href="#cb12-2"></a>  =<span class="op">&gt;</span> <span class="kw">(</span><span class="ex">Tokens</span> s -<span class="op">&gt;</span> Tokens s -<span class="op">&gt;</span> Bool<span class="kw">)</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>    <span class="ex">--</span> ^ チャンクの等価性をチェックする述語</span>
<span id="cb12-4"><a href="#cb12-4"></a>  <span class="ex">-</span><span class="op">&gt;</span> Tokens s</span>
<span id="cb12-5"><a href="#cb12-5"></a>    <span class="ex">--</span> ^ 入力にマッチさせたいチャンク</span>
<span id="cb12-6"><a href="#cb12-6"></a>  <span class="ex">-</span><span class="op">&gt;</span> m (Tokens s)</span></code></pre></div>
<p><code>tokens</code> に関して定義された2つのパーサがあります。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="co">-- from &quot;Text.Megaparsec&quot;:</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="ot">chunk ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb13-3"><a href="#cb13-3"></a>  <span class="ot">=&gt;</span> <span class="dt">Tokens</span> s</span>
<span id="cb13-4"><a href="#cb13-4"></a>  <span class="ot">-&gt;</span> m (<span class="dt">Tokens</span> s)</span>
<span id="cb13-5"><a href="#cb13-5"></a>chunk <span class="ot">=</span> tokens (<span class="op">==</span>)</span>
<span id="cb13-6"><a href="#cb13-6"></a></span>
<span id="cb13-7"><a href="#cb13-7"></a><span class="co">-- from &quot;Text.Megaparsec.Char&quot; and &quot;Text.Megaparsec.Byte&quot;:</span></span>
<span id="cb13-8"><a href="#cb13-8"></a><span class="ot">string' ::</span> (<span class="dt">MonadParsec</span> e s m, <span class="dt">CI.FoldCase</span> (<span class="dt">Tokens</span> s))</span>
<span id="cb13-9"><a href="#cb13-9"></a>  <span class="ot">=&gt;</span> <span class="dt">Tokens</span> s</span>
<span id="cb13-10"><a href="#cb13-10"></a>  <span class="ot">-&gt;</span> m (<span class="dt">Tokens</span> s)</span>
<span id="cb13-11"><a href="#cb13-11"></a>string' <span class="ot">=</span> tokens ((<span class="op">==</span>) <span class="ot">`on`</span> CI.mk)</span></code></pre></div>
<p>それらは入力の一定のチャンクにマッチします。 <code>chunk</code> (<code>Text.Megaparsec.Byte</code> と <code>Text.Megaparsec.Char</code> では <code>string</code> と呼ばれる型制約のあるシノニムを使用する) は大文字と小文字を区別しますが、 <code>string'</code> は大文字と小文字を区別しません。 大文字と小文字を区別しない場合のマッチには <code>case-insensitive</code> パッケージが使われているため、 <code>FoldCase</code> 制約があります。</p>
<p>新しいコンビネータも使ってみましょう。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a>λ<span class="op">&gt;</span> parseTest (string <span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> <span class="dt">Parser</span> <span class="dt">Text</span>) <span class="st">&quot;foo&quot;</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="st">&quot;foo&quot;</span></span>
<span id="cb14-3"><a href="#cb14-3"></a></span>
<span id="cb14-4"><a href="#cb14-4"></a>λ<span class="op">&gt;</span> parseTest (string <span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> <span class="dt">Parser</span> <span class="dt">Text</span>) <span class="st">&quot;bar&quot;</span></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="dv">1</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span></span>
<span id="cb14-6"><a href="#cb14-6"></a>  <span class="op">|</span></span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="dv">1</span> <span class="op">|</span> bar</span>
<span id="cb14-8"><a href="#cb14-8"></a>  <span class="op">|</span> <span class="op">^</span></span>
<span id="cb14-9"><a href="#cb14-9"></a>unexpected <span class="st">&quot;bar&quot;</span></span>
<span id="cb14-10"><a href="#cb14-10"></a>expecting <span class="st">&quot;foo&quot;</span></span>
<span id="cb14-11"><a href="#cb14-11"></a></span>
<span id="cb14-12"><a href="#cb14-12"></a>λ<span class="op">&gt;</span> parseTest (string' <span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> <span class="dt">Parser</span> <span class="dt">Text</span>) <span class="st">&quot;FOO&quot;</span></span>
<span id="cb14-13"><a href="#cb14-13"></a><span class="st">&quot;FOO&quot;</span></span>
<span id="cb14-14"><a href="#cb14-14"></a></span>
<span id="cb14-15"><a href="#cb14-15"></a>λ<span class="op">&gt;</span> parseTest (string' <span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> <span class="dt">Parser</span> <span class="dt">Text</span>) <span class="st">&quot;FoO&quot;</span></span>
<span id="cb14-16"><a href="#cb14-16"></a><span class="st">&quot;FoO&quot;</span></span>
<span id="cb14-17"><a href="#cb14-17"></a></span>
<span id="cb14-18"><a href="#cb14-18"></a>λ<span class="op">&gt;</span> parseTest (string' <span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> <span class="dt">Parser</span> <span class="dt">Text</span>) <span class="st">&quot;FoZ&quot;</span></span>
<span id="cb14-19"><a href="#cb14-19"></a><span class="dv">1</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span></span>
<span id="cb14-20"><a href="#cb14-20"></a>  <span class="op">|</span></span>
<span id="cb14-21"><a href="#cb14-21"></a><span class="dv">1</span> <span class="op">|</span> <span class="dt">FoZ</span></span>
<span id="cb14-22"><a href="#cb14-22"></a>  <span class="op">|</span> <span class="op">^</span></span>
<span id="cb14-23"><a href="#cb14-23"></a>unexpected <span class="st">&quot;FoZ&quot;</span></span>
<span id="cb14-24"><a href="#cb14-24"></a>expecting <span class="st">&quot;foo&quot;</span></span></code></pre></div>
<p>OK、単一のトークンと入力のチャンクをマッチできました。 次のステップは、より興味深いパーサを書くために 基本的なパーサを組み合わせる方法を学びます。</p>
<p><a name="MonaAp"></a></p>
<h2 id="モナディック構文とアプリカティブ構文">モナディック構文とアプリカティブ構文</h2>
<p>パーサを組み合わせる最も簡単な方法は、それらを逐次実行することです。 <code>ParsecT</code>と<code>Parsec</code>はモナドであり、 モナドでの束縛はパーサを連続で使用することとまったく同じです。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a><span class="ot">mySequence ::</span> <span class="dt">Parser</span> (<span class="dt">Char</span>, <span class="dt">Char</span>, <span class="dt">Char</span>)</span>
<span id="cb15-2"><a href="#cb15-2"></a>mySequence <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb15-3"><a href="#cb15-3"></a>  a <span class="ot">&lt;-</span> char <span class="ch">'a'</span></span>
<span id="cb15-4"><a href="#cb15-4"></a>  b <span class="ot">&lt;-</span> char <span class="ch">'b'</span></span>
<span id="cb15-5"><a href="#cb15-5"></a>  c <span class="ot">&lt;-</span> char <span class="ch">'c'</span></span>
<span id="cb15-6"><a href="#cb15-6"></a>  <span class="fu">return</span> (a, b, c)</span></code></pre></div>
<p>これを実行すると、すべてが期待通りに機能することを確認できます。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> mySequence <span class="st">&quot;abc&quot;</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="kw">(</span><span class="st">'a'</span>,<span class="st">'b'</span>,<span class="st">'c'</span><span class="kw">)</span></span>
<span id="cb16-3"><a href="#cb16-3"></a></span>
<span id="cb16-4"><a href="#cb16-4"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> mySequence <span class="st">&quot;bcd&quot;</span></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="ex">1</span>:1:</span>
<span id="cb16-6"><a href="#cb16-6"></a>  <span class="kw">|</span></span>
<span id="cb16-7"><a href="#cb16-7"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">bcd</span></span>
<span id="cb16-8"><a href="#cb16-8"></a>  <span class="kw">|</span> ^</span>
<span id="cb16-9"><a href="#cb16-9"></a><span class="ex">unexpected</span> <span class="st">'b'</span></span>
<span id="cb16-10"><a href="#cb16-10"></a><span class="ex">expecting</span> <span class="st">'a'</span></span>
<span id="cb16-11"><a href="#cb16-11"></a></span>
<span id="cb16-12"><a href="#cb16-12"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> mySequence <span class="st">&quot;adc&quot;</span></span>
<span id="cb16-13"><a href="#cb16-13"></a><span class="ex">1</span>:2:</span>
<span id="cb16-14"><a href="#cb16-14"></a>  <span class="kw">|</span></span>
<span id="cb16-15"><a href="#cb16-15"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">adc</span></span>
<span id="cb16-16"><a href="#cb16-16"></a>  <span class="kw">|</span>  ^</span>
<span id="cb16-17"><a href="#cb16-17"></a><span class="ex">unexpected</span> <span class="st">'d'</span></span>
<span id="cb16-18"><a href="#cb16-18"></a><span class="ex">expecting</span> <span class="st">'b'</span></span></code></pre></div>
<p>すべてのモナドがアプリカティブファンクターでもあることを覚えていれば、 逐次実行のための代替構文が可能であり、 アプリカティブ構文を使用できます。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a><span class="ot">mySequence ::</span> <span class="dt">Parser</span> (<span class="dt">Char</span>, <span class="dt">Char</span>, <span class="dt">Char</span>)</span>
<span id="cb17-2"><a href="#cb17-2"></a>mySequence <span class="ot">=</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>  (,,) <span class="op">&lt;$&gt;</span> char <span class="ch">'a'</span></span>
<span id="cb17-4"><a href="#cb17-4"></a>       <span class="op">&lt;*&gt;</span> char <span class="ch">'b'</span></span>
<span id="cb17-5"><a href="#cb17-5"></a>       <span class="op">&lt;*&gt;</span> char <span class="ch">'c'</span></span></code></pre></div>
<p>2番目のバージョンは最初のバージョンとまったく同じように機能します。 どちらのスタイルを使うかは、しばしば好みの問題です。 モナディックスタイルは間違いなく冗長で、ときにはより明確ですが、 一方アプリカティブスタイルはより簡潔です。 そうは言っても、モナドはアプリカティブファンクターよりも強力であるため、 モナディックスタイルはもちろんより強力です。</p>
<p><a name="Eof"></a></p>
<h2 id="eof-による入力の強制消費">eof による入力の強制消費</h2>
<p><code>Applicative</code> はとてもおもしろいことをするのに十分強力です。 単位元を持つ結合演算子を備えることで、 Haskell では <code>Alternative</code> 型クラスとして表現される アプリカティブファンクタのモノイドを得ます。 <code>parser-combinators</code> パッケージは <code>Applicative</code> と <code>Alternative</code> の概念に基づき構築された かなりの数の抽象的なコンビネータを提供します。 <code>Text.Megaparsec</code> モジュールはそれらを <code>Control.Applicative.Combinators</code> から再エクスポートします。</p>
<p>最も一般的なコンビネータの1つに、<code>many</code> と呼ばれるものがあります。 それは与えられたパーサを0回以上実行することができます。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (many (char <span class="st">'a'</span>) :: <span class="ex">Parser</span> [Char]) <span class="st">&quot;aaa&quot;</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="st">&quot;aaa&quot;</span></span>
<span id="cb18-3"><a href="#cb18-3"></a></span>
<span id="cb18-4"><a href="#cb18-4"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (many (char <span class="st">'a'</span>) :: <span class="ex">Parser</span> [Char]) <span class="st">&quot;aabbb&quot;</span></span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="st">&quot;aa&quot;</span></span></code></pre></div>
<p>2番目の結果は少し驚くかもしれません。 パーサは <code>a</code> が一致したとして消費しましたが、その後停止しました。 <code>many (char 'a')</code> の後に何をしたいのか何も言っていませんでした！</p>
<p>ほとんどの場合は、パーサに入力全体の消費を強制させ、 恥ずかしがり屋で黙ってやめるのではなく、 パースエラーを報告させたいです。 これは、入力の終わりに達することを 要求することによって行われます。 入力の終わりは概念にすぎませんが、 幸いにも <code>eof :: MonadParsec e m =&gt; m ()</code>と呼ばれるプリミティブがあり、 これは何も消費せず、入力の終わりでのみ成功します。 これをパーサに追加してもう一度試してみましょう。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (many (char <span class="st">'a'</span>) <span class="op">&lt;</span><span class="ex">*</span> eof :: Parser [Char]) <span class="st">&quot;aabbb&quot;</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="ex">1</span>:3:</span>
<span id="cb19-3"><a href="#cb19-3"></a>  <span class="kw">|</span></span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">aabbb</span></span>
<span id="cb19-5"><a href="#cb19-5"></a>  <span class="kw">|</span>   ^</span>
<span id="cb19-6"><a href="#cb19-6"></a><span class="ex">unexpected</span> <span class="st">'b'</span></span>
<span id="cb19-7"><a href="#cb19-7"></a><span class="ex">expecting</span> <span class="st">'a'</span> or end of input</span></code></pre></div>
<p>パーサで<code>b</code>について何も言わなかったことにより、 それらは確かに予想外となりました。</p>
<p><a name="Alt"></a></p>
<h2 id="選択肢を使った動作">選択肢を使った動作</h2>
<p>これから、次の形式のURIのパースが可能である実用的なパーサを開発します。</p>
<pre><code>scheme:[//[user:password@]host[:port]][/]path[?query][#fragment]</code></pre>
<p>角括弧 <code>[]</code> の中はオプションであり、それらは有効なURIに現れても現れなくてもよいことを覚えておくべきです。 <code>[]</code> は、ある可能性を別の可能性の中で表現するためにネストすることさえできます。私たちはこのすべてを処理します<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>。</p>
<p><code>scheme</code> から始めましょう。 <code>data</code>、<code>file</code>、<code>ftp</code>、<code>http</code>、<code>https</code>、<code>irc</code>、<code>mailto</code> など、私たちが知っているスキームのみを受け入れます。</p>
<p>一定の文字列と一致させるために、<code>string</code> を使います。 選択を表現するために、<code>Alternative</code> 型クラスの <code>(&lt;|&gt;)</code> メソッドを使います。 次のように書くことができます。</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="ot">{-# LANGUAGE RecordWildCards   #-}</span></span>
<span id="cb21-3"><a href="#cb21-3"></a></span>
<span id="cb21-4"><a href="#cb21-4"></a><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></span>
<span id="cb21-5"><a href="#cb21-5"></a></span>
<span id="cb21-6"><a href="#cb21-6"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb21-7"><a href="#cb21-7"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb21-8"><a href="#cb21-8"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb21-9"><a href="#cb21-9"></a><span class="kw">import</span> <span class="dt">Data.Void</span></span>
<span id="cb21-10"><a href="#cb21-10"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span> <span class="kw">hiding</span> (<span class="dt">State</span>)</span>
<span id="cb21-11"><a href="#cb21-11"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec.Char</span></span>
<span id="cb21-12"><a href="#cb21-12"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb21-13"><a href="#cb21-13"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Megaparsec.Char.Lexer</span> <span class="kw">as</span> <span class="dt">L</span></span>
<span id="cb21-14"><a href="#cb21-14"></a></span>
<span id="cb21-15"><a href="#cb21-15"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Void</span> <span class="dt">Text</span></span>
<span id="cb21-16"><a href="#cb21-16"></a></span>
<span id="cb21-17"><a href="#cb21-17"></a><span class="ot">pScheme ::</span> <span class="dt">Parser</span> <span class="dt">Text</span></span>
<span id="cb21-18"><a href="#cb21-18"></a>pScheme <span class="ot">=</span> string <span class="st">&quot;data&quot;</span></span>
<span id="cb21-19"><a href="#cb21-19"></a>  <span class="op">&lt;|&gt;</span> string <span class="st">&quot;file&quot;</span></span>
<span id="cb21-20"><a href="#cb21-20"></a>  <span class="op">&lt;|&gt;</span> string <span class="st">&quot;ftp&quot;</span></span>
<span id="cb21-21"><a href="#cb21-21"></a>  <span class="op">&lt;|&gt;</span> string <span class="st">&quot;http&quot;</span></span>
<span id="cb21-22"><a href="#cb21-22"></a>  <span class="op">&lt;|&gt;</span> string <span class="st">&quot;https&quot;</span></span>
<span id="cb21-23"><a href="#cb21-23"></a>  <span class="op">&lt;|&gt;</span> string <span class="st">&quot;irc&quot;</span></span>
<span id="cb21-24"><a href="#cb21-24"></a>  <span class="op">&lt;|&gt;</span> string <span class="st">&quot;mailto&quot;</span></span></code></pre></div>
<p>試してみましょう。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb22-1"><a href="#cb22-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pScheme <span class="st">&quot;&quot;</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="ex">1</span>:1:</span>
<span id="cb22-3"><a href="#cb22-3"></a>  <span class="kw">|</span></span>
<span id="cb22-4"><a href="#cb22-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="op">&lt;</span><span class="ex">empty</span> line<span class="op">&gt;</span></span>
<span id="cb22-5"><a href="#cb22-5"></a>  <span class="kw">|</span> ^</span>
<span id="cb22-6"><a href="#cb22-6"></a><span class="ex">unexpected</span> end of input</span>
<span id="cb22-7"><a href="#cb22-7"></a><span class="ex">expecting</span> <span class="st">&quot;data&quot;</span>, <span class="st">&quot;file&quot;</span>, <span class="st">&quot;ftp&quot;</span>, <span class="st">&quot;http&quot;</span>, <span class="st">&quot;https&quot;</span>, <span class="st">&quot;irc&quot;</span>, or <span class="st">&quot;mailto&quot;</span></span>
<span id="cb22-8"><a href="#cb22-8"></a></span>
<span id="cb22-9"><a href="#cb22-9"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pScheme <span class="st">&quot;dat&quot;</span></span>
<span id="cb22-10"><a href="#cb22-10"></a><span class="ex">1</span>:1:</span>
<span id="cb22-11"><a href="#cb22-11"></a>  <span class="kw">|</span></span>
<span id="cb22-12"><a href="#cb22-12"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">dat</span></span>
<span id="cb22-13"><a href="#cb22-13"></a>  <span class="kw">|</span> ^</span>
<span id="cb22-14"><a href="#cb22-14"></a><span class="ex">unexpected</span> <span class="st">&quot;dat&quot;</span></span>
<span id="cb22-15"><a href="#cb22-15"></a><span class="ex">expecting</span> <span class="st">&quot;data&quot;</span>, <span class="st">&quot;file&quot;</span>, <span class="st">&quot;ftp&quot;</span>, <span class="st">&quot;http&quot;</span>, <span class="st">&quot;https&quot;</span>, <span class="st">&quot;irc&quot;</span>, or <span class="st">&quot;mailto&quot;</span></span>
<span id="cb22-16"><a href="#cb22-16"></a></span>
<span id="cb22-17"><a href="#cb22-17"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pScheme <span class="st">&quot;file&quot;</span></span>
<span id="cb22-18"><a href="#cb22-18"></a><span class="st">&quot;file&quot;</span></span>
<span id="cb22-19"><a href="#cb22-19"></a></span>
<span id="cb22-20"><a href="#cb22-20"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pScheme <span class="st">&quot;irc&quot;</span></span>
<span id="cb22-21"><a href="#cb22-21"></a><span class="st">&quot;irc&quot;</span></span></code></pre></div>
<p>見栄えは良いですが、<code>pScheme</code>の定義は少し反復的です。 <code>choice</code> コンビネータを使って <code>pScheme</code> を書く方法があります。</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1"></a><span class="ot">pScheme ::</span> <span class="dt">Parser</span> <span class="dt">Text</span></span>
<span id="cb23-2"><a href="#cb23-2"></a>pScheme <span class="ot">=</span> choice</span>
<span id="cb23-3"><a href="#cb23-3"></a>  [ string <span class="st">&quot;data&quot;</span></span>
<span id="cb23-4"><a href="#cb23-4"></a>  , string <span class="st">&quot;file&quot;</span></span>
<span id="cb23-5"><a href="#cb23-5"></a>  , string <span class="st">&quot;ftp&quot;</span></span>
<span id="cb23-6"><a href="#cb23-6"></a>  , string <span class="st">&quot;http&quot;</span></span>
<span id="cb23-7"><a href="#cb23-7"></a>  , string <span class="st">&quot;https&quot;</span></span>
<span id="cb23-8"><a href="#cb23-8"></a>  , string <span class="st">&quot;irc&quot;</span></span>
<span id="cb23-9"><a href="#cb23-9"></a>  , string <span class="st">&quot;mailto&quot;</span> ]</span></code></pre></div>
<p><code>choice</code> は要素間に <code>(&lt;|&gt;)</code> を入れてリストを畳み込む操作である <code>asum</code> の単なるシノニムであり、<code>pScheme</code> の2つの定義は実際には同じです。 <code>choice</code> を使用したほうがが少し良く見えるかもしれません。</p>
<p>スキームの後にはコロン<code>:</code>があるはずです。 何かした後で別の何かを要求するために、 モナドでの束縛またはdo記法を使います。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">data</span> <span class="dt">Uri</span> <span class="ot">=</span> <span class="dt">Uri</span></span>
<span id="cb24-2"><a href="#cb24-2"></a>  {<span class="ot"> uriScheme ::</span> <span class="dt">Text</span></span>
<span id="cb24-3"><a href="#cb24-3"></a>  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb24-4"><a href="#cb24-4"></a></span>
<span id="cb24-5"><a href="#cb24-5"></a><span class="ot">pUri ::</span> <span class="dt">Parser</span> <span class="dt">Uri</span></span>
<span id="cb24-6"><a href="#cb24-6"></a>pUri <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb24-7"><a href="#cb24-7"></a>  r <span class="ot">&lt;-</span> pScheme</span>
<span id="cb24-8"><a href="#cb24-8"></a>  _ <span class="ot">&lt;-</span> char <span class="ch">':'</span></span>
<span id="cb24-9"><a href="#cb24-9"></a>  <span class="fu">return</span> (<span class="dt">Uri</span> r)</span></code></pre></div>
<p><code>pUri</code>を実行しようとすると、スキーム名の後に <code>:</code> が必要であることがわかります。</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb25-1"><a href="#cb25-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pUri <span class="st">&quot;irc&quot;</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="ex">1</span>:4:</span>
<span id="cb25-3"><a href="#cb25-3"></a>  <span class="kw">|</span></span>
<span id="cb25-4"><a href="#cb25-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">irc</span></span>
<span id="cb25-5"><a href="#cb25-5"></a>  <span class="kw">|</span>    ^</span>
<span id="cb25-6"><a href="#cb25-6"></a><span class="ex">unexpected</span> end of input</span>
<span id="cb25-7"><a href="#cb25-7"></a><span class="ex">expecting</span> <span class="st">':'</span></span>
<span id="cb25-8"><a href="#cb25-8"></a></span>
<span id="cb25-9"><a href="#cb25-9"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pUri <span class="st">&quot;irc:&quot;</span></span>
<span id="cb25-10"><a href="#cb25-10"></a><span class="ex">Uri</span> {uriScheme = <span class="st">&quot;irc&quot;</span>}</span></code></pre></div>
<p>しかし、このスキームのパーサは完成していません。 良い Haskell のプログラマーは、 正しくないデータを表現できないように型を定義しようとします。 すべての <code>Text</code> の値が有効なスキームであるとは限りません。 スキームを表すためにデータ型を定義し、 <code>pScheme</code> パーサにその型の値を返させます。</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1"></a><span class="kw">data</span> <span class="dt">Scheme</span></span>
<span id="cb26-2"><a href="#cb26-2"></a>  <span class="ot">=</span> <span class="dt">SchemeData</span></span>
<span id="cb26-3"><a href="#cb26-3"></a>  <span class="op">|</span> <span class="dt">SchemeFile</span></span>
<span id="cb26-4"><a href="#cb26-4"></a>  <span class="op">|</span> <span class="dt">SchemeFtp</span></span>
<span id="cb26-5"><a href="#cb26-5"></a>  <span class="op">|</span> <span class="dt">SchemeHttp</span></span>
<span id="cb26-6"><a href="#cb26-6"></a>  <span class="op">|</span> <span class="dt">SchemeHttps</span></span>
<span id="cb26-7"><a href="#cb26-7"></a>  <span class="op">|</span> <span class="dt">SchemeIrc</span></span>
<span id="cb26-8"><a href="#cb26-8"></a>  <span class="op">|</span> <span class="dt">SchemeMailto</span></span>
<span id="cb26-9"><a href="#cb26-9"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb26-10"><a href="#cb26-10"></a></span>
<span id="cb26-11"><a href="#cb26-11"></a><span class="ot">pScheme ::</span> <span class="dt">Parser</span> <span class="dt">Scheme</span></span>
<span id="cb26-12"><a href="#cb26-12"></a>pScheme <span class="ot">=</span> choice</span>
<span id="cb26-13"><a href="#cb26-13"></a>  [ <span class="dt">SchemeData</span>   <span class="op">&lt;$</span> string <span class="st">&quot;data&quot;</span></span>
<span id="cb26-14"><a href="#cb26-14"></a>  , <span class="dt">SchemeFile</span>   <span class="op">&lt;$</span> string <span class="st">&quot;file&quot;</span></span>
<span id="cb26-15"><a href="#cb26-15"></a>  , <span class="dt">SchemeFtp</span>    <span class="op">&lt;$</span> string <span class="st">&quot;ftp&quot;</span></span>
<span id="cb26-16"><a href="#cb26-16"></a>  , <span class="dt">SchemeHttp</span>   <span class="op">&lt;$</span> string <span class="st">&quot;http&quot;</span></span>
<span id="cb26-17"><a href="#cb26-17"></a>  , <span class="dt">SchemeHttps</span>  <span class="op">&lt;$</span> string <span class="st">&quot;https&quot;</span></span>
<span id="cb26-18"><a href="#cb26-18"></a>  , <span class="dt">SchemeIrc</span>    <span class="op">&lt;$</span> string <span class="st">&quot;irc&quot;</span></span>
<span id="cb26-19"><a href="#cb26-19"></a>  , <span class="dt">SchemeMailto</span> <span class="op">&lt;$</span> string <span class="st">&quot;mailto&quot;</span> ]</span>
<span id="cb26-20"><a href="#cb26-20"></a></span>
<span id="cb26-21"><a href="#cb26-21"></a><span class="kw">data</span> <span class="dt">Uri</span> <span class="ot">=</span> <span class="dt">Uri</span></span>
<span id="cb26-22"><a href="#cb26-22"></a>  {<span class="ot"> uriScheme ::</span> <span class="dt">Scheme</span></span>
<span id="cb26-23"><a href="#cb26-23"></a>  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p><code>(&lt;$)</code> 演算子は、左側にある値をただちに関数型コンテキストに入れて、 その時点で存在しているものはすべて置き換えます。 <code>a &lt;$ f</code> は <code>const a &lt;$&gt; f</code> と同じですが、 関数によってはより効率的な場合があります。</p>
<p>引き続きパーサを使ってみましょう。</p>
<pre><code>λ&gt; parseTest pUri &quot;https:&quot;
1:5:
  |
1 | https:
  |     ^
unexpected 's'
expecting ':'</code></pre>
<p>うーん、<code>https</code> は有効なスキームであるべきです。 何がいけないのかわかりますか？ パーサは選択肢を一つずつ試し、 <code>http</code> で一致し、 <code>https</code> を試すことはありません。 解決策は、<code>SchemeHttp &lt;$ string "https"</code> という行を <code>SchemeHttp &lt;$ string "http"</code> という行の前に置くことです。 選択肢は順序が重要であることを覚えておいてください！</p>
<p><code>pUri</code> は正しく動作するようになりました。</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb28-1"><a href="#cb28-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pUri <span class="st">&quot;http:&quot;</span></span>
<span id="cb28-2"><a href="#cb28-2"></a><span class="ex">Uri</span> {uriScheme = SchemeHttp}</span>
<span id="cb28-3"><a href="#cb28-3"></a></span>
<span id="cb28-4"><a href="#cb28-4"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pUri <span class="st">&quot;https:&quot;</span></span>
<span id="cb28-5"><a href="#cb28-5"></a><span class="ex">Uri</span> {uriScheme = SchemeHttps}</span>
<span id="cb28-6"><a href="#cb28-6"></a></span>
<span id="cb28-7"><a href="#cb28-7"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pUri <span class="st">&quot;mailto:&quot;</span></span>
<span id="cb28-8"><a href="#cb28-8"></a><span class="ex">Uri</span> {uriScheme = SchemeMailto}</span>
<span id="cb28-9"><a href="#cb28-9"></a></span>
<span id="cb28-10"><a href="#cb28-10"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pUri <span class="st">&quot;foo:&quot;</span></span>
<span id="cb28-11"><a href="#cb28-11"></a><span class="ex">1</span>:1:</span>
<span id="cb28-12"><a href="#cb28-12"></a>  <span class="kw">|</span></span>
<span id="cb28-13"><a href="#cb28-13"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">foo</span>:</span>
<span id="cb28-14"><a href="#cb28-14"></a>  <span class="kw">|</span> ^</span>
<span id="cb28-15"><a href="#cb28-15"></a><span class="ex">unexpected</span> <span class="st">&quot;foo:&quot;</span></span>
<span id="cb28-16"><a href="#cb28-16"></a><span class="ex">expecting</span> <span class="st">&quot;data&quot;</span>, <span class="st">&quot;file&quot;</span>, <span class="st">&quot;ftp&quot;</span>, <span class="st">&quot;http&quot;</span>, <span class="st">&quot;https&quot;</span>, <span class="st">&quot;irc&quot;</span>, or <span class="st">&quot;mailto&quot;</span></span></code></pre></div>
<p><a name="Try"></a></p>
<h2 id="try-によるバックトラックの制御"><code>try</code> によるバックトラックの制御</h2>
<p>次に扱う部分は <code>[//[user:password@]host[:port]]</code> つまり認証情報です。 オプション部分のネストが含まれるので、 これを反映するように <code>Uri</code> 型 を更新しましょう。</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1"></a><span class="kw">data</span> <span class="dt">Uri</span> <span class="ot">=</span> <span class="dt">Uri</span></span>
<span id="cb29-2"><a href="#cb29-2"></a>  {<span class="ot"> uriScheme    ::</span> <span class="dt">Scheme</span></span>
<span id="cb29-3"><a href="#cb29-3"></a>  ,<span class="ot"> uriAuthority ::</span> <span class="dt">Maybe</span> <span class="dt">Authority</span></span>
<span id="cb29-4"><a href="#cb29-4"></a>  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb29-5"><a href="#cb29-5"></a></span>
<span id="cb29-6"><a href="#cb29-6"></a><span class="kw">data</span> <span class="dt">Authority</span> <span class="ot">=</span> <span class="dt">Authority</span></span>
<span id="cb29-7"><a href="#cb29-7"></a>  {<span class="ot"> authUser ::</span> <span class="dt">Maybe</span> (<span class="dt">Text</span>, <span class="dt">Text</span>) <span class="co">-- (user, password)</span></span>
<span id="cb29-8"><a href="#cb29-8"></a>  ,<span class="ot"> authHost ::</span> <span class="dt">Text</span></span>
<span id="cb29-9"><a href="#cb29-9"></a>  ,<span class="ot"> authPort ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb29-10"><a href="#cb29-10"></a>  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p>ここで、バックトラックと呼ばれる重要な概念について議論する必要があります。 バックトラックは、入力を「消費しない」処理により時間を遡る方法です。 これは主に分岐で重要です。ここに一例を示します。</p>
<pre class="haskel"><code>alternatives :: Parser (Char, Char)
alternatives = foo &lt;|&gt; bar
  where
    foo = (,) &lt;$&gt; char 'a' &lt;*&gt; char 'b'
    bar = (,) &lt;$&gt; char 'a' &lt;*&gt; char 'c'</code></pre>
<p>合理的に見えますが、これを試してみましょう。</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb31-1"><a href="#cb31-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> alternatives <span class="st">&quot;ab&quot;</span></span>
<span id="cb31-2"><a href="#cb31-2"></a><span class="kw">(</span><span class="st">'a'</span>,<span class="st">'b'</span><span class="kw">)</span></span>
<span id="cb31-3"><a href="#cb31-3"></a></span>
<span id="cb31-4"><a href="#cb31-4"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> alternatives <span class="st">&quot;ac&quot;</span></span>
<span id="cb31-5"><a href="#cb31-5"></a><span class="ex">1</span>:2:</span>
<span id="cb31-6"><a href="#cb31-6"></a>  <span class="kw">|</span></span>
<span id="cb31-7"><a href="#cb31-7"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">ac</span></span>
<span id="cb31-8"><a href="#cb31-8"></a>  <span class="kw">|</span>  ^</span>
<span id="cb31-9"><a href="#cb31-9"></a><span class="ex">unexpected</span> <span class="st">'c'</span></span>
<span id="cb31-10"><a href="#cb31-10"></a><span class="ex">expecting</span> <span class="st">'b'</span></span></code></pre></div>
<p>ここで起きたことは、 <code>foo</code> の <code>char 'a'</code> の部分(これが最初に試行されます)の成功と、 入力ストリームからの <code>a</code> の消費です。 <code>char 'b'</code> は <code>'c'</code>とのマッチに失敗したため、エラーになりました。 ここで重要なことは、 <code>foo</code> が何らかの入力を消費しているので <code>(&lt;|&gt;)</code> は <code>bar</code> を試していないということです！</p>
<p>これはパフォーマンス上の理由から行われており、 また、<code>foo</code> の残り物を <code>bar</code> に与えて実行するのは意味が無いです。 <code>bar</code> は <code>foo</code> と同じ場所の入力ストリームから実行したいです。 <code>megaparsec</code> は <code>attoparsec</code> や前の章のトイコンビネータとは異なり、 自動で戻りません。そのため、<code>try</code> と呼ばれるプリミティブを使用して、 明示的にバックトラックしたいという願望を表現する必要があります。 <code>try p</code> は、 <code>p</code> が入力の消費に失敗した場合、 入力が消費されていないかのように失敗します (実際、パーサの状態全体をバックトラックします)。 これにより <code>(&lt;|&gt;)</code> で右側の選択肢を試すことが可能になります。</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1"></a><span class="ot">alternatives ::</span> <span class="dt">Parser</span> (<span class="dt">Char</span>, <span class="dt">Char</span>)</span>
<span id="cb32-2"><a href="#cb32-2"></a>alternatives <span class="ot">=</span> try foo <span class="op">&lt;|&gt;</span> bar</span>
<span id="cb32-3"><a href="#cb32-3"></a>  <span class="kw">where</span></span>
<span id="cb32-4"><a href="#cb32-4"></a>    foo <span class="ot">=</span> (,) <span class="op">&lt;$&gt;</span> char <span class="ch">'a'</span> <span class="op">&lt;*&gt;</span> char <span class="ch">'b'</span></span>
<span id="cb32-5"><a href="#cb32-5"></a>    bar <span class="ot">=</span> (,) <span class="op">&lt;$&gt;</span> char <span class="ch">'a'</span> <span class="op">&lt;*&gt;</span> char <span class="ch">'c'</span></span></code></pre></div>
<div class="sourceCode" id="cb33"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb33-1"><a href="#cb33-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> alternatives <span class="st">&quot;ac&quot;</span></span>
<span id="cb33-2"><a href="#cb33-2"></a><span class="kw">(</span><span class="st">'a'</span>,<span class="st">'c'</span><span class="kw">)</span></span></code></pre></div>
<p>実際に入力を消費するすべてのプリミティブ （<code>try</code> などの既存のパーサの動作を変更するプリミティブもあります）は、 入力の消費という点で「アトミック」です。 これは、失敗した場合に自動的にバックトラックするため、 入力を消費して途中で失敗することはできないことを意味します。 これが、<code>pScheme</code> の選択肢のリストが機能する理由です。 つまり、<code>string</code> は <code>tokens</code> の上に定義され、<code>tokens</code> はプリミティブです。 文字列全体を <code>string</code> でマッチさせるか、 入力ストリームをまったく消費せずに失敗します。</p>
<p>URIのパースに戻ると、 <code>(&lt;|&gt;)</code> を使った <code>optional</code> という便利なコンビネータを作ることができます。</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1"></a><span class="ot">optional ::</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f (<span class="dt">Maybe</span> a)</span>
<span id="cb34-2"><a href="#cb34-2"></a>optional p <span class="ot">=</span> (<span class="dt">Just</span> <span class="op">&lt;$&gt;</span> p) <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> <span class="dt">Nothing</span></span></code></pre></div>
<p><code>optional p</code> の <code>p</code> でマッチすれば、結果は <code>Just</code> になります。 そうでなければ <code>Nothing</code> が返されます。 ちょうど欲ほしかったものです！ <code>optional</code> を定義する必要はありません、 <code>Text.Megaparsec</code> はこのコンビネータを再エクスポートします。 これを <code>pUri</code> で使うことができます。</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1"></a><span class="ot">pUri ::</span> <span class="dt">Parser</span> <span class="dt">Uri</span></span>
<span id="cb35-2"><a href="#cb35-2"></a>pUri <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb35-3"><a href="#cb35-3"></a>  uriScheme <span class="ot">&lt;-</span> pScheme</span>
<span id="cb35-4"><a href="#cb35-4"></a>  void (char <span class="ch">':'</span>)</span>
<span id="cb35-5"><a href="#cb35-5"></a>  uriAuthority <span class="ot">&lt;-</span> optional <span class="op">.</span> try <span class="op">$</span> <span class="kw">do</span>            <span class="co">-- (1)</span></span>
<span id="cb35-6"><a href="#cb35-6"></a>    void (string <span class="st">&quot;//&quot;</span>)</span>
<span id="cb35-7"><a href="#cb35-7"></a>    authUser <span class="ot">&lt;-</span> optional <span class="op">.</span> try <span class="op">$</span> <span class="kw">do</span>              <span class="co">-- (2)</span></span>
<span id="cb35-8"><a href="#cb35-8"></a>      user <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar       <span class="co">-- (3)</span></span>
<span id="cb35-9"><a href="#cb35-9"></a>      void (char <span class="ch">':'</span>)</span>
<span id="cb35-10"><a href="#cb35-10"></a>      password <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar</span>
<span id="cb35-11"><a href="#cb35-11"></a>      void (char <span class="ch">'@'</span>)</span>
<span id="cb35-12"><a href="#cb35-12"></a>      <span class="fu">return</span> (user, password)</span>
<span id="cb35-13"><a href="#cb35-13"></a>    authHost <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some (alphaNumChar <span class="op">&lt;|&gt;</span> char <span class="ch">'.'</span>)</span>
<span id="cb35-14"><a href="#cb35-14"></a>    authPort <span class="ot">&lt;-</span> optional (char <span class="ch">':'</span> <span class="op">*&gt;</span> L.decimal) <span class="co">-- (4)</span></span>
<span id="cb35-15"><a href="#cb35-15"></a>    <span class="fu">return</span> <span class="dt">Authority</span> {<span class="op">..</span>}                        <span class="co">-- (5)</span></span>
<span id="cb35-16"><a href="#cb35-16"></a>  <span class="fu">return</span> <span class="dt">Uri</span> {<span class="op">..</span>}                                <span class="co">-- (6)</span></span></code></pre></div>
<p>ユーザー名とパスワードとして 任意の英数字の文字列を受け入れることができるようにし、 同様にホストの形式を単純化しました。</p>
<p>以下に重要な点を挙げます。</p>
<ul>
<li><ol type="1">
<li>と (2) では、 <code>optional</code> の引数を <code>try</code> でラップする必要があります。 これは複合パーサであり、プリミティブではないためです。</li>
</ol></li>
<li><ol start="3" type="1">
<li><code>some</code> は <code>many</code> に似ていますが、その引数のパーサが少なくとも一度はマッチすることを要求します(<code>some p =（:) &lt;$&gt; p &lt;*&gt; many p</code>)。</li>
</ol></li>
<li><ol start="4" type="1">
<li>必要でない限り <code>try</code> を使わないでください！ここでは <code>char ':'</code> が成功すると (<code>token</code> の上に構築されているので, <code>try</code> は必要はありません)、そのあとに必ずポートが続かなければならないことがわかっているので、<code>L.decimal</code> により 10進数を要求します。<code>:</code> にマッチした後は、後戻りできないので、戻る方法は必要ありません。</li>
</ol></li>
<li><ol start="5" type="1">
<li>と (6) では、<code>RecordWildCards</code> 言語拡張を使用して <code>Authority</code> と <code>Uri</code> の値を作り上げます。</li>
</ol></li>
</ul>
<p>GHCiで <code>pUri</code> を試し、それが機能することを確認してください。</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb36-1"><a href="#cb36-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pUri <span class="op">&lt;</span>* eof) <span class="st">&quot;https://mark:secret@example.com&quot;</span></span>
<span id="cb36-2"><a href="#cb36-2"></a><span class="ex">Uri</span></span>
<span id="cb36-3"><a href="#cb36-3"></a>  <span class="kw">{</span> <span class="ex">uriScheme</span> = SchemeHttps</span>
<span id="cb36-4"><a href="#cb36-4"></a>  , <span class="ex">uriAuthority</span> = Just (Authority</span>
<span id="cb36-5"><a href="#cb36-5"></a>    <span class="kw">{</span> <span class="ex">authUser</span> = Just (<span class="st">&quot;mark&quot;</span>,<span class="st">&quot;secret&quot;</span>)</span>
<span id="cb36-6"><a href="#cb36-6"></a>    , <span class="ex">authHost</span> = <span class="st">&quot;example.com&quot;</span></span>
<span id="cb36-7"><a href="#cb36-7"></a>    , <span class="ex">authPort</span> = Nothing <span class="kw">}</span> ) <span class="kw">}</span></span>
<span id="cb36-8"><a href="#cb36-8"></a></span>
<span id="cb36-9"><a href="#cb36-9"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pUri <span class="op">&lt;</span>* eof) <span class="st">&quot;https://mark:secret@example.com:123&quot;</span></span>
<span id="cb36-10"><a href="#cb36-10"></a><span class="ex">Uri</span></span>
<span id="cb36-11"><a href="#cb36-11"></a>  <span class="kw">{</span> <span class="ex">uriScheme</span> = SchemeHttps</span>
<span id="cb36-12"><a href="#cb36-12"></a>  , <span class="ex">uriAuthority</span> = Just (Authority</span>
<span id="cb36-13"><a href="#cb36-13"></a>    <span class="kw">{</span> <span class="ex">authUser</span> = Just (<span class="st">&quot;mark&quot;</span>,<span class="st">&quot;secret&quot;</span>)</span>
<span id="cb36-14"><a href="#cb36-14"></a>    , <span class="ex">authHost</span> = <span class="st">&quot;example.com&quot;</span></span>
<span id="cb36-15"><a href="#cb36-15"></a>    , <span class="ex">authPort</span> = Just 123 <span class="kw">}</span> ) <span class="kw">}</span></span>
<span id="cb36-16"><a href="#cb36-16"></a></span>
<span id="cb36-17"><a href="#cb36-17"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pUri <span class="op">&lt;</span>* eof) <span class="st">&quot;https://example.com:123&quot;</span></span>
<span id="cb36-18"><a href="#cb36-18"></a><span class="ex">Uri</span></span>
<span id="cb36-19"><a href="#cb36-19"></a>  <span class="kw">{</span> <span class="ex">uriScheme</span> = SchemeHttps</span>
<span id="cb36-20"><a href="#cb36-20"></a>  , <span class="ex">uriAuthority</span> = Just (Authority</span>
<span id="cb36-21"><a href="#cb36-21"></a>    <span class="kw">{</span> <span class="ex">authUser</span> = Nothing</span>
<span id="cb36-22"><a href="#cb36-22"></a>    , <span class="ex">authHost</span> = <span class="st">&quot;example.com&quot;</span></span>
<span id="cb36-23"><a href="#cb36-23"></a>    , <span class="ex">authPort</span> = Just 123 <span class="kw">}</span> ) <span class="kw">}</span></span>
<span id="cb36-24"><a href="#cb36-24"></a></span>
<span id="cb36-25"><a href="#cb36-25"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pUri <span class="op">&lt;</span>* eof) <span class="st">&quot;https://mark@example.com:123&quot;</span></span>
<span id="cb36-26"><a href="#cb36-26"></a><span class="ex">1</span>:13:</span>
<span id="cb36-27"><a href="#cb36-27"></a>  <span class="kw">|</span></span>
<span id="cb36-28"><a href="#cb36-28"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">https</span>://mark@example.com:123</span>
<span id="cb36-29"><a href="#cb36-29"></a>  <span class="kw">|</span>             ^</span>
<span id="cb36-30"><a href="#cb36-30"></a><span class="ex">unexpected</span> <span class="st">'@'</span></span>
<span id="cb36-31"><a href="#cb36-31"></a><span class="ex">expecting</span> <span class="st">'.'</span>, <span class="st">':'</span>, alphanumeric character, or end of input</span></code></pre></div>
<p><a name="Debug"></a></p>
<h2 id="パーサのデバッグ">パーサのデバッグ</h2>
<p>問題が起こっていることに気付くかもしれません。</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1"></a>λ<span class="op">&gt;</span> parseTest (pUri <span class="op">&lt;*</span> eof) <span class="st">&quot;https://mark:@example.com&quot;</span></span>
<span id="cb37-2"><a href="#cb37-2"></a><span class="dv">1</span><span class="op">:</span><span class="dv">7</span><span class="op">:</span></span>
<span id="cb37-3"><a href="#cb37-3"></a>  <span class="op">|</span></span>
<span id="cb37-4"><a href="#cb37-4"></a><span class="dv">1</span> <span class="op">|</span> https<span class="op">://</span>mark<span class="op">:@</span>example<span class="op">.</span>com</span>
<span id="cb37-5"><a href="#cb37-5"></a>  <span class="op">|</span>       <span class="op">^</span></span>
<span id="cb37-6"><a href="#cb37-6"></a>unexpected <span class="ch">'/'</span></span>
<span id="cb37-7"><a href="#cb37-7"></a>expecting end <span class="kw">of</span> input</span></code></pre></div>
<p>パースエラーを改善できそうです。何をすればいいでしょうか？ 何が起きているのかを知る最も簡単な方法は、 組み込みのヘルパー <code>dbg</code> を使うことです。</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1"></a><span class="ot">dbg ::</span> (<span class="dt">Stream</span> s, <span class="dt">ShowToken</span> (<span class="dt">Token</span> s), <span class="dt">ShowErrorComponent</span> e, <span class="dt">Show</span> a)</span>
<span id="cb38-2"><a href="#cb38-2"></a>  <span class="ot">=&gt;</span> <span class="dt">String</span>            <span class="co">-- ^ デバッグ用のラベル</span></span>
<span id="cb38-3"><a href="#cb38-3"></a>  <span class="ot">-&gt;</span> <span class="dt">ParsecT</span> e s m a   <span class="co">-- ^ デバッグするパーサ</span></span>
<span id="cb38-4"><a href="#cb38-4"></a>  <span class="ot">-&gt;</span> <span class="dt">ParsecT</span> e s m a   <span class="co">-- ^ デバッグメッセージを出力するパーサ</span></span></code></pre></div>
<p>これを <code>pUri</code> で使ってみましょう。</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1"></a><span class="ot">pUri ::</span> <span class="dt">Parser</span> <span class="dt">Uri</span></span>
<span id="cb39-2"><a href="#cb39-2"></a>pUri <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb39-3"><a href="#cb39-3"></a>  uriScheme <span class="ot">&lt;-</span> dbg <span class="st">&quot;scheme&quot;</span> pScheme</span>
<span id="cb39-4"><a href="#cb39-4"></a>  void (char <span class="ch">':'</span>)</span>
<span id="cb39-5"><a href="#cb39-5"></a>  uriAuthority <span class="ot">&lt;-</span> dbg <span class="st">&quot;auth&quot;</span> <span class="op">.</span> optional <span class="op">.</span> try <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb39-6"><a href="#cb39-6"></a>    void (string <span class="st">&quot;//&quot;</span>)</span>
<span id="cb39-7"><a href="#cb39-7"></a>    authUser <span class="ot">&lt;-</span> dbg <span class="st">&quot;user&quot;</span> <span class="op">.</span> optional <span class="op">.</span> try <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb39-8"><a href="#cb39-8"></a>      user <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar</span>
<span id="cb39-9"><a href="#cb39-9"></a>      void (char <span class="ch">':'</span>)</span>
<span id="cb39-10"><a href="#cb39-10"></a>      password <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar</span>
<span id="cb39-11"><a href="#cb39-11"></a>      void (char <span class="ch">'@'</span>)</span>
<span id="cb39-12"><a href="#cb39-12"></a>      <span class="fu">return</span> (user, password)</span>
<span id="cb39-13"><a href="#cb39-13"></a>    authHost <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> dbg <span class="st">&quot;host&quot;</span> (some (alphaNumChar <span class="op">&lt;|&gt;</span> char <span class="ch">'.'</span>))</span>
<span id="cb39-14"><a href="#cb39-14"></a>    authPort <span class="ot">&lt;-</span> dbg <span class="st">&quot;port&quot;</span> <span class="op">$</span> optional (char <span class="ch">':'</span> <span class="op">*&gt;</span> L.decimal)</span>
<span id="cb39-15"><a href="#cb39-15"></a>    <span class="fu">return</span> <span class="dt">Authority</span> {<span class="op">..</span>}</span>
<span id="cb39-16"><a href="#cb39-16"></a>  <span class="fu">return</span> <span class="dt">Uri</span> {<span class="op">..</span>}</span></code></pre></div>
<p>それでは、その不幸な入力に対してもう一度 <code>pUri</code> を実行してみましょう。</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1"></a>λ<span class="op">&gt;</span> parseTest (pUri <span class="op">&lt;*</span> eof) <span class="st">&quot;https://mark:@example.com&quot;</span></span>
<span id="cb40-2"><a href="#cb40-2"></a>scheme<span class="op">&gt;</span> <span class="dt">IN</span><span class="op">:</span> <span class="st">&quot;https://mark:@example.com&quot;</span></span>
<span id="cb40-3"><a href="#cb40-3"></a>scheme<span class="op">&gt;</span> <span class="dt">MATCH</span> (<span class="dt">COK</span>)<span class="op">:</span> <span class="st">&quot;https&quot;</span></span>
<span id="cb40-4"><a href="#cb40-4"></a>scheme<span class="op">&gt;</span> <span class="dt">VALUE</span><span class="op">:</span> <span class="dt">SchemeHttps</span></span>
<span id="cb40-5"><a href="#cb40-5"></a></span>
<span id="cb40-6"><a href="#cb40-6"></a>user<span class="op">&gt;</span> <span class="dt">IN</span><span class="op">:</span> <span class="st">&quot;mark:@example.com&quot;</span></span>
<span id="cb40-7"><a href="#cb40-7"></a>user<span class="op">&gt;</span> <span class="dt">MATCH</span> (<span class="dt">EOK</span>)<span class="op">:</span> <span class="op">&lt;</span><span class="dt">EMPTY</span><span class="op">&gt;</span></span>
<span id="cb40-8"><a href="#cb40-8"></a>user<span class="op">&gt;</span> <span class="dt">VALUE</span><span class="op">:</span> <span class="dt">Nothing</span></span>
<span id="cb40-9"><a href="#cb40-9"></a></span>
<span id="cb40-10"><a href="#cb40-10"></a>host<span class="op">&gt;</span> <span class="dt">IN</span><span class="op">:</span> <span class="st">&quot;mark:@example.com&quot;</span></span>
<span id="cb40-11"><a href="#cb40-11"></a>host<span class="op">&gt;</span> <span class="dt">MATCH</span> (<span class="dt">COK</span>)<span class="op">:</span> <span class="st">&quot;mark&quot;</span></span>
<span id="cb40-12"><a href="#cb40-12"></a>host<span class="op">&gt;</span> <span class="dt">VALUE</span><span class="op">:</span> <span class="st">&quot;mark&quot;</span></span>
<span id="cb40-13"><a href="#cb40-13"></a></span>
<span id="cb40-14"><a href="#cb40-14"></a>port<span class="op">&gt;</span> <span class="dt">IN</span><span class="op">:</span> <span class="st">&quot;:@example.com&quot;</span></span>
<span id="cb40-15"><a href="#cb40-15"></a>port<span class="op">&gt;</span> <span class="dt">MATCH</span> (<span class="dt">CERR</span>)<span class="op">:</span> <span class="ch">':'</span></span>
<span id="cb40-16"><a href="#cb40-16"></a>port<span class="op">&gt;</span> <span class="dt">ERROR</span><span class="op">:</span></span>
<span id="cb40-17"><a href="#cb40-17"></a>port<span class="op">&gt;</span> <span class="dv">1</span><span class="op">:</span><span class="dv">14</span><span class="op">:</span></span>
<span id="cb40-18"><a href="#cb40-18"></a>port<span class="op">&gt;</span> unexpected <span class="ch">'@'</span></span>
<span id="cb40-19"><a href="#cb40-19"></a>port<span class="op">&gt;</span> expecting integer</span>
<span id="cb40-20"><a href="#cb40-20"></a></span>
<span id="cb40-21"><a href="#cb40-21"></a>auth<span class="op">&gt;</span> <span class="dt">IN</span><span class="op">:</span> <span class="st">&quot;//mark:@example.com&quot;</span></span>
<span id="cb40-22"><a href="#cb40-22"></a>auth<span class="op">&gt;</span> <span class="dt">MATCH</span> (<span class="dt">EOK</span>)<span class="op">:</span> <span class="op">&lt;</span><span class="dt">EMPTY</span><span class="op">&gt;</span></span>
<span id="cb40-23"><a href="#cb40-23"></a>auth<span class="op">&gt;</span> <span class="dt">VALUE</span><span class="op">:</span> <span class="dt">Nothing</span></span>
<span id="cb40-24"><a href="#cb40-24"></a></span>
<span id="cb40-25"><a href="#cb40-25"></a><span class="dv">1</span><span class="op">:</span><span class="dv">7</span><span class="op">:</span></span>
<span id="cb40-26"><a href="#cb40-26"></a>  <span class="op">|</span></span>
<span id="cb40-27"><a href="#cb40-27"></a><span class="dv">1</span> <span class="op">|</span> https<span class="op">://</span>mark<span class="op">:@</span>example<span class="op">.</span>com</span>
<span id="cb40-28"><a href="#cb40-28"></a>  <span class="op">|</span>       <span class="op">^</span></span>
<span id="cb40-29"><a href="#cb40-29"></a>unexpected <span class="ch">'/'</span></span>
<span id="cb40-30"><a href="#cb40-30"></a>expecting end <span class="kw">of</span> input</span></code></pre></div>
<p><code>megaparsec</code> の内部で何が起こっているのか正確にわかります。</p>
<ul>
<li><p><code>scheme</code> のマッチに成功します。</p></li>
<li><p><code>user</code> は失敗します。<code>mark</code> の所にユーザー名がありますが、<code>:</code> の後にパスワードはありません（ここではパスワードを空にしないことを要求します）。失敗し、<code>try</code> のおかげでバックトラックします。</p></li>
<li><p><code>host</code> は <code>user</code> と同じ場所から開始し、入力をホスト名として解釈しようとします。これは成功し、ホスト名として <code>mark</code> を返すことがわかります。</p></li>
<li><p><code>host</code> の後にポート番号があるかもしれないので、<code>port</code> は機会を得ます。それは <code>:</code> を見ますが、その後に整数がないので <code>port</code> は失敗します。</p></li>
<li><p>そのため、<code>auth</code> パーサ全体が失敗します（<code>port</code> は <code>auth</code> の内側にあり、失敗しました）。</p></li>
<li><p><code>auth</code> パーサは、何もパースできなかったため、<code>Nothing</code>を返します。<code>eof</code> は入力の終わりに達したことを要求しますが、そうではないので、最終的なエラーメッセージが表示されます。</p></li>
</ul>
<p>何をすべきでしょうか？これは、<code>try</code> を使用してコードの大部分を囲むと、 パースエラーが悪化する可能性がある場合の例です。 パースしたい構文をもう一度見てみましょう。</p>
<pre><code>scheme:[//[user:password@]host[:port]][/]path[?query][#fragment]</code></pre>
<p>私たちは何を探していますか？ パースのある特定の分岐にコミットできるようにするための何か。 <code>:</code> を見たときにポート番号が続かなければならないポートのように。 注意深く見れば、二重スラッシュ<code>//</code>が、URIに認証情報の部分があることを示す記号であることがわかります。 <code>//</code> のマッチはアトミックパーサ（<code>string</code>）が使われていることにより、 マッチは自動的にバックトラックするので、 <code>//</code> にマッチした後は必ず、認証情報の部分を要求することができます。 最初の<code>try</code>を<code>pUri</code>から削除しましょう。</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1"></a><span class="ot">pUri ::</span> <span class="dt">Parser</span> <span class="dt">Uri</span></span>
<span id="cb42-2"><a href="#cb42-2"></a>pUri <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb42-3"><a href="#cb42-3"></a>  uriScheme <span class="ot">&lt;-</span> pScheme</span>
<span id="cb42-4"><a href="#cb42-4"></a>  void (char <span class="ch">':'</span>)</span>
<span id="cb42-5"><a href="#cb42-5"></a>  uriAuthority <span class="ot">&lt;-</span> optional <span class="op">$</span> <span class="kw">do</span> <span class="co">-- この行から try を削除した</span></span>
<span id="cb42-6"><a href="#cb42-6"></a>    void (string <span class="st">&quot;//&quot;</span>)</span>
<span id="cb42-7"><a href="#cb42-7"></a>    authUser <span class="ot">&lt;-</span> optional <span class="op">.</span> try <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb42-8"><a href="#cb42-8"></a>      user <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar</span>
<span id="cb42-9"><a href="#cb42-9"></a>      void (char <span class="ch">':'</span>)</span>
<span id="cb42-10"><a href="#cb42-10"></a>      password <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar</span>
<span id="cb42-11"><a href="#cb42-11"></a>      void (char <span class="ch">'@'</span>)</span>
<span id="cb42-12"><a href="#cb42-12"></a>      <span class="fu">return</span> (user, password)</span>
<span id="cb42-13"><a href="#cb42-13"></a>    authHost <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some (alphaNumChar <span class="op">&lt;|&gt;</span> char <span class="ch">'.'</span>)</span>
<span id="cb42-14"><a href="#cb42-14"></a>    authPort <span class="ot">&lt;-</span> optional (char <span class="ch">':'</span> <span class="op">*&gt;</span> L.decimal)</span>
<span id="cb42-15"><a href="#cb42-15"></a>    <span class="fu">return</span> <span class="dt">Authority</span> {<span class="op">..</span>}</span>
<span id="cb42-16"><a href="#cb42-16"></a>  <span class="fu">return</span> <span class="dt">Uri</span> {<span class="op">..</span>}</span></code></pre></div>
<p>これで、より良いパースエラーを得られるようになりました。</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb43-1"><a href="#cb43-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pUri <span class="op">&lt;</span>* eof) <span class="st">&quot;https://mark:@example.com&quot;</span></span>
<span id="cb43-2"><a href="#cb43-2"></a><span class="ex">1</span>:14:</span>
<span id="cb43-3"><a href="#cb43-3"></a>  <span class="kw">|</span></span>
<span id="cb43-4"><a href="#cb43-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">https</span>://mark:@example.com</span>
<span id="cb43-5"><a href="#cb43-5"></a>  <span class="kw">|</span>              ^</span>
<span id="cb43-6"><a href="#cb43-6"></a><span class="ex">unexpected</span> <span class="st">'@'</span></span>
<span id="cb43-7"><a href="#cb43-7"></a><span class="ex">expecting</span> integer</span></code></pre></div>
<p>まだ少し誤解を招くようですが、まあ、それは私が選んだトリッキーな例です。 たくさんの<code>optional</code>。</p>
<p><a name="Label"></a></p>
<h2 id="ラベル付けと隠蔽">ラベル付けと隠蔽</h2>
<p>時には期待されるアイテムのリストがかなり長くなるかもしれません。 認識されていないスキームを使用しようとしたときに得られるものを覚えていますか？</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb44-1"><a href="#cb44-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pUri <span class="op">&lt;</span>* eof) <span class="st">&quot;foo://example.com&quot;</span></span>
<span id="cb44-2"><a href="#cb44-2"></a><span class="ex">1</span>:1:</span>
<span id="cb44-3"><a href="#cb44-3"></a>  <span class="kw">|</span></span>
<span id="cb44-4"><a href="#cb44-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">foo</span>://example.com</span>
<span id="cb44-5"><a href="#cb44-5"></a>  <span class="kw">|</span> ^</span>
<span id="cb44-6"><a href="#cb44-6"></a><span class="ex">unexpected</span> <span class="st">&quot;foo://&quot;</span></span>
<span id="cb44-7"><a href="#cb44-7"></a><span class="ex">expecting</span> <span class="st">&quot;data&quot;</span>, <span class="st">&quot;file&quot;</span>, <span class="st">&quot;ftp&quot;</span>, <span class="st">&quot;http&quot;</span>, <span class="st">&quot;https&quot;</span>, <span class="st">&quot;irc&quot;</span>, or <span class="st">&quot;mailto&quot;</span></span></code></pre></div>
<p><code>megaparsec</code> は、一般的に<em>ラベル</em>と呼ばれるカスタムで、期待されるアイテムを上書きする方法を提供します。これは、<code>label</code> プリミティブ(<code>(&lt;?&gt;)</code> 演算子の形式のシノニムを持つ)を使用して行われます。</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1"></a><span class="ot">pUri ::</span> <span class="dt">Parser</span> <span class="dt">Uri</span></span>
<span id="cb45-2"><a href="#cb45-2"></a>pUri <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb45-3"><a href="#cb45-3"></a>  uriScheme <span class="ot">&lt;-</span> pScheme <span class="op">&lt;?&gt;</span> <span class="st">&quot;valid scheme&quot;</span></span>
<span id="cb45-4"><a href="#cb45-4"></a>  <span class="co">-- 残りの部分は同じ</span></span></code></pre></div>
<div class="sourceCode" id="cb46"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb46-1"><a href="#cb46-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pUri <span class="op">&lt;</span>* eof) <span class="st">&quot;foo://example.com&quot;</span></span>
<span id="cb46-2"><a href="#cb46-2"></a><span class="ex">1</span>:1:</span>
<span id="cb46-3"><a href="#cb46-3"></a>  <span class="kw">|</span></span>
<span id="cb46-4"><a href="#cb46-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">foo</span>://example.com</span>
<span id="cb46-5"><a href="#cb46-5"></a>  <span class="kw">|</span> ^</span>
<span id="cb46-6"><a href="#cb46-6"></a><span class="ex">unexpected</span> <span class="st">&quot;foo://&quot;</span></span>
<span id="cb46-7"><a href="#cb46-7"></a><span class="ex">expecting</span> valid scheme</span></code></pre></div>
<p>エラーメッセージを読みやすくするために、ラベルを追加します。</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1"></a><span class="ot">pUri ::</span> <span class="dt">Parser</span> <span class="dt">Uri</span></span>
<span id="cb47-2"><a href="#cb47-2"></a>pUri <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb47-3"><a href="#cb47-3"></a>  uriScheme <span class="ot">&lt;-</span> pScheme <span class="op">&lt;?&gt;</span> <span class="st">&quot;valid scheme&quot;</span></span>
<span id="cb47-4"><a href="#cb47-4"></a>  void (char <span class="ch">':'</span>)</span>
<span id="cb47-5"><a href="#cb47-5"></a>  uriAuthority <span class="ot">&lt;-</span> optional <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb47-6"><a href="#cb47-6"></a>    void (string <span class="st">&quot;//&quot;</span>)</span>
<span id="cb47-7"><a href="#cb47-7"></a>    authUser <span class="ot">&lt;-</span> optional <span class="op">.</span> try <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb47-8"><a href="#cb47-8"></a>      user <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar <span class="op">&lt;?&gt;</span> <span class="st">&quot;username&quot;</span></span>
<span id="cb47-9"><a href="#cb47-9"></a>      void (char <span class="ch">':'</span>)</span>
<span id="cb47-10"><a href="#cb47-10"></a>      password <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar <span class="op">&lt;?&gt;</span> <span class="st">&quot;password&quot;</span></span>
<span id="cb47-11"><a href="#cb47-11"></a>      void (char <span class="ch">'@'</span>)</span>
<span id="cb47-12"><a href="#cb47-12"></a>      <span class="fu">return</span> (user, password)</span>
<span id="cb47-13"><a href="#cb47-13"></a>    authHost <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some (alphaNumChar <span class="op">&lt;|&gt;</span> char <span class="ch">'.'</span>) <span class="op">&lt;?&gt;</span> <span class="st">&quot;hostname&quot;</span></span>
<span id="cb47-14"><a href="#cb47-14"></a>    authPort <span class="ot">&lt;-</span> optional (char <span class="ch">':'</span> <span class="op">*&gt;</span> label <span class="st">&quot;port number&quot;</span> L.decimal)</span>
<span id="cb47-15"><a href="#cb47-15"></a>    <span class="fu">return</span> <span class="dt">Authority</span> {<span class="op">..</span>}</span>
<span id="cb47-16"><a href="#cb47-16"></a>  <span class="fu">return</span> <span class="dt">Uri</span> {<span class="op">..</span>}</span></code></pre></div>
<p>例:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb48-1"><a href="#cb48-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pUri <span class="op">&lt;</span>* eof) <span class="st">&quot;https://mark:@example.com&quot;</span></span>
<span id="cb48-2"><a href="#cb48-2"></a><span class="ex">1</span>:14:</span>
<span id="cb48-3"><a href="#cb48-3"></a>  <span class="kw">|</span></span>
<span id="cb48-4"><a href="#cb48-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">https</span>://mark:@example.com</span>
<span id="cb48-5"><a href="#cb48-5"></a>  <span class="kw">|</span>              ^</span>
<span id="cb48-6"><a href="#cb48-6"></a><span class="ex">unexpected</span> <span class="st">'@'</span></span>
<span id="cb48-7"><a href="#cb48-7"></a><span class="ex">expecting</span> port number</span></code></pre></div>
<p>もう1つのプリミティブは <code>hidden</code> と呼ばれます。 <code>label</code> が名前の変更であることに対し、 hiddenは単にそれらを完全に削除します。 比較しましょう。</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb49-1"><a href="#cb49-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (many (char <span class="st">'a'</span>) <span class="op">&gt;&gt;</span> <span class="ex">many</span> (char <span class="st">'b'</span>) <span class="op">&gt;&gt;</span> <span class="ex">eof</span> :: Parser ()) <span class="st">&quot;d&quot;</span></span>
<span id="cb49-2"><a href="#cb49-2"></a><span class="ex">1</span>:1:</span>
<span id="cb49-3"><a href="#cb49-3"></a>  <span class="kw">|</span></span>
<span id="cb49-4"><a href="#cb49-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">d</span></span>
<span id="cb49-5"><a href="#cb49-5"></a>  <span class="kw">|</span> ^</span>
<span id="cb49-6"><a href="#cb49-6"></a><span class="ex">unexpected</span> <span class="st">'d'</span></span>
<span id="cb49-7"><a href="#cb49-7"></a><span class="ex">expecting</span> <span class="st">'a'</span>, <span class="st">'b'</span>, or end of input</span>
<span id="cb49-8"><a href="#cb49-8"></a></span>
<span id="cb49-9"><a href="#cb49-9"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (many (char <span class="st">'a'</span>) <span class="op">&gt;&gt;</span> <span class="ex">hidden</span> (many (char <span class="st">'b'</span>)) <span class="op">&gt;&gt;</span> <span class="ex">eof</span> :: Parser ()) <span class="st">&quot;d&quot;</span></span>
<span id="cb49-10"><a href="#cb49-10"></a><span class="ex">1</span>:1:</span>
<span id="cb49-11"><a href="#cb49-11"></a>  <span class="kw">|</span></span>
<span id="cb49-12"><a href="#cb49-12"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">d</span></span>
<span id="cb49-13"><a href="#cb49-13"></a>  <span class="kw">|</span> ^</span>
<span id="cb49-14"><a href="#cb49-14"></a><span class="ex">unexpected</span> <span class="st">'d'</span></span>
<span id="cb49-15"><a href="#cb49-15"></a><span class="ex">expecting</span> <span class="st">'a'</span> or end of input</span></code></pre></div>
<p>エラーメッセージのノイズを少なくすることが望ましい場合は、 <code>hidden</code> を使用してください。 例えば、プログラミング言語をパースするときは、通常、各トークンの後に空白文字がある可能性があるため、“expecting white space” というメッセージを削除することをお勧めします。</p>
<p>演習 : <code>pUri</code> パーサを完成させることは読者のための課題として残されています。完成に必要なすべてのツールは説明されました。</p>
<p><a name="Run"></a></p>
<h2 id="パーサの実行">パーサの実行</h2>
<p>パーサを構築する方法を詳細に調べました。 しかし、 <code>parseTest</code> を除いて、 それらを実行できる関数を調べていませんでした。</p>
<p>慣習的に、あなたがプログラムしたパーサを実行するための “デフォルト”の関数は <code>parse</code> でした。 しかし、<code>parse</code> は実際には <code>runParser</code> のシノニムです。</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1"></a>runParser</span>
<span id="cb50-2"><a href="#cb50-2"></a><span class="ot">  ::</span> <span class="dt">Parsec</span> e s a <span class="co">-- ^ 実行するパーサ</span></span>
<span id="cb50-3"><a href="#cb50-3"></a>  <span class="ot">-&gt;</span> <span class="dt">String</span>     <span class="co">-- ^ ソースファイルの名前</span></span>
<span id="cb50-4"><a href="#cb50-4"></a>  <span class="ot">-&gt;</span> s          <span class="co">-- ^ パーサへの入力</span></span>
<span id="cb50-5"><a href="#cb50-5"></a>  <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">ParseErrorBundle</span> s e) a</span></code></pre></div>
<p>2番目の引数は、生成されたパースエラーに含まれる単なるファイル名です。 実際の入力は関数の3番目の引数として渡されるため、 <code>megaparsec</code> はそのファイルから何も読みません。</p>
<p><code>runParser</code> を使用すると、<code>Parsec</code> モナドを実行できます。 これは、既にご存知のとおり、変換子を使わないバージョンの <code>ParsecT</code> です。</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1"></a><span class="kw">type</span> <span class="dt">Parsec</span> e s <span class="ot">=</span> <span class="dt">ParsecT</span> e s <span class="dt">Identity</span></span></code></pre></div>
<p><code>runParser</code> には、<code>runParser'</code>、<code>runParserT</code>、 および <code>runParserT'</code> の3つの変種があります。 接尾辞 <code>T</code> の付いたバージョンは <code>PrasecT</code> モナド変換子を実行し、 「プライム」バージョンはパーサの状態を受け取り、返します。 すべての関数を表にまとめましょう。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">引数</th>
<th style="text-align: left;"><code>Parsec</code> の実行</th>
<th style="text-align: left;"><code>ParsecT</code> の実行</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">入力とファイル名</td>
<td style="text-align: left;"><code>runParser</code></td>
<td style="text-align: left;"><code>runParserT</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">カスタム初期状態</td>
<td style="text-align: left;"><code>runParser'</code></td>
<td style="text-align: left;"><code>runParserT'</code></td>
</tr>
</tbody>
</table>
<p>タブの幅を標準以外の値(デフォルトの値は8)に設定したい場合など、 カスタム初期状態が必要な場合があります。 例として、<code>runParser'</code> の型シグネチャはこのようになっています。</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1"></a>runParser'</span>
<span id="cb52-2"><a href="#cb52-2"></a><span class="ot">  ::</span> <span class="dt">Parsec</span> e s a <span class="co">-- ^ 実行するパーサ</span></span>
<span id="cb52-3"><a href="#cb52-3"></a>  <span class="ot">-&gt;</span> <span class="dt">State</span> s    <span class="co">-- ^ 初期状態</span></span>
<span id="cb52-4"><a href="#cb52-4"></a>  <span class="ot">-&gt;</span> (<span class="dt">State</span> s, <span class="dt">Either</span> (<span class="dt">ParseErrorBundle</span> s e) a)</span></code></pre></div>
<p>手動で状態を変更することはライブラリの高度な使用法であり、 ここでは説明しません。</p>
<p><code>ParseErrorBundle</code> とは何かについて疑問に思う場合は、 <a href="#Error">この後の節のいずれか</a>で説明します。</p>
<p><a name="MonadParsec"></a></p>
<h2 id="monadparsec-型クラス"><code>MonadParsec</code> 型クラス</h2>
<p><code>megaparsec</code> のすべてのツールは、 <code>MonadParsec</code> 型クラスの任意のインスタンスと連携します。 型クラスは、プリミティブコンビネータ、 つまりすべての <code>megaparsec</code> のパーサの基本的な構成要素、 他のコンビネータでは表現できないコンビネータを抽象化します。</p>
<p>プリミティブコンビネータを型クラスに持つことで、 <code>megaarsec</code> の <code>ParsecT</code> の主要なモナド変換子を、 MTL系のよく知られている変換子にラップして、 モナドスタックのレイヤー間でさまざまな相互作用を実現することができます。 動機をよりよく理解するために、 モナドスタック内のレイヤーの順序が重要であることを思い出してください。 このように <code>ReaderT</code> と <code>State</code> を組み合わせると、</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1"></a><span class="kw">type</span> <span class="dt">MyStack</span> a <span class="ot">=</span> <span class="dt">ReaderT</span> <span class="dt">MyContext</span> (<span class="dt">State</span> <span class="dt">MyState</span>) a</span></code></pre></div>
<p>外側のレイヤー <code>ReaderT</code> はその下のレイヤー <code>m</code> の内部構造を検査できません。 <code>ReaderT</code> の <code>Monad</code> インスタンスはバインディングの戦略を記述しています。</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1"></a><span class="kw">newtype</span> <span class="dt">ReaderT</span> r m a <span class="ot">=</span> <span class="dt">ReaderT</span> {<span class="ot"> runReaderT ::</span> r <span class="ot">-&gt;</span> m a }</span>
<span id="cb54-2"><a href="#cb54-2"></a></span>
<span id="cb54-3"><a href="#cb54-3"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">ReaderT</span> r m) <span class="kw">where</span></span>
<span id="cb54-4"><a href="#cb54-4"></a>  m <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="dt">ReaderT</span> <span class="op">$</span> \r <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb54-5"><a href="#cb54-5"></a>    a <span class="ot">&lt;-</span> runReaderT m r</span>
<span id="cb54-6"><a href="#cb54-6"></a>    runReaderT (k a) r</span></code></pre></div>
<p>実際、<code>m</code> について私たちが知っている唯一のことは、 それが <code>Monad</code>のインスタンスであり、 したがって <code>m</code> の状態はモナディックバインドを介してのみ <code>k</code> に渡すことができるということです。 とにかくそれが <code>ReaderT</code> の <code>(&gt;&gt;=)</code> から私たちが通常欲しいものです。</p>
<p><code>Alternative</code> 型クラスの <code>(&lt;|&gt;)</code> メソッドは異なった働きをします。 それは状態を「分割」し、パーサの2つの分岐はもう接触しません。 そのため、最初の分岐が破棄されるとその状態への変更も破棄され、 2番目の分岐に影響を与えることはできないという意味で バックトラックした状態になります (最初の分岐が失敗したときの状態を「バックトラック」します。)。</p>
<p>説明のために、ReaderTのAlternativeの定義を見てみましょう。</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1"></a><span class="kw">instance</span> <span class="dt">Alternative</span> m <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">ReaderT</span> r m) <span class="kw">where</span></span>
<span id="cb55-2"><a href="#cb55-2"></a>  empty <span class="ot">=</span> liftReaderT empty</span>
<span id="cb55-3"><a href="#cb55-3"></a>  <span class="dt">ReaderT</span> m <span class="op">&lt;|&gt;</span> <span class="dt">ReaderT</span> n <span class="ot">=</span> <span class="dt">ReaderT</span> <span class="op">$</span> \r <span class="ot">-&gt;</span> m r <span class="op">&lt;|&gt;</span> n r</span></code></pre></div>
<p><code>ReaderT</code> は「ステートレス」なモナド変換子であり、 (何を持っていない) <code>ReaderT</code> 自体に関連するモナドの状態を組み合わせる必要なしに(ここで <code>m</code> の <code>Alternative</code> インスタンスが役に立ちます。) 実際の作業を内部のモナドに委任するのは簡単なので、 これはすべて非常に素晴らしいことです。</p>
<p>それでは、Stateを見てみましょう。 <code>State s a</code> は <code>StateT s Identity a</code> の単なるシノニムなので、 <code>StateT s m</code> 自体の <code>Alternative</code> インスタンスを見てください。</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1"></a><span class="kw">instance</span> (<span class="dt">Functor</span> m, <span class="dt">Alternative</span> m) <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">StateT</span> s m) <span class="kw">where</span></span>
<span id="cb56-2"><a href="#cb56-2"></a>  empty <span class="ot">=</span> <span class="dt">StateT</span> <span class="op">$</span> \_ <span class="ot">-&gt;</span> empty</span>
<span id="cb56-3"><a href="#cb56-3"></a>  <span class="dt">StateT</span> m <span class="op">&lt;|&gt;</span> <span class="dt">StateT</span> n <span class="ot">=</span> <span class="dt">StateT</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> m s <span class="op">&lt;|&gt;</span> n s</span></code></pre></div>
<p>ここでは、reader のコンテキスト <code>r</code> の共有を見たように、 状態 <code>s</code> の分割を見ることができます。 ただし、<code>m s</code> と <code>n s</code> の式はステートフルな結果を生成するため、 モナディック値と一緒に、新しい状態をタプルで返すという違いがあります。 ここでは、<code>m s</code> か <code>n s</code> のどちらかで進み、 自然にバックトラックを達成します。</p>
<p><code>ParsecT</code> はどうですか？ <code>State</code> を <code>ParsecT</code> の中に次のように置くことを考えてみましょう。</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1"></a><span class="kw">type</span> <span class="dt">MyStack</span> a <span class="ot">=</span> <span class="dt">ParsecT</span> <span class="dt">Void</span> <span class="dt">Text</span> (<span class="dt">State</span> <span class="dt">MyState</span>) a</span></code></pre></div>
<p><code>ParsecT</code> は <code>ReaderT</code> よりも複雑で、<code>(&lt;|&gt;)</code>の実装にはもっと多くのことが必要です。</p>
<ul>
<li>パーサ自体の状態管理</li>
<li>起こるべき（適切な）パースエラーのマージ。</li>
</ul>
<p><code>ParsecT</code> の <code>Alternative</code> のインスタンスへの<code>(&lt;|&gt;)</code>の実装は、 その基盤となる <code>State MyState</code> モナドの <code>Alternative</code>インスタンスに その作業を委任することができないので、<code>MyState</code>の分割は発生せず、 バックトラックはありません。</p>
<p>例を挙げて説明しましょう。</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb58-2"><a href="#cb58-2"></a></span>
<span id="cb58-3"><a href="#cb58-3"></a><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></span>
<span id="cb58-4"><a href="#cb58-4"></a></span>
<span id="cb58-5"><a href="#cb58-5"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb58-6"><a href="#cb58-6"></a><span class="kw">import</span> <span class="dt">Control.Monad.State.Strict</span></span>
<span id="cb58-7"><a href="#cb58-7"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb58-8"><a href="#cb58-8"></a><span class="kw">import</span> <span class="dt">Data.Void</span></span>
<span id="cb58-9"><a href="#cb58-9"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span> <span class="kw">hiding</span> (<span class="dt">State</span>)</span>
<span id="cb58-10"><a href="#cb58-10"></a></span>
<span id="cb58-11"><a href="#cb58-11"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">ParsecT</span> <span class="dt">Void</span> <span class="dt">Text</span> (<span class="dt">State</span> <span class="dt">String</span>)</span>
<span id="cb58-12"><a href="#cb58-12"></a></span>
<span id="cb58-13"><a href="#cb58-13"></a><span class="ot">parser0 ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb58-14"><a href="#cb58-14"></a>parser0 <span class="ot">=</span> a <span class="op">&lt;|&gt;</span> b</span>
<span id="cb58-15"><a href="#cb58-15"></a>  <span class="kw">where</span></span>
<span id="cb58-16"><a href="#cb58-16"></a>    a <span class="ot">=</span> <span class="st">&quot;foo&quot;</span> <span class="op">&lt;$</span> put <span class="st">&quot;branch A&quot;</span></span>
<span id="cb58-17"><a href="#cb58-17"></a>    b <span class="ot">=</span> get   <span class="op">&lt;*</span> put <span class="st">&quot;branch B&quot;</span></span>
<span id="cb58-18"><a href="#cb58-18"></a></span>
<span id="cb58-19"><a href="#cb58-19"></a><span class="ot">parser1 ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb58-20"><a href="#cb58-20"></a>parser1 <span class="ot">=</span> a <span class="op">&lt;|&gt;</span> b</span>
<span id="cb58-21"><a href="#cb58-21"></a>  <span class="kw">where</span></span>
<span id="cb58-22"><a href="#cb58-22"></a>    a <span class="ot">=</span> <span class="st">&quot;foo&quot;</span> <span class="op">&lt;$</span> put <span class="st">&quot;branch A&quot;</span> <span class="op">&lt;*</span> empty</span>
<span id="cb58-23"><a href="#cb58-23"></a>    b <span class="ot">=</span> get   <span class="op">&lt;*</span> put <span class="st">&quot;branch B&quot;</span></span>
<span id="cb58-24"><a href="#cb58-24"></a></span>
<span id="cb58-25"><a href="#cb58-25"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb58-26"><a href="#cb58-26"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb58-27"><a href="#cb58-27"></a>  <span class="kw">let</span> run p          <span class="ot">=</span> runState (runParserT p <span class="st">&quot;&quot;</span> <span class="st">&quot;&quot;</span>) <span class="st">&quot;initial&quot;</span></span>
<span id="cb58-28"><a href="#cb58-28"></a>      (<span class="dt">Right</span> a0, s0) <span class="ot">=</span> run parser0</span>
<span id="cb58-29"><a href="#cb58-29"></a>      (<span class="dt">Right</span> a1, s1) <span class="ot">=</span> run parser1</span>
<span id="cb58-30"><a href="#cb58-30"></a></span>
<span id="cb58-31"><a href="#cb58-31"></a>  <span class="fu">putStrLn</span>  <span class="st">&quot;Parser 0&quot;</span></span>
<span id="cb58-32"><a href="#cb58-32"></a>  <span class="fu">putStrLn</span> (<span class="st">&quot;Result:      &quot;</span> <span class="op">++</span> <span class="fu">show</span> a0)</span>
<span id="cb58-33"><a href="#cb58-33"></a>  <span class="fu">putStrLn</span> (<span class="st">&quot;Final state: &quot;</span> <span class="op">++</span> <span class="fu">show</span> s0)</span>
<span id="cb58-34"><a href="#cb58-34"></a></span>
<span id="cb58-35"><a href="#cb58-35"></a>  <span class="fu">putStrLn</span>  <span class="st">&quot;Parser 1&quot;</span></span>
<span id="cb58-36"><a href="#cb58-36"></a>  <span class="fu">putStrLn</span> (<span class="st">&quot;Result:      &quot;</span> <span class="op">++</span> <span class="fu">show</span> a1)</span>
<span id="cb58-37"><a href="#cb58-37"></a>  <span class="fu">putStrLn</span> (<span class="st">&quot;Final state: &quot;</span> <span class="op">++</span> <span class="fu">show</span> s1)</span></code></pre></div>
<p>これがプログラムを実行した結果です。</p>
<pre><code>Parser 0
Result:      &quot;foo&quot;
Final state: &quot;branch A&quot;
Parser 1
Result:      &quot;branch A&quot;
Final state: &quot;branch B&quot;</code></pre>
<p><code>parser0</code> を使うと、分岐 <code>b</code> が試行されていないことがわかります。 しかしparser1では、<code>empty</code> によって失敗し、 成功したのは分岐 <code>b</code> であるにもかかわらず、 最終結果（<code>get</code> によって返される値）が分岐 <code>a</code>から得られることは明らかです。 (パーサの文脈では <code>empty</code> は 「即座に失敗し、何が起こったのかについての情報がない」 という意味です。) バックトラックは発生しません。</p>
<p>パーサーでカスタム状態をバックトラックしたい場合はどうしますか？ <code>ParsecT</code> を <code>StateT</code> 内にラップすることを許可するならば、それを提供することができます。</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1"></a><span class="kw">type</span> <span class="dt">MyStack</span> a <span class="ot">=</span> <span class="dt">StateT</span> <span class="dt">MyState</span> (<span class="dt">ParsecT</span> <span class="dt">Void</span> <span class="dt">Text</span> <span class="dt">Identity</span>) a</span></code></pre></div>
<p><code>MyStack</code> で <code>(&lt;|&gt;)</code> を使用すると、 使用されるインスタンスは <code>StateT</code> のインスタンスになります。</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1"></a><span class="dt">StateT</span> m <span class="op">&lt;|&gt;</span> <span class="dt">StateT</span> n <span class="ot">=</span> <span class="dt">StateT</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> m s <span class="op">&lt;|&gt;</span> n s</span></code></pre></div>
<p>これは状態をバックトラックさせ、 それから残りの作業をその内部モナド<code>ParsecT</code> の <code>Alternative</code> インスタンスに委任します。 この動作はまさに私たちが望むものです。</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb62-2"><a href="#cb62-2"></a></span>
<span id="cb62-3"><a href="#cb62-3"></a><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></span>
<span id="cb62-4"><a href="#cb62-4"></a></span>
<span id="cb62-5"><a href="#cb62-5"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb62-6"><a href="#cb62-6"></a><span class="kw">import</span> <span class="dt">Control.Monad.Identity</span></span>
<span id="cb62-7"><a href="#cb62-7"></a><span class="kw">import</span> <span class="dt">Control.Monad.State.Strict</span></span>
<span id="cb62-8"><a href="#cb62-8"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb62-9"><a href="#cb62-9"></a><span class="kw">import</span> <span class="dt">Data.Void</span></span>
<span id="cb62-10"><a href="#cb62-10"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span> <span class="kw">hiding</span> (<span class="dt">State</span>)</span>
<span id="cb62-11"><a href="#cb62-11"></a></span>
<span id="cb62-12"><a href="#cb62-12"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">StateT</span> <span class="dt">String</span> (<span class="dt">ParsecT</span> <span class="dt">Void</span> <span class="dt">Text</span> <span class="dt">Identity</span>)</span>
<span id="cb62-13"><a href="#cb62-13"></a></span>
<span id="cb62-14"><a href="#cb62-14"></a><span class="ot">parser ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb62-15"><a href="#cb62-15"></a>parser <span class="ot">=</span> a <span class="op">&lt;|&gt;</span> b</span>
<span id="cb62-16"><a href="#cb62-16"></a>  <span class="kw">where</span></span>
<span id="cb62-17"><a href="#cb62-17"></a>    a <span class="ot">=</span> <span class="st">&quot;foo&quot;</span> <span class="op">&lt;$</span> put <span class="st">&quot;branch A&quot;</span> <span class="op">&lt;*</span> empty</span>
<span id="cb62-18"><a href="#cb62-18"></a>    b <span class="ot">=</span> get   <span class="op">&lt;*</span> put <span class="st">&quot;branch B&quot;</span></span>
<span id="cb62-19"><a href="#cb62-19"></a></span>
<span id="cb62-20"><a href="#cb62-20"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb62-21"><a href="#cb62-21"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb62-22"><a href="#cb62-22"></a>  <span class="kw">let</span> p            <span class="ot">=</span> runStateT parser <span class="st">&quot;initial&quot;</span></span>
<span id="cb62-23"><a href="#cb62-23"></a>      <span class="dt">Right</span> (a, s) <span class="ot">=</span> runParser p <span class="st">&quot;&quot;</span> <span class="st">&quot;&quot;</span></span>
<span id="cb62-24"><a href="#cb62-24"></a>  <span class="fu">putStrLn</span> (<span class="st">&quot;Result:      &quot;</span> <span class="op">++</span> <span class="fu">show</span> a)</span>
<span id="cb62-25"><a href="#cb62-25"></a>  <span class="fu">putStrLn</span> (<span class="st">&quot;Final state: &quot;</span> <span class="op">++</span> <span class="fu">show</span> s)</span></code></pre></div>
<p>プログラムは次のように出力します。</p>
<pre><code>Result:      &quot;initial&quot;
Final state: &quot;branch B&quot;</code></pre>
<p>このアプローチを実行可能にするために、 <code>StateT</code> はプリミティブパーサのセット全体をサポートするべきであり、 そうすることで <code>ParsecT</code> と同じようにそれを扱うことができます。 言い換えれば、 内部モナドが(MTLの)<code>MonadWriter</code>のインスタンスである場合は <code>MonadState</code> だけではなく、<code>MonadWriter</code>も <code>MonadParsec</code>のインスタンスである必要があります。</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1"></a><span class="kw">instance</span> <span class="dt">MonadWriter</span> w m <span class="ot">=&gt;</span> <span class="dt">MonadWriter</span> w (<span class="dt">StateT</span> s m) <span class="kw">where</span> …</span></code></pre></div>
<p>確かに、<code>MonadParsec</code> の内部インスタンスから <code>StateT</code> に プリミティブを持ち上げることができます。</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1"></a><span class="kw">instance</span> <span class="dt">MonadParsec</span> e s m <span class="ot">=&gt;</span> <span class="dt">MonadParsec</span> e s (<span class="dt">StateT</span> st m) <span class="kw">where</span> …</span></code></pre></div>
<p><code>megaparsec</code>は MTL のすべてのモナド変換子に対して <code>MonadParsec</code> のインスタンスを定義しているので、 ユーザーは変換子を <code>ParsecT</code> の内側に挿入したり、 それらの変換子で <code>ParsecT</code> をラップしたりして、 モナドスタックの層間で異なる種類の相互作用を実現できます。</p>
<p><a name="Lexing"></a></p>
<h2 id="字句解析">字句解析</h2>
<p>字句解析は、入力ストリームを整数、キーワード、シンボルなどのトークン のストリームに変換するプロセスです。 これらは、生の入力を直接パースするよりもパースが容易であるか、 またはパーサジェネレータで生成されたパーサへの入力として期待されます。 字句解析は、<code>alex</code>などの外部ツールを使用して別のパスで実行できますが、 <code>megaparsec</code>はパーサの一部として、シームレスに字句解析プログラムを書くことを簡単にする関数も提供します。</p>
<p>文字ストリーム用の <code>Text.Megaparsec.Char.Lexer</code> と バイトストリーム用の <code>Text.Megaparsec.Byte.Lexer</code> の 2つの字句解析モジュールがあります。 正格な <code>Text</code> を入力ストリームとして扱うので <code>Text.Megaparsec.Char.Lexer</code> を使いますが、 <code>ByteStrings</code> を使いたい場合はほとんどの関数は <code>Text.Megaparsec.Byte.Lexer</code> にも反映されます。</p>
<p><a name="White"></a></p>
<h2 id="空白">空白</h2>
<p>最初に取り上げる必要があるトピックは、空白の扱いです。 すべてのトークンの前またはすべてのトークンの後に、 一貫した方法で空白を消費することが役立ちます。 Megaparsec の字句解析モジュールは、 「トークンの前に空白を入れず、トークンの後にすべての空白を消費する」 という戦略に従います。</p>
<p>空白を消費するには、<em>スペースコンシューマ</em> と呼ばれる特別なパーサが必要です。 <code>Text.Megaparsec.Char.Lexer</code> モジュールは、 一般的なスペースコンシューマを構築するためのヘルパーを提供します。</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1"></a><span class="ot">space ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb66-2"><a href="#cb66-2"></a>  <span class="ot">=&gt;</span> m () <span class="co">-- ^ 空の入力を受け入れない空白文字のパーサ</span></span>
<span id="cb66-3"><a href="#cb66-3"></a>          <span class="co">-- (e.g. 'space1')</span></span>
<span id="cb66-4"><a href="#cb66-4"></a>  <span class="ot">-&gt;</span> m () <span class="co">-- ^ 行コメントのパーサ (e.g. 'skipLineComment')</span></span>
<span id="cb66-5"><a href="#cb66-5"></a>  <span class="ot">-&gt;</span> m () <span class="co">-- ^ ブロックコメントのパーサ (e.g. 'skipBlockComment')</span></span>
<span id="cb66-6"><a href="#cb66-6"></a>  <span class="ot">-&gt;</span> m ()</span></code></pre></div>
<p><code>space</code> 関数のドキュメンテーションはそれ自体で非常に包括的ですが、 例を挙げて補足しましょう。</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb67-2"><a href="#cb67-2"></a></span>
<span id="cb67-3"><a href="#cb67-3"></a><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></span>
<span id="cb67-4"><a href="#cb67-4"></a></span>
<span id="cb67-5"><a href="#cb67-5"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb67-6"><a href="#cb67-6"></a><span class="kw">import</span> <span class="dt">Data.Void</span></span>
<span id="cb67-7"><a href="#cb67-7"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span></span>
<span id="cb67-8"><a href="#cb67-8"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec.Char</span></span>
<span id="cb67-9"><a href="#cb67-9"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Megaparsec.Char.Lexer</span> <span class="kw">as</span> <span class="dt">L</span> <span class="co">-- (1)</span></span>
<span id="cb67-10"><a href="#cb67-10"></a></span>
<span id="cb67-11"><a href="#cb67-11"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Void</span> <span class="dt">Text</span></span>
<span id="cb67-12"><a href="#cb67-12"></a></span>
<span id="cb67-13"><a href="#cb67-13"></a><span class="ot">sc ::</span> <span class="dt">Parser</span> ()</span>
<span id="cb67-14"><a href="#cb67-14"></a>sc <span class="ot">=</span> L.space</span>
<span id="cb67-15"><a href="#cb67-15"></a>  space1                         <span class="co">-- (2)</span></span>
<span id="cb67-16"><a href="#cb67-16"></a>  (L.skipLineComment <span class="st">&quot;//&quot;</span>)       <span class="co">-- (3)</span></span>
<span id="cb67-17"><a href="#cb67-17"></a>  (L.skipBlockComment <span class="st">&quot;/*&quot;</span> <span class="st">&quot;*/&quot;</span>) <span class="co">-- (4)</span></span></code></pre></div>
<p>いくつかのメモ：</p>
<ul>
<li><p><code>Text.Megaparsec.Char.Lexer</code>は、修飾付きでインポートされることを意図されています。なぜなら、Text.Megaparsec.Charの<code>space</code>のように衝突する名前を含んでいるからです。</p></li>
<li><p><code>L.space</code> の最初の引数は空白を拾うために使用されることになっているパーサであるべきです。重要な点は、<code>L.space</code>が無限ループに入ってしまうので、空の入力を受け入れてはいけないということです。<code>space1</code>は、要件を完全に満たす <code>Text.Megaparsec.Char</code> のパーサです。</p></li>
<li><p><code>L.space</code> の2番目の引数は、行コメント、すなわち、与えられたトークンのシーケンスで始まり行の終わりで終わるコメントをスキップする方法を定義します。<code>skipLineComment</code> ヘルパーを使用すると、行コメント用の補助パーサを簡単に作成できます。</p></li>
<li><p><code>L.space</code> の3番目の引数は、ブロックコメント、つまりトークンの開始シーケンスと終了シーケンスの間のすべてのものをを受け取る方法を定義します。<code>skipBlockComment</code> ヘルパーは、ネストされていないブロックコメントを扱うことができます。ネストされたブロックコメントをサポートする場合は、代わりに <code>skipBlockCommentNested</code> を使用してください。</p></li>
</ul>
<p>操作的には、<code>L.space</code> は3つすべてのパーサを適用できなくなるまで、順番に試行します。つまり、空白がすべて消費されたことになります。 これを知っていれば、文法にブロックコメントや行コメントが含まれていない場合は、<code>L.space</code>の2番目または3番目の引数として<code>empty</code>を渡すことができます。 <code>(&lt;|&gt;)</code> の単位元である <code>empty</code> は、<code>L.space</code> が次の空白要素のためにパーサを試みるようにします。まさに望んでいたことです。</p>
<p>スペースコンシューマ <code>sc</code> を持っているなら、 さまざまな空白関連のヘルパーを定義できます。</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb68-1"><a href="#cb68-1"></a><span class="ot">lexeme ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb68-2"><a href="#cb68-2"></a>lexeme <span class="ot">=</span> L.lexeme sc</span>
<span id="cb68-3"><a href="#cb68-3"></a></span>
<span id="cb68-4"><a href="#cb68-4"></a><span class="ot">symbol ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Text</span></span>
<span id="cb68-5"><a href="#cb68-5"></a>symbol <span class="ot">=</span> L.symbol sc</span></code></pre></div>
<ul>
<li><p><code>lexeme</code> は、供給されたスペースコンシューマを使用してすべての末尾の空白を取る、語彙素のラッパーです。</p></li>
<li><p><code>symbol</code> は内部で <code>string</code> を使って与えられたテキストにマッチさせ、そして同様にすべての末尾の空白を拾うパーサです。</p></li>
</ul>
<p>私たちはすぐにそれがすべて一緒に動作する方法を見ますが、 最初に <code>Text.Megaparsec.Char.Lexer</code> からさらに2,3のヘルパーを 導入する必要があります。</p>
<p><a name="Chara"></a></p>
<h2 id="文字と文字列リテラル">文字と文字列リテラル</h2>
<p>エスケープ規則はさまざまなので、 文字リテラルおよび文字列リテラルのパースは難しい場合があります。 簡単にするために、<code>megaparsec</code> は <code>charLiteral</code> パーサを提供します。</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb69-1"><a href="#cb69-1"></a><span class="ot">charLiteral ::</span> (<span class="dt">MonadParsec</span> e s m, <span class="dt">Token</span> s <span class="op">~</span> <span class="dt">Char</span>) <span class="ot">=&gt;</span> m <span class="dt">Char</span></span></code></pre></div>
<p><code>charLiteral</code> の仕事は、Haskellレポートに記述されている文字リテラルの構文に従ってエスケープされる可能性がある単一の文字をパースすることです。 ただし、次の2つの理由から、リテラルを囲む引用符はパースされません。</p>
<ul>
<li><p>ユーザーは文字リテラルの引用方法を制御できる</p></li>
<li><p>そのため、charLiteralを使用して文字列リテラルもパースできる</p></li>
</ul>
<p><code>charLiteral</code>の上に構築されたパーサの例をいくつか示します。</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb70-1"><a href="#cb70-1"></a><span class="ot">charLiteral ::</span> <span class="dt">Parser</span> <span class="dt">Char</span></span>
<span id="cb70-2"><a href="#cb70-2"></a>charLiteral <span class="ot">=</span> between (char <span class="ch">'\''</span>) (char <span class="ch">'\''</span>) L.charLiteral</span>
<span id="cb70-3"><a href="#cb70-3"></a></span>
<span id="cb70-4"><a href="#cb70-4"></a><span class="ot">stringLiteral ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb70-5"><a href="#cb70-5"></a>stringLiteral <span class="ot">=</span> char <span class="ch">'\&quot;'</span> <span class="op">*&gt;</span> manyTill L.charLiteral (char <span class="ch">'\&quot;'</span>)</span></code></pre></div>
<ul>
<li><p><code>L.charLiteral</code> を文字リテラルのパーサに変えるには、囲む引用符を追加するだけです。ここではHaskellの構文に従い、シングルクオートを使います。<code>between</code>コンビネータは、単純に<code>between open close p = open *&gt; p &lt;* close</code>ように定義されます。</p></li>
<li><p><code>stringLiteral</code>はダブルクオートで囲まれた文字列リテラル内の個々の文字をパースするために <code>L.charLiteral</code> を使用します。</p></li>
</ul>
<p>2番目の関数も、<code>manyTill</code> コンビネータを使用しているため興味深いです。</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb71-1"><a href="#cb71-1"></a><span class="ot">manyTill ::</span> <span class="dt">Alternative</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> m end <span class="ot">-&gt;</span> m [a]</span>
<span id="cb71-2"><a href="#cb71-2"></a>manyTill p end <span class="ot">=</span> go</span>
<span id="cb71-3"><a href="#cb71-3"></a>  <span class="kw">where</span></span>
<span id="cb71-4"><a href="#cb71-4"></a>    go <span class="ot">=</span> ([] <span class="op">&lt;$</span> end) <span class="op">&lt;|&gt;</span> ((<span class="op">:</span>) <span class="op">&lt;$&gt;</span> p <span class="op">&lt;*&gt;</span> go)</span></code></pre></div>
<p><code>manyTill</code> は繰り返しごとにパーサ <code>end</code> を適用しようとし、 失敗するとパーサ <code>p</code> を実行して <code>p</code> の結果をリストに蓄積します。</p>
<p>少なくとも1つのアイテムが存在することを要求する <code>someTill</code> もあります。</p>
<p><a name="Numbers"></a></p>
<h2 id="数字">数字</h2>
<p>最後に、非常に一般的なニーズは数値をパースすることです。 整数の場合、10進数、8進数、および16進数の表現で 値をパースできる3つのヘルパーがあります。</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb72-1"><a href="#cb72-1"></a>decimal, octal, hexadecimal</span>
<span id="cb72-2"><a href="#cb72-2"></a><span class="ot">  ::</span> (<span class="dt">MonadParsec</span> e s m, <span class="dt">Token</span> s <span class="op">~</span> <span class="dt">Char</span>, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> m a</span></code></pre></div>
<p>それらを使うのは簡単です。</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb73-1"><a href="#cb73-1"></a><span class="ot">integer ::</span> <span class="dt">Parser</span> <span class="dt">Integer</span></span>
<span id="cb73-2"><a href="#cb73-2"></a>integer <span class="ot">=</span> lexeme L.decimal</span></code></pre></div>
<div class="sourceCode" id="cb74"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb74-1"><a href="#cb74-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (integer <span class="op">&lt;</span>* eof) <span class="st">&quot;123  &quot;</span></span>
<span id="cb74-2"><a href="#cb74-2"></a><span class="ex">123</span></span>
<span id="cb74-3"><a href="#cb74-3"></a></span>
<span id="cb74-4"><a href="#cb74-4"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (integer <span class="op">&lt;</span>* eof) <span class="st">&quot;12a  &quot;</span></span>
<span id="cb74-5"><a href="#cb74-5"></a><span class="ex">1</span>:3:</span>
<span id="cb74-6"><a href="#cb74-6"></a>  <span class="kw">|</span></span>
<span id="cb74-7"><a href="#cb74-7"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">12a</span></span>
<span id="cb74-8"><a href="#cb74-8"></a>  <span class="kw">|</span>   ^</span>
<span id="cb74-9"><a href="#cb74-9"></a><span class="ex">unexpected</span> <span class="st">'a'</span></span>
<span id="cb74-10"><a href="#cb74-10"></a><span class="ex">expecting</span> end of input or the rest of integer</span></code></pre></div>
<p><code>scientific</code> は整数と小数の文法を受理し、 <code>float</code> は小数の文法のみ受理します。 <code>scientific</code> は<code>scientific</code>パッケージの <code>Scientific</code>型を返しますが、 <code>float</code> はその結果の型が多相的であり、 <code>RealFloat</code> の任意のインスタンスを返すことができます。</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb75-1"><a href="#cb75-1"></a><span class="ot">scientific ::</span> (<span class="dt">MonadParsec</span> e s m, <span class="dt">Token</span> s <span class="op">~</span> <span class="dt">Char</span>)              <span class="ot">=&gt;</span> m <span class="dt">Scientific</span></span>
<span id="cb75-2"><a href="#cb75-2"></a><span class="ot">float      ::</span> (<span class="dt">MonadParsec</span> e s m, <span class="dt">Token</span> s <span class="op">~</span> <span class="dt">Char</span>, <span class="dt">RealFloat</span> a) <span class="ot">=&gt;</span> m a</span></code></pre></div>
<p>例：</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb76-1"><a href="#cb76-1"></a><span class="ot">float ::</span> <span class="dt">Parser</span> <span class="dt">Double</span></span>
<span id="cb76-2"><a href="#cb76-2"></a>float <span class="ot">=</span> lexeme L.float</span></code></pre></div>
<div class="sourceCode" id="cb77"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb77-1"><a href="#cb77-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (float <span class="op">&lt;</span>* eof) <span class="st">&quot;123&quot;</span></span>
<span id="cb77-2"><a href="#cb77-2"></a><span class="ex">1</span>:4:</span>
<span id="cb77-3"><a href="#cb77-3"></a>  <span class="kw">|</span></span>
<span id="cb77-4"><a href="#cb77-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">123</span></span>
<span id="cb77-5"><a href="#cb77-5"></a>  <span class="kw">|</span>    ^</span>
<span id="cb77-6"><a href="#cb77-6"></a><span class="ex">unexpected</span> end of input</span>
<span id="cb77-7"><a href="#cb77-7"></a><span class="ex">expecting</span> <span class="st">'.'</span>, <span class="st">'E'</span>, <span class="st">'e'</span>, or digit</span>
<span id="cb77-8"><a href="#cb77-8"></a></span>
<span id="cb77-9"><a href="#cb77-9"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (float <span class="op">&lt;</span>* eof) <span class="st">&quot;123.45&quot;</span></span>
<span id="cb77-10"><a href="#cb77-10"></a><span class="ex">123.45</span></span>
<span id="cb77-11"><a href="#cb77-11"></a></span>
<span id="cb77-12"><a href="#cb77-12"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (float <span class="op">&lt;</span>* eof) <span class="st">&quot;123d&quot;</span></span>
<span id="cb77-13"><a href="#cb77-13"></a><span class="ex">1</span>:4:</span>
<span id="cb77-14"><a href="#cb77-14"></a>  <span class="kw">|</span></span>
<span id="cb77-15"><a href="#cb77-15"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">123d</span></span>
<span id="cb77-16"><a href="#cb77-16"></a>  <span class="kw">|</span>    ^</span>
<span id="cb77-17"><a href="#cb77-17"></a><span class="ex">unexpected</span> <span class="st">'d'</span></span>
<span id="cb77-18"><a href="#cb77-18"></a><span class="ex">expecting</span> <span class="st">'.'</span>, <span class="st">'E'</span>, <span class="st">'e'</span>, or digit</span></code></pre></div>
<p>これらすべてのパーサは符号付き数値をパースしないことに注意してください。 符号付き数値用のパーサを作成するには、 既存のパーサを <code>signed</code> コンビネータでラップする必要があります。</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb78-1"><a href="#cb78-1"></a><span class="ot">signedInteger ::</span> <span class="dt">Parser</span> <span class="dt">Integer</span></span>
<span id="cb78-2"><a href="#cb78-2"></a>signedInteger <span class="ot">=</span> L.signed sc integer</span>
<span id="cb78-3"><a href="#cb78-3"></a></span>
<span id="cb78-4"><a href="#cb78-4"></a><span class="ot">signedFloat ::</span> <span class="dt">Parser</span> <span class="dt">Double</span></span>
<span id="cb78-5"><a href="#cb78-5"></a>signedFloat <span class="ot">=</span> L.signed sc float</span></code></pre></div>
<p><code>signed</code> の最初の引数(スペースコンシューマ)は、符号と実際の数字の間の空白の消費を制御します。スペースを入れたくない場合は、代わりに<code>return ()</code>を渡してください。</p>
<p><a name="lookAhead"></a></p>
<h2 id="notfollowedby-と-lookahead"><code>notFollowedBy</code> と <code>lookAhead</code></h2>
<p>実際にはパーサの位置を進めずに入力ストリームの 先読みを実行できる(<code>try</code> に加えて)さらに2つのプリミティブがあります。</p>
<p>１つめは <code>notFollowedBy</code> と呼ばれるものです。</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb79-1"><a href="#cb79-1"></a><span class="ot">notFollowedBy ::</span> <span class="dt">MonadParsec</span> e s m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> m ()</span></code></pre></div>
<p>引数のパーサが失敗したときにのみ成功し、 入力を消費したり、パーサの状態を変更することはありません。</p>
<p><code>notFollowedBy</code> を使いたいと思うかもしれない例として、 キーワードのパースを考えます。</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb80-1"><a href="#cb80-1"></a><span class="ot">pKeyword ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Text</span></span>
<span id="cb80-2"><a href="#cb80-2"></a>pKeyword keyword <span class="ot">=</span> lexeme (string keyword)</span></code></pre></div>
<p>このパーサは問題を抱えています。 マッチさせるキーワードが単に識別子の接頭辞であるならどうでしょうか？ その場合、それは間違いなくキーワードではありません。 したがって、<code>notFollowedBy</code> を使用して そのようなケースを排除する必要があります。</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb81-1"><a href="#cb81-1"></a><span class="ot">pKeyword ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Text</span></span>
<span id="cb81-2"><a href="#cb81-2"></a>pKeyword keyword <span class="ot">=</span> lexeme (string keyword <span class="op">&lt;*</span> notFollowedBy alphaNumChar)</span></code></pre></div>
<p>もう1つのプリミティブは<code>lookAhead</code>です。</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb82-1"><a href="#cb82-1"></a><span class="ot">lookAhead ::</span> <span class="dt">MonadParsec</span> e s m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p><code>lookAhead</code> の引数 <code>p</code> が成功すると、<code>lookAhead p</code> 全体も成功しますが、 入力ストリーム（およびパーサの状態全体）はそのまま残ります。 つまり、何も消費されません。</p>
<p>これが有用である可能性がある場所の一例は、 すでにパースされた入力に対してチェックを実行し、 失敗または正常に継続することです。 慣用表現として、次のようなコードで表すことができます。</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb83-1"><a href="#cb83-1"></a>withPredicate1</span>
<span id="cb83-2"><a href="#cb83-2"></a><span class="ot">  ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)       <span class="co">-- ^ パース後の入力の振る舞いの確認</span></span>
<span id="cb83-3"><a href="#cb83-3"></a>  <span class="ot">-&gt;</span> <span class="dt">String</span>            <span class="co">-- ^ チェックが失敗した時に表示するメッセージ</span></span>
<span id="cb83-4"><a href="#cb83-4"></a>  <span class="ot">-&gt;</span> <span class="dt">Parser</span> a          <span class="co">-- ^ 実行するパーサ</span></span>
<span id="cb83-5"><a href="#cb83-5"></a>  <span class="ot">-&gt;</span> <span class="dt">Parser</span> a          <span class="co">-- ^ 振る舞いを確認したパーサの結果</span></span>
<span id="cb83-6"><a href="#cb83-6"></a>withPredicate1 f msg p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb83-7"><a href="#cb83-7"></a>  r <span class="ot">&lt;-</span> lookAhead p</span>
<span id="cb83-8"><a href="#cb83-8"></a>  <span class="kw">if</span> f r</span>
<span id="cb83-9"><a href="#cb83-9"></a>    <span class="kw">then</span> p</span>
<span id="cb83-10"><a href="#cb83-10"></a>    <span class="kw">else</span> <span class="fu">fail</span> msg</span></code></pre></div>
<p>これは <code>lookAhead</code> を使用した例ですが、 チェックが成功した場合に2回パーサを実行しており、 良くないことにも注意してください。 ここに <code>getOffset</code> 関数を使用した代わりの解決方法があります。</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb84-1"><a href="#cb84-1"></a>withPredicate2</span>
<span id="cb84-2"><a href="#cb84-2"></a><span class="ot">  ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)       <span class="co">-- ^ パース後の入力の振る舞いの確認</span></span>
<span id="cb84-3"><a href="#cb84-3"></a>  <span class="ot">-&gt;</span> <span class="dt">String</span>            <span class="co">-- ^ チェックが失敗した時に表示するメッセージ</span></span>
<span id="cb84-4"><a href="#cb84-4"></a>  <span class="ot">-&gt;</span> <span class="dt">Parser</span> a          <span class="co">-- ^ 実行するパーサ</span></span>
<span id="cb84-5"><a href="#cb84-5"></a>  <span class="ot">-&gt;</span> <span class="dt">Parser</span> a          <span class="co">-- ^ 振る舞いを確認したパーサの結果</span></span>
<span id="cb84-6"><a href="#cb84-6"></a>withPredicate2 f msg p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb84-7"><a href="#cb84-7"></a>  o <span class="ot">&lt;-</span> getOffset</span>
<span id="cb84-8"><a href="#cb84-8"></a>  r <span class="ot">&lt;-</span> p</span>
<span id="cb84-9"><a href="#cb84-9"></a>  <span class="kw">if</span> f r</span>
<span id="cb84-10"><a href="#cb84-10"></a>    <span class="kw">then</span> <span class="fu">return</span> r</span>
<span id="cb84-11"><a href="#cb84-11"></a>    <span class="kw">else</span> <span class="kw">do</span></span>
<span id="cb84-12"><a href="#cb84-12"></a>      setOffset o</span>
<span id="cb84-13"><a href="#cb84-13"></a>      <span class="fu">fail</span> msg</span></code></pre></div>
<p>このようにして、入力ストリームの <code>offset</code> を <code>p</code> を実行する前の状態に設定してから失敗します。 未消費の残りとオフセットの位置に不一致がありますが、 <code>fail</code> を呼び出してすぐにパースを終了するので、 この場合では問題になりません。 他の場合で問題になるかもしれませんが、 そのような状況でより良くする方法については、 この章の後半で説明します。</p>
<p><a name="Expr"></a></p>
<h2 id="式のパース">式のパース</h2>
<p>「式」とは、 項とそれらの項に適用される演算子から形成される構造を意味します。 演算子は、 異なる優先順位で、前置、中置、後置、左と右の結合にすることができます。 このような構文の例として、学校でよく知られている算術式があります。</p>
<pre><code>a * (b + 2)</code></pre>
<p>2種類の項、変数(<code>a</code> と <code>b</code>)と整数(<code>2</code>)を見ることができます。 2つの演算子、<code>*</code>と<code>+</code>もあります。</p>
<p>式のパーサを書くには時間がかかるかもしれません。 これ手助けするために、 <a href="https://hackage.haskell.org/package/parser-combinators"><code>parser-combinators</code></a>パッケージ には <code>Control.Monad.Combinators.Expr</code> モジュールが付属しています。 これは、<code>Operator</code>データ型と<code>makeExprParser</code>ヘルパーの 2つのだけをエクスポートします。</p>
<p>両方ともよくドキュメント化されているので、 このセクションではドキュメント化を繰り返すことはせず、 代わりに単純だが完全に機能する式のパーサを書くつもりです。</p>
<p>式を表すデータ型を <a href="https://ja.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E6%A7%8B%E6%96%87%E6%9C%A8">AST</a>として定義することから始めましょう。</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb86-1"><a href="#cb86-1"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb86-2"><a href="#cb86-2"></a>  <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">String</span></span>
<span id="cb86-3"><a href="#cb86-3"></a>  <span class="op">|</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb86-4"><a href="#cb86-4"></a>  <span class="op">|</span> <span class="dt">Negation</span> <span class="dt">Expr</span></span>
<span id="cb86-5"><a href="#cb86-5"></a>  <span class="op">|</span> <span class="dt">Sum</span>      <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb86-6"><a href="#cb86-6"></a>  <span class="op">|</span> <span class="dt">Subtr</span>    <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb86-7"><a href="#cb86-7"></a>  <span class="op">|</span> <span class="dt">Product</span>  <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb86-8"><a href="#cb86-8"></a>  <span class="op">|</span> <span class="dt">Division</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb86-9"><a href="#cb86-9"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p><code>makeExprParser</code> を使用するには、 項のパーサと演算子テーブルを指定する必要があります。</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb87-1"><a href="#cb87-1"></a><span class="ot">makeExprParser ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb87-2"><a href="#cb87-2"></a>  <span class="ot">=&gt;</span> m a               <span class="co">-- ^ 項のパーサ</span></span>
<span id="cb87-3"><a href="#cb87-3"></a>  <span class="ot">-&gt;</span> [[<span class="dt">Operator</span> m a]]  <span class="co">-- ^ 演算子テーブル, 'Operator'を参照</span></span>
<span id="cb87-4"><a href="#cb87-4"></a>  <span class="ot">-&gt;</span> m a               <span class="co">-- ^ 式のパーサの結果</span></span></code></pre></div>
<p>それでは項のパーサから始めましょう。 結合性や優先順位のようなものを扱う場合、式をパースするアルゴリズムでは、 項をボックスとみなし、分割できない全体として考えることをお勧めします。 この場合、このカテゴリに分類されるものが3つあります。 変数、整数、および括弧内の式全体です。 前の章の定義を使用して、項のパーサを次のように定義できます。</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb88-1"><a href="#cb88-1"></a><span class="ot">pVariable ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb88-2"><a href="#cb88-2"></a>pVariable <span class="ot">=</span> <span class="dt">Var</span> <span class="op">&lt;$&gt;</span> lexeme</span>
<span id="cb88-3"><a href="#cb88-3"></a>  ((<span class="op">:</span>) <span class="op">&lt;$&gt;</span> letterChar <span class="op">&lt;*&gt;</span> many alphaNumChar <span class="op">&lt;?&gt;</span> <span class="st">&quot;variable&quot;</span>)</span>
<span id="cb88-4"><a href="#cb88-4"></a></span>
<span id="cb88-5"><a href="#cb88-5"></a><span class="ot">pInteger ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb88-6"><a href="#cb88-6"></a>pInteger <span class="ot">=</span> <span class="dt">Int</span> <span class="op">&lt;$&gt;</span> lexeme L.decimal</span>
<span id="cb88-7"><a href="#cb88-7"></a></span>
<span id="cb88-8"><a href="#cb88-8"></a><span class="ot">parens ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb88-9"><a href="#cb88-9"></a>parens <span class="ot">=</span> between (symbol <span class="st">&quot;(&quot;</span>) (symbol <span class="st">&quot;)&quot;</span>)</span>
<span id="cb88-10"><a href="#cb88-10"></a></span>
<span id="cb88-11"><a href="#cb88-11"></a><span class="ot">pTerm ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb88-12"><a href="#cb88-12"></a>pTerm <span class="ot">=</span> choice</span>
<span id="cb88-13"><a href="#cb88-13"></a>  [ parens pExpr</span>
<span id="cb88-14"><a href="#cb88-14"></a>  , pVariable</span>
<span id="cb88-15"><a href="#cb88-15"></a>  , pInteger</span>
<span id="cb88-16"><a href="#cb88-16"></a>  ]</span>
<span id="cb88-17"><a href="#cb88-17"></a></span>
<span id="cb88-18"><a href="#cb88-18"></a><span class="ot">pExpr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb88-19"><a href="#cb88-19"></a>pExpr <span class="ot">=</span> makeExprParser pTerm operatorTable</span>
<span id="cb88-20"><a href="#cb88-20"></a></span>
<span id="cb88-21"><a href="#cb88-21"></a><span class="ot">operatorTable ::</span> [[<span class="dt">Operator</span> <span class="dt">Parser</span> <span class="dt">Expr</span>]]</span>
<span id="cb88-22"><a href="#cb88-22"></a>operatorTable <span class="ot">=</span> <span class="fu">undefined</span> <span class="co">-- TODO</span></span></code></pre></div>
<p><code>pVariable</code>、<code>pInteger</code>、および<code>parens</code>の定義は、 ここまでで問題なく進むはずです。 文法が重ならないので <code>pTerm</code> に <code>try</code> が必要ないという点も、 ここではとてもラッキーです。</p>
<ul>
<li><p>開き括弧 <code>(</code> がある場合は、括弧内に式が続くことを知っているので、そのブランチにコミットします。</p></li>
<li><p>文字を見れば、それが識別子の始まりであることがわかります。</p></li>
<li><p>数字が見えれば、それが整数の始まりであることがわかります。</p></li>
</ul>
<p>最後に、<code>pExpr</code> を終了するために、 <code>operatorTable</code> を定義する必要があります。 型からネストされたリストであることがわかります。 すべての内部リストはサポートしたい演算子のリストです。 それらはすべて同じ優先順位を持っています。 外側のリストは優先順位の降順で並べられているので、 高い位置に演算子のグループを配置するほど、 それらはより強く結合されます。</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb89-1"><a href="#cb89-1"></a><span class="kw">data</span> <span class="dt">Operator</span> m a <span class="co">-- 注意</span></span>
<span id="cb89-2"><a href="#cb89-2"></a>  <span class="ot">=</span> <span class="dt">InfixN</span>  (m (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a)) <span class="co">-- ^ 非結合の中置</span></span>
<span id="cb89-3"><a href="#cb89-3"></a>  <span class="op">|</span> <span class="dt">InfixL</span>  (m (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a)) <span class="co">-- ^ 左結合の中置</span></span>
<span id="cb89-4"><a href="#cb89-4"></a>  <span class="op">|</span> <span class="dt">InfixR</span>  (m (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a)) <span class="co">-- ^ 右結合の中置</span></span>
<span id="cb89-5"><a href="#cb89-5"></a>  <span class="op">|</span> <span class="dt">Prefix</span>  (m (a <span class="ot">-&gt;</span> a))      <span class="co">-- ^ 前置</span></span>
<span id="cb89-6"><a href="#cb89-6"></a>  <span class="op">|</span> <span class="dt">Postfix</span> (m (a <span class="ot">-&gt;</span> a))      <span class="co">-- ^ 後置</span></span>
<span id="cb89-7"><a href="#cb89-7"></a></span>
<span id="cb89-8"><a href="#cb89-8"></a><span class="ot">operatorTable ::</span> [[<span class="dt">Operator</span> <span class="dt">Parser</span> <span class="dt">Expr</span>]]</span>
<span id="cb89-9"><a href="#cb89-9"></a>operatorTable <span class="ot">=</span></span>
<span id="cb89-10"><a href="#cb89-10"></a>  [ [ prefix <span class="st">&quot;-&quot;</span> <span class="dt">Negation</span></span>
<span id="cb89-11"><a href="#cb89-11"></a>    , prefix <span class="st">&quot;+&quot;</span> <span class="fu">id</span></span>
<span id="cb89-12"><a href="#cb89-12"></a>    ]</span>
<span id="cb89-13"><a href="#cb89-13"></a>  , [ binary <span class="st">&quot;*&quot;</span> <span class="dt">Product</span></span>
<span id="cb89-14"><a href="#cb89-14"></a>    , binary <span class="st">&quot;/&quot;</span> <span class="dt">Division</span></span>
<span id="cb89-15"><a href="#cb89-15"></a>    ]</span>
<span id="cb89-16"><a href="#cb89-16"></a>  , [ binary <span class="st">&quot;+&quot;</span> <span class="dt">Sum</span></span>
<span id="cb89-17"><a href="#cb89-17"></a>    , binary <span class="st">&quot;-&quot;</span> <span class="dt">Subtr</span></span>
<span id="cb89-18"><a href="#cb89-18"></a>    ]</span>
<span id="cb89-19"><a href="#cb89-19"></a>  ]</span>
<span id="cb89-20"><a href="#cb89-20"></a></span>
<span id="cb89-21"><a href="#cb89-21"></a><span class="ot">binary ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> (<span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span>) <span class="ot">-&gt;</span> <span class="dt">Operator</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb89-22"><a href="#cb89-22"></a>binary  name f <span class="ot">=</span> <span class="dt">InfixL</span>  (f <span class="op">&lt;$</span> symbol name)</span>
<span id="cb89-23"><a href="#cb89-23"></a></span>
<span id="cb89-24"><a href="#cb89-24"></a>prefix,<span class="ot"> postfix ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> (<span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span>) <span class="ot">-&gt;</span> <span class="dt">Operator</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb89-25"><a href="#cb89-25"></a>prefix  name f <span class="ot">=</span> <span class="dt">Prefix</span>  (f <span class="op">&lt;$</span> symbol name)</span>
<span id="cb89-26"><a href="#cb89-26"></a>postfix name f <span class="ot">=</span> <span class="dt">Postfix</span> (f <span class="op">&lt;$</span> symbol name)</span></code></pre></div>
<p><code>binary</code> で <code>InfixL</code> 内部の <code>Parser (Expr -&gt; Expr -&gt; Expr)</code> を どのように配置し、 同様に<code>prefix</code> と <code>postfix</code> に <code>Parser (Expr -&gt; Expr)</code> を どのように配置しているのか注意してください。 すなわち、<code>symbol name</code> を実行し、 <code>Expr</code> 型の最終結果を得るために項に適用する関数を返します。</p>
<p>これでパーサを試すことができます。準備は完了です！</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb90-1"><a href="#cb90-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pExpr <span class="op">&lt;</span>* eof) <span class="st">&quot;a * (b + 2)&quot;</span></span>
<span id="cb90-2"><a href="#cb90-2"></a><span class="ex">Product</span> (Var <span class="st">&quot;a&quot;</span>) <span class="kw">(</span><span class="ex">Sum</span> (Var <span class="st">&quot;b&quot;</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">Int</span> 2<span class="kw">)</span>)</span>
<span id="cb90-3"><a href="#cb90-3"></a></span>
<span id="cb90-4"><a href="#cb90-4"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pExpr <span class="op">&lt;</span>* eof) <span class="st">&quot;a * b + 2&quot;</span></span>
<span id="cb90-5"><a href="#cb90-5"></a><span class="ex">Sum</span> (Product (Var <span class="st">&quot;a&quot;</span>) <span class="kw">(</span><span class="ex">Var</span> <span class="st">&quot;b&quot;</span><span class="kw">)</span>) <span class="kw">(</span><span class="ex">Int</span> 2<span class="kw">)</span></span>
<span id="cb90-6"><a href="#cb90-6"></a></span>
<span id="cb90-7"><a href="#cb90-7"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pExpr <span class="op">&lt;</span>* eof) <span class="st">&quot;a * b / 2&quot;</span></span>
<span id="cb90-8"><a href="#cb90-8"></a><span class="ex">Division</span> (Product (Var <span class="st">&quot;a&quot;</span>) <span class="kw">(</span><span class="ex">Var</span> <span class="st">&quot;b&quot;</span><span class="kw">)</span>) <span class="kw">(</span><span class="ex">Int</span> 2<span class="kw">)</span></span>
<span id="cb90-9"><a href="#cb90-9"></a></span>
<span id="cb90-10"><a href="#cb90-10"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pExpr <span class="op">&lt;</span>* eof) <span class="st">&quot;a * (b $ 2)&quot;</span></span>
<span id="cb90-11"><a href="#cb90-11"></a><span class="ex">1</span>:8:</span>
<span id="cb90-12"><a href="#cb90-12"></a>  <span class="kw">|</span></span>
<span id="cb90-13"><a href="#cb90-13"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">a</span> * (b $ 2)</span>
<span id="cb90-14"><a href="#cb90-14"></a>  <span class="kw">|</span>        ^</span>
<span id="cb90-15"><a href="#cb90-15"></a><span class="ex">unexpected</span> <span class="st">'$'</span></span>
<span id="cb90-16"><a href="#cb90-16"></a><span class="ex">expecting</span> <span class="st">')'</span> or operator</span></code></pre></div>
<p><code>Text.Megaparsec.Expr</code> モジュールのドキュメントには、 あまり標準的ではない状況で役立つヒントがいくつか含まれているので、 それを読むことをお勧めします。</p>
<p><a name="Indentation"></a></p>
<h2 id="indentation-sensitiveなパース">Indentation-sensitiveなパース</h2>
<p><code>Text.Megaparsec.Char.Lexer</code> モジュールには、 Indentation-sensitive な文法をパースするときに役立つツールが含まれています。 最初に利用可能なコンビネータを見直し、 次にIndentation-sensitiveなパーサを書くことによって それらを使えるようにします。</p>
<p><a name="nonIndented"></a></p>
<h2 id="nonindented-と-indentblock"><code>nonIndented</code> と <code>indentBlock</code></h2>
<p>最も単純な<code>nonIndented</code> から始めましょう。</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb91-1"><a href="#cb91-1"></a><span class="ot">nonIndented ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb91-2"><a href="#cb91-2"></a>  <span class="ot">=&gt;</span> m ()              <span class="co">-- ^ インデント (スペース) の消費方法</span></span>
<span id="cb91-3"><a href="#cb91-3"></a>  <span class="ot">-&gt;</span> m a               <span class="co">-- ^ 内側のパーサ</span></span>
<span id="cb91-4"><a href="#cb91-4"></a>  <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>それはその内側のパーサが インデントされていない入力を消費することを確認できます。 これは、Indentation-sensitiveな入力による 高レベルなパーサの背後にあるモデルの一部です。 インデントされていないトップレベルの項目があり、 すべてのインデントされたトークンはそれらのトップレベル定義の 直接的または間接的な子であると述べます。 <code>megaparsec</code>では、これを表現するために追加の状態を必要としません。 インデントは常に相対的なので、 私たちの考えは、参照トークンとインデントトークンのために パーサを明示的に結び付けることです。 そして、パーサの純粋な組み合わせによって Indentation-sensitiveな文法を定義することです。</p>
<p>それでは、インデントブロックのパーサを どのように定義すればよいのでしょうか。 <code>indentBlock</code>のシグネチャを見てみましょう。</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb92-1"><a href="#cb92-1"></a><span class="ot">indentBlock ::</span> (<span class="dt">MonadParsec</span> e s m, <span class="dt">Token</span> s <span class="op">~</span> <span class="dt">Char</span>)</span>
<span id="cb92-2"><a href="#cb92-2"></a>  <span class="ot">=&gt;</span> m ()              <span class="co">-- ^ インデント (スペース) の消費方法</span></span>
<span id="cb92-3"><a href="#cb92-3"></a>  <span class="ot">-&gt;</span> m (<span class="dt">IndentOpt</span> m a b) <span class="co">-- ^ 「参照」トークン の消費方法</span></span>
<span id="cb92-4"><a href="#cb92-4"></a>  <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>はじめに、インデントの消費方法を指定します。 ここで注意すべき重要なことは、 このスペースを消費するパーサは改行も消費しなければならないのに対し、 トークン(参照トークンとインデントトークン)は 通常改行をそれらの後に消費するべきではないということです。</p>
<p>ご覧のとおり、2番目の引数を使用すると参照トークンをパースし、 次に<code>indentBlock</code>に何をするかを指示するデータ構造を返すことができます。 いくつかのオプションがあります。</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb93-1"><a href="#cb93-1"></a><span class="kw">data</span> <span class="dt">IndentOpt</span> m a b</span>
<span id="cb93-2"><a href="#cb93-2"></a>  <span class="ot">=</span> <span class="dt">IndentNone</span> a</span>
<span id="cb93-3"><a href="#cb93-3"></a>    <span class="co">-- ^ インデントトークンを消費せず、値を返すだけ</span></span>
<span id="cb93-4"><a href="#cb93-4"></a>  <span class="op">|</span> <span class="dt">IndentMany</span> (<span class="dt">Maybe</span> <span class="dt">Pos</span>) ([b] <span class="ot">-&gt;</span> m a) (m b)</span>
<span id="cb93-5"><a href="#cb93-5"></a>    <span class="co">-- ^ 多くの(0個の場合を含む)インデントトークンをパースし, 与えられたインデント</span></span>
<span id="cb93-6"><a href="#cb93-6"></a>    <span class="co">-- レベルを使う ('Nothing' の場合は最初にインデントされたトークンのレベルを使う)。</span></span>
<span id="cb93-7"><a href="#cb93-7"></a>    <span class="co">-- 2番目の引数は最終結果を取得する方法を示し、三番目の</span></span>
<span id="cb93-8"><a href="#cb93-8"></a>    <span class="co">-- 引数はインデントされたトークンをパースする方法を示す。</span></span>
<span id="cb93-9"><a href="#cb93-9"></a>  <span class="op">|</span> <span class="dt">IndentSome</span> (<span class="dt">Maybe</span> <span class="dt">Pos</span>) ([b] <span class="ot">-&gt;</span> m a) (m b)</span>
<span id="cb93-10"><a href="#cb93-10"></a>    <span class="co">-- ^ 'IndentMany'に似ているが、少なくとも1つのインデントトークンが</span></span>
<span id="cb93-11"><a href="#cb93-11"></a>    <span class="co">-- 出現することを要求する。</span></span></code></pre></div>
<p>考えを変えてインデントのないトークンをパースすることができます。 多くの（つまり、場合によっては0個の）インデントトークンをパースするか、 少なくとも1つのそのようなトークンを要求することができます。 <code>indentBlock</code>が最初のインデントトークンのインデントレベルを検出して それを使用するか、手動でインデントレベルを指定することができます。</p>
<p><a name="SimpleIndented"></a></p>
<h2 id="単純なインデントされたリストのパース">単純なインデントされたリストのパース</h2>
<p>いくつかの項目の単純なインデントされたリストをパースしましょう。 インポートセクションから始めます。</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb94-1"><a href="#cb94-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb94-2"><a href="#cb94-2"></a><span class="ot">{-# LANGUAGE TupleSections     #-}</span></span>
<span id="cb94-3"><a href="#cb94-3"></a></span>
<span id="cb94-4"><a href="#cb94-4"></a><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></span>
<span id="cb94-5"><a href="#cb94-5"></a></span>
<span id="cb94-6"><a href="#cb94-6"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb94-7"><a href="#cb94-7"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (void)</span>
<span id="cb94-8"><a href="#cb94-8"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb94-9"><a href="#cb94-9"></a><span class="kw">import</span> <span class="dt">Data.Void</span></span>
<span id="cb94-10"><a href="#cb94-10"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span></span>
<span id="cb94-11"><a href="#cb94-11"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec.Char</span></span>
<span id="cb94-12"><a href="#cb94-12"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Megaparsec.Char.Lexer</span> <span class="kw">as</span> <span class="dt">L</span></span>
<span id="cb94-13"><a href="#cb94-13"></a></span>
<span id="cb94-14"><a href="#cb94-14"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Void</span> <span class="dt">Text</span></span></code></pre></div>
<p>2種類のスペースコンシューマが必要になります。 1つは改行を消費する<code>scn</code>、もう1つは消費しない<code>sc</code>です（実際にはここではスペースとタブのみをパースします）。</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb95-1"><a href="#cb95-1"></a><span class="ot">lineComment ::</span> <span class="dt">Parser</span> ()</span>
<span id="cb95-2"><a href="#cb95-2"></a>lineComment <span class="ot">=</span> L.skipLineComment <span class="st">&quot;#&quot;</span></span>
<span id="cb95-3"><a href="#cb95-3"></a></span>
<span id="cb95-4"><a href="#cb95-4"></a><span class="ot">scn ::</span> <span class="dt">Parser</span> ()</span>
<span id="cb95-5"><a href="#cb95-5"></a>scn <span class="ot">=</span> L.space space1 lineComment empty</span>
<span id="cb95-6"><a href="#cb95-6"></a></span>
<span id="cb95-7"><a href="#cb95-7"></a><span class="ot">sc ::</span> <span class="dt">Parser</span> ()</span>
<span id="cb95-8"><a href="#cb95-8"></a>sc <span class="ot">=</span> L.space (void <span class="op">$</span> some (char <span class="ch">' '</span> <span class="op">&lt;|&gt;</span> char <span class="ch">'\t'</span>)) lineComment empty</span>
<span id="cb95-9"><a href="#cb95-9"></a></span>
<span id="cb95-10"><a href="#cb95-10"></a><span class="ot">lexeme ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb95-11"><a href="#cb95-11"></a>lexeme <span class="ot">=</span> L.lexeme sc</span></code></pre></div>
<p>楽しみのために、<code>#</code>で始まる行のコメントを許可します。</p>
<p><code>pItemList</code> は、それ自体が参照トークン（リストのヘッダー） とインデントトークン（リストの項目）の組み合わせである トップレベルの形式です。</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb96-1"><a href="#cb96-1"></a><span class="ot">pItemList ::</span> <span class="dt">Parser</span> (<span class="dt">String</span>, [<span class="dt">String</span>]) <span class="co">-- ヘッダとアイテムのリスト</span></span>
<span id="cb96-2"><a href="#cb96-2"></a>pItemList <span class="ot">=</span> L.nonIndented scn (L.indentBlock scn p)</span>
<span id="cb96-3"><a href="#cb96-3"></a>  <span class="kw">where</span></span>
<span id="cb96-4"><a href="#cb96-4"></a>    p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb96-5"><a href="#cb96-5"></a>      header <span class="ot">&lt;-</span> pItem</span>
<span id="cb96-6"><a href="#cb96-6"></a>      <span class="fu">return</span> (<span class="dt">L.IndentMany</span> <span class="dt">Nothing</span> (<span class="fu">return</span> <span class="op">.</span> (header, )) pItem)</span></code></pre></div>
<p>私たちの目的であるアイテムは、英数字とハイフンのシーケンスです。</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb97-1"><a href="#cb97-1"></a><span class="ot">pItem ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb97-2"><a href="#cb97-2"></a>pItem <span class="ot">=</span> lexeme (some (alphaNumChar <span class="op">&lt;|&gt;</span> char <span class="ch">'-'</span>)) <span class="op">&lt;?&gt;</span> <span class="st">&quot;list item&quot;</span></span></code></pre></div>
<p>GHCiでコードをロードし、 組み込みの<code>parseTest</code>の助けを借りて試してみましょう。</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb98-1"><a href="#cb98-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;&quot;</span></span>
<span id="cb98-2"><a href="#cb98-2"></a><span class="ex">1</span>:1:</span>
<span id="cb98-3"><a href="#cb98-3"></a>  <span class="kw">|</span></span>
<span id="cb98-4"><a href="#cb98-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="op">&lt;</span><span class="ex">empty</span> line<span class="op">&gt;</span></span>
<span id="cb98-5"><a href="#cb98-5"></a>  <span class="kw">|</span> ^</span>
<span id="cb98-6"><a href="#cb98-6"></a><span class="ex">unexpected</span> end of input</span>
<span id="cb98-7"><a href="#cb98-7"></a><span class="ex">expecting</span> list item</span>
<span id="cb98-8"><a href="#cb98-8"></a></span>
<span id="cb98-9"><a href="#cb98-9"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;something&quot;</span></span>
<span id="cb98-10"><a href="#cb98-10"></a><span class="kw">(</span><span class="st">&quot;something&quot;</span>,[]<span class="kw">)</span></span>
<span id="cb98-11"><a href="#cb98-11"></a></span>
<span id="cb98-12"><a href="#cb98-12"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;  something&quot;</span></span>
<span id="cb98-13"><a href="#cb98-13"></a><span class="ex">1</span>:3:</span>
<span id="cb98-14"><a href="#cb98-14"></a>  <span class="kw">|</span></span>
<span id="cb98-15"><a href="#cb98-15"></a><span class="ex">1</span> <span class="kw">|</span>   <span class="ex">something</span></span>
<span id="cb98-16"><a href="#cb98-16"></a>  <span class="kw">|</span>   ^</span>
<span id="cb98-17"><a href="#cb98-17"></a><span class="ex">incorrect</span> indentation (got 3, should be equal to 1)</span>
<span id="cb98-18"><a href="#cb98-18"></a></span>
<span id="cb98-19"><a href="#cb98-19"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;something\none\ntwo\nthree&quot;</span></span>
<span id="cb98-20"><a href="#cb98-20"></a><span class="ex">2</span>:1:</span>
<span id="cb98-21"><a href="#cb98-21"></a>  <span class="kw">|</span></span>
<span id="cb98-22"><a href="#cb98-22"></a><span class="ex">2</span> <span class="kw">|</span> <span class="ex">one</span></span>
<span id="cb98-23"><a href="#cb98-23"></a>  <span class="kw">|</span> ^</span>
<span id="cb98-24"><a href="#cb98-24"></a><span class="ex">unexpected</span> <span class="st">'o'</span></span>
<span id="cb98-25"><a href="#cb98-25"></a><span class="ex">expecting</span> end of input</span></code></pre></div>
<p><code>IndentMany</code> オプションを使用しているので、 空のリストでも問題ありませんが、 組み込みのコンビネータ<code>space</code>はエラーメッセージから 「より多くのスペースを期待する」というフレーズを隠しているので、 このエラーメッセージは完全に妥当です。</p>
<p>続けましょう。</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb99-1"><a href="#cb99-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;something\n  one\n    two\n  three&quot;</span></span>
<span id="cb99-2"><a href="#cb99-2"></a><span class="ex">3</span>:5:</span>
<span id="cb99-3"><a href="#cb99-3"></a>  <span class="kw">|</span></span>
<span id="cb99-4"><a href="#cb99-4"></a><span class="ex">3</span> <span class="kw">|</span>     <span class="ex">two</span></span>
<span id="cb99-5"><a href="#cb99-5"></a>  <span class="kw">|</span>     ^</span>
<span id="cb99-6"><a href="#cb99-6"></a><span class="ex">incorrect</span> indentation (got 5, should be equal to 3)</span>
<span id="cb99-7"><a href="#cb99-7"></a></span>
<span id="cb99-8"><a href="#cb99-8"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;something\n  one\n  two\n three&quot;</span></span>
<span id="cb99-9"><a href="#cb99-9"></a><span class="ex">4</span>:2:</span>
<span id="cb99-10"><a href="#cb99-10"></a>  <span class="kw">|</span></span>
<span id="cb99-11"><a href="#cb99-11"></a><span class="ex">4</span> <span class="kw">|</span>  <span class="ex">three</span></span>
<span id="cb99-12"><a href="#cb99-12"></a>  <span class="kw">|</span>  ^</span>
<span id="cb99-13"><a href="#cb99-13"></a><span class="ex">incorrect</span> indentation (got 2, should be equal to 3)</span>
<span id="cb99-14"><a href="#cb99-14"></a></span>
<span id="cb99-15"><a href="#cb99-15"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;something\n  one\n  two\n  three&quot;</span></span>
<span id="cb99-16"><a href="#cb99-16"></a><span class="kw">(</span><span class="st">&quot;something&quot;</span>,[<span class="st">&quot;one&quot;</span>,<span class="st">&quot;two&quot;</span>,<span class="st">&quot;three&quot;</span>]<span class="kw">)</span></span></code></pre></div>
<p><code>IndentMany</code> を <code>IndentSome</code> に、<code>Nothing</code> を<code>Just (mkPos 5)</code>に 置き換えます（インデントレベルは1から数えられるため、 インデントされる項目の前に4つのスペースが必要になります）。</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb100-1"><a href="#cb100-1"></a><span class="ot">pItemList ::</span> <span class="dt">Parser</span> (<span class="dt">String</span>, [<span class="dt">String</span>])</span>
<span id="cb100-2"><a href="#cb100-2"></a>pItemList <span class="ot">=</span> L.nonIndented scn (L.indentBlock scn p)</span>
<span id="cb100-3"><a href="#cb100-3"></a>  <span class="kw">where</span></span>
<span id="cb100-4"><a href="#cb100-4"></a>    p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb100-5"><a href="#cb100-5"></a>      header <span class="ot">&lt;-</span> pItem</span>
<span id="cb100-6"><a href="#cb100-6"></a>      <span class="fu">return</span> (<span class="dt">L.IndentSome</span> (<span class="dt">Just</span> (mkPos <span class="dv">5</span>)) (<span class="fu">return</span> <span class="op">.</span> (header, )) pItem)</span></code></pre></div>
<p>ここで、</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb101-1"><a href="#cb101-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;something\n&quot;</span></span>
<span id="cb101-2"><a href="#cb101-2"></a><span class="ex">2</span>:1:</span>
<span id="cb101-3"><a href="#cb101-3"></a>  <span class="kw">|</span></span>
<span id="cb101-4"><a href="#cb101-4"></a><span class="ex">2</span> <span class="kw">|</span> <span class="op">&lt;</span><span class="ex">empty</span> line<span class="op">&gt;</span></span>
<span id="cb101-5"><a href="#cb101-5"></a>  <span class="kw">|</span> ^</span>
<span id="cb101-6"><a href="#cb101-6"></a><span class="ex">incorrect</span> indentation (got 1, should be greater than 1)</span>
<span id="cb101-7"><a href="#cb101-7"></a></span>
<span id="cb101-8"><a href="#cb101-8"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;something\n  one&quot;</span></span>
<span id="cb101-9"><a href="#cb101-9"></a><span class="ex">2</span>:3:</span>
<span id="cb101-10"><a href="#cb101-10"></a>  <span class="kw">|</span></span>
<span id="cb101-11"><a href="#cb101-11"></a><span class="ex">2</span> <span class="kw">|</span>   <span class="ex">one</span></span>
<span id="cb101-12"><a href="#cb101-12"></a>  <span class="kw">|</span>   ^</span>
<span id="cb101-13"><a href="#cb101-13"></a><span class="ex">incorrect</span> indentation (got 3, should be equal to 5)</span>
<span id="cb101-14"><a href="#cb101-14"></a></span>
<span id="cb101-15"><a href="#cb101-15"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;something\n    one&quot;</span></span>
<span id="cb101-16"><a href="#cb101-16"></a><span class="kw">(</span><span class="st">&quot;something&quot;</span>,[<span class="st">&quot;one&quot;</span>]<span class="kw">)</span></span></code></pre></div>
<p>最初のメッセージは少し驚くかもしれませんが、 リスト内に少なくとも1つの項目がなければならないことを <code>megaparsec</code>は知っているので、インデントレベルをチェックし、 そしてそれは1であり、間違っているので報告します。</p>
<p><a name="NestedIndented"></a></p>
<h2 id="ネストされたインデントのあるリスト">ネストされたインデントのあるリスト</h2>
<p>リストのアイテムにサブアイテムを含めることを許可しましょう。 これには、新しいパーサ<code>pComplexItem</code>が必要になります。</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb102-1"><a href="#cb102-1"></a><span class="ex">pComplexItem</span> :: Parser (String, [String])</span>
<span id="cb102-2"><a href="#cb102-2"></a><span class="ex">pComplexItem</span> = L.indentBlock scn p</span>
<span id="cb102-3"><a href="#cb102-3"></a>  <span class="ex">where</span></span>
<span id="cb102-4"><a href="#cb102-4"></a>    <span class="ex">p</span> = do</span>
<span id="cb102-5"><a href="#cb102-5"></a>      <span class="ex">header</span> <span class="op">&lt;</span>- pItem</span>
<span id="cb102-6"><a href="#cb102-6"></a>      <span class="bu">return</span> (L.IndentMany Nothing (return . (header, )) <span class="ex">pItem</span>)</span>
<span id="cb102-7"><a href="#cb102-7"></a></span>
<span id="cb102-8"><a href="#cb102-8"></a><span class="ex">pItemList</span> :: Parser (String, [(String, [String])])</span>
<span id="cb102-9"><a href="#cb102-9"></a><span class="ex">pItemList</span> = L.nonIndented scn (L.indentBlock scn p)</span>
<span id="cb102-10"><a href="#cb102-10"></a>  <span class="ex">where</span></span>
<span id="cb102-11"><a href="#cb102-11"></a>    <span class="ex">p</span> = do</span>
<span id="cb102-12"><a href="#cb102-12"></a>      <span class="ex">header</span> <span class="op">&lt;</span>- pItem</span>
<span id="cb102-13"><a href="#cb102-13"></a>      <span class="bu">return</span> (L.IndentSome Nothing (return . (header, )) <span class="ex">pComplexItem</span>)</span></code></pre></div>
<p>次のような入力を与えます。</p>
<pre><code>first-chapter
  paragraph-one
      note-A # an important note here!
      note-B
  paragraph-two
    note-1
    note-2
  paragraph-three</code></pre>
<p>このような結果が得られます。</p>
<pre><code>Right
  ( &quot;first-chapter&quot;
  , [ (&quot;paragraph-one&quot;,   [&quot;note-A&quot;,&quot;note-B&quot;])
    , (&quot;paragraph-two&quot;,   [&quot;note-1&quot;,&quot;note-2&quot;])
    , (&quot;paragraph-three&quot;, [])
    ]
  )</code></pre>
<p>これは、このアプローチがネストされたインデントのある構造に対して 追加の状態を必要とせずにどのように拡張するかを示しています。</p>
<p><a name="LineFold"></a></p>
<h2 id="行の畳み込みの追加">行の畳み込みの追加</h2>
<p>行の畳み込みは、後続の項目のインデントレベルが 最初の項目のインデントレベルよりも大きい限り、 1行または複数行に配置できる複数の要素で構成されます。</p>
<p><code>lineFold</code> という別のヘルパーを利用しましょう。</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb105-1"><a href="#cb105-1"></a><span class="ot">pComplexItem ::</span> <span class="dt">Parser</span> (<span class="dt">String</span>, [<span class="dt">String</span>])</span>
<span id="cb105-2"><a href="#cb105-2"></a>pComplexItem <span class="ot">=</span> L.indentBlock scn p</span>
<span id="cb105-3"><a href="#cb105-3"></a>  <span class="kw">where</span></span>
<span id="cb105-4"><a href="#cb105-4"></a>    p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb105-5"><a href="#cb105-5"></a>      header <span class="ot">&lt;-</span> pItem</span>
<span id="cb105-6"><a href="#cb105-6"></a>      <span class="fu">return</span> (<span class="dt">L.IndentMany</span> <span class="dt">Nothing</span> (<span class="fu">return</span> <span class="op">.</span> (header, )) pLineFold)</span>
<span id="cb105-7"><a href="#cb105-7"></a></span>
<span id="cb105-8"><a href="#cb105-8"></a><span class="ot">pLineFold ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb105-9"><a href="#cb105-9"></a>pLineFold <span class="ot">=</span> L.lineFold scn <span class="op">$</span> \sc' <span class="ot">-&gt;</span></span>
<span id="cb105-10"><a href="#cb105-10"></a>  <span class="kw">let</span> ps <span class="ot">=</span> some (alphaNumChar <span class="op">&lt;|&gt;</span> char <span class="ch">'-'</span>) <span class="ot">`sepBy1`</span> try sc'</span>
<span id="cb105-11"><a href="#cb105-11"></a>  <span class="kw">in</span> <span class="fu">unwords</span> <span class="op">&lt;$&gt;</span> ps <span class="op">&lt;*</span> scn <span class="co">-- (1)</span></span></code></pre></div>
<p><code>lineFold</code>は次のように機能します。 改行を受理するスペースコンシューマ<code>scn</code>を提供し、 行の畳み込みの要素間のスペースを消費するために コールバックで使用できる特別なスペースコンシューマ<code>sc'</code>を返します。</p>
<p>なぜ <code>try sc'</code> と (1) の行で <code>scn</code>を使うのですか？状況は以下のとおりです。</p>
<ul>
<li><p>行の畳込みの要素は、開始位置よりもインデントが大きくなります。</p></li>
<li><p><code>sc'</code>は、空白を消費した後の列が最初の列よりも大きくなるように、改行とともに空白を消費します。</p></li>
<li><p>停止させるには、<code>sc'</code> は逆の状況に遭遇する必要があります。つまり、消費後の列は最初の列以下になります。その時点では (tryのおかげで) 入力を消費せずに失敗し、<code>scn</code> はその列から始まる新しいものの前の空白を取り上げるために使用されます。</p></li>
<li><p>先程使用していた <code>sc'</code> はすでに改行文字を消費するスペースコンシューマによって空白を調べています。したがって、末尾の空白を拾うときに改行も消費するのは論理的なことです。(1) の行で <code>sc</code>ではなく<code>scn</code>が使用されるのはこのためです。</p></li>
</ul>
<p>練習問題：私たちのパーサーの最終版で遊ぶことは 読者のための練習として残されています。 複数の単語からなる「項目」を作成することができ、 それらが折り返されている限り、 それらはそれらの間の単一のスペースでパースされ連結されます。</p>
<p><a name="Efficient"></a></p>
<h2 id="効率のよいパーサを書く">効率のよいパーサを書く</h2>
<p><code>megaparsec</code> のパーサの性能を向上させるために 何を試みるべきか議論しましょう。 プロファイリングとベンチマークによって 改善があるかどうかを常に確認する必要があることに注意してください。 これは、パフォーマンスを調整するときに正しいことを 行っているかどうかを理解するための唯一の方法です。</p>
<p>一般的なアドバイス：</p>
<ul>
<li><p>あなたのパーサが普通の<code>Parsec</code>モナド (これは<code>Identity</code>を組み合わせた<code>ParsecT</code>のモナド変換子であることを思い出してください。これは非常に軽量です) の代わりにモナドスタックを使っている場合、少なくとも<code>transformer</code>ライブラリのバージョン0.5と、<code>megaparsec</code> のバージョン7.0以上を必ず使用してください。これらのバージョンでは、どちらのライブラリもパフォーマンスが大幅に向上しているため、何もしなくても優れたパフォーマンスを得ることができます。</p></li>
<li><p><code>Parsec</code> モナドは、 <code>ParsecT</code> ベースのモナド変換子よりも常に高速になります。どうしても必要な場合以外は、<code>StateT</code>、<code>WriterT</code>、およびその他のモナド変換子を使用しないでください。スタックに追加すればするほど遅くなります。</p></li>
<li><p>バックトラックはコストの高い操作です。すべての分岐が失敗する前に入力に深く入り込むことができるような長い分岐の連鎖を作ることを避けてください。</p></li>
<li><p>あなたが本当にそうしたい理由がない限り、パーサの多相性を保ってはいけません。トップレベルの定義ごとに、<code>Parser = Parsec Void Text</code> などの具体的な型を指定して、パーサの型を修正することをお勧めします。このようにすればGHCはより良く最適化できるでしょう。</p></li>
<li><p>惜しみなくインライン展開しましょう(もちろん、理にかなっているときに)。特に短い関数では、インライン展開による違いを見たとき、あなたは目を疑うでしょう。 これは特に、あるモジュールで定義され、別のモジュールで使用されるパーサに当てはまります。なぜなら<code>INLINE</code>および<code>INLINEABLE</code>プラグマはGHCに関数定義をインタフェースファイルにダンプさせるので、特殊化が容易になるからです。</p></li>
<li><p>可能な場合は、<code>takeWhileP</code>、<code>takeWhile1P</code>、および<code>takeP</code>などの高速なプリミティブを使用してください。<a href="https://markkarpov.com/post/megaparsec-more-speed-more-power.html#there-is-hope">このブログ記事</a>では、なぜそれらがとても速いのかを説明します。</p></li>
<li><p>可能であれば <code>oneOf</code>と<code>noneOf</code>を避け、<code>satisfy</code> と <code>notChar</code> を選択してください。</p></li>
</ul>
<p>上記の点のほとんどは追加のコメントを必要としませんが、 新しい高速のプリミティブ、<code>takeWhileP</code> 、 <code>takeWhile1P</code> 、 および <code>takeP</code> を使用する習慣を身に付けることが有益であると思います。 最初の2つは、いくつかの<code>many</code>と<code>some</code>ベースの構造を置き換え、 それらを早くし、返されるデータの型を入力ストリームのチャンクに変更すること、つまり以前議論した <code>Tokens s</code> 型に変更できるため、特に一般的です。</p>
<p>たとえば、URIをパースしたときに、 認証の構成要素内でユーザ名をパースするための 次のコードがあったことを思い出してください。</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb106-1"><a href="#cb106-1"></a>  user <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar</span></code></pre></div>
<p>これは <code>takeWhile1P</code> に置き換え可能です。</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb107-1"><a href="#cb107-1"></a>user <span class="ot">&lt;-</span> takeWhile1P (<span class="dt">Just</span> <span class="st">&quot;alpha num character&quot;</span>) <span class="fu">isAlphaNum</span></span>
<span id="cb107-2"><a href="#cb107-2"></a>  <span class="co">--                  ^                            ^</span></span>
<span id="cb107-3"><a href="#cb107-3"></a>  <span class="co">--                  |                            |</span></span>
<span id="cb107-4"><a href="#cb107-4"></a>  <span class="co">-- マッチさせるトークンのラベル                 述語</span></span></code></pre></div>
<p><code>ByteStrings</code> と <code>Text</code>をパースすると、 これは元の方法よりはるかに高速になります。 また、<code>takeWhile1P</code> から直接 <code>Text</code>を取得するため、 <code>T.pack</code>は不要になりました。</p>
<p>以下の式は、<code>takeWhileP</code> と <code>takeWhile1P</code> の <code>Maybe String</code> 引数の意味を理解するのに役立つかもしれません。</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb108-1"><a href="#cb108-1"></a>takeWhileP  (<span class="dt">Just</span> <span class="st">&quot;foo&quot;</span>) f <span class="ot">=</span> many (satisfy f <span class="op">&lt;?&gt;</span> <span class="st">&quot;foo&quot;</span>)</span>
<span id="cb108-2"><a href="#cb108-2"></a>takeWhileP  <span class="dt">Nothing</span>      f <span class="ot">=</span> many (satisfy f)</span>
<span id="cb108-3"><a href="#cb108-3"></a>takeWhile1P (<span class="dt">Just</span> <span class="st">&quot;foo&quot;</span>) f <span class="ot">=</span> some (satisfy f <span class="op">&lt;?&gt;</span> <span class="st">&quot;foo&quot;</span>)</span>
<span id="cb108-4"><a href="#cb108-4"></a>takeWhile1P <span class="dt">Nothing</span>      f <span class="ot">=</span> some (satisfy f)</span></code></pre></div>
<p><a name="Error"></a></p>
<h2 id="パースエラー">パースエラー</h2>
<p><code>megaparsec</code> のほとんどの機能の使い方を調べてきたので、 パースエラーの定義する方法、通知する方法、 実行中のパーサ内での処理方法について学びましょう。</p>
<p><a name="ErrDef"></a></p>
<h2 id="パースエラーの定義">パースエラーの定義</h2>
<p>型<code>ParseError</code> は次のように定義されています。</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb109-1"><a href="#cb109-1"></a><span class="kw">data</span> <span class="dt">ParseError</span> s e</span>
<span id="cb109-2"><a href="#cb109-2"></a>  <span class="ot">=</span> <span class="dt">TrivialError</span> <span class="dt">Int</span> (<span class="dt">Maybe</span> (<span class="dt">ErrorItem</span> (<span class="dt">Token</span> s))) (<span class="dt">Set</span> (<span class="dt">ErrorItem</span> (<span class="dt">Token</span> s)))</span>
<span id="cb109-3"><a href="#cb109-3"></a>    <span class="co">-- ^ Megaparsecの機構によって生成された自明なエラー。 データコンストラクタには、</span></span>
<span id="cb109-4"><a href="#cb109-4"></a>    <span class="co">-- エラーのオフセット、予期しないトークン（存在する場合）、</span></span>
<span id="cb109-5"><a href="#cb109-5"></a>    <span class="co">-- および予期するトークンが含まれます。</span></span>
<span id="cb109-6"><a href="#cb109-6"></a>  <span class="op">|</span> <span class="dt">FancyError</span> <span class="dt">Int</span> (<span class="dt">Set</span> (<span class="dt">ErrorFancy</span> e))</span>
<span id="cb109-7"><a href="#cb109-7"></a>    <span class="co">-- ^ ファンシーなカスタムエラー。</span></span></code></pre></div>
<p><code>ParseError</code>は、多くても1つの予期しないアイテムと 予期するアイテムの（空かもしれない）コレクションを持つ <code>TrivialError</code>、 または <code>FancyError</code> のいずれかです。</p>
<p><code>ParseError s e</code> は、2つの型変数によってパラメータ化されています。</p>
<ul>
<li><code>s</code> は入力ストリームの型です。</li>
<li><code>e</code> は、パースエラーのカスタムコンポーネントの型です。</li>
</ul>
<p><code>ErrorItem</code> は次のように定義されています。</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb110-1"><a href="#cb110-1"></a><span class="kw">data</span> <span class="dt">ErrorItem</span> t</span>
<span id="cb110-2"><a href="#cb110-2"></a>  <span class="ot">=</span> <span class="dt">Tokens</span> (<span class="dt">NonEmpty</span> t)      <span class="co">-- ^ 空ではないトークンのストリーム</span></span>
<span id="cb110-3"><a href="#cb110-3"></a>  <span class="op">|</span> <span class="dt">Label</span> (<span class="dt">NonEmpty</span> <span class="dt">Char</span>)    <span class="co">-- ^ ラベル (空ではない)</span></span>
<span id="cb110-4"><a href="#cb110-4"></a>  <span class="op">|</span> <span class="dt">EndOfInput</span>               <span class="co">-- ^ 入力の終わり</span></span></code></pre></div>
<p>これが<code>ErrorFancy</code> です。</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb111-1"><a href="#cb111-1"></a><span class="kw">data</span> <span class="dt">ErrorFancy</span> e</span>
<span id="cb111-2"><a href="#cb111-2"></a>  <span class="ot">=</span> <span class="dt">ErrorFail</span> <span class="dt">String</span></span>
<span id="cb111-3"><a href="#cb111-3"></a>    <span class="co">-- ^ パーサモナドで 'fail'が使われている</span></span>
<span id="cb111-4"><a href="#cb111-4"></a>  <span class="op">|</span> <span class="dt">ErrorIndentation</span> <span class="dt">Ordering</span> <span class="dt">Pos</span> <span class="dt">Pos</span></span>
<span id="cb111-5"><a href="#cb111-5"></a>    <span class="co">-- ^ インデントの誤りによるエラー：参照レベルと実際のレベルの間の</span></span>
<span id="cb111-6"><a href="#cb111-6"></a>    <span class="co">-- 望ましい順序、参照インデントレベル、実際のインデントレベル。</span></span>
<span id="cb111-7"><a href="#cb111-7"></a>  <span class="op">|</span> <span class="dt">ErrorCustom</span> e</span>
<span id="cb111-8"><a href="#cb111-8"></a>    <span class="co">-- ^ カスタムエラーデータ、 'Error Fancy'の'e'を'Void'に</span></span>
<span id="cb111-9"><a href="#cb111-9"></a>    <span class="co">-- することで都合に応じて無効にすることができます。</span></span></code></pre></div>
<p><code>ErrorFancy</code>には、2つの一般的なケースのための データコンストラクタが含まれており、 <code>megaparsec</code>はそのまま使えるようになっています。</p>
<ul>
<li><p><code>fail</code>関数の使用により、パーサが任意の<code>String</code> で失敗の報告をする。</p></li>
<li><p>前の章で見たインデント関連の問題です。 すぐに使えるindentation-sensitive な文法を扱うためのツールを 提供しているので、インデントの問題に関する正しく型付けされた 情報を保存する方法が必要です。</p></li>
</ul>
<p>最後に、<code>ErrorCustom</code>は<code>ErrorFancy</code>型に任意のデータを 埋め込むことを可能にする一種の「拡張スロット」です。 パースエラーにカスタムデータが必要ない場合は、 <code>ErrorFancy</code>を<code>Void</code>でパラメータ化します。 <code>Void</code>はボトムしか含まないため、<code>ErrorCustom</code>は「キャンセル」されるか、 または代数データ型と数値の間の類推に従うと「0倍」になります。</p>
<p>ライブラリの古いバージョンでは、<code>ParseError</code> は <code>parse</code>のような 関数によって直接返していました。しかしバージョン7はエラーごとの 行と列の計算が遅れます。 同様にエラーが発生した場合に表示するために入力から関連する行を取得します。 この情報は通常、パーサが失敗した場合にのみ役立つので、 パースを高速化するために行われます。 古いバージョンのライブラリのもう1つの問題は、 一度に複数のパースエラーを表示する場合では、 正しい行を取得するために毎回入力を再びトラバースする必要があることです。</p>
<p>この問題は<code>ParseErrorBundle</code>データ型で解決されます。</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb112-1"><a href="#cb112-1"></a><span class="co">-- | エラーの効率的かつ正確なプリティプリントが可能な、</span></span>
<span id="cb112-2"><a href="#cb112-2"></a><span class="co">-- 'PosState'を備えた 'ParseError'の空でないコレクション。</span></span>
<span id="cb112-3"><a href="#cb112-3"></a></span>
<span id="cb112-4"><a href="#cb112-4"></a><span class="kw">data</span> <span class="dt">ParseErrorBundle</span> s e <span class="ot">=</span> <span class="dt">ParseErrorBundle</span></span>
<span id="cb112-5"><a href="#cb112-5"></a>  {<span class="ot"> bundleErrors ::</span> <span class="dt">NonEmpty</span> (<span class="dt">ParseError</span> s e)</span>
<span id="cb112-6"><a href="#cb112-6"></a>    <span class="co">-- ^ パースエラーのオフセットでソートされた 'ParseError'のコレクション</span></span>
<span id="cb112-7"><a href="#cb112-7"></a>  ,<span class="ot"> bundlePosState ::</span> <span class="dt">PosState</span> s</span>
<span id="cb112-8"><a href="#cb112-8"></a>    <span class="co">-- ^ 行と列の計算に使用される状態</span></span>
<span id="cb112-9"><a href="#cb112-9"></a>  }</span></code></pre></div>
<p>パーサを実行するすべての関数は、正しく設定された <code>bundlePosState</code>と 単一の<code>ParseError</code>を内部に持つ<code>ParseErrorBundle</code>を返します。 <code>ParseErrorBundle</code>をユーザに表示する前に、 内部の<code>ParseError</code>のコレクションを拡張できます。 <code>ParseErrors</code>をそれらのオフセットでソートしておくことはユーザーの責任です。</p>
<p><a name="SigErr"></a></p>
<h2 id="パースエラーを通知する方法">パースエラーを通知する方法</h2>
<p>パースエラーを通知するためのさまざまな方法について説明しましょう。 最も簡単な関数は<code>fail</code>です。</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb113-1"><a href="#cb113-1"></a>λ<span class="op">&gt;</span> parseTest (<span class="fu">fail</span> <span class="st">&quot;I'm failing, help me!&quot;</span><span class="ot"> ::</span> <span class="dt">Parser</span> ()) <span class="st">&quot;&quot;</span></span>
<span id="cb113-2"><a href="#cb113-2"></a><span class="dv">1</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span></span>
<span id="cb113-3"><a href="#cb113-3"></a>  <span class="op">|</span></span>
<span id="cb113-4"><a href="#cb113-4"></a><span class="dv">1</span> <span class="op">|</span> <span class="op">&lt;</span>empty line<span class="op">&gt;</span></span>
<span id="cb113-5"><a href="#cb113-5"></a>  <span class="op">|</span> <span class="op">^</span></span>
<span id="cb113-6"><a href="#cb113-6"></a><span class="dt">I'm</span> failing, help me<span class="op">!</span></span></code></pre></div>
<p><code>parsec</code>のような、より単純なパーサライブラリに精通している 多くの人々にとってはこれで十分です。 しかし、パースエラーをユーザーに表示することだけではなく、 それを分析したり操作したりする必要があるかもしれません。 これが<code>String</code>があまり便利ではないところです。</p>
<p>自明なパースエラーは通常 <code>megaparsec</code> によって生成されますが、 <code>failure</code>コンビネータを使って自分自身でそのようなエラーを 知らせることができます。</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb114-1"><a href="#cb114-1"></a><span class="ot">failure ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb114-2"><a href="#cb114-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Maybe</span> (<span class="dt">ErrorItem</span> (<span class="dt">Token</span> s)) <span class="co">-- ^ 予期しないアイテム（ある場合）</span></span>
<span id="cb114-3"><a href="#cb114-3"></a>  <span class="ot">-&gt;</span> <span class="dt">Set</span> (<span class="dt">ErrorItem</span> (<span class="dt">Token</span> s)) <span class="co">-- ^ 予期するアイテム</span></span>
<span id="cb114-4"><a href="#cb114-4"></a>  <span class="ot">-&gt;</span> m a</span></code></pre></div>
<div class="sourceCode" id="cb115"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb115-1"><a href="#cb115-1"></a><span class="ot">unfortunateParser ::</span> <span class="dt">Parser</span> ()</span>
<span id="cb115-2"><a href="#cb115-2"></a>unfortunateParser <span class="ot">=</span> failure (<span class="dt">Just</span> <span class="dt">EndOfInput</span>) (Set.fromList es)</span>
<span id="cb115-3"><a href="#cb115-3"></a>  <span class="kw">where</span></span>
<span id="cb115-4"><a href="#cb115-4"></a>    es <span class="ot">=</span> [<span class="dt">Tokens</span> (NE.fromList <span class="st">&quot;a&quot;</span>), <span class="dt">Tokens</span> (NE.fromList <span class="st">&quot;b&quot;</span>)]</span></code></pre></div>
<div class="sourceCode" id="cb116"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb116-1"><a href="#cb116-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> unfortunateParser <span class="st">&quot;&quot;</span></span>
<span id="cb116-2"><a href="#cb116-2"></a><span class="ex">1</span>:1:</span>
<span id="cb116-3"><a href="#cb116-3"></a>  <span class="kw">|</span></span>
<span id="cb116-4"><a href="#cb116-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="op">&lt;</span><span class="ex">empty</span> line<span class="op">&gt;</span></span>
<span id="cb116-5"><a href="#cb116-5"></a>  <span class="kw">|</span> ^</span>
<span id="cb116-6"><a href="#cb116-6"></a><span class="ex">unexpected</span> end of input</span>
<span id="cb116-7"><a href="#cb116-7"></a><span class="ex">expecting</span> <span class="st">'a'</span> or <span class="st">'b'</span></span></code></pre></div>
<p><code>fail</code>に基づいたアプローチとは異なり、 簡単なパースエラーはパターンマッチによる検査や変更が容易です。</p>
<p>ファンシーエラーについては、 <code>fancyFaliure</code>コンビネータで対応します。</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb117-1"><a href="#cb117-1"></a><span class="ot">fancyFailure ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb117-2"><a href="#cb117-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Set</span> (<span class="dt">ErrorFancy</span> e) <span class="co">-- ^ ファンシーエラーのコンポーネント</span></span>
<span id="cb117-3"><a href="#cb117-3"></a>  <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p><code>fancyFailure</code> を使う際には、直接 <code>fancyFailure</code> を呼び出すのではなく、 字句解析モジュールにある次のようなヘルパーとして定義するのが 望ましいことがよくあります。</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb118-1"><a href="#cb118-1"></a><span class="ot">incorrectIndent ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb118-2"><a href="#cb118-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Ordering</span>  <span class="co">-- ^ 参照レベルと実際のレベル間の望ましい順序</span></span>
<span id="cb118-3"><a href="#cb118-3"></a>  <span class="ot">-&gt;</span> <span class="dt">Pos</span>               <span class="co">-- ^ 参照インデントレベル</span></span>
<span id="cb118-4"><a href="#cb118-4"></a>  <span class="ot">-&gt;</span> <span class="dt">Pos</span>               <span class="co">-- ^ 実際のインデントレベル</span></span>
<span id="cb118-5"><a href="#cb118-5"></a>  <span class="ot">-&gt;</span> m a</span>
<span id="cb118-6"><a href="#cb118-6"></a>incorrectIndent <span class="fu">ord</span> ref actual <span class="ot">=</span> fancyFailure <span class="op">.</span> E.singleton <span class="op">$</span></span>
<span id="cb118-7"><a href="#cb118-7"></a>  <span class="dt">ErrorIndentation</span> <span class="fu">ord</span> ref actual</span></code></pre></div>
<p>あなたのパーサにカスタムパースエラーコンポーネントを追加する例として、 与えられた<code>Text</code>の値がキーワードではないことを示す、 特別なパースエラーを定義することを通して見てみましょう。</p>
<p>まず、サポートしたいシナリオを表現するコンストラクタを使用して データ型を定義する必要があります。</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb119-1"><a href="#cb119-1"></a><span class="kw">data</span> <span class="dt">Custom</span> <span class="ot">=</span> <span class="dt">NotKeyword</span> <span class="dt">Text</span></span>
<span id="cb119-2"><a href="#cb119-2"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Ord</span>)</span></code></pre></div>
<p>そしてそれをパースエラーで表示する方法を<code>megaparsec</code>に伝えてください。</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb120-1"><a href="#cb120-1"></a><span class="kw">instance</span> <span class="dt">ShowErrorComponent</span> <span class="dt">Custom</span> <span class="kw">where</span></span>
<span id="cb120-2"><a href="#cb120-2"></a>  showErrorComponent (<span class="dt">NotKeyword</span> txt) <span class="ot">=</span> T.unpack txt <span class="op">++</span> <span class="st">&quot; is not a keyword&quot;</span></span></code></pre></div>
<p>次に、<code>Parser</code>型シノニムを更新します。</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb121-1"><a href="#cb121-1"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Custom</span> <span class="dt">Text</span></span></code></pre></div>
<p>その後、<code>notKeyword</code>ヘルパーを定義できます。</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb122-1"><a href="#cb122-1"></a><span class="ot">notKeyword ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb122-2"><a href="#cb122-2"></a>notKeyword <span class="ot">=</span> customFailure <span class="op">.</span> <span class="dt">NotKeyword</span></span></code></pre></div>
<p><code>customFailure</code>は<code>Text.Megaparsec</code>モジュールの便利なヘルパーです。</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb123-1"><a href="#cb123-1"></a><span class="ot">customFailure ::</span> <span class="dt">MonadParsec</span> e s m <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> m a</span>
<span id="cb123-2"><a href="#cb123-2"></a>customFailure <span class="ot">=</span> fancyFailure <span class="op">.</span> E.singleton <span class="op">.</span> <span class="dt">ErrorCustom</span></span></code></pre></div>
<p>最後に試してみましょう。</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb124-1"><a href="#cb124-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (notKeyword <span class="st">&quot;foo&quot;</span> :: Parser ()) <span class="st">&quot;&quot;</span></span>
<span id="cb124-2"><a href="#cb124-2"></a><span class="ex">1</span>:1:</span>
<span id="cb124-3"><a href="#cb124-3"></a>  <span class="kw">|</span></span>
<span id="cb124-4"><a href="#cb124-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="op">&lt;</span><span class="ex">empty</span> line<span class="op">&gt;</span></span>
<span id="cb124-5"><a href="#cb124-5"></a>  <span class="kw">|</span> ^</span>
<span id="cb124-6"><a href="#cb124-6"></a><span class="ex">foo</span> is not a keyword</span></code></pre></div>
<p><a name="DispErr"></a></p>
<h2 id="パースエラーの表示">パースエラーの表示</h2>
<p><code>ParseErrorBundle</code>の表示は<code>errorBundlePretty</code>関数で行われます。</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb125-1"><a href="#cb125-1"></a><span class="co">-- | 'ParseErrorBundle'をプリティプリントします。バンドル内のすべての 'ParseError'は、</span></span>
<span id="cb125-2"><a href="#cb125-2"></a><span class="co">-- 入力ストリームに対して単一の効率的なパスを実行することによって、</span></span>
<span id="cb125-3"><a href="#cb125-3"></a><span class="co">-- 対応する問題が起きている行とともに順番にプリティプリントされます。</span></span>
<span id="cb125-4"><a href="#cb125-4"></a><span class="co">-- レンダリングされた 'String'は常に改行で終わります。</span></span>
<span id="cb125-5"><a href="#cb125-5"></a></span>
<span id="cb125-6"><a href="#cb125-6"></a>errorBundlePretty</span>
<span id="cb125-7"><a href="#cb125-7"></a><span class="ot">  ::</span> ( <span class="dt">Stream</span> s</span>
<span id="cb125-8"><a href="#cb125-8"></a>     , <span class="dt">ShowErrorComponent</span> e</span>
<span id="cb125-9"><a href="#cb125-9"></a>     )</span>
<span id="cb125-10"><a href="#cb125-10"></a>  <span class="ot">=&gt;</span> <span class="dt">ParseErrorBundle</span> s e <span class="co">-- ^ 表示するパースエラーバンドル</span></span>
<span id="cb125-11"><a href="#cb125-11"></a>  <span class="ot">-&gt;</span> <span class="dt">String</span>               <span class="co">-- ^ バンドルのテキスト表現</span></span></code></pre></div>
<p>99％のケースで、あなたはこの1つの関数だけを必要とするでしょう。</p>
<p><a name="ChatchErr"></a></p>
<h2 id="実行中のパーサでパースエラーをチャッチする">実行中のパーサでパースエラーをチャッチする</h2>
<p><code>megaparsec</code> のもう1つの便利な機能は、 パースエラーを「キャッチ」し、それを何らかの方法で変更してから、 例外のように再びスローすることが可能なことです。 これはプリミティブ <code>observing</code> によって有効になります。</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb126-1"><a href="#cb126-1"></a><span class="co">-- | @'observing' p@ はパーサ @p@ の失敗を「観察」することを可能にします.</span></span>
<span id="cb126-2"><a href="#cb126-2"></a><span class="co">-- 実際にはパーサを終了せずに、代わりに 'Left'の 'ParseError'を取得します。</span></span>
<span id="cb126-3"><a href="#cb126-3"></a><span class="co">-- 成功すると、パースされた値はいつものように 'Right' で返されます。</span></span>
<span id="cb126-4"><a href="#cb126-4"></a><span class="co">-- このプリミティブは、発生したパースエラーを観察することを可能にするだけで、</span></span>
<span id="cb126-5"><a href="#cb126-5"></a><span class="co">-- パーサ @p@ の動作をバックトラックしたり変更したりすることはありません。</span></span>
<span id="cb126-6"><a href="#cb126-6"></a></span>
<span id="cb126-7"><a href="#cb126-7"></a><span class="ot">observing ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb126-8"><a href="#cb126-8"></a>  <span class="ot">=&gt;</span> m a             <span class="co">-- ^ The parser to run</span></span>
<span id="cb126-9"><a href="#cb126-9"></a>  <span class="ot">-&gt;</span> m (<span class="dt">Either</span> (<span class="dt">ParseError</span> (<span class="dt">Token</span> s) e) a)</span></code></pre></div>
<p>これは、の典型的な <code>observing</code> の使い方を示す完全なプログラムです。</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb127-1"><a href="#cb127-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb127-2"><a href="#cb127-2"></a><span class="ot">{-# LANGUAGE TypeApplications  #-}</span></span>
<span id="cb127-3"><a href="#cb127-3"></a></span>
<span id="cb127-4"><a href="#cb127-4"></a><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></span>
<span id="cb127-5"><a href="#cb127-5"></a></span>
<span id="cb127-6"><a href="#cb127-6"></a><span class="co">-- import Control.Applicative</span></span>
<span id="cb127-7"><a href="#cb127-7"></a><span class="kw">import</span> <span class="dt">Data.List</span> (intercalate)</span>
<span id="cb127-8"><a href="#cb127-8"></a><span class="kw">import</span> <span class="dt">Data.Set</span> (<span class="dt">Set</span>)</span>
<span id="cb127-9"><a href="#cb127-9"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb127-10"><a href="#cb127-10"></a><span class="kw">import</span> <span class="dt">Data.Void</span></span>
<span id="cb127-11"><a href="#cb127-11"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span></span>
<span id="cb127-12"><a href="#cb127-12"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec.Char</span></span>
<span id="cb127-13"><a href="#cb127-13"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb127-14"><a href="#cb127-14"></a></span>
<span id="cb127-15"><a href="#cb127-15"></a><span class="kw">data</span> <span class="dt">Custom</span></span>
<span id="cb127-16"><a href="#cb127-16"></a>  <span class="ot">=</span> <span class="dt">TrivialWithLocation</span></span>
<span id="cb127-17"><a href="#cb127-17"></a>    [<span class="dt">String</span>] <span class="co">-- 位置スタック</span></span>
<span id="cb127-18"><a href="#cb127-18"></a>    (<span class="dt">Maybe</span> (<span class="dt">ErrorItem</span> <span class="dt">Char</span>))</span>
<span id="cb127-19"><a href="#cb127-19"></a>    (<span class="dt">Set</span> (<span class="dt">ErrorItem</span> <span class="dt">Char</span>))</span>
<span id="cb127-20"><a href="#cb127-20"></a>  <span class="op">|</span> <span class="dt">FancyWithLocation</span></span>
<span id="cb127-21"><a href="#cb127-21"></a>    [<span class="dt">String</span>] <span class="co">-- 位置スタック</span></span>
<span id="cb127-22"><a href="#cb127-22"></a>    (<span class="dt">ErrorFancy</span> <span class="dt">Void</span>) <span class="co">-- Custom をネストさせないように Void になっている</span></span>
<span id="cb127-23"><a href="#cb127-23"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span>
<span id="cb127-24"><a href="#cb127-24"></a></span>
<span id="cb127-25"><a href="#cb127-25"></a><span class="kw">instance</span> <span class="dt">ShowErrorComponent</span> <span class="dt">Custom</span> <span class="kw">where</span></span>
<span id="cb127-26"><a href="#cb127-26"></a>  showErrorComponent (<span class="dt">TrivialWithLocation</span> stack us es) <span class="ot">=</span></span>
<span id="cb127-27"><a href="#cb127-27"></a>    parseErrorTextPretty (<span class="dt">TrivialError</span> <span class="op">@</span><span class="dt">Text</span> <span class="op">@</span><span class="dt">Void</span> <span class="fu">undefined</span> us es)</span>
<span id="cb127-28"><a href="#cb127-28"></a>      <span class="op">++</span> showPosStack stack</span>
<span id="cb127-29"><a href="#cb127-29"></a>  showErrorComponent (<span class="dt">FancyWithLocation</span> stack cs) <span class="ot">=</span></span>
<span id="cb127-30"><a href="#cb127-30"></a>    parseErrorTextPretty (<span class="dt">FancyError</span> <span class="op">@</span><span class="dt">Text</span> <span class="op">@</span><span class="dt">Void</span> <span class="fu">undefined</span> (Set.singleton cs))</span>
<span id="cb127-31"><a href="#cb127-31"></a>      <span class="op">++</span> showPosStack stack</span>
<span id="cb127-32"><a href="#cb127-32"></a></span>
<span id="cb127-33"><a href="#cb127-33"></a><span class="ot">showPosStack ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb127-34"><a href="#cb127-34"></a>showPosStack <span class="ot">=</span> intercalate <span class="st">&quot;, &quot;</span> <span class="op">.</span> <span class="fu">fmap</span> (<span class="st">&quot;in &quot;</span> <span class="op">++</span>)</span>
<span id="cb127-35"><a href="#cb127-35"></a></span>
<span id="cb127-36"><a href="#cb127-36"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Custom</span> <span class="dt">Text</span></span>
<span id="cb127-37"><a href="#cb127-37"></a></span>
<span id="cb127-38"><a href="#cb127-38"></a><span class="ot">inside ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb127-39"><a href="#cb127-39"></a>inside location p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb127-40"><a href="#cb127-40"></a>  r <span class="ot">&lt;-</span> observing p</span>
<span id="cb127-41"><a href="#cb127-41"></a>  <span class="kw">case</span> r <span class="kw">of</span></span>
<span id="cb127-42"><a href="#cb127-42"></a>    <span class="dt">Left</span> (<span class="dt">TrivialError</span> _ us es) <span class="ot">-&gt;</span></span>
<span id="cb127-43"><a href="#cb127-43"></a>      fancyFailure <span class="op">.</span> Set.singleton <span class="op">.</span> <span class="dt">ErrorCustom</span> <span class="op">$</span></span>
<span id="cb127-44"><a href="#cb127-44"></a>        <span class="dt">TrivialWithLocation</span> [location] us es</span>
<span id="cb127-45"><a href="#cb127-45"></a>    <span class="dt">Left</span> (<span class="dt">FancyError</span> _ xs) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb127-46"><a href="#cb127-46"></a>      <span class="kw">let</span> f (<span class="dt">ErrorFail</span> msg) <span class="ot">=</span> <span class="dt">ErrorCustom</span> <span class="op">$</span></span>
<span id="cb127-47"><a href="#cb127-47"></a>            <span class="dt">FancyWithLocation</span> [location] (<span class="dt">ErrorFail</span> msg)</span>
<span id="cb127-48"><a href="#cb127-48"></a>          f (<span class="dt">ErrorIndentation</span> <span class="fu">ord</span> rlvl alvl) <span class="ot">=</span> <span class="dt">ErrorCustom</span> <span class="op">$</span></span>
<span id="cb127-49"><a href="#cb127-49"></a>            <span class="dt">FancyWithLocation</span> [location] (<span class="dt">ErrorIndentation</span> <span class="fu">ord</span> rlvl alvl)</span>
<span id="cb127-50"><a href="#cb127-50"></a>          f (<span class="dt">ErrorCustom</span> (<span class="dt">TrivialWithLocation</span> ps us es)) <span class="ot">=</span> <span class="dt">ErrorCustom</span> <span class="op">$</span></span>
<span id="cb127-51"><a href="#cb127-51"></a>            <span class="dt">TrivialWithLocation</span> (location<span class="op">:</span>ps) us es</span>
<span id="cb127-52"><a href="#cb127-52"></a>          f (<span class="dt">ErrorCustom</span> (<span class="dt">FancyWithLocation</span> ps cs)) <span class="ot">=</span> <span class="dt">ErrorCustom</span> <span class="op">$</span></span>
<span id="cb127-53"><a href="#cb127-53"></a>            <span class="dt">FancyWithLocation</span> (location<span class="op">:</span>ps) cs</span>
<span id="cb127-54"><a href="#cb127-54"></a>      fancyFailure (Set.map f xs)</span>
<span id="cb127-55"><a href="#cb127-55"></a>    <span class="dt">Right</span> x <span class="ot">-&gt;</span> <span class="fu">return</span> x</span>
<span id="cb127-56"><a href="#cb127-56"></a></span>
<span id="cb127-57"><a href="#cb127-57"></a><span class="ot">myParser ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb127-58"><a href="#cb127-58"></a>myParser <span class="ot">=</span> some (char <span class="ch">'a'</span>) <span class="op">*&gt;</span> some (char <span class="ch">'b'</span>)</span>
<span id="cb127-59"><a href="#cb127-59"></a></span>
<span id="cb127-60"><a href="#cb127-60"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb127-61"><a href="#cb127-61"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb127-62"><a href="#cb127-62"></a>  parseTest (inside <span class="st">&quot;foo&quot;</span> myParser) <span class="st">&quot;aaacc&quot;</span></span>
<span id="cb127-63"><a href="#cb127-63"></a>  parseTest (inside <span class="st">&quot;foo&quot;</span> <span class="op">$</span> inside <span class="st">&quot;bar&quot;</span> myParser) <span class="st">&quot;aaacc&quot;</span></span></code></pre></div>
<p>演習: このプログラムがどのように機能するのか詳細に理解しなさい。</p>
<p>このプログラムを実行すると、次のように出力されます。</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb128-1"><a href="#cb128-1"></a><span class="dv">1</span><span class="op">:</span><span class="dv">4</span><span class="op">:</span></span>
<span id="cb128-2"><a href="#cb128-2"></a>  <span class="op">|</span></span>
<span id="cb128-3"><a href="#cb128-3"></a><span class="dv">1</span> <span class="op">|</span> aaacc</span>
<span id="cb128-4"><a href="#cb128-4"></a>  <span class="op">|</span>    <span class="op">^</span></span>
<span id="cb128-5"><a href="#cb128-5"></a>unexpected <span class="ch">'c'</span></span>
<span id="cb128-6"><a href="#cb128-6"></a>expecting <span class="ch">'a'</span> <span class="fu">or</span> <span class="ch">'b'</span></span>
<span id="cb128-7"><a href="#cb128-7"></a><span class="kw">in</span> foo</span>
<span id="cb128-8"><a href="#cb128-8"></a><span class="dv">1</span><span class="op">:</span><span class="dv">4</span><span class="op">:</span></span>
<span id="cb128-9"><a href="#cb128-9"></a>  <span class="op">|</span></span>
<span id="cb128-10"><a href="#cb128-10"></a><span class="dv">1</span> <span class="op">|</span> aaacc</span>
<span id="cb128-11"><a href="#cb128-11"></a>  <span class="op">|</span>    <span class="op">^</span></span>
<span id="cb128-12"><a href="#cb128-12"></a>unexpected <span class="ch">'c'</span></span>
<span id="cb128-13"><a href="#cb128-13"></a>expecting <span class="ch">'a'</span> <span class="fu">or</span> <span class="ch">'b'</span></span>
<span id="cb128-14"><a href="#cb128-14"></a><span class="kw">in</span> foo, <span class="kw">in</span> bar</span></code></pre></div>
<p>したがって、この機能を使用してパースエラーに対する位置ラベルの添付や、 実際にパースエラーが何らかの方法で処理される領域を定義できます。 このイディオムは非常に便利なので、 プリミティブ <code>observing</code> の観点から構築された <code>region</code> と呼ばれる非プリミティブヘルパーもあります。</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb129-1"><a href="#cb129-1"></a><span class="co">-- | 内部のラッパーで発生する 'ParseError'の処理方法を指定します。</span></span>
<span id="cb129-2"><a href="#cb129-2"></a><span class="co">-- これは、通常と遅延の両方の 'ParseError'に適用されます。</span></span>
<span id="cb129-3"><a href="#cb129-3"></a><span class="co">--</span></span>
<span id="cb129-4"><a href="#cb129-4"></a><span class="co">-- 実装の副作用として、内部計算は遅延エラーの空のコレクションから始まり、</span></span>
<span id="cb129-5"><a href="#cb129-5"></a><span class="co">-- それらは更新され、 'region' から出て行くときに「復元」されます。</span></span>
<span id="cb129-6"><a href="#cb129-6"></a></span>
<span id="cb129-7"><a href="#cb129-7"></a><span class="ot">region ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb129-8"><a href="#cb129-8"></a>  <span class="ot">=&gt;</span> (<span class="dt">ParseError</span> s e <span class="ot">-&gt;</span> <span class="dt">ParseError</span> s e)</span>
<span id="cb129-9"><a href="#cb129-9"></a>     <span class="co">-- ^ 'ParseError' を処理する方法</span></span>
<span id="cb129-10"><a href="#cb129-10"></a>  <span class="ot">-&gt;</span> m a     <span class="co">-- ^ 処理を適用する 「領域」</span></span>
<span id="cb129-11"><a href="#cb129-11"></a>  <span class="ot">-&gt;</span> m a</span>
<span id="cb129-12"><a href="#cb129-12"></a>region f m <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb129-13"><a href="#cb129-13"></a>  r <span class="ot">&lt;-</span> observing m</span>
<span id="cb129-14"><a href="#cb129-14"></a>  <span class="kw">case</span> r <span class="kw">of</span></span>
<span id="cb129-15"><a href="#cb129-15"></a>    <span class="dt">Left</span> err <span class="ot">-&gt;</span> parseError (f err) <span class="co">-- 次の章を見てください</span></span>
<span id="cb129-16"><a href="#cb129-16"></a>    <span class="dt">Right</span> x <span class="ot">-&gt;</span> <span class="fu">return</span> x</span></code></pre></div>
<p>演習: 上記のプログラムで <code>region</code> を使用して <code>inside</code> 関数を書き換えなさい。</p>
<p>回答例:</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb130-1"><a href="#cb130-1"></a><span class="ot">inside' ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb130-2"><a href="#cb130-2"></a>inside' location p <span class="ot">=</span> region (processParseError location) p</span>
<span id="cb130-3"><a href="#cb130-3"></a></span>
<span id="cb130-4"><a href="#cb130-4"></a><span class="ot">processParseError ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ParseError</span> <span class="dt">Text</span> <span class="dt">Custom</span> <span class="ot">-&gt;</span> <span class="dt">ParseError</span> <span class="dt">Text</span> <span class="dt">Custom</span></span>
<span id="cb130-5"><a href="#cb130-5"></a>processParseError location (<span class="dt">TrivialError</span> i us es) <span class="ot">=</span></span>
<span id="cb130-6"><a href="#cb130-6"></a>  <span class="dt">FancyError</span> i <span class="op">.</span> Set.singleton <span class="op">.</span> <span class="dt">ErrorCustom</span> <span class="op">$</span></span>
<span id="cb130-7"><a href="#cb130-7"></a>    <span class="dt">TrivialWithLocation</span> [location] us es</span>
<span id="cb130-8"><a href="#cb130-8"></a>processParseError location (<span class="dt">FancyError</span> i xs) <span class="ot">=</span></span>
<span id="cb130-9"><a href="#cb130-9"></a>  <span class="dt">FancyError</span> i <span class="op">$</span> Set.map (processErrorFancy location) xs</span>
<span id="cb130-10"><a href="#cb130-10"></a></span>
<span id="cb130-11"><a href="#cb130-11"></a><span class="ot">processErrorFancy ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ErrorFancy</span> <span class="dt">Custom</span> <span class="ot">-&gt;</span> <span class="dt">ErrorFancy</span> <span class="dt">Custom</span></span>
<span id="cb130-12"><a href="#cb130-12"></a>processErrorFancy location (<span class="dt">ErrorFail</span> msg) <span class="ot">=</span> <span class="dt">ErrorCustom</span> <span class="op">$</span></span>
<span id="cb130-13"><a href="#cb130-13"></a>  <span class="dt">FancyWithLocation</span> [location] (<span class="dt">ErrorFail</span> msg)</span>
<span id="cb130-14"><a href="#cb130-14"></a>processErrorFancy location (<span class="dt">ErrorIndentation</span> <span class="fu">ord</span> rlvl alvl) <span class="ot">=</span> <span class="dt">ErrorCustom</span> <span class="op">$</span></span>
<span id="cb130-15"><a href="#cb130-15"></a>  <span class="dt">FancyWithLocation</span> [location] (<span class="dt">ErrorIndentation</span> <span class="fu">ord</span> rlvl alvl)</span>
<span id="cb130-16"><a href="#cb130-16"></a>processErrorFancy location (<span class="dt">ErrorCustom</span> (<span class="dt">TrivialWithLocation</span> ps us es)) <span class="ot">=</span></span>
<span id="cb130-17"><a href="#cb130-17"></a>  <span class="dt">ErrorCustom</span> <span class="op">$</span> <span class="dt">TrivialWithLocation</span> (location<span class="op">:</span>ps) us es</span>
<span id="cb130-18"><a href="#cb130-18"></a>processErrorFancy location (<span class="dt">ErrorCustom</span> (<span class="dt">FancyWithLocation</span> ps cs)) <span class="ot">=</span></span>
<span id="cb130-19"><a href="#cb130-19"></a>  <span class="dt">ErrorCustom</span> <span class="op">$</span> <span class="dt">FancyWithLocation</span> (location<span class="op">:</span>ps) cs</span></code></pre></div>
<p><a name="Control"></a></p>
<h3 id="パースエラー位置のコントロール">パースエラー位置のコントロール</h3>
<p><code>region</code> の定義では、 <code>parseError</code> プリミティブが使われていました。</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb131-1"><a href="#cb131-1"></a><span class="ot">parseError ::</span> <span class="dt">MonadParsec</span> e s m <span class="ot">=&gt;</span> <span class="dt">ParseError</span> s e <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>これはエラーを報告する基本的なプリミティブであり、 これまで見てきた他の関数は <code>parseError</code> を使用して定義されています。</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb132-1"><a href="#cb132-1"></a>failure</span>
<span id="cb132-2"><a href="#cb132-2"></a><span class="ot">  ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb132-3"><a href="#cb132-3"></a>  <span class="ot">=&gt;</span> <span class="dt">Maybe</span> (<span class="dt">ErrorItem</span> (<span class="dt">Token</span> s)) <span class="co">-- ^ Unexpected item (if any)</span></span>
<span id="cb132-4"><a href="#cb132-4"></a>  <span class="ot">-&gt;</span> <span class="dt">Set</span> (<span class="dt">ErrorItem</span> (<span class="dt">Token</span> s)) <span class="co">-- ^ Expected items</span></span>
<span id="cb132-5"><a href="#cb132-5"></a>  <span class="ot">-&gt;</span> m a</span>
<span id="cb132-6"><a href="#cb132-6"></a>failure us ps <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb132-7"><a href="#cb132-7"></a>  o <span class="ot">&lt;-</span> getOffset</span>
<span id="cb132-8"><a href="#cb132-8"></a>  parseError (<span class="dt">TrivialError</span> o us ps)</span>
<span id="cb132-9"><a href="#cb132-9"></a></span>
<span id="cb132-10"><a href="#cb132-10"></a>fancyFailure</span>
<span id="cb132-11"><a href="#cb132-11"></a><span class="ot">  ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb132-12"><a href="#cb132-12"></a>  <span class="ot">=&gt;</span> <span class="dt">Set</span> (<span class="dt">ErrorFancy</span> e) <span class="co">-- ^ Fancy error components</span></span>
<span id="cb132-13"><a href="#cb132-13"></a>  <span class="ot">-&gt;</span> m a</span>
<span id="cb132-14"><a href="#cb132-14"></a>fancyFailure xs <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb132-15"><a href="#cb132-15"></a>  o <span class="ot">&lt;-</span> getOffset</span>
<span id="cb132-16"><a href="#cb132-16"></a>  parseError (<span class="dt">FancyError</span> o xs)</span></code></pre></div>
<p><code>parseError</code>ができることの1つは、エラーオフセット（つまり、位置）を 入力ストリームの現在の位置以外に設定することです。 パースの結果をさかのぼって拒否する例に戻りましょう。</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb133-1"><a href="#cb133-1"></a>withPredicate2</span>
<span id="cb133-2"><a href="#cb133-2"></a><span class="ot">  ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)       <span class="co">-- ^ パースした入力に行うチェック</span></span>
<span id="cb133-3"><a href="#cb133-3"></a>  <span class="ot">-&gt;</span> <span class="dt">String</span>            <span class="co">-- ^ チェックが失敗したときに表示するメッセージ</span></span>
<span id="cb133-4"><a href="#cb133-4"></a>  <span class="ot">-&gt;</span> <span class="dt">Parser</span> a          <span class="co">-- ^ 実行するパーサ</span></span>
<span id="cb133-5"><a href="#cb133-5"></a>  <span class="ot">-&gt;</span> <span class="dt">Parser</span> a          <span class="co">-- ^ チェックを実行するパーサを返す</span></span>
<span id="cb133-6"><a href="#cb133-6"></a>withPredicate2 f msg p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb133-7"><a href="#cb133-7"></a>  o <span class="ot">&lt;-</span> getOffset</span>
<span id="cb133-8"><a href="#cb133-8"></a>  r <span class="ot">&lt;-</span> p</span>
<span id="cb133-9"><a href="#cb133-9"></a>  <span class="kw">if</span> f r</span>
<span id="cb133-10"><a href="#cb133-10"></a>    <span class="kw">then</span> <span class="fu">return</span> r</span>
<span id="cb133-11"><a href="#cb133-11"></a>    <span class="kw">else</span> <span class="kw">do</span></span>
<span id="cb133-12"><a href="#cb133-12"></a>      setOffset o</span>
<span id="cb133-13"><a href="#cb133-13"></a>      <span class="fu">fail</span> msg</span></code></pre></div>
<p><code>setOffset o</code>はエラーの位置を適切に設定しますが、 副作用としてパーサの状態も無効になり、 オフセットは現実を反映しなくなります。 これは、より複雑なパーサでは現実的な問題になる可能性があります。 たとえば、<code>withPredicate2</code>を<code>observing</code>で囲み、 <code>fail</code>の後に実行されるコードがあることを想像してください。</p>
<p>最終的に<code>parseError</code>と<code>region</code>により問題の適切な解決策が得られます。 <code>parseError</code>を使用してパースエラーの場所をリセットするか、 最初に<code>parseError</code>を使用します。</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb134-1"><a href="#cb134-1"></a>withPredicate3</span>
<span id="cb134-2"><a href="#cb134-2"></a><span class="ot">  ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)       <span class="co">-- ^ パースした入力に行うチェック</span></span>
<span id="cb134-3"><a href="#cb134-3"></a>  <span class="ot">-&gt;</span> <span class="dt">String</span>            <span class="co">-- ^ チェックが失敗したときに表示するメッセージ</span></span>
<span id="cb134-4"><a href="#cb134-4"></a>  <span class="ot">-&gt;</span> <span class="dt">Parser</span> a          <span class="co">-- ^ 実行するパーサ</span></span>
<span id="cb134-5"><a href="#cb134-5"></a>  <span class="ot">-&gt;</span> <span class="dt">Parser</span> a          <span class="co">-- ^ チェックを実行するパーサを返す</span></span>
<span id="cb134-6"><a href="#cb134-6"></a>withPredicate3 f msg p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb134-7"><a href="#cb134-7"></a>  o <span class="ot">&lt;-</span> getOffset</span>
<span id="cb134-8"><a href="#cb134-8"></a>  r <span class="ot">&lt;-</span> p</span>
<span id="cb134-9"><a href="#cb134-9"></a>  <span class="kw">if</span> f r</span>
<span id="cb134-10"><a href="#cb134-10"></a>    <span class="kw">then</span> <span class="fu">return</span> r</span>
<span id="cb134-11"><a href="#cb134-11"></a>    <span class="kw">else</span> region (setErrorOffset o) (<span class="fu">fail</span> msg)</span>
<span id="cb134-12"><a href="#cb134-12"></a></span>
<span id="cb134-13"><a href="#cb134-13"></a>withPredicate4</span>
<span id="cb134-14"><a href="#cb134-14"></a><span class="ot">  ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)       <span class="co">-- ^ パースした入力に行うチェック</span></span>
<span id="cb134-15"><a href="#cb134-15"></a>  <span class="ot">-&gt;</span> <span class="dt">String</span>            <span class="co">-- ^ チェックが失敗したときに表示するメッセージ</span></span>
<span id="cb134-16"><a href="#cb134-16"></a>  <span class="ot">-&gt;</span> <span class="dt">Parser</span> a          <span class="co">-- ^ 実行するパーサ</span></span>
<span id="cb134-17"><a href="#cb134-17"></a>  <span class="ot">-&gt;</span> <span class="dt">Parser</span> a          <span class="co">-- ^ チェックを実行するパーサを返す</span></span>
<span id="cb134-18"><a href="#cb134-18"></a>withPredicate4 f msg p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb134-19"><a href="#cb134-19"></a>  o <span class="ot">&lt;-</span> getOffset</span>
<span id="cb134-20"><a href="#cb134-20"></a>  r <span class="ot">&lt;-</span> p</span>
<span id="cb134-21"><a href="#cb134-21"></a>  <span class="kw">if</span> f r</span>
<span id="cb134-22"><a href="#cb134-22"></a>    <span class="kw">then</span> <span class="fu">return</span> r</span>
<span id="cb134-23"><a href="#cb134-23"></a>    <span class="kw">else</span> parseError (<span class="dt">FancyError</span> o (Set.singleton (<span class="dt">ErrorFail</span> msg)))</span></code></pre></div>
<p><a name="Multi"></a></p>
<h3 id="複数のパースエラーを報告する">複数のパースエラーを報告する</h3>
<p>最終的に、<code>megaparsec</code>は1回の実行で複数のパースエラーを通知できます。 これによって複数の問題を一度に修正できるため、 パーサをより少ない回数で実行する必要のある エンドユーザにとって役立つ場合があります。</p>
<p>マルチエラーパーサを使用するための前提条件の1つは、 入力の問題のある部分をスキップして、 正常であることがわかっている位置からパースを再開できることです。 この部分は、<code>withRecovery</code>プリミティブを使用して実現されます。</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb135-1"><a href="#cb135-1"></a><span class="co">-- | @'withRecovery' r p@ は、パーサ @p@ が失敗した場合でもパースを続行できます。</span></span>
<span id="cb135-2"><a href="#cb135-2"></a><span class="co">-- この場合、実際の 'ParseError' を引数とする @r@ が呼び出されます。</span></span>
<span id="cb135-3"><a href="#cb135-3"></a><span class="co">-- よくある使い方として、特定のオブジェクトのパースの失敗を意味する値を返すことで、</span></span>
<span id="cb135-4"><a href="#cb135-4"></a><span class="co">-- その入力の一部を消費し次のオブジェクトの開始位置に移動します。</span></span>
<span id="cb135-5"><a href="#cb135-5"></a><span class="co">--</span></span>
<span id="cb135-6"><a href="#cb135-6"></a><span class="co">-- @r@ が失敗すると、元のエラーメッセージが 'withRecovery' なしで報告されることに注意してください。</span></span>
<span id="cb135-7"><a href="#cb135-7"></a><span class="co">-- パーサ @r@ を回復してもエラーメッセージに影響することはありません。</span></span>
<span id="cb135-8"><a href="#cb135-8"></a></span>
<span id="cb135-9"><a href="#cb135-9"></a></span>
<span id="cb135-10"><a href="#cb135-10"></a>withRecovery</span>
<span id="cb135-11"><a href="#cb135-11"></a><span class="ot">  ::</span> (<span class="dt">ParseError</span> s e <span class="ot">-&gt;</span> m a) <span class="co">-- ^ 失敗の回復方法</span></span>
<span id="cb135-12"><a href="#cb135-12"></a>  <span class="ot">-&gt;</span> m a             <span class="co">-- ^ オリジナルのパーサ</span></span>
<span id="cb135-13"><a href="#cb135-13"></a>  <span class="ot">-&gt;</span> m a             <span class="co">-- ^ 失敗から回復できるパーサ</span></span></code></pre></div>
<p>Megaparsec 8 より前のユーザは、成功と失敗の可能性を含む直和型になるように型<code>a</code>を選択する必要がありました。 たとえば、<code>Either (ParseError s e) Result</code> です。 パースエラーを収集し、後で表示する前に手動で<code>ParseErrorBundle</code>に追加する必要がありました。 言うまでもなく、これらはすべて、ユーザフレンドリーではない高度な使用例です。</p>
<p>Megaparsec 8 は、遅延パースエラーをサポートします。</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb136-1"><a href="#cb136-1"></a><span class="co">-- | 後で報告するために 'ParseError'を登録します。</span></span>
<span id="cb136-2"><a href="#cb136-2"></a><span class="co">-- このアクションはパースを終了せず、パースの最後に考慮される</span></span>
<span id="cb136-3"><a href="#cb136-3"></a><span class="co">-- 「遅延」'ParseError'のコレクションに与えられた「ParseError」を</span></span>
<span id="cb136-4"><a href="#cb136-4"></a><span class="co">-- 追加するだけです。 このコレクションが空の場合のみ、</span></span>
<span id="cb136-5"><a href="#cb136-5"></a><span class="co">-- パーサは成功します。 これは、複数のパースエラーを一度に報告する</span></span>
<span id="cb136-6"><a href="#cb136-6"></a><span class="co">-- 主な方法です。</span></span>
<span id="cb136-7"><a href="#cb136-7"></a></span>
<span id="cb136-8"><a href="#cb136-8"></a><span class="ot">registerParseError ::</span> <span class="dt">MonadParsec</span> e s m <span class="ot">=&gt;</span> <span class="dt">ParseError</span> s e <span class="ot">-&gt;</span> m ()</span>
<span id="cb136-9"><a href="#cb136-9"></a></span>
<span id="cb136-10"><a href="#cb136-10"></a><span class="co">-- | 'failure'に似ていますが、 遅延'ParseError'のためのものです。</span></span>
<span id="cb136-11"><a href="#cb136-11"></a></span>
<span id="cb136-12"><a href="#cb136-12"></a>registerFailure</span>
<span id="cb136-13"><a href="#cb136-13"></a><span class="ot">  ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb136-14"><a href="#cb136-14"></a>  <span class="ot">=&gt;</span> <span class="dt">Maybe</span> (<span class="dt">ErrorItem</span> (<span class="dt">Token</span> s)) <span class="co">-- ^ 期待しないアイテム (あれば)</span></span>
<span id="cb136-15"><a href="#cb136-15"></a>  <span class="ot">-&gt;</span> <span class="dt">Set</span> (<span class="dt">ErrorItem</span> (<span class="dt">Token</span> s)) <span class="co">-- ^ 期待するアイテム</span></span>
<span id="cb136-16"><a href="#cb136-16"></a>  <span class="ot">-&gt;</span> m ()</span>
<span id="cb136-17"><a href="#cb136-17"></a></span>
<span id="cb136-18"><a href="#cb136-18"></a><span class="co">-- | 'fancyFailure'に似ていますが、 遅延'ParseError'のためのものです。</span></span>
<span id="cb136-19"><a href="#cb136-19"></a></span>
<span id="cb136-20"><a href="#cb136-20"></a>registerFancyFailure</span>
<span id="cb136-21"><a href="#cb136-21"></a><span class="ot">  ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb136-22"><a href="#cb136-22"></a>  <span class="ot">=&gt;</span> <span class="dt">Set</span> (<span class="dt">ErrorFancy</span> e) <span class="co">-- ^ Fancy error components</span></span>
<span id="cb136-23"><a href="#cb136-23"></a>  <span class="ot">-&gt;</span> m ()</span></code></pre></div>
<p>これらのエラーは <code>withRecovery</code> のエラー処理コールバックに登録でき、結果の型は <code>Maybe Result</code> になります。 これにより、遅延エラーが最終的な <code>ParseErrorBundle</code> に含まれるようになり、遅延エラーのコレクションが空でない場合に パーサが最終的に失敗するようになります。</p>
<p>以上のことから、マルチエラーパーサを書く習慣がユーザ間でより一般的になることを願っています。</p>
<p><a name="Testing"></a></p>
<h2 id="megaparsec-パーサのテスト">Megaparsec パーサのテスト</h2>
<p>パーサのテストは、ほとんどの人が遅かれ早かれ直面する実践的なタスクであり、 それをカバーしなければなりません。 <code>megaparsec</code> のパーサをテストするための推奨される方法は <a href="https://hackage.haskell.org/package/hspec-megaparsec"><code>hspec-megaparsec</code></a>パッケージを使うことです。 このパッケージは、<code>hspec</code> テストフレームワークで動作する <code>shouldParse</code>、 <code>parseSatisfies</code> などのユーティリティテスト関数のを追加します。</p>
<p>次の例から見てみましょう。</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb137-1"><a href="#cb137-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb137-2"><a href="#cb137-2"></a></span>
<span id="cb137-3"><a href="#cb137-3"></a><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></span>
<span id="cb137-4"><a href="#cb137-4"></a></span>
<span id="cb137-5"><a href="#cb137-5"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb137-6"><a href="#cb137-6"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb137-7"><a href="#cb137-7"></a><span class="kw">import</span> <span class="dt">Data.Void</span></span>
<span id="cb137-8"><a href="#cb137-8"></a><span class="kw">import</span> <span class="dt">Test.Hspec</span></span>
<span id="cb137-9"><a href="#cb137-9"></a><span class="kw">import</span> <span class="dt">Test.Hspec.Megaparsec</span></span>
<span id="cb137-10"><a href="#cb137-10"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span></span>
<span id="cb137-11"><a href="#cb137-11"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec.Char</span></span>
<span id="cb137-12"><a href="#cb137-12"></a></span>
<span id="cb137-13"><a href="#cb137-13"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Void</span> <span class="dt">Text</span></span>
<span id="cb137-14"><a href="#cb137-14"></a></span>
<span id="cb137-15"><a href="#cb137-15"></a><span class="ot">myParser ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb137-16"><a href="#cb137-16"></a>myParser <span class="ot">=</span> some (char <span class="ch">'a'</span>)</span>
<span id="cb137-17"><a href="#cb137-17"></a></span>
<span id="cb137-18"><a href="#cb137-18"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb137-19"><a href="#cb137-19"></a>main <span class="ot">=</span> hspec <span class="op">$</span></span>
<span id="cb137-20"><a href="#cb137-20"></a>  describe <span class="st">&quot;myParser&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb137-21"><a href="#cb137-21"></a>    it <span class="st">&quot;returns correct result&quot;</span> <span class="op">$</span></span>
<span id="cb137-22"><a href="#cb137-22"></a>      parse myParser <span class="st">&quot;&quot;</span> <span class="st">&quot;aaa&quot;</span> <span class="ot">`shouldParse`</span> <span class="st">&quot;aaa&quot;</span></span>
<span id="cb137-23"><a href="#cb137-23"></a>    it <span class="st">&quot;result of parsing satisfies what it should&quot;</span> <span class="op">$</span></span>
<span id="cb137-24"><a href="#cb137-24"></a>      parse myParser <span class="st">&quot;&quot;</span> <span class="st">&quot;aaaa&quot;</span> <span class="ot">`parseSatisfies`</span> ((<span class="op">==</span> <span class="dv">4</span>) <span class="op">.</span> <span class="fu">length</span>)</span></code></pre></div>
<p><code>shouldParse</code> は、パース結果 <code>Either（ParseErrorBundle s e）a</code> と比較する型 <code>a</code> の値を引数として受け取ります。 おそらく最も一般的なヘルパーです。 <code>parseSatisfies</code> は非常に似ていますが、期待される結果と等しいかどうかを比較する代わりに、任意の述語を適用することによって結果をチェックすることができます。</p>
<p>その他の単純なテスト関数は、 <code>shouldSucceedOn</code> と <code>shouldFailOn</code> です（これらはめったに使われません）。</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb138-1"><a href="#cb138-1"></a>    it <span class="st">&quot;should parse 'a's all right&quot;</span> <span class="op">$</span></span>
<span id="cb138-2"><a href="#cb138-2"></a>      parse myParser <span class="st">&quot;&quot;</span> <span class="ot">`shouldSucceedOn`</span> <span class="st">&quot;aaaa&quot;</span></span>
<span id="cb138-3"><a href="#cb138-3"></a>    it <span class="st">&quot;should fail on 'b's&quot;</span> <span class="op">$</span></span>
<span id="cb138-4"><a href="#cb138-4"></a>      parse myParser <span class="st">&quot;&quot;</span> <span class="ot">`shouldFailOn`</span> <span class="st">&quot;bbb&quot;</span></span></code></pre></div>
<p><code>megaparsec</code> で、パーサが生み出すパースエラーを詳細にテストしたいです。 パースエラーをテストするには <code>shouldFailWith</code> があります。 これは次のように使用できます。</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb139-1"><a href="#cb139-1"></a>    it <span class="st">&quot;fails on 'b's producing correct error message&quot;</span> <span class="op">$</span></span>
<span id="cb139-2"><a href="#cb139-2"></a>      parse myParser <span class="st">&quot;&quot;</span> <span class="st">&quot;bbb&quot;</span> <span class="ot">`shouldFailWith`</span></span>
<span id="cb139-3"><a href="#cb139-3"></a>        <span class="dt">TrivialError</span></span>
<span id="cb139-4"><a href="#cb139-4"></a>          <span class="dv">0</span></span>
<span id="cb139-5"><a href="#cb139-5"></a>          (<span class="dt">Just</span> (<span class="dt">Tokens</span> (<span class="ch">'b'</span> <span class="op">:|</span> [])))</span>
<span id="cb139-6"><a href="#cb139-6"></a>          (Set.singleton (<span class="dt">Tokens</span> (<span class="ch">'a'</span> <span class="op">:|</span> [])))</span></code></pre></div>
<p>このように <code>TrivialError</code> を書き出すのは面倒です。 <code>ParseError</code> の定義には、<code>Set</code> や <code>NonEmpty</code> のような 「不便な」型が含まれています。これらは、 今見たとおり直接入力するのには便利ではありません。 幸い、<code>Test.Hspec.Megaparsec</code> は、 <code>ParserErrors</code>をより簡単に構築するためのAPIを提供する <code>Text.Megaparsec.Error.Builder</code> モジュールも再エクスポートします。 代わりに <code>err</code> ヘルパーを使用しましょう。</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb140-1"><a href="#cb140-1"></a>    it <span class="st">&quot;fails on 'b's producing correct error message&quot;</span> <span class="op">$</span></span>
<span id="cb140-2"><a href="#cb140-2"></a>      parse myParser <span class="st">&quot;&quot;</span> <span class="st">&quot;bbb&quot;</span> <span class="ot">`shouldFailWith`</span> err <span class="dv">0</span> (utok <span class="ch">'b'</span> <span class="op">&lt;&gt;</span> etok <span class="ch">'a'</span>)</span></code></pre></div>
<ul>
<li><p><code>err</code> の最初の引数は、パースエラーのオフセット（エラーが発生する前に消費されたトークンの数）です。今回はそれは単に0です。</p></li>
<li><p><code>utok</code> は「期待しないトークン」を表し、同様に <code>etok</code> は「期待するトークン」を意味します。</p></li>
</ul>
<p>演習: ファンシーパースエラーを構築するために、<code>errFancy</code> と呼ばれる同様のヘルパーがありますので、それをよく理解してください。</p>
<p>最後に、<code>failsLeaving</code> と <code>succeedsLeaving</code> を使用して、 パース後に入力のどの部分が未消費のままであるかをテストすることができます。</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb141-1"><a href="#cb141-1"></a>    it <span class="st">&quot;consumes all 'a's but does not touch 'b's&quot;</span> <span class="op">$</span></span>
<span id="cb141-2"><a href="#cb141-2"></a>      runParser' myParser (initialState <span class="st">&quot;aaabbb&quot;</span>) <span class="ot">`succeedsLeaving`</span> <span class="st">&quot;bbb&quot;</span></span>
<span id="cb141-3"><a href="#cb141-3"></a>    it <span class="st">&quot;fails without consuming anything&quot;</span> <span class="op">$</span></span>
<span id="cb141-4"><a href="#cb141-4"></a>      runParser' myParser (initialState <span class="st">&quot;bbbccc&quot;</span>) <span class="ot">`failsLeaving`</span> <span class="st">&quot;bbbccc&quot;</span></span></code></pre></div>
<p>これらは、パーサのカスタム初期状態を受け取り、 その最終状態を返す <code>runParser'</code> または <code>runParserT'</code> と共に 使用する必要があります（これにより、 パース後に入力ストリームの残りをチェックすることができます）。</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb142-1"><a href="#cb142-1"></a>runParser'</span>
<span id="cb142-2"><a href="#cb142-2"></a><span class="ot">  ::</span> <span class="dt">Parsec</span> e s a      <span class="co">-- ^ Parser to run</span></span>
<span id="cb142-3"><a href="#cb142-3"></a>  <span class="ot">-&gt;</span> <span class="dt">State</span> s           <span class="co">-- ^ Initial state</span></span>
<span id="cb142-4"><a href="#cb142-4"></a>  <span class="ot">-&gt;</span> (<span class="dt">State</span> s, <span class="dt">Either</span> (<span class="dt">ParseError</span> (<span class="dt">Token</span> s) e) a)</span>
<span id="cb142-5"><a href="#cb142-5"></a></span>
<span id="cb142-6"><a href="#cb142-6"></a><span class="ot">runParserT' ::</span> <span class="dt">Monad</span> m</span>
<span id="cb142-7"><a href="#cb142-7"></a>  <span class="ot">=&gt;</span> <span class="dt">ParsecT</span> e s m a   <span class="co">-- ^ Parser to run</span></span>
<span id="cb142-8"><a href="#cb142-8"></a>  <span class="ot">-&gt;</span> <span class="dt">State</span> s           <span class="co">-- ^ Initial state</span></span>
<span id="cb142-9"><a href="#cb142-9"></a>  <span class="ot">-&gt;</span> m (<span class="dt">State</span> s, <span class="dt">Either</span> (<span class="dt">ParseError</span> (<span class="dt">Token</span> s) e) a)</span></code></pre></div>
<p><code>initialState</code> 関数は入力ストリームを受け取り、 その入力ストリームとデフォルト値で埋められた レコードフィールドの初期状態を返します。</p>
<p><code>hspec-megaparsec</code> を使用するためのその他のヒントは次のとおりです。</p>
<ul>
<li><p><a href="https://github.com/mrkkrp/megaparsec/tree/master/megaparsec-tests">Megaparsec自身のテスト</a> はhspec-megaparsecを使って書かれています。</p></li>
<li><p><code>hspec-megaparsec</code> 自体に付属している<a href="https://github.com/mrkkrp/hspec-megaparsec/blob/master/tests/Main.hs">トイテストスイート</a>。</p></li>
</ul>
<p><a name="CustomInput"></a></p>
<h2 id="カスタム入力ストリームの操作">カスタム入力ストリームの操作</h2>
<p><code>megaparsec</code> は、 <code>Stream</code> 型クラスのインスタンスである入力をパースできます。 これは、<code>alex</code>などの字句解析ツールと組み合わせて使用できることを 意味します。</p>
<p>主題から離れないようにするため、 <code>alex</code> がどのようにしてトークンのストリーム生成するのかは説明しません。 また、次の形式を想定します。</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb143-1"><a href="#cb143-1"></a><span class="ot">{-# LANGUAGE LambdaCase        #-}</span></span>
<span id="cb143-2"><a href="#cb143-2"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb143-3"><a href="#cb143-3"></a><span class="ot">{-# LANGUAGE RecoedWildCards   #-}</span></span>
<span id="cb143-4"><a href="#cb143-4"></a><span class="ot">{-# LANGUAGE TypeFamilies      #-}</span></span>
<span id="cb143-5"><a href="#cb143-5"></a></span>
<span id="cb143-6"><a href="#cb143-6"></a><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></span>
<span id="cb143-7"><a href="#cb143-7"></a></span>
<span id="cb143-8"><a href="#cb143-8"></a><span class="kw">import</span> <span class="dt">Data.List.NonEmpty</span> (<span class="dt">NonEmpty</span> (..))</span>
<span id="cb143-9"><a href="#cb143-9"></a><span class="kw">import</span> <span class="dt">Data.Proxy</span></span>
<span id="cb143-10"><a href="#cb143-10"></a><span class="kw">import</span> <span class="dt">Data.Void</span></span>
<span id="cb143-11"><a href="#cb143-11"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span></span>
<span id="cb143-12"><a href="#cb143-12"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.List</span>          <span class="kw">as</span> <span class="dt">DL</span></span>
<span id="cb143-13"><a href="#cb143-13"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.List.NonEmpty</span> <span class="kw">as</span> <span class="dt">NE</span></span>
<span id="cb143-14"><a href="#cb143-14"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span>           <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb143-15"><a href="#cb143-15"></a></span>
<span id="cb143-16"><a href="#cb143-16"></a><span class="kw">data</span> <span class="dt">MyToken</span></span>
<span id="cb143-17"><a href="#cb143-17"></a>  <span class="ot">=</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb143-18"><a href="#cb143-18"></a>  <span class="op">|</span> <span class="dt">Plus</span></span>
<span id="cb143-19"><a href="#cb143-19"></a>  <span class="op">|</span> <span class="dt">Mul</span></span>
<span id="cb143-20"><a href="#cb143-20"></a>  <span class="op">|</span> <span class="dt">Div</span></span>
<span id="cb143-21"><a href="#cb143-21"></a>  <span class="op">|</span> <span class="dt">OpenParen</span></span>
<span id="cb143-22"><a href="#cb143-22"></a>  <span class="op">|</span> <span class="dt">CloseParen</span></span>
<span id="cb143-23"><a href="#cb143-23"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p>パースエラーを報告するために、 トークンの開始位置、終了位置、長さを知る方法が必要なので、 <code>WithPos</code> を追加しましょう。</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb144-1"><a href="#cb144-1"></a><span class="kw">data</span> <span class="dt">WithPos</span> a <span class="ot">=</span> <span class="dt">WithPos</span></span>
<span id="cb144-2"><a href="#cb144-2"></a>  {<span class="ot"> startPos ::</span> <span class="dt">SourcePos</span></span>
<span id="cb144-3"><a href="#cb144-3"></a>  ,<span class="ot"> endPos ::</span> <span class="dt">SourcePos</span></span>
<span id="cb144-4"><a href="#cb144-4"></a>  ,<span class="ot"> tokenLength ::</span> <span class="dt">Int</span></span>
<span id="cb144-5"><a href="#cb144-5"></a>  ,<span class="ot"> tokenVal ::</span> a</span>
<span id="cb144-6"><a href="#cb144-6"></a>  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p>これでストリームのデータ型ができます。</p>
<div class="sourceCode" id="cb145"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb145-1"><a href="#cb145-1"></a><span class="kw">newtype</span> <span class="dt">MyStream</span> <span class="ot">=</span> <span class="dt">MyStream</span></span>
<span id="cb145-2"><a href="#cb145-2"></a>  {<span class="ot"> myStreamInput ::</span> <span class="dt">String</span> <span class="co">-- 問題のある行を表示するため</span></span>
<span id="cb145-3"><a href="#cb145-3"></a>  ,<span class="ot"> unMyStream ::</span> [<span class="dt">WithPos</span> <span class="dt">MyToken</span>]</span>
<span id="cb145-4"><a href="#cb145-4"></a>  }</span></code></pre></div>
<p>次に、<code>MyStream</code> を <code>Stream</code> 型クラスのインスタンスにする必要があります。 関連型関数 <code>Token</code> と <code>Tokens</code> を定義したいので、 <code>TypeFamilies</code> の言語拡張が必要です。</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb146-1"><a href="#cb146-1"></a><span class="kw">instance</span> <span class="dt">Stream</span> <span class="dt">MyStream</span> <span class="kw">where</span></span>
<span id="cb146-2"><a href="#cb146-2"></a>  <span class="kw">type</span> <span class="dt">Token</span>  <span class="dt">MyStream</span> <span class="ot">=</span> <span class="dt">WithPos</span> <span class="dt">MyToken</span></span>
<span id="cb146-3"><a href="#cb146-3"></a>  <span class="kw">type</span> <span class="dt">Tokens</span> <span class="dt">MyStream</span> <span class="ot">=</span> [<span class="dt">WithPos</span> <span class="dt">MyToken</span>]</span>
<span id="cb146-4"><a href="#cb146-4"></a>  <span class="co">-- …</span></span></code></pre></div>
<p><code>Stream</code> は <code>Text.Megaparsec.Stream</code> モジュールに 詳しいドキュメントがあります。 足りないメソッドを定義していきましょう。</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb147-1"><a href="#cb147-1"></a>  <span class="co">-- …</span></span>
<span id="cb147-2"><a href="#cb147-2"></a>  tokenToChunk <span class="dt">Proxy</span> x <span class="ot">=</span> [x]</span>
<span id="cb147-3"><a href="#cb147-3"></a>  tokensToChunk <span class="dt">Proxy</span> xs <span class="ot">=</span> xs</span>
<span id="cb147-4"><a href="#cb147-4"></a>  chunkToTokens <span class="dt">Proxy</span> <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb147-5"><a href="#cb147-5"></a>  chunkLength <span class="dt">Proxy</span> <span class="ot">=</span> <span class="fu">length</span></span>
<span id="cb147-6"><a href="#cb147-6"></a>  chunkEmpty <span class="dt">Proxy</span> <span class="ot">=</span> <span class="fu">null</span></span>
<span id="cb147-7"><a href="#cb147-7"></a>  take1_ (<span class="dt">MyStream</span> _ []) <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb147-8"><a href="#cb147-8"></a>  take1_ (<span class="dt">MyStream</span> str (t<span class="op">:</span>ts)) <span class="ot">=</span> <span class="dt">Just</span></span>
<span id="cb147-9"><a href="#cb147-9"></a>    ( t</span>
<span id="cb147-10"><a href="#cb147-10"></a>    , <span class="dt">MyStream</span> (<span class="fu">drop</span> (tokensLength pxy (t<span class="op">:|</span>[])) str) ts</span>
<span id="cb147-11"><a href="#cb147-11"></a>    )</span>
<span id="cb147-12"><a href="#cb147-12"></a>  takeN_ n (<span class="dt">MyStream</span> str s)</span>
<span id="cb147-13"><a href="#cb147-13"></a>    <span class="op">|</span> n <span class="op">&lt;=</span> <span class="dv">0</span>    <span class="ot">=</span> <span class="dt">Just</span> ([], <span class="dt">MyStream</span> str s)</span>
<span id="cb147-14"><a href="#cb147-14"></a>    <span class="op">|</span> <span class="fu">null</span> s    <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb147-15"><a href="#cb147-15"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span></span>
<span id="cb147-16"><a href="#cb147-16"></a>        <span class="kw">let</span> (x, s') <span class="ot">=</span> <span class="fu">splitAt</span> n s</span>
<span id="cb147-17"><a href="#cb147-17"></a>        <span class="kw">in</span> <span class="kw">case</span> NE.nonEmpty x <span class="kw">of</span></span>
<span id="cb147-18"><a href="#cb147-18"></a>          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> (x, <span class="dt">MyStream</span> str s')</span>
<span id="cb147-19"><a href="#cb147-19"></a>          <span class="dt">Just</span> nex <span class="ot">-&gt;</span> <span class="dt">Just</span> (x, <span class="dt">MyStream</span> (<span class="fu">drop</span> (tokensLength pxy nex) str) s')</span>
<span id="cb147-20"><a href="#cb147-20"></a>  takeWhile_ f (<span class="dt">MyStream</span> str s) <span class="ot">=</span></span>
<span id="cb147-21"><a href="#cb147-21"></a>    <span class="kw">let</span> (x, s') <span class="ot">=</span> DL.span f s</span>
<span id="cb147-22"><a href="#cb147-22"></a>    <span class="kw">in</span> <span class="kw">case</span> NE.nonEmpty x <span class="kw">of</span></span>
<span id="cb147-23"><a href="#cb147-23"></a>      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> (x, <span class="dt">MyStream</span> str s')</span>
<span id="cb147-24"><a href="#cb147-24"></a>      <span class="dt">Just</span> nex <span class="ot">-&gt;</span> (x, <span class="dt">MyStream</span> (<span class="fu">drop</span> (tokensLength pxy nex) str) s')</span>
<span id="cb147-25"><a href="#cb147-25"></a>  showTokens <span class="dt">Proxy</span> <span class="ot">=</span> DL.intercalate <span class="st">&quot; &quot;</span></span>
<span id="cb147-26"><a href="#cb147-26"></a>    <span class="op">.</span> NE.toList</span>
<span id="cb147-27"><a href="#cb147-27"></a>    <span class="op">.</span> <span class="fu">fmap</span> (showMyToken <span class="op">.</span> tokenVal)</span>
<span id="cb147-28"><a href="#cb147-28"></a>  tokensLength <span class="dt">Proxy</span> xs <span class="ot">=</span> <span class="fu">sum</span> (tokenLength <span class="op">&lt;$&gt;</span> xs)</span>
<span id="cb147-29"><a href="#cb147-29"></a>  reachOffset o <span class="dt">PosState</span> {<span class="op">..</span>} <span class="ot">=</span></span>
<span id="cb147-30"><a href="#cb147-30"></a>    ( prefix <span class="op">++</span> restOfLine</span>
<span id="cb147-31"><a href="#cb147-31"></a>    , <span class="dt">PosState</span></span>
<span id="cb147-32"><a href="#cb147-32"></a>        { pstateInput <span class="ot">=</span> <span class="dt">MyStream</span></span>
<span id="cb147-33"><a href="#cb147-33"></a>            { myStreamInput <span class="ot">=</span> postStr</span>
<span id="cb147-34"><a href="#cb147-34"></a>            , unMyStream <span class="ot">=</span> post</span>
<span id="cb147-35"><a href="#cb147-35"></a>            }</span>
<span id="cb147-36"><a href="#cb147-36"></a>        , pstateOffset <span class="ot">=</span> <span class="fu">max</span> pstateOffset o</span>
<span id="cb147-37"><a href="#cb147-37"></a>        , pstateSourcePos <span class="ot">=</span> newSourcePos</span>
<span id="cb147-38"><a href="#cb147-38"></a>        , pstateTabWidth <span class="ot">=</span> pstateTabWidth</span>
<span id="cb147-39"><a href="#cb147-39"></a>        , pstateLinePrefix <span class="ot">=</span> prefix</span>
<span id="cb147-40"><a href="#cb147-40"></a>        }</span>
<span id="cb147-41"><a href="#cb147-41"></a>    )</span>
<span id="cb147-42"><a href="#cb147-42"></a>    <span class="kw">where</span></span>
<span id="cb147-43"><a href="#cb147-43"></a>      prefix <span class="ot">=</span></span>
<span id="cb147-44"><a href="#cb147-44"></a>        <span class="kw">if</span> sameLine</span>
<span id="cb147-45"><a href="#cb147-45"></a>          <span class="kw">then</span> pstateLinePrefix <span class="op">++</span> preStr</span>
<span id="cb147-46"><a href="#cb147-46"></a>          <span class="kw">else</span> preStr</span>
<span id="cb147-47"><a href="#cb147-47"></a>      sameLine <span class="ot">=</span> sourceLine newSourcePos <span class="op">==</span> sourceLine pstateSourcePos</span>
<span id="cb147-48"><a href="#cb147-48"></a>      newSourcePos <span class="ot">=</span></span>
<span id="cb147-49"><a href="#cb147-49"></a>        <span class="kw">case</span> post <span class="kw">of</span></span>
<span id="cb147-50"><a href="#cb147-50"></a>          [] <span class="ot">-&gt;</span> pstateSourcePos</span>
<span id="cb147-51"><a href="#cb147-51"></a>          (x<span class="op">:</span>_) <span class="ot">-&gt;</span> startPos x</span>
<span id="cb147-52"><a href="#cb147-52"></a>      (pre, post) <span class="ot">=</span> <span class="fu">splitAt</span> (o <span class="op">-</span> pstateOffset) (unMyStream pstateInput)</span>
<span id="cb147-53"><a href="#cb147-53"></a>      (preStr, postStr) <span class="ot">=</span> <span class="fu">splitAt</span> tokensConsumed (myStreamInput pstateInput)</span>
<span id="cb147-54"><a href="#cb147-54"></a>      tokensConsumed <span class="ot">=</span></span>
<span id="cb147-55"><a href="#cb147-55"></a>        <span class="kw">case</span> NE.nonEmpty pre <span class="kw">of</span></span>
<span id="cb147-56"><a href="#cb147-56"></a>          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dv">0</span></span>
<span id="cb147-57"><a href="#cb147-57"></a>          <span class="dt">Just</span> nePre <span class="ot">-&gt;</span> tokensLength pxy nePre</span>
<span id="cb147-58"><a href="#cb147-58"></a>      restOfLine <span class="ot">=</span> <span class="fu">takeWhile</span> (<span class="op">/=</span> <span class="ch">'\n'</span>) postStr</span>
<span id="cb147-59"><a href="#cb147-59"></a></span>
<span id="cb147-60"><a href="#cb147-60"></a><span class="ot">pxy ::</span> <span class="dt">Proxy</span> <span class="dt">MyStream</span></span>
<span id="cb147-61"><a href="#cb147-61"></a>pxy <span class="ot">=</span> <span class="dt">Proxy</span></span>
<span id="cb147-62"><a href="#cb147-62"></a></span>
<span id="cb147-63"><a href="#cb147-63"></a><span class="ot">showMyToken ::</span> <span class="dt">MyToken</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb147-64"><a href="#cb147-64"></a>showMyToken <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb147-65"><a href="#cb147-65"></a>  (<span class="dt">Int</span> n)    <span class="ot">-&gt;</span> <span class="fu">show</span> n</span>
<span id="cb147-66"><a href="#cb147-66"></a>  <span class="dt">Plus</span>       <span class="ot">-&gt;</span> <span class="st">&quot;+&quot;</span></span>
<span id="cb147-67"><a href="#cb147-67"></a>  <span class="dt">Mul</span>        <span class="ot">-&gt;</span> <span class="st">&quot;*&quot;</span></span>
<span id="cb147-68"><a href="#cb147-68"></a>  <span class="dt">Div</span>        <span class="ot">-&gt;</span> <span class="st">&quot;/&quot;</span></span>
<span id="cb147-69"><a href="#cb147-69"></a>  <span class="dt">OpenParen</span>  <span class="ot">-&gt;</span> <span class="st">&quot;(&quot;</span></span>
<span id="cb147-70"><a href="#cb147-70"></a>  <span class="dt">CloseParen</span> <span class="ot">-&gt;</span> <span class="st">&quot;)&quot;</span></span></code></pre></div>
<p><code>Stream</code> 型クラスに関する詳しい参考資料 (そしてなぜこのようになっているのか)は <a href="https://markkarpov.com/post/megaparsec-more-speed-more-power.html">このブログ記事</a> に書いてあります。</p>
<p>これで <code>Parser</code> 型が定義できます。</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb148-1"><a href="#cb148-1"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Void</span> <span class="dt">MyStream</span></span></code></pre></div>
<p>次のステップは、 <code>token</code> と (意味があるなら)<code>tokens</code> のプリミティブを使って、 基本的なパーサを定義することです。 そのまま使用できるストリームには、 <code>Text.Megaparsec.Byte</code> および <code>Text.Megaparsec.Char</code> モジュールが ありますが、カスタムトークンを使用する場合はカスタムヘルパーが必要です。</p>
<div class="sourceCode" id="cb149"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb149-1"><a href="#cb149-1"></a><span class="ot">liftMyToken ::</span> <span class="dt">MyToken</span> <span class="ot">-&gt;</span> <span class="dt">WithPos</span> <span class="dt">MyToken</span></span>
<span id="cb149-2"><a href="#cb149-2"></a>liftMyToken myToken <span class="ot">=</span> <span class="dt">WithPos</span> pos pos <span class="dv">0</span> myToken</span>
<span id="cb149-3"><a href="#cb149-3"></a>  <span class="kw">where</span></span>
<span id="cb149-4"><a href="#cb149-4"></a>    pos <span class="ot">=</span> initialPos <span class="st">&quot;&quot;</span></span>
<span id="cb149-5"><a href="#cb149-5"></a></span>
<span id="cb149-6"><a href="#cb149-6"></a><span class="ot">pToken ::</span> <span class="dt">MyToken</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">MyToken</span></span>
<span id="cb149-7"><a href="#cb149-7"></a>pToken c <span class="ot">=</span> token test (Set.singleton <span class="op">.</span> <span class="dt">Tokens</span> <span class="op">.</span> nes <span class="op">.</span> liftMyToken <span class="op">$</span> c)</span>
<span id="cb149-8"><a href="#cb149-8"></a>  <span class="kw">where</span></span>
<span id="cb149-9"><a href="#cb149-9"></a>    test (<span class="dt">WithPos</span> _ _ _ x) <span class="ot">=</span></span>
<span id="cb149-10"><a href="#cb149-10"></a>      <span class="kw">if</span> x <span class="op">==</span> c</span>
<span id="cb149-11"><a href="#cb149-11"></a>        <span class="kw">then</span> <span class="dt">Just</span> x</span>
<span id="cb149-12"><a href="#cb149-12"></a>        <span class="kw">else</span> <span class="dt">Nothing</span></span>
<span id="cb149-13"><a href="#cb149-13"></a>    nes x <span class="ot">=</span> x <span class="op">:|</span> []</span>
<span id="cb149-14"><a href="#cb149-14"></a></span>
<span id="cb149-15"><a href="#cb149-15"></a><span class="ot">pInt ::</span> <span class="dt">Parser</span> <span class="dt">Int</span></span>
<span id="cb149-16"><a href="#cb149-16"></a>pInt <span class="ot">=</span> token test Set.empty <span class="op">&lt;?&gt;</span> <span class="st">&quot;integer&quot;</span></span>
<span id="cb149-17"><a href="#cb149-17"></a>  <span class="kw">where</span></span>
<span id="cb149-18"><a href="#cb149-18"></a>    test (<span class="dt">WithPos</span> _ _ _ (<span class="dt">Int</span> n)) <span class="ot">=</span> <span class="dt">Just</span> n</span>
<span id="cb149-19"><a href="#cb149-19"></a>    test _ <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>最後に、足し算をパースするテストパーサを用意しましょう。</p>
<div class="sourceCode" id="cb150"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb150-1"><a href="#cb150-1"></a><span class="ot">pSum ::</span> <span class="dt">Parser</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb150-2"><a href="#cb150-2"></a>pSum <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb150-3"><a href="#cb150-3"></a>  a <span class="ot">&lt;-</span> pInt</span>
<span id="cb150-4"><a href="#cb150-4"></a>  _ <span class="ot">&lt;-</span> pToken <span class="dt">Plus</span></span>
<span id="cb150-5"><a href="#cb150-5"></a>  b <span class="ot">&lt;-</span> pInt</span>
<span id="cb150-6"><a href="#cb150-6"></a>  <span class="fu">return</span> (a, b)</span></code></pre></div>
<p>入力例は次のようにします。</p>
<div class="sourceCode" id="cb151"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb151-1"><a href="#cb151-1"></a><span class="ot">exampleStream ::</span> <span class="dt">MyStream</span></span>
<span id="cb151-2"><a href="#cb151-2"></a>exampleStream <span class="ot">=</span> <span class="dt">MyStream</span></span>
<span id="cb151-3"><a href="#cb151-3"></a>  <span class="st">&quot;5 + 6&quot;</span></span>
<span id="cb151-4"><a href="#cb151-4"></a>  [ at <span class="dv">1</span> <span class="dv">1</span> (<span class="dt">Int</span> <span class="dv">5</span>)</span>
<span id="cb151-5"><a href="#cb151-5"></a>  , at <span class="dv">1</span> <span class="dv">3</span> <span class="dt">Plus</span>         <span class="co">-- (1)</span></span>
<span id="cb151-6"><a href="#cb151-6"></a>  , at <span class="dv">1</span> <span class="dv">5</span> (<span class="dt">Int</span> <span class="dv">6</span>)</span>
<span id="cb151-7"><a href="#cb151-7"></a>  ]</span>
<span id="cb151-8"><a href="#cb151-8"></a>  <span class="kw">where</span></span>
<span id="cb151-9"><a href="#cb151-9"></a>    at  l c <span class="ot">=</span> <span class="dt">WithPos</span> (at' l c) (at' l (c <span class="op">+</span> <span class="dv">1</span>)) <span class="dv">2</span></span>
<span id="cb151-10"><a href="#cb151-10"></a>    at' l c <span class="ot">=</span> <span class="dt">SourcePos</span> <span class="st">&quot;&quot;</span> (mkPos l) (mkPos c)</span></code></pre></div>
<p>試してみましょう。</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb152-1"><a href="#cb152-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pSum <span class="op">&lt;</span>* eof) <span class="ex">exampleStream</span></span>
<span id="cb152-2"><a href="#cb152-2"></a><span class="kw">(</span><span class="ex">5</span>,6<span class="kw">)</span></span></code></pre></div>
<p>行(1)の <code>Plus</code> を <code>Div</code> に変更すると、正しいパースエラーが発生します。</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb153-1"><a href="#cb153-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pSum <span class="op">&lt;</span>* eof) <span class="ex">exampleStream</span></span>
<span id="cb153-2"><a href="#cb153-2"></a><span class="ex">1</span>:3:</span>
<span id="cb153-3"><a href="#cb153-3"></a>  <span class="kw">|</span></span>
<span id="cb153-4"><a href="#cb153-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">5</span> + 6</span>
<span id="cb153-5"><a href="#cb153-5"></a>  <span class="kw">|</span>   ^^</span>
<span id="cb153-6"><a href="#cb153-6"></a><span class="ex">unexpected</span> /</span>
<span id="cb153-7"><a href="#cb153-7"></a><span class="ex">expecting</span> +</span></code></pre></div>
<p>言い換えると、カスタムストリームのパースが可能な 十分に機能するパーサができました。</p>
<h2 id="演習の回答例puri-を完成させる">演習の回答例(<code>pUri</code> を完成させる)</h2>
<div class="sourceCode" id="cb154"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb154-1"><a href="#cb154-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb154-2"><a href="#cb154-2"></a><span class="ot">{-# LANGUAGE RecordWildCards   #-}</span></span>
<span id="cb154-3"><a href="#cb154-3"></a></span>
<span id="cb154-4"><a href="#cb154-4"></a><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></span>
<span id="cb154-5"><a href="#cb154-5"></a></span>
<span id="cb154-6"><a href="#cb154-6"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span> <span class="kw">hiding</span> (some,many)</span>
<span id="cb154-7"><a href="#cb154-7"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb154-8"><a href="#cb154-8"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb154-9"><a href="#cb154-9"></a><span class="kw">import</span> <span class="dt">Data.Void</span></span>
<span id="cb154-10"><a href="#cb154-10"></a><span class="kw">import</span> <span class="dt">Data.Char</span></span>
<span id="cb154-11"><a href="#cb154-11"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span> <span class="kw">hiding</span> (<span class="dt">State</span>)</span>
<span id="cb154-12"><a href="#cb154-12"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec.Char</span></span>
<span id="cb154-13"><a href="#cb154-13"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb154-14"><a href="#cb154-14"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Megaparsec.Char.Lexer</span> <span class="kw">as</span> <span class="dt">L</span></span>
<span id="cb154-15"><a href="#cb154-15"></a></span>
<span id="cb154-16"><a href="#cb154-16"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Void</span> <span class="dt">Text</span></span>
<span id="cb154-17"><a href="#cb154-17"></a></span>
<span id="cb154-18"><a href="#cb154-18"></a><span class="kw">data</span> <span class="dt">Uri</span> <span class="ot">=</span> <span class="dt">Uri</span></span>
<span id="cb154-19"><a href="#cb154-19"></a>  {<span class="ot"> uriScheme    ::</span> <span class="dt">Scheme</span></span>
<span id="cb154-20"><a href="#cb154-20"></a>  ,<span class="ot"> uriAuthority ::</span> <span class="dt">Maybe</span> <span class="dt">Authority</span></span>
<span id="cb154-21"><a href="#cb154-21"></a>  ,<span class="ot"> uriPath      ::</span> [<span class="dt">Text</span>]</span>
<span id="cb154-22"><a href="#cb154-22"></a>  ,<span class="ot"> uriQuery     ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span></span>
<span id="cb154-23"><a href="#cb154-23"></a>  ,<span class="ot"> uriFlagment  ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span></span>
<span id="cb154-24"><a href="#cb154-24"></a>  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb154-25"><a href="#cb154-25"></a></span>
<span id="cb154-26"><a href="#cb154-26"></a><span class="kw">data</span> <span class="dt">Scheme</span></span>
<span id="cb154-27"><a href="#cb154-27"></a>  <span class="ot">=</span> <span class="dt">SchemeData</span></span>
<span id="cb154-28"><a href="#cb154-28"></a>  <span class="op">|</span> <span class="dt">SchemeFile</span></span>
<span id="cb154-29"><a href="#cb154-29"></a>  <span class="op">|</span> <span class="dt">SchemeFtp</span></span>
<span id="cb154-30"><a href="#cb154-30"></a>  <span class="op">|</span> <span class="dt">SchemeHttp</span></span>
<span id="cb154-31"><a href="#cb154-31"></a>  <span class="op">|</span> <span class="dt">SchemeHttps</span></span>
<span id="cb154-32"><a href="#cb154-32"></a>  <span class="op">|</span> <span class="dt">SchemeIrc</span></span>
<span id="cb154-33"><a href="#cb154-33"></a>  <span class="op">|</span> <span class="dt">SchemeMailto</span></span>
<span id="cb154-34"><a href="#cb154-34"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb154-35"><a href="#cb154-35"></a></span>
<span id="cb154-36"><a href="#cb154-36"></a><span class="kw">data</span> <span class="dt">Authority</span> <span class="ot">=</span> <span class="dt">Authority</span></span>
<span id="cb154-37"><a href="#cb154-37"></a>  {<span class="ot"> authUser ::</span> <span class="dt">Maybe</span> (<span class="dt">Text</span>, <span class="dt">Text</span>) <span class="co">-- (user, password)</span></span>
<span id="cb154-38"><a href="#cb154-38"></a>  ,<span class="ot"> authHost ::</span> <span class="dt">Text</span></span>
<span id="cb154-39"><a href="#cb154-39"></a>  ,<span class="ot"> authPort ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb154-40"><a href="#cb154-40"></a>  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb154-41"><a href="#cb154-41"></a></span>
<span id="cb154-42"><a href="#cb154-42"></a><span class="ot">pScheme ::</span> <span class="dt">Parser</span> <span class="dt">Scheme</span></span>
<span id="cb154-43"><a href="#cb154-43"></a>pScheme <span class="ot">=</span> choice</span>
<span id="cb154-44"><a href="#cb154-44"></a>  [ <span class="dt">SchemeData</span>   <span class="op">&lt;$</span> string <span class="st">&quot;data&quot;</span></span>
<span id="cb154-45"><a href="#cb154-45"></a>  , <span class="dt">SchemeFile</span>   <span class="op">&lt;$</span> string <span class="st">&quot;file&quot;</span></span>
<span id="cb154-46"><a href="#cb154-46"></a>  , <span class="dt">SchemeFtp</span>    <span class="op">&lt;$</span> string <span class="st">&quot;ftp&quot;</span></span>
<span id="cb154-47"><a href="#cb154-47"></a>  , <span class="dt">SchemeHttps</span>  <span class="op">&lt;$</span> string <span class="st">&quot;https&quot;</span></span>
<span id="cb154-48"><a href="#cb154-48"></a>  , <span class="dt">SchemeHttp</span>   <span class="op">&lt;$</span> string <span class="st">&quot;http&quot;</span></span>
<span id="cb154-49"><a href="#cb154-49"></a>  , <span class="dt">SchemeIrc</span>    <span class="op">&lt;$</span> string <span class="st">&quot;irc&quot;</span></span>
<span id="cb154-50"><a href="#cb154-50"></a>  , <span class="dt">SchemeMailto</span> <span class="op">&lt;$</span> string <span class="st">&quot;mailto&quot;</span> ]</span>
<span id="cb154-51"><a href="#cb154-51"></a></span>
<span id="cb154-52"><a href="#cb154-52"></a><span class="ot">alternatives ::</span> <span class="dt">Parser</span> (<span class="dt">Char</span>, <span class="dt">Char</span>)</span>
<span id="cb154-53"><a href="#cb154-53"></a>alternatives <span class="ot">=</span> try foo <span class="op">&lt;|&gt;</span> bar</span>
<span id="cb154-54"><a href="#cb154-54"></a>  <span class="kw">where</span></span>
<span id="cb154-55"><a href="#cb154-55"></a>    foo <span class="ot">=</span> (,) <span class="op">&lt;$&gt;</span> char <span class="ch">'a'</span> <span class="op">&lt;*&gt;</span> char <span class="ch">'b'</span></span>
<span id="cb154-56"><a href="#cb154-56"></a>    bar <span class="ot">=</span> (,) <span class="op">&lt;$&gt;</span> char <span class="ch">'a'</span> <span class="op">&lt;*&gt;</span> char <span class="ch">'c'</span></span>
<span id="cb154-57"><a href="#cb154-57"></a></span>
<span id="cb154-58"><a href="#cb154-58"></a><span class="ot">pPath ::</span> <span class="dt">Parser</span> [<span class="dt">Text</span>]</span>
<span id="cb154-59"><a href="#cb154-59"></a>pPath <span class="ot">=</span> choice</span>
<span id="cb154-60"><a href="#cb154-60"></a>  [ pPathAbempty</span>
<span id="cb154-61"><a href="#cb154-61"></a>  , pPathAbsolute</span>
<span id="cb154-62"><a href="#cb154-62"></a>  , pPathNoScheme</span>
<span id="cb154-63"><a href="#cb154-63"></a>  , pPathRootless</span>
<span id="cb154-64"><a href="#cb154-64"></a>  , pPathEmpty</span>
<span id="cb154-65"><a href="#cb154-65"></a>  ]</span>
<span id="cb154-66"><a href="#cb154-66"></a></span>
<span id="cb154-67"><a href="#cb154-67"></a><span class="ot">pPathAbempty ::</span> <span class="dt">Parser</span> [<span class="dt">Text</span>]</span>
<span id="cb154-68"><a href="#cb154-68"></a>pPathAbempty <span class="ot">=</span> many (char <span class="ch">'/'</span> <span class="op">*&gt;</span> pSegment)</span>
<span id="cb154-69"><a href="#cb154-69"></a></span>
<span id="cb154-70"><a href="#cb154-70"></a><span class="ot">pPathAbsolute ::</span> <span class="dt">Parser</span> [<span class="dt">Text</span>]</span>
<span id="cb154-71"><a href="#cb154-71"></a>pPathAbsolute <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb154-72"><a href="#cb154-72"></a>  void (char <span class="ch">'/'</span>)</span>
<span id="cb154-73"><a href="#cb154-73"></a>  option [] <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb154-74"><a href="#cb154-74"></a>    seg <span class="ot">&lt;-</span> pSegmentNz</span>
<span id="cb154-75"><a href="#cb154-75"></a>    segs <span class="ot">&lt;-</span>  many (char <span class="ch">'/'</span> <span class="op">*&gt;</span> pSegment)</span>
<span id="cb154-76"><a href="#cb154-76"></a>    <span class="fu">return</span> (seg<span class="op">:</span>segs)</span>
<span id="cb154-77"><a href="#cb154-77"></a></span>
<span id="cb154-78"><a href="#cb154-78"></a><span class="ot">pPathNoScheme ::</span> <span class="dt">Parser</span> [<span class="dt">Text</span>]</span>
<span id="cb154-79"><a href="#cb154-79"></a>pPathNoScheme <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb154-80"><a href="#cb154-80"></a>  seg <span class="ot">&lt;-</span> pSegmentNzNc</span>
<span id="cb154-81"><a href="#cb154-81"></a>  segs <span class="ot">&lt;-</span> many (char <span class="ch">'/'</span> <span class="op">*&gt;</span> pSegment)</span>
<span id="cb154-82"><a href="#cb154-82"></a>  <span class="fu">return</span> (seg<span class="op">:</span>segs)</span>
<span id="cb154-83"><a href="#cb154-83"></a></span>
<span id="cb154-84"><a href="#cb154-84"></a><span class="ot">pPathRootless ::</span> <span class="dt">Parser</span> [<span class="dt">Text</span>]</span>
<span id="cb154-85"><a href="#cb154-85"></a>pPathRootless <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb154-86"><a href="#cb154-86"></a>  seg <span class="ot">&lt;-</span> pSegmentNz</span>
<span id="cb154-87"><a href="#cb154-87"></a>  segs <span class="ot">&lt;-</span> many (char <span class="ch">'/'</span> <span class="op">*&gt;</span> pSegment)</span>
<span id="cb154-88"><a href="#cb154-88"></a>  <span class="fu">return</span> (seg<span class="op">:</span>segs)</span>
<span id="cb154-89"><a href="#cb154-89"></a></span>
<span id="cb154-90"><a href="#cb154-90"></a><span class="ot">pPathEmpty ::</span> <span class="dt">Parser</span> [<span class="dt">Text</span>]</span>
<span id="cb154-91"><a href="#cb154-91"></a>pPathEmpty <span class="ot">=</span> <span class="fu">return</span> []</span>
<span id="cb154-92"><a href="#cb154-92"></a></span>
<span id="cb154-93"><a href="#cb154-93"></a><span class="ot">pSegment ::</span> <span class="dt">Parser</span> <span class="dt">Text</span></span>
<span id="cb154-94"><a href="#cb154-94"></a>pSegment <span class="ot">=</span> T.pack <span class="op">&lt;$&gt;</span> many pPchar</span>
<span id="cb154-95"><a href="#cb154-95"></a></span>
<span id="cb154-96"><a href="#cb154-96"></a><span class="ot">pSegmentNz ::</span> <span class="dt">Parser</span> <span class="dt">Text</span></span>
<span id="cb154-97"><a href="#cb154-97"></a>pSegmentNz <span class="ot">=</span> T.pack <span class="op">&lt;$&gt;</span> some pPchar</span>
<span id="cb154-98"><a href="#cb154-98"></a></span>
<span id="cb154-99"><a href="#cb154-99"></a><span class="ot">pSegmentNzNc ::</span> <span class="dt">Parser</span> <span class="dt">Text</span></span>
<span id="cb154-100"><a href="#cb154-100"></a>pSegmentNzNc <span class="ot">=</span> T.pack <span class="op">&lt;$&gt;</span> some (pUnreserved <span class="op">&lt;|&gt;</span> pPctEncoded <span class="op">&lt;|&gt;</span> pSubDelims <span class="op">&lt;|&gt;</span> char <span class="ch">'@'</span>)</span>
<span id="cb154-101"><a href="#cb154-101"></a></span>
<span id="cb154-102"><a href="#cb154-102"></a><span class="ot">pPchar ::</span> <span class="dt">Parser</span> <span class="dt">Char</span></span>
<span id="cb154-103"><a href="#cb154-103"></a>pPchar <span class="ot">=</span> pUnreserved <span class="op">&lt;|&gt;</span> pPctEncoded <span class="op">&lt;|&gt;</span> pSubDelims <span class="op">&lt;|&gt;</span> char <span class="ch">':'</span> <span class="op">&lt;|&gt;</span> char <span class="ch">'@'</span></span>
<span id="cb154-104"><a href="#cb154-104"></a></span>
<span id="cb154-105"><a href="#cb154-105"></a><span class="ot">pUnreserved ::</span> <span class="dt">Parser</span> <span class="dt">Char</span></span>
<span id="cb154-106"><a href="#cb154-106"></a>pUnreserved <span class="ot">=</span> alphaNumChar <span class="op">&lt;|&gt;</span> char <span class="ch">'-'</span> <span class="op">&lt;|&gt;</span> char <span class="ch">'.'</span> <span class="op">&lt;|&gt;</span> char <span class="ch">'_'</span> <span class="op">&lt;|&gt;</span> char <span class="ch">'~'</span></span>
<span id="cb154-107"><a href="#cb154-107"></a></span>
<span id="cb154-108"><a href="#cb154-108"></a><span class="ot">pPctEncoded ::</span> <span class="dt">Parser</span> <span class="dt">Char</span></span>
<span id="cb154-109"><a href="#cb154-109"></a>pPctEncoded <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb154-110"><a href="#cb154-110"></a>  void (char <span class="ch">'%'</span>)</span>
<span id="cb154-111"><a href="#cb154-111"></a>  a <span class="ot">&lt;-</span> hexDigitChar</span>
<span id="cb154-112"><a href="#cb154-112"></a>  b <span class="ot">&lt;-</span> hexDigitChar</span>
<span id="cb154-113"><a href="#cb154-113"></a>  <span class="fu">return</span> <span class="op">.</span> <span class="fu">chr</span> <span class="op">$</span> (<span class="fu">digitToInt</span> a)<span class="op">*</span><span class="dv">16</span> <span class="op">+</span> <span class="fu">digitToInt</span> b</span>
<span id="cb154-114"><a href="#cb154-114"></a></span>
<span id="cb154-115"><a href="#cb154-115"></a><span class="ot">pSubDelims ::</span> <span class="dt">Parser</span> <span class="dt">Char</span></span>
<span id="cb154-116"><a href="#cb154-116"></a>pSubDelims <span class="ot">=</span> choice <span class="op">$</span> <span class="fu">map</span> char <span class="st">&quot;!$&amp;'()*+,;=&quot;</span></span>
<span id="cb154-117"><a href="#cb154-117"></a></span>
<span id="cb154-118"><a href="#cb154-118"></a><span class="ot">pUri ::</span> <span class="dt">Parser</span> <span class="dt">Uri</span></span>
<span id="cb154-119"><a href="#cb154-119"></a>pUri <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb154-120"><a href="#cb154-120"></a>  uriScheme <span class="ot">&lt;-</span> pScheme <span class="op">&lt;?&gt;</span> <span class="st">&quot;valid scheme&quot;</span></span>
<span id="cb154-121"><a href="#cb154-121"></a>  void (char <span class="ch">':'</span>)</span>
<span id="cb154-122"><a href="#cb154-122"></a>  uriAuthority <span class="ot">&lt;-</span> optional <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb154-123"><a href="#cb154-123"></a>    void (string <span class="st">&quot;//&quot;</span>)</span>
<span id="cb154-124"><a href="#cb154-124"></a>    authUser <span class="ot">&lt;-</span> optional <span class="op">.</span> try <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb154-125"><a href="#cb154-125"></a>      user <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar <span class="op">&lt;?&gt;</span> <span class="st">&quot;username&quot;</span></span>
<span id="cb154-126"><a href="#cb154-126"></a>      void (char <span class="ch">':'</span>)</span>
<span id="cb154-127"><a href="#cb154-127"></a>      password <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar <span class="op">&lt;?&gt;</span> <span class="st">&quot;password&quot;</span></span>
<span id="cb154-128"><a href="#cb154-128"></a>      void (char <span class="ch">'@'</span>)</span>
<span id="cb154-129"><a href="#cb154-129"></a>      <span class="fu">return</span> (user, password)</span>
<span id="cb154-130"><a href="#cb154-130"></a>    authHost <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some (alphaNumChar <span class="op">&lt;|&gt;</span> char <span class="ch">'.'</span>) <span class="op">&lt;?&gt;</span> <span class="st">&quot;hostname&quot;</span></span>
<span id="cb154-131"><a href="#cb154-131"></a>    authPort <span class="ot">&lt;-</span> optional (char <span class="ch">':'</span> <span class="op">*&gt;</span> label <span class="st">&quot;port number&quot;</span> L.decimal)</span>
<span id="cb154-132"><a href="#cb154-132"></a>    <span class="fu">return</span> <span class="dt">Authority</span> {<span class="op">..</span>}</span>
<span id="cb154-133"><a href="#cb154-133"></a>  uriPath <span class="ot">&lt;-</span> pPath</span>
<span id="cb154-134"><a href="#cb154-134"></a>  uriQuery <span class="ot">&lt;-</span> optional (T.pack <span class="op">&lt;$&gt;</span> (char <span class="ch">'?'</span> <span class="op">*&gt;</span> many (pPchar <span class="op">&lt;|&gt;</span> char <span class="ch">'/'</span> <span class="op">&lt;|&gt;</span> char <span class="ch">'?'</span>)))</span>
<span id="cb154-135"><a href="#cb154-135"></a>  uriFlagment <span class="ot">&lt;-</span> optional (T.pack <span class="op">&lt;$&gt;</span> (char <span class="ch">'#'</span> <span class="op">*&gt;</span> many (pPchar <span class="op">&lt;|&gt;</span> char <span class="ch">'/'</span> <span class="op">&lt;|&gt;</span> char <span class="ch">'?'</span>)) <span class="op">&lt;?&gt;</span> <span class="st">&quot;flagment&quot;</span>)</span>
<span id="cb154-136"><a href="#cb154-136"></a>  <span class="fu">return</span> <span class="dt">Uri</span> {<span class="op">..</span>}</span></code></pre></div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>RFC 3986 に従ってURIのパースが可能であり Megaparsec パーサを含む <a href="https://hackage.haskell.org/package/modern-uri"><code>modern-uri</code></a> パッケージが実際にあります。ただし、パッケージのパーサはここで説明したものよりもはるかに複雑です。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
      </article>

      <div class="row pager">
        <div class="col s6">
          
            <a class="waves-effect waves-light btn white-text left prev" href="../../posts/2019/02-13-sum-monoid%20copy.html"><i class="material-icons left">navigate_before</i>Sum Monoid</a>
          
        </div>
        <div class="col s6">
          
            <a class="waves-effect waves-light btn white-text right next" href="../../posts/2019/08-19-extensible-migration.html">extensible-0.6.1 マイグレーションガイド<i class="material-icons right">navigate_next</i></a>
          
        </div>
      </div>

      <div class="row">
        <div class="col s6 offset-s6" style="position: relative; height: 100px;">
          <div class="fixed-action-btn horizontal" style="position: absolute; display: inline-block; right: 24px;">
  <a class="btn-floating btn-large red">
    <i class="large material-icons">share</i>
  </a>
  <ul>
    <li>
      <a class="btn-floating waves-effect waves-light blue tooltipped" data-position="bottom" data-delay="20" data-tooltip="Share on Twitter" href="https://twitter.com/intent/tweet?text=Megaparsec tutorial from IH book (翻訳)&url=https://haskell.e-bigmoon.com/posts/2019/07-14-megaparsec-tutorial.html"><i class="mdi mdi-twitter white-text"></i></a>
    </li>
    <li>
      <a class="btn-floating waves-effect waves-light indigo tooltipped" data-position="bottom" data-delay="20" data-tooltip="Share on Facebook" href="https://facebook.com/sharer.php?u=https://haskell.e-bigmoon.com/posts/2019/07-14-megaparsec-tutorial.html"><i class="mdi mdi-facebook white-text"></i></a>
    </li>
    <li>
      <a class="btn-floating waves-effect waves-light red tooltipped" data-position="bottom" data-delay="20" data-tooltip="Share on Google+" href="https://plus.google.com/share?url=https://haskell.e-bigmoon.com/posts/2019/07-14-megaparsec-tutorial.html"><i class="mdi mdi-google-plus white-text"></i></a>
    </li>
  </ul>
</div>
        </div>
      </div>

    </div>
  </div>

  <!-- {% if page.mathjax %} -->
  <!--   {% include mathjax_support.html %} -->
  <!-- {% endif %} -->

</div>

      </div>
    </div>

    <footer class="page-footer indigo lighten-1">

  <div class="footer-copyright">

    <div class="container">
      © 2017-2019 BIGMOON&nbsp;
      Site proudly generated by <a class="red-text text-accent-1" href="http://jaspervdj.be/hakyll">Hakyll</a>,&nbsp;
      original Jekyll theme by <a class="red-text text-accent-1" href="https://github.com/mumuxme/materialize-jekyll">mumuxme</a>.
    </div>

  </div>

</footer>


    <!-- scrolltop button -->
    <button class="material-scrolltop waves-effect waves-light hide-on-small-only" type="button">
      <i class="mdi mdi-arrow-up-bold small white-text"></i>
    </button>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-19322672-9"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-19322672-9');
    </script>

    <!-- jquery -->
    <script type="text/javascript" src="../../lib/jquery-min.js"></script>
    <!-- materialize -->
    <script src="../../lib/materialize/js/materialize.min.js"></script>
    <!-- <\!-- Material ScrollTop plugin -\-> -->
    <script src="../../lib/material-scrolltop/material-scrolltop.js"></script>
    <!-- main -->
    <script src="../../js/init.js"></script>
    <script src="../../js/main.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/haskell.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/yaml.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/shell.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/bash.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>

</html>
