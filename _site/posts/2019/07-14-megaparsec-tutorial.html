<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">

  <head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# article: http://ogp.me/ns/article#">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0" />
  <!-- MUST in hex format, may the same as header-color. This color is for android chrome browser. -->
  <meta name="theme-color" content="#5c6bc0">

  <!-- Metadata. -->
  <meta name="keywords" content="haskell,blog,bigmoon" />
  <title>Megaparsec tutorial from IH book</title>
  <meta name="description" content="Great original post: Megaparsec tutorial from IH book
この Megaparsec のチュートリアルは、元々は Intermediate Haskell という本の１つの章のために書かれました。 ここ一年で本が進展していないため、 他の著者は私がスタンドアロンのチュー">
  <link rel="canonical" href="../../posts/2019/07-14-megaparsec-tutorial.html">
  <link rel="alternate" type="application/atom+xml" title="Megaparsec tutorial from IH book" href="../../feed.xml" />
  <link rel="shortcut icon" href="../../images/favicon.ico" />
  <meta name="google-site-verification" content="X2YNboLvzw3_bclXLMvohyJDqj68D06_hPDMukRbgTs" />

  <!-- Stylesheets. -->
  <link rel="stylesheet" href="../../lib/materialize/css/materialize.min.css" />
  <link rel="stylesheet" href="../../css/main.css" />
  <link media="all" rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/MaterialDesign-Webfont/3.3.92/css/materialdesignicons.min.css" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="../../lib/material-scrolltop/material-scrolltop.css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" />

  <!-- OGP -->
  <meta property="og:title" content="Megaparsec tutorial from IH book" />
  <meta property="og:type" content="article" />
  <meta property="og:url" content="/posts/2019/07-14-megaparsec-tutorial.html" />
  <!-- <meta property="og:image" content=" サムネイル画像の URL" /> -->
  <meta property="og:site_name" content="Megaparsec tutorial from IH book" />
  <meta property="og:description" content="Great original post: Megaparsec tutorial from IH book
この Megaparsec のチュートリアルは、元々は Intermediate Haskell という本の１つの章のために書かれました。 ここ一年で本が進展していないため、 他の著者は私がスタンドアロンのチュー" />

  <meta name="twitter:card" content="summary" />
  <!-- <meta name="twitter:site" content="@[ Twitter ID]" /> -->
  <!-- <meta name="twitter:player" content="@[ Twitter ID]" /> -->

  <noscript>
  <div class="notice-warning noscript">You don't have javascript enabled. Good luck! :(</div>
</noscript>

<!--[if IE]>
  <div class="notice-warning">Oh, you are using Internet Explorer! Good luck... :(</div>
<![endif]-->

</head>


  <body>
    <header class="site-header">
      <nav class="nav-extended indigo lighten-1">
        <div class="nav-wrapper">
  <a href="../../"><span class="site-title">BIGMOON Haskeller's BLOG</span></a>
  <a href="#" data-activates="mobile-navbar" class="button-collapse">
    <i class="mdi mdi-menu white-text"></i>
  </a>

  <ul id="nav-mobile" class="right hide-on-med-and-down">
    <li>
      <a href="../../" class="white-text">
        <i class="mdi mdi-home left indigo-text text-lighten-3"></i>
        Home
      </a>
    </li>
    <li>
      <a href="../../about.html" class="white-text">
        <i class="mdi mdi-account-circle left indigo-text text-lighten-3"></i>
        About
      </a>
    </li>
    <li>
      <a href="../../stack/" class="white-text">
        <i class="mdi mdi-wrench left indigo-text text-lighten-3"></i>
        Development
      </a>
    </li>
    <li>
      <a href="../../quiz/index.html" class="white-text">
        <i class="mdi mdi-comment-question-outline left indigo-text text-lighten-3"></i>
        Quiz
      </a>
    </li>
    <li>
      <a href="../../libraries/" class="white-text">
        <i class="mdi mdi-package-variant left indigo-text text-lighten-3"></i>
        Libraries
      </a>
    </li>
    <li>
      <a href="../../yesod/" class="white-text">
        <i class="mdi mdi-earth left indigo-text text-lighten-3"></i>
        Yesod
      </a>
    </li>
    <li>
      <a href="../../contact.html" class="white-text">
        <i class="mdi mdi-lead-pencil left indigo-text text-lighten-3"></i>
        Contact
      </a>
    </li>
    <li>
      <a href="../../feed.xml" class="white-text">
        <i class="mdi mdi-rss left indigo-text text-lighten-3"></i>
        Feed
      </a>
    </li>
  </ul>

  <ul class="side-nav" id="mobile-navbar">
    <li>
      <a href="../../" class="waves-effect waves-teal black-text">
        <i class="mdi mdi-home left green-text"></i>
        Home
      </a>
    </li>
    <li>
      <a href="../../about.html" class="navbar-text-colour-mobile">
        <i class="mdi mdi-account-circle left blue-text"></i>
        About
      </a>
    </li>
    <li>
      <a href="../../stack/" class="navbar-text-colour-mobile">
        <i class="mdi mdi-wrench left blue-text"></i>
        Development
      </a>
    </li>
    <li>
      <a href="../../quiz/" class="navbar-text-colour-mobile">
        <i class="mdi mdi-comment-question-outline left blue-text"></i>
        Quiz
      </a>
    </li>
    <li>
      <a href="../../libraries/" class="navbar-text-colour-mobile">
        <i class="mdi mdi-package-variant left blue-text"></i>
        Libraries
      </a>
    </li>
    <li>
      <a href="../../yesod/" class="navbar-text-colour-mobile">
        <i class="mdi mdi-earth left blue-text"></i>
        Yesod
      </a>
    </li>
    <li>
      <a href="../../contact.html" class="navbar-text-colour-mobile">
        <i class="mdi mdi-lead-pencil left blue-text"></i>
        Contact
      </a>
    </li>
  </ul>
</div>

      </nav>
    </header>

    <div class="site-container" id="tab-main">
      <div class="wrapper">
        <div class="post-ribbon"></div>

<div class="container post-container">
  <div class="post-page card-panel z-depth-2">
    <div class="post-section">

      <p class="grey-text">
        <i class="mdi mdi-calendar"></i>&nbsp;
        Posted on July 14, 2019
        
          &nbsp;&nbsp;<i class="mdi mdi-account-circle"></i>&nbsp;
          translated by Wataru Yamada
        
        
          &nbsp;&nbsp;<i class="mdi mdi-account-circle"></i>&nbsp;
          authored by Mark Karpov
        
        &nbsp;
        
          <i class="mdi mdi-folder"></i>&nbsp;
          <span class="capitalize"></span>
          <!-- &emsp;<i class="mdi mdi-refresh"></i>&nbsp;UPDATE: {% if page.update %}{{ page.update | date: "%b %-d, %Y" }}{% else %}{{ page.last_modified_at | date: "%b %-d, %Y" }}{% endif %} -->
        
      </p>

      <div class="post-header">
        <h1 class="post-title">Megaparsec tutorial from IH book</h1>

        <div class="row">
        
          <div class="col s6">
            <i class="post-tag mdi mdi-tag-multiple waves-effect waves-light"></i>
            <div class="chip"><a href="../../tags/megaparsec.html">megaparsec</a>, <a href="../../tags/package.html">package</a>, <a href="../../tags/%E7%BF%BB%E8%A8%B3.html">翻訳</a></div>
          </div>
        

          <div class="col s6">
            <div style="position: relative; top: 70px;">
            <div class="fixed-action-btn horizontal" style="position: absolute; display: inline-block; right: 24px;">
  <a class="btn-floating btn-large red">
    <i class="large material-icons">share</i>
  </a>
  <ul>
    <li>
      <a class="btn-floating waves-effect waves-light blue tooltipped" data-position="bottom" data-delay="20" data-tooltip="Share on Twitter" href="https://twitter.com/intent/tweet?text=Megaparsec tutorial from IH book&url=https://haskell.e-bigmoon.com/posts/2019/07-14-megaparsec-tutorial.html"><i class="mdi mdi-twitter white-text"></i></a>
    </li>
    <li>
      <a class="btn-floating waves-effect waves-light indigo tooltipped" data-position="bottom" data-delay="20" data-tooltip="Share on Facebook" href="https://facebook.com/sharer.php?u=https://haskell.e-bigmoon.com/posts/2019/07-14-megaparsec-tutorial.html"><i class="mdi mdi-facebook white-text"></i></a>
    </li>
    <li>
      <a class="btn-floating waves-effect waves-light red tooltipped" data-position="bottom" data-delay="20" data-tooltip="Share on Google+" href="https://plus.google.com/share?url=https://haskell.e-bigmoon.com/posts/2019/07-14-megaparsec-tutorial.html"><i class="mdi mdi-google-plus white-text"></i></a>
    </li>
  </ul>
</div>
            </div>
          </div>
        </div>
      </div>

      <article class="post-content">
        <p>Great original post: <a href="https://markkarpov.com/megaparsec/megaparsec.html">Megaparsec tutorial from IH book</a></p>
<p>この Megaparsec のチュートリアルは、元々は <a href="https://intermediatehaskell.com/">Intermediate Haskell</a> という本の１つの章のために書かれました。 ここ一年で本が進展していないため、 他の著者は私がスタンドアロンのチュートリアルとしてテキストを公表し、 人々が少なくとも私たちの仕事のこの部分から恩恵を受けることができるようにする ことに同意しました。</p>
<!--more-->
<ul>
<li><a href="#ParsecT"><code>ParsecT</code> と <code>Parsec</code> モナド</a></li>
<li><a href="#Character">文字 とバイナリストリーム</a></li>
<li><a href="#MonaAp">モナディック構文とアプリカティブ構文</a></li>
<li><a href="#Eof"><code>Eof</code> による入力の強制消費</a></li>
<li><a href="#Alt">選択肢を使った動作</a></li>
<li><a href="#Try"><code>try</code> によるバックトラックの制御</a></li>
<li><a href="#Debug">パーサのデバッグ</a></li>
<li><a href="#Label">ラベル付けと隠蔽</a></li>
<li><a href="#Run">パーサの実行</a></li>
<li><a href="#MonadParsec"><code>MonadParsec</code> 型クラス</a></li>
<li><a href="#Lexing">字句解析</a>
<ul>
<li><a href="#White">空白</a></li>
<li><a href="#Char">文字と文字列リテラル</a></li>
<li><a href="#Numbers">数字</a></li>
</ul></li>
<li><a href="#lookAhead"><code>notFollowedBy</code> と <code>lookAhead</code></a></li>
<li><a href="#Expr">式のパース</a></li>
<li><a href="#Indentation">Indentation-sensitiveなパース</a>
<ul>
<li><a href="#nonIndented"><code>nonIndented</code> と <code>indentBlock</code></a></li>
<li><a href="#SimpleIndented">単純なインデントされたリスト</a></li>
<li><a href="#NestedIndented">ネストされたインデントのあるリスト</a></li>
<li><a href="#LineFolds">折り返しの追加</a></li>
</ul></li>
<li><a href="#Efficient">効率のよいパーサを書く</a></li>
<li><a href="#Error">パースエラー</a>
<ul>
<li><a href="#ErrDef">パースエラーの定義</a></li>
<li><a href="#SigErr">パースエラーを通知する方法</a></li>
<li><a href="#DispErr">パースエラーの表示</a></li>
<li><a href="#CatchErr">パーサ実行時にパースエラーをキャッチする</a></li>
</ul></li>
<li><a href="#Testing">Megaparsecパーサのテスト</a></li>
<li><a href="#CustomInput">カスタム入力ストリームの操作</a></li>
</ul>
<p>「例：あなた自身のパーサコンビネータを書く」の章で開発されたトイパーサコンビネータは、実際の使用には適していないので、 同じ問題を解決するHaskellエコシステムのライブラリを見ていきましょう。 そして、それらがなすさまざまなトレードオフに注意してください。</p>
<ul>
<li><p><a href="https://hackage.haskell.org/package/parsec">parsec</a> は長い間 Haskellの「デフォルト」のパーサライブラリでした。このライブラリは、エラーメッセージの品質に焦点を当てていると言われています。ただし、テストカバレッジは良くなく、現在メンテナンスモードになっています。</p></li>
<li><p><a href="https://hackage.haskell.org/package/attoparsec">attoparsec</a> は、パフォーマンスを重視した堅牢で高速なパーサライブラリです。このリストの中で、インクリメンタルパージングを完全にサポートしているのはこれだけです。欠点はエラーメッセージの質が悪いこと、モナド変換子として使用できないこと、および入力ストリームとして使用できる型の組み合わせが限られていることです。</p></li>
<li><p><a href="https://hackage.haskell.org/package/trifecta">trifecta</a> は優れたエラーメッセージを特徴としていますが、あまり文書化されておらず、理解するのが難しいです。 <code>String</code> と <code>ByteString</code> はそのままではパースできますが、<code>Text</code> はパースできません。</p></li>
<li><p><a href="https://hackage.haskell.org/package/megaparsec">megaparsec</a> は、ここ数年で積極的に開発されてきた <code>parsec</code> のフォークです。現在のバージョンは、速度、エラーメッセージの品質、そして柔軟性の間で素晴らしいバランスを取っています。 <code>parsec</code> の非公式の後継者として、<code>parsec</code> ライブラリを使用したことがあるか、チュートリアルを読んだことがあるユーザにとっては慣習的でなじみのあるものです。</p></li>
</ul>
<p>これらすべてのライブラリを網羅しようとするのは実用的ではないため、 <code>megaparsec</code> に焦点を当てます。より正確には、この本が出版される時までにはほとんどどこでも古いバージョンに取って代わるであろうバージョン7をカバーするつもりです。</p>
<p><a name="ParsecT"></a></p>
<h2 id="parsect-と-parsec-モナド">ParsecT と Parsec モナド</h2>
<p><code>ParsecT</code>は、主要なパーサモナド変換子であり、<code>megaparsec</code> の中心的なデータ型です。 <code>ParsecT e s m a</code> は、次のようにパラメータ化されています。</p>
<ul>
<li><p><code>e</code> はエラーメッセージのカスタムコンポーネントの型です。もし私たちが何もカスタムを望まないのであれば（そして今のところ私たちはしません）、 <code>Data.Void</code> モジュールの <code>Void</code> を使うだけです。</p></li>
<li><p><code>s</code> は入力ストリームの型です。 <code>megaparsec</code> は、<code>String</code>、正格または遅延 <code>Text</code> 、 正格または遅延 <code>ByteStrings</code> をそのまま使用して動作します。カスタム入力ストリームを扱うことも可能です。</p></li>
<li><p><code>m</code> は <code>ParsecT</code> モナド変換子の内部モナドです。</p></li>
<li><p><code>a</code> はパース結果であるモナディック値です。</p></li>
</ul>
<p>ほとんどの場合、<code>m</code> は <code>Identity</code> に他ならないので、<code>Parsec</code> 型シノニムは非常に便利です。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">type</span> <span class="dt">Parsec</span> e s a <span class="ot">=</span> <span class="dt">ParsecT</span> e s <span class="dt">Identity</span> a</a></code></pre></div>
<p><code>Parsec</code> は、単なる <code>ParsecT</code>の変換子を使わないバージョンです。</p>
<p><code>megaparsec</code> のモナド変換子と MTL のモナド変換子およびクラスの間の類似点を示すこともできます。 確かに、<code>MonadState</code> や <code>MonadReader</code> などの型クラスと目的が似ている <code>MonadParsec</code> 型クラスがあります。 後で <code>MonadParsec</code> に戻り、詳細について説明します。</p>
<p>カスタムした型シノニムを定義することは <code>megaparsec</code> を使ってパーサを書くことを始める最も良い方法です。 これは次の2つの理由から良い考えです。</p>
<ul>
<li><p>あなたのパーサモナドとして <code>Parser</code> があれば、<code>Parser Int</code> のようなトップレベルのシグネチャを追加することがより簡単になります。シグネチャがないと、<code>e</code> のようなものが曖昧になることがよくあります。これはライブラリの多相APIの反面です。</p></li>
<li><p>すべての型変数を具体的な方に固定して操作すると、GHCの最適化が大幅に向上します。パーサが多相性を保っている場合、GHCは最適化の観点からそれほど多くのことはできません。<code>megaparsec</code> APIは多相ですが、エンドユーザーは具体的にパーサモナドの型を固定することが予想されます。そのため、インライン展開と、ほとんどの関数の定義がインターフェイスファイルと呼ばれるファイルに出力されているという事実により、GHCは非常に効率的な非多相的なコードを生成できます。</p></li>
</ul>
<p>次のように型シノニム（通常は <code>Parser</code> と呼ばれる）を定義しましょう。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1">ype <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Void</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="co">--                   ^    ^</span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="co">--                   |    ┗━━━━┓</span></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="co">-- カスタムエラーコンポーネント  入力ストリームの型</span></a></code></pre></div>
<p>カスタムパースエラーを扱い始めるまでは、この章で <code>Parser</code>が表示されているときは、この型を想定してください。</p>
<p><a name="Character"></a></p>
<h2 id="文字とバイナリストリーム">文字とバイナリストリーム</h2>
<p><code>megaparsec</code> は、5種類の入力ストリーム（<code>String</code>、正格または遅延 <code>Text</code> 、 正格または遅延 <code>ByteStrings</code>）をそのまま使用できると言われています。 これが可能なのは、ライブラリでこれらの型が <code>Stream</code> 型クラスのインスタンスになっているからです。 <code>Stream</code> 型クラスはそれぞれのデータ型が <code>megaparsec</code> のパーサへの入力として使用するために必要な関数を抽象化したものです。</p>
<p>シンプルにしたバージョンの <code>Stream</code> は、次のようになります。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">class</span> <span class="dt">Stream</span> s <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="kw">type</span> <span class="dt">Token</span><span class="ot">  s ::</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb3-3" title="3">  <span class="kw">type</span> <span class="dt">Tokens</span><span class="ot"> s ::</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="ot">  take1_ ::</span> s <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Token</span> s, s) <span class="co">-- aka uncons</span></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="ot">  tokensToChunk ::</span> <span class="dt">Proxy</span> s <span class="ot">-&gt;</span> [<span class="dt">Token</span> s] <span class="ot">-&gt;</span> <span class="dt">Tokens</span> s</a></code></pre></div>
<p>実際の <code>Stream</code> の定義にはもっと多くのメソッドがありますが、それらを知ることはライブラリを使うために必要ではありません。</p>
<p>型クラスには2つの型関数が関連付けられています。</p>
<ul>
<li><p>ストリーム <code>s</code> における <code>Token s</code> は単一トークンの型です。一般的な例は <code>Char</code> と <code>Word8</code> ですが、カスタムストリームのために何か他のものになるかもしれません。</p></li>
<li><p>ストリーム <code>s</code> における <code>Tokens s</code> はストリームの「チャンク」の型です。チャンクの概念はパフォーマンス上の理由から導入されただけです。確かに、トークンのリスト <code>[Token s]</code> と同型であるストリームの一部のより効率的な表現が可能です。例えば、 <code>Text</code> 型の入力ストリームは <code>Tokens s ~ Text</code> であり、<code>Text</code> のチャンクは <code>Text</code> です。型の等価性 <code>Tokens s ~ s</code> はしばしば成り立ちますが、 <code>Tokens s</code> と <code>s</code> はカスタムストリームでは異なる可能性があるため、<code>megaparsec</code> ではこれらの型を分離します。</p></li>
</ul>
<p>デフォルトの入力ストリームの型を以下の表に示します。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><code>s</code></th>
<th style="text-align: left;"><code>Token s</code></th>
<th style="text-align: left;"><code>Tokens s</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>String</code></td>
<td style="text-align: left;"><code>Char</code></td>
<td style="text-align: left;"><code>String</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">正格 <code>Text</code></td>
<td style="text-align: left;"><code>Char</code></td>
<td style="text-align: left;">正格 <code>Text</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">遅延 <code>Text</code></td>
<td style="text-align: left;"><code>Char</code></td>
<td style="text-align: left;">遅延 <code>Text</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">正格 <code>ByteString</code></td>
<td style="text-align: left;"><code>Word8</code></td>
<td style="text-align: left;">正格 <code>ByteString</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">遅延 <code>ByteString</code></td>
<td style="text-align: left;"><code>Word8</code></td>
<td style="text-align: left;">遅延 <code>ByteString</code></td>
</tr>
</tbody>
</table>
<p><code>Token</code> および <code>Tokens</code> 型関数は <code>megaparsec</code> API の型にて 多く出現するため、慣れることが重要です。</p>
<p>お気づきかもしれませんが、デフォルト入力ストリームを<code>Token</code>型でグループ化すると、2つのグループになります。</p>
<ul>
<li><p><code>Token s ~ Char</code> となる文字ストリーム : <code>String</code> および 正格・遅延 <code>Text</code>。</p></li>
<li><p><code>Token s ~ Word8</code> となるバイナリストリーム : 正格・遅延 <code>ByteString</code>。</p></li>
</ul>
<p><code>megaparsec</code> では、それぞれの型の入力ストリームに対して同じパーサをコーディングする必要はないことがわかりました。 (<code>attoparsec</code> ライブラリではする必要があります) しかし、それぞれの <code>Token s</code> ごとに異なるコードが必要です。</p>
<ul>
<li><p>文字ストリームの共通のコンビネータを得るには、<code>Text.Megaparsec.Char</code> モジュールをインポートしてください。</p></li>
<li><p>バイナリストリームで同じようにするには、<code>Text.Megaparsec.Byte</code>をインポートします。</p></li>
</ul>
<p>これらのモジュールには、次のような2つの類似したヘルパーパーサのセットが含まれています。</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Name</strong></th>
<th style="text-align: left;"><code>Text.Megaparsec.Char</code></th>
<th style="text-align: left;"><code>Text.Megaparsec.Byte</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>newline</code></td>
<td style="text-align: left;"><code>(MonadParsec e s m, Token s ~ Char) =&gt; m (Token s)</code></td>
<td style="text-align: left;"><code>(MonadParsec e s m, Token s ~ Word8) =&gt; m (Token s)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>eol</code></td>
<td style="text-align: left;"><code>(MonadParsec e s m, Token s ~ Char) =&gt; m (Tokens s)</code></td>
<td style="text-align: left;"><code>(MonadParsec e s m, Token s ~ Word8) =&gt; m (Tokens s)</code></td>
</tr>
</tbody>
</table>
<p>このモジュールを構築するプリミティブをいくつか紹介しましょう。そうすれば、これから使用するツールを理解できます。</p>
<p>最初のプリミティブは<code>token</code>と呼ばれ、<code>Token s</code>をパースすることができます。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="ot">token ::</span> <span class="dt">MonadParsec</span> e s m</a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="ot">=&gt;</span> (<span class="dt">Token</span> s <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a)</a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="co">-- ^ Matching function for the token to parse</span></a>
<a class="sourceLine" id="cb4-4" title="4">  <span class="ot">-&gt;</span> <span class="dt">Set</span> (<span class="dt">ErrorItem</span> (<span class="dt">Token</span> s))</a>
<a class="sourceLine" id="cb4-5" title="5">     <span class="co">-- ^ Expected items (in case of an error)</span></a>
<a class="sourceLine" id="cb4-6" title="6">  <span class="ot">-&gt;</span> m a</a></code></pre></div>
<p><code>token</code> の最初の引数はパースしたいトークンのマッチング関数です。 関数が<code>Just</code>で何かを返す場合、その値はパース結果になります。 <code>Nothing</code> はパーサがトークンを受理しなかったことによりプリミティブが失敗したこと示します。</p>
<p>2番目の引数は、（<code>container</code>パッケージの）<code>Set</code> であり、失敗した場合にユーザーに表示されるすべての予想されるErrorItemを含みます。 パースエラーについて議論するときに、<code>ErrorItem</code> 型を詳しく調べます。</p>
<p>トークンがどのように機能するのかをよりよく理解するために、 <code>Text.Megaparsec</code> モジュールの定義を見てみましょう。 これにはあらゆる種類の入力ストリームで 機能するコンビネータが含まれています。 <code>satisfy</code>はかなり一般的なコンビネータです。 マッチさせたいトークンを与えると <code>True</code> を返す述語を与え、 パーサは結果を返します。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="ot">satisfy ::</span> <span class="dt">MonadParsec</span> e s m</a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="ot">=&gt;</span> (<span class="dt">Token</span> s <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="co">-- ^ Predicate to apply</span></a>
<a class="sourceLine" id="cb5-3" title="3">  <span class="ot">-&gt;</span> m (<span class="dt">Token</span> s)</a>
<a class="sourceLine" id="cb5-4" title="4">satisfy f <span class="ot">=</span> token testToken Set.empty</a>
<a class="sourceLine" id="cb5-5" title="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-6" title="6">    testToken x <span class="ot">=</span> <span class="kw">if</span> f x <span class="kw">then</span> <span class="dt">Just</span> x <span class="kw">else</span> <span class="dt">Nothing</span></a></code></pre></div>
<p><code>testToken</code> は <code>Bool</code> を返す関数 <code>f</code> を 期待するトークン <code>Maybe (Token s)</code> を返す関数に変えます。 <code>satisfy</code> では、 一致すると予想される正確なトークン列がわからないため、 2番目の引数として <code>Set.empty</code> を渡します。</p>
<p><code>satisfy</code> を理解するために、機能するか見てみましょう。 パーサで遊ぶためには、それを実行するヘルパー関数が必要です。 GHCiでテストするために <code>megaparsec</code> は <code>parseTest</code> を提供します。</p>
<p>まず、GHCiを起動していくつかのモジュールをインポートしましょう。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" title="1">λ<span class="op">&gt;</span> <span class="ex">import</span> Text.Megaparsec</a>
<a class="sourceLine" id="cb6-2" title="2">λ<span class="op">&gt;</span> <span class="ex">import</span> Text.Megaparsec.Char</a>
<a class="sourceLine" id="cb6-3" title="3">λ<span class="op">&gt;</span> <span class="ex">import</span> Data.Text (Text)</a>
<a class="sourceLine" id="cb6-4" title="4">λ<span class="op">&gt;</span> <span class="ex">import</span> Data.Void</a></code></pre></div>
<p>パーサの型のあいまいさを解決するために、 使用する <code>Parser</code> 型シノニムを追加します。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" title="1">λ<span class="op">&gt;</span> <span class="bu">type</span> Parser = Parsec Void Text</a></code></pre></div>
<p>また、文字列リテラルを <code>Text</code> の値として使用できるように、<code>OverloadedStrings</code> 言語拡張を有効にする必要があります。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" title="1">λ<span class="op">&gt;</span> :<span class="ex">set</span> -XOverloadedStrings</a>
<a class="sourceLine" id="cb8-2" title="2"></a>
<a class="sourceLine" id="cb8-3" title="3">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (satisfy (== <span class="st">'a'</span>) :: <span class="ex">Parser</span> Char) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="ex">1</span>:1:</a>
<a class="sourceLine" id="cb8-5" title="5">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb8-6" title="6"><span class="ex">1</span> <span class="kw">|</span> <span class="op">&lt;</span><span class="ex">empty</span> line<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb8-7" title="7">  <span class="kw">|</span> ^</a>
<a class="sourceLine" id="cb8-8" title="8"><span class="ex">unexpected</span> end of input</a>
<a class="sourceLine" id="cb8-9" title="9"></a>
<a class="sourceLine" id="cb8-10" title="10">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (satisfy (== <span class="st">'a'</span>) :: <span class="ex">Parser</span> Char) <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb8-11" title="11"><span class="st">'a'</span></a>
<a class="sourceLine" id="cb8-12" title="12"></a>
<a class="sourceLine" id="cb8-13" title="13">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (satisfy (== <span class="st">'a'</span>) :: <span class="ex">Parser</span> Char) <span class="st">&quot;b&quot;</span></a>
<a class="sourceLine" id="cb8-14" title="14"><span class="ex">1</span>:1:</a>
<a class="sourceLine" id="cb8-15" title="15">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb8-16" title="16"><span class="ex">1</span> <span class="kw">|</span> <span class="ex">b</span></a>
<a class="sourceLine" id="cb8-17" title="17">  <span class="kw">|</span> ^</a>
<a class="sourceLine" id="cb8-18" title="18"><span class="ex">unexpected</span> <span class="st">'b'</span></a>
<a class="sourceLine" id="cb8-19" title="19"></a>
<a class="sourceLine" id="cb8-20" title="20">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (satisfy (<span class="op">&gt;</span> <span class="st">'c'</span>) :: <span class="ex">Parser</span> Char) <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb8-21" title="21"><span class="ex">1</span>:1:</a>
<a class="sourceLine" id="cb8-22" title="22">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb8-23" title="23"><span class="ex">1</span> <span class="kw">|</span> <span class="ex">a</span></a>
<a class="sourceLine" id="cb8-24" title="24">  <span class="kw">|</span> ^</a>
<a class="sourceLine" id="cb8-25" title="25"><span class="ex">unexpected</span> <span class="st">'a'</span></a>
<a class="sourceLine" id="cb8-26" title="26"></a>
<a class="sourceLine" id="cb8-27" title="27">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (satisfy (<span class="op">&gt;</span> <span class="st">'c'</span>) :: <span class="ex">Parser</span> Char) <span class="st">&quot;d&quot;</span></a>
<a class="sourceLine" id="cb8-28" title="28"><span class="st">'d'</span></a></code></pre></div>
<p><code>satisfy</code> の多相性により、 <code>parseTest</code> は <code>MonadParsec e s m</code> で <code>e</code> と <code>s</code> に何を使うべきかわからないため、 アノテーション <code>:: Parser Char</code> は必要です (<code>m</code> はこれらのヘルパーにより <code>Identity</code> と仮定されます)。 型シグネチャを持つ既存のパーサを使う場合、 パーサの型を明示的に説明する必要はありません。</p>
<p>うまくいきそうです。 <code>satisfy</code> の問題は、 それが失敗したときに何が期待されるのかを述べないということです。 なぜなら、 <code>satisfy</code> の呼び出し元が提供する関数を分析することができないからです。 あまり一般的ではないですが、 代わりにもっと有用なエラーメッセージを生成することができる 他のコンビネータがあります。 例えば、<code>single</code> (<code>Text.Megaparsec.Byte</code> と <code>Text.Megaparsec.Char</code> では <code>char</code> と呼ばれる型制約のあるシノニムを使用する) は特定のトークン値にマッチします。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb9-1" title="1"><span class="ex">single</span> :: MonadParsec e s m</a>
<a class="sourceLine" id="cb9-2" title="2">  =<span class="op">&gt;</span> <span class="ex">Token</span> s           -- ^ Token to match</a>
<a class="sourceLine" id="cb9-3" title="3">  <span class="ex">-</span><span class="op">&gt;</span> m (Token s)</a>
<a class="sourceLine" id="cb9-4" title="4"><span class="ex">single</span> t = token testToken expected</a>
<a class="sourceLine" id="cb9-5" title="5">  <span class="ex">where</span></a>
<a class="sourceLine" id="cb9-6" title="6">    <span class="ex">testToken</span> x = if x == t then Just x else Nothing</a>
<a class="sourceLine" id="cb9-7" title="7">    <span class="ex">expected</span>    = E.singleton (Tokens (t:<span class="kw">|</span>[]))</a></code></pre></div>
<p><code>Tokens</code> 値コンストラクタは、前に説明した型関数 <code>Tokens</code> と何の共通点もありません。 実際、 <code>Tokens</code> は <code>ErrorItem</code> のコンストラクタの1つであり、 一致すると予想される具体的なトークン列 を指定するために使用されます。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb10-1" title="1">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (char <span class="st">'a'</span> :: Parser Char) <span class="st">&quot;b&quot;</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="ex">1</span>:1:</a>
<a class="sourceLine" id="cb10-3" title="3">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="ex">1</span> <span class="kw">|</span> <span class="ex">b</span></a>
<a class="sourceLine" id="cb10-5" title="5">  <span class="kw">|</span> ^</a>
<a class="sourceLine" id="cb10-6" title="6"><span class="ex">unexpected</span> <span class="st">'b'</span></a>
<a class="sourceLine" id="cb10-7" title="7"><span class="ex">expecting</span> <span class="st">'a'</span></a>
<a class="sourceLine" id="cb10-8" title="8"></a>
<a class="sourceLine" id="cb10-9" title="9">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (char <span class="st">'a'</span> :: Parser Char) <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb10-10" title="10"><span class="st">'a'</span></a></code></pre></div>
<p>以下のようにの改行を定義できます。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb11-1" title="1"><span class="ex">newline</span> :: (MonadParsec e s m, Token s ~ Char) =<span class="op">&gt;</span> <span class="ex">m</span> (Token s)</a>
<a class="sourceLine" id="cb11-2" title="2"><span class="ex">newline</span> = single <span class="st">'\n'</span></a></code></pre></div>
<p>2つ目のプリミティブは<code>tokens</code>と呼ばれ、 <code>Tokens</code> をパースすることを可能にします。 つまり、入力の固定されたチャンクに一致させるために使用できます。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb12-1" title="1"><span class="ex">tokens</span> :: MonadParsec e s m</a>
<a class="sourceLine" id="cb12-2" title="2">  =<span class="op">&gt;</span> <span class="kw">(</span><span class="ex">Tokens</span> s -<span class="op">&gt;</span> Tokens s -<span class="op">&gt;</span> Bool<span class="kw">)</span></a>
<a class="sourceLine" id="cb12-3" title="3">    <span class="ex">--</span> ^ チャンクの等価性をチェックする述語</a>
<a class="sourceLine" id="cb12-4" title="4">  <span class="ex">-</span><span class="op">&gt;</span> Tokens s</a>
<a class="sourceLine" id="cb12-5" title="5">    <span class="ex">--</span> ^ 入力にマッチさせたいチャンク</a>
<a class="sourceLine" id="cb12-6" title="6">  <span class="ex">-</span><span class="op">&gt;</span> m (Tokens s)</a></code></pre></div>
<p><code>tokens</code> に関して定義された2つのパーサがあります。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="co">-- from &quot;Text.Megaparsec&quot;:</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="ot">chunk ::</span> <span class="dt">MonadParsec</span> e s m</a>
<a class="sourceLine" id="cb13-3" title="3">  <span class="ot">=&gt;</span> <span class="dt">Tokens</span> s</a>
<a class="sourceLine" id="cb13-4" title="4">  <span class="ot">-&gt;</span> m (<span class="dt">Tokens</span> s)</a>
<a class="sourceLine" id="cb13-5" title="5">chunk <span class="ot">=</span> tokens (<span class="op">==</span>)</a>
<a class="sourceLine" id="cb13-6" title="6"></a>
<a class="sourceLine" id="cb13-7" title="7"><span class="co">-- from &quot;Text.Megaparsec.Char&quot; and &quot;Text.Megaparsec.Byte&quot;:</span></a>
<a class="sourceLine" id="cb13-8" title="8"><span class="ot">string' ::</span> (<span class="dt">MonadParsec</span> e s m, <span class="dt">CI.FoldCase</span> (<span class="dt">Tokens</span> s))</a>
<a class="sourceLine" id="cb13-9" title="9">  <span class="ot">=&gt;</span> <span class="dt">Tokens</span> s</a>
<a class="sourceLine" id="cb13-10" title="10">  <span class="ot">-&gt;</span> m (<span class="dt">Tokens</span> s)</a>
<a class="sourceLine" id="cb13-11" title="11">string' <span class="ot">=</span> tokens ((<span class="op">==</span>) <span class="ot">`on`</span> CI.mk)</a></code></pre></div>
<p>それらは入力の一定のチャンクにマッチします。 <code>chunk</code> (<code>Text.Megaparsec.Byte</code> と <code>Text.Megaparsec.Char</code> では <code>string</code> と呼ばれる型制約のあるシノニムを使用する) は大文字と小文字を区別しますが、 <code>string'</code> は大文字と小文字を区別しません。 大文字と小文字を区別しない場合のマッチには <code>case-insensitive</code> パッケージが使われているため、 <code>FoldCase</code> 制約があります。</p>
<p>新しいコンビネータも使ってみましょう。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1">λ<span class="op">&gt;</span> parseTest (string <span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> <span class="dt">Parser</span> <span class="dt">Text</span>) <span class="st">&quot;foo&quot;</span></a>
<a class="sourceLine" id="cb14-2" title="2"><span class="st">&quot;foo&quot;</span></a>
<a class="sourceLine" id="cb14-3" title="3"></a>
<a class="sourceLine" id="cb14-4" title="4">λ<span class="op">&gt;</span> parseTest (string <span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> <span class="dt">Parser</span> <span class="dt">Text</span>) <span class="st">&quot;bar&quot;</span></a>
<a class="sourceLine" id="cb14-5" title="5"><span class="dv">1</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span></a>
<a class="sourceLine" id="cb14-6" title="6">  <span class="op">|</span></a>
<a class="sourceLine" id="cb14-7" title="7"><span class="dv">1</span> <span class="op">|</span> bar</a>
<a class="sourceLine" id="cb14-8" title="8">  <span class="op">|</span> <span class="op">^</span></a>
<a class="sourceLine" id="cb14-9" title="9">unexpected <span class="st">&quot;bar&quot;</span></a>
<a class="sourceLine" id="cb14-10" title="10">expecting <span class="st">&quot;foo&quot;</span></a>
<a class="sourceLine" id="cb14-11" title="11"></a>
<a class="sourceLine" id="cb14-12" title="12">λ<span class="op">&gt;</span> parseTest (string' <span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> <span class="dt">Parser</span> <span class="dt">Text</span>) <span class="st">&quot;FOO&quot;</span></a>
<a class="sourceLine" id="cb14-13" title="13"><span class="st">&quot;FOO&quot;</span></a>
<a class="sourceLine" id="cb14-14" title="14"></a>
<a class="sourceLine" id="cb14-15" title="15">λ<span class="op">&gt;</span> parseTest (string' <span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> <span class="dt">Parser</span> <span class="dt">Text</span>) <span class="st">&quot;FoO&quot;</span></a>
<a class="sourceLine" id="cb14-16" title="16"><span class="st">&quot;FoO&quot;</span></a>
<a class="sourceLine" id="cb14-17" title="17"></a>
<a class="sourceLine" id="cb14-18" title="18">λ<span class="op">&gt;</span> parseTest (string' <span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> <span class="dt">Parser</span> <span class="dt">Text</span>) <span class="st">&quot;FoZ&quot;</span></a>
<a class="sourceLine" id="cb14-19" title="19"><span class="dv">1</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span></a>
<a class="sourceLine" id="cb14-20" title="20">  <span class="op">|</span></a>
<a class="sourceLine" id="cb14-21" title="21"><span class="dv">1</span> <span class="op">|</span> <span class="dt">FoZ</span></a>
<a class="sourceLine" id="cb14-22" title="22">  <span class="op">|</span> <span class="op">^</span></a>
<a class="sourceLine" id="cb14-23" title="23">unexpected <span class="st">&quot;FoZ&quot;</span></a>
<a class="sourceLine" id="cb14-24" title="24">expecting <span class="st">&quot;foo&quot;</span></a></code></pre></div>
<p>OK、単一のトークンと入力のチャンクをマッチできました。 次のステップは、より興味深いパーサを書くために 基本的なパーサを組み合わせる方法を学びます。</p>
<p><a name="MonaAp"></a></p>
<h2 id="モナディック構文とアプリカティブ構文">モナディック構文とアプリカティブ構文</h2>
<p>パーサを組み合わせる最も簡単な方法は、それらを逐次実行することです。 <code>ParsecT</code>と<code>Parsec</code>はモナドであり、 モナドでの束縛はパーサを連続で使用することとまったく同じです。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="ot">mySequence ::</span> <span class="dt">Parser</span> (<span class="dt">Char</span>, <span class="dt">Char</span>, <span class="dt">Char</span>)</a>
<a class="sourceLine" id="cb15-2" title="2">mySequence <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb15-3" title="3">  a <span class="ot">&lt;-</span> char <span class="ch">'a'</span></a>
<a class="sourceLine" id="cb15-4" title="4">  b <span class="ot">&lt;-</span> char <span class="ch">'b'</span></a>
<a class="sourceLine" id="cb15-5" title="5">  c <span class="ot">&lt;-</span> char <span class="ch">'c'</span></a>
<a class="sourceLine" id="cb15-6" title="6">  <span class="fu">return</span> (a, b, c)</a></code></pre></div>
<p>これを実行すると、すべてが期待通りに機能することを確認できます。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb16-1" title="1">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> mySequence <span class="st">&quot;abc&quot;</span></a>
<a class="sourceLine" id="cb16-2" title="2"><span class="kw">(</span><span class="st">'a'</span>,<span class="st">'b'</span>,<span class="st">'c'</span><span class="kw">)</span></a>
<a class="sourceLine" id="cb16-3" title="3"></a>
<a class="sourceLine" id="cb16-4" title="4">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> mySequence <span class="st">&quot;bcd&quot;</span></a>
<a class="sourceLine" id="cb16-5" title="5"><span class="ex">1</span>:1:</a>
<a class="sourceLine" id="cb16-6" title="6">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb16-7" title="7"><span class="ex">1</span> <span class="kw">|</span> <span class="ex">bcd</span></a>
<a class="sourceLine" id="cb16-8" title="8">  <span class="kw">|</span> ^</a>
<a class="sourceLine" id="cb16-9" title="9"><span class="ex">unexpected</span> <span class="st">'b'</span></a>
<a class="sourceLine" id="cb16-10" title="10"><span class="ex">expecting</span> <span class="st">'a'</span></a>
<a class="sourceLine" id="cb16-11" title="11"></a>
<a class="sourceLine" id="cb16-12" title="12">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> mySequence <span class="st">&quot;adc&quot;</span></a>
<a class="sourceLine" id="cb16-13" title="13"><span class="ex">1</span>:2:</a>
<a class="sourceLine" id="cb16-14" title="14">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb16-15" title="15"><span class="ex">1</span> <span class="kw">|</span> <span class="ex">adc</span></a>
<a class="sourceLine" id="cb16-16" title="16">  <span class="kw">|</span>  ^</a>
<a class="sourceLine" id="cb16-17" title="17"><span class="ex">unexpected</span> <span class="st">'d'</span></a>
<a class="sourceLine" id="cb16-18" title="18"><span class="ex">expecting</span> <span class="st">'b'</span></a></code></pre></div>
<p>すべてのモナドがアプリカティブファンクターでもあることを覚えていれば、 逐次実行のための代替構文が可能であり、 アプリカティブ構文を使用できます。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="ot">mySequence ::</span> <span class="dt">Parser</span> (<span class="dt">Char</span>, <span class="dt">Char</span>, <span class="dt">Char</span>)</a>
<a class="sourceLine" id="cb17-2" title="2">mySequence <span class="ot">=</span></a>
<a class="sourceLine" id="cb17-3" title="3">  (,,) <span class="op">&lt;$&gt;</span> char <span class="ch">'a'</span></a>
<a class="sourceLine" id="cb17-4" title="4">       <span class="op">&lt;*&gt;</span> char <span class="ch">'b'</span></a>
<a class="sourceLine" id="cb17-5" title="5">       <span class="op">&lt;*&gt;</span> char <span class="ch">'c'</span></a></code></pre></div>
<p>2番目のバージョンは最初のバージョンとまったく同じように機能します。 どちらのスタイルを使うかは、しばしば好みの問題です。 モナディックスタイルは間違いなく冗長で、ときにはより明確ですが、 一方アプリカティブスタイルはより簡潔です。 そうは言っても、モナドはアプリカティブファンクターよりも強力であるため、 モナディックスタイルはもちろんより強力です。</p>
<p><a name="Eof"></a></p>
<h2 id="eof-による入力の強制消費">eof による入力の強制消費</h2>
<p><code>Applicative</code> はとてもおもしろいことをするのに十分強力です。 単位元を持つ結合演算子を備えることで、 Haskell では <code>Alternative</code> 型クラスとして表現される アプリカティブファンクタのモノイドを得ます。 <code>parser-combinators</code> パッケージは <code>Applicative</code> と <code>Alternative</code> の概念に基づき構築された かなりの数の抽象的なコンビネータを提供します。 <code>Text.Megaparsec</code> モジュールはそれらを <code>Control.Applicative.Combinators</code> から再エクスポートします。</p>
<p>最も一般的なコンビネータの1つに、<code>many</code> と呼ばれるものがあります。 それは与えられたパーサを0回以上実行することができます。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb18-1" title="1">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (many (char <span class="st">'a'</span>) :: <span class="ex">Parser</span> [Char]) <span class="st">&quot;aaa&quot;</span></a>
<a class="sourceLine" id="cb18-2" title="2"><span class="st">&quot;aaa&quot;</span></a>
<a class="sourceLine" id="cb18-3" title="3"></a>
<a class="sourceLine" id="cb18-4" title="4">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (many (char <span class="st">'a'</span>) :: <span class="ex">Parser</span> [Char]) <span class="st">&quot;aabbb&quot;</span></a>
<a class="sourceLine" id="cb18-5" title="5"><span class="st">&quot;aa&quot;</span></a></code></pre></div>
<p>2番目の結果は少し驚くかもしれません。 パーサは <code>a</code> が一致したとして消費しましたが、その後停止しました。 <code>many (char 'a')</code> の後に何をしたいのか何も言っていませんでした！</p>
<p>ほとんどの場合は、パーサに入力全体の消費を強制させ、 恥ずかしがり屋で黙ってやめるのではなく、 パースエラーを報告させたいです。 これは、入力の終わりに達することを 要求することによって行われます。 入力の終わりは概念にすぎませんが、 幸いにも <code>eof :: MonadParsec e m =&gt; m ()</code>と呼ばれるプリミティブがあり、 これは何も消費せず、入力の終わりでのみ成功します。 これをパーサに追加してもう一度試してみましょう。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb19-1" title="1">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (many (char <span class="st">'a'</span>) <span class="op">&lt;</span><span class="ex">*</span> eof :: Parser [Char]) <span class="st">&quot;aabbb&quot;</span></a>
<a class="sourceLine" id="cb19-2" title="2"><span class="ex">1</span>:3:</a>
<a class="sourceLine" id="cb19-3" title="3">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb19-4" title="4"><span class="ex">1</span> <span class="kw">|</span> <span class="ex">aabbb</span></a>
<a class="sourceLine" id="cb19-5" title="5">  <span class="kw">|</span>   ^</a>
<a class="sourceLine" id="cb19-6" title="6"><span class="ex">unexpected</span> <span class="st">'b'</span></a>
<a class="sourceLine" id="cb19-7" title="7"><span class="ex">expecting</span> <span class="st">'a'</span> or end of input</a></code></pre></div>
<p>パーサで<code>b</code>について何も言わなかったことにより、 それらは確かに予想外となりました。</p>
<p><a name="Alt"></a></p>
<h2 id="選択肢を使った動作">選択肢を使った動作</h2>
<p>これから、次の形式のURIのパースが可能である実用的なパーサを開発します。</p>
<pre><code>scheme:[//[user:password@]host[:port]][/]path[?query][#fragment]</code></pre>
<p>角括弧 <code>[]</code> の中はオプションであり、それらは有効なURIに現れても現れなくてもよいことを覚えておくべきです。 <code>[]</code> は、ある可能性を別の可能性の中で表現するためにネストすることさえできます。私たちはこのすべてを処理します<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>。</p>
<p><code>scheme</code> から始めましょう。 <code>data</code>、<code>file</code>、<code>ftp</code>、<code>http</code>、<code>https</code>、<code>irc</code>、<code>mailto</code> など、私たちが知っているスキームのみを受け入れます。</p>
<p>一定の文字列と一致させるために、<code>string</code> を使います。 選択を表現するために、<code>Alternative</code> 型クラスの <code>(&lt;|&gt;)</code> メソッドを使います。 次のように書くことができます。</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb21-2" title="2"><span class="ot">{-# LANGUAGE RecordWildCards   #-}</span></a>
<a class="sourceLine" id="cb21-3" title="3"></a>
<a class="sourceLine" id="cb21-4" title="4"><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-5" title="5"></a>
<a class="sourceLine" id="cb21-6" title="6"><span class="kw">import</span> <span class="dt">Control.Applicative</span></a>
<a class="sourceLine" id="cb21-7" title="7"><span class="kw">import</span> <span class="dt">Control.Monad</span></a>
<a class="sourceLine" id="cb21-8" title="8"><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb21-9" title="9"><span class="kw">import</span> <span class="dt">Data.Void</span></a>
<a class="sourceLine" id="cb21-10" title="10"><span class="kw">import</span> <span class="dt">Text.Megaparsec</span> <span class="kw">hiding</span> (<span class="dt">State</span>)</a>
<a class="sourceLine" id="cb21-11" title="11"><span class="kw">import</span> <span class="dt">Text.Megaparsec.Char</span></a>
<a class="sourceLine" id="cb21-12" title="12"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></a>
<a class="sourceLine" id="cb21-13" title="13"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Megaparsec.Char.Lexer</span> <span class="kw">as</span> <span class="dt">L</span></a>
<a class="sourceLine" id="cb21-14" title="14"></a>
<a class="sourceLine" id="cb21-15" title="15"><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Void</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb21-16" title="16"></a>
<a class="sourceLine" id="cb21-17" title="17"><span class="ot">pScheme ::</span> <span class="dt">Parser</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb21-18" title="18">pScheme <span class="ot">=</span> string <span class="st">&quot;data&quot;</span></a>
<a class="sourceLine" id="cb21-19" title="19">  <span class="op">&lt;|&gt;</span> string <span class="st">&quot;file&quot;</span></a>
<a class="sourceLine" id="cb21-20" title="20">  <span class="op">&lt;|&gt;</span> string <span class="st">&quot;ftp&quot;</span></a>
<a class="sourceLine" id="cb21-21" title="21">  <span class="op">&lt;|&gt;</span> string <span class="st">&quot;http&quot;</span></a>
<a class="sourceLine" id="cb21-22" title="22">  <span class="op">&lt;|&gt;</span> string <span class="st">&quot;https&quot;</span></a>
<a class="sourceLine" id="cb21-23" title="23">  <span class="op">&lt;|&gt;</span> string <span class="st">&quot;irc&quot;</span></a>
<a class="sourceLine" id="cb21-24" title="24">  <span class="op">&lt;|&gt;</span> string <span class="st">&quot;mailto&quot;</span></a></code></pre></div>
<p>試してみましょう。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb22-1" title="1">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pScheme <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb22-2" title="2"><span class="ex">1</span>:1:</a>
<a class="sourceLine" id="cb22-3" title="3">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb22-4" title="4"><span class="ex">1</span> <span class="kw">|</span> <span class="op">&lt;</span><span class="ex">empty</span> line<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb22-5" title="5">  <span class="kw">|</span> ^</a>
<a class="sourceLine" id="cb22-6" title="6"><span class="ex">unexpected</span> end of input</a>
<a class="sourceLine" id="cb22-7" title="7"><span class="ex">expecting</span> <span class="st">&quot;data&quot;</span>, <span class="st">&quot;file&quot;</span>, <span class="st">&quot;ftp&quot;</span>, <span class="st">&quot;http&quot;</span>, <span class="st">&quot;https&quot;</span>, <span class="st">&quot;irc&quot;</span>, or <span class="st">&quot;mailto&quot;</span></a>
<a class="sourceLine" id="cb22-8" title="8"></a>
<a class="sourceLine" id="cb22-9" title="9">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pScheme <span class="st">&quot;dat&quot;</span></a>
<a class="sourceLine" id="cb22-10" title="10"><span class="ex">1</span>:1:</a>
<a class="sourceLine" id="cb22-11" title="11">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb22-12" title="12"><span class="ex">1</span> <span class="kw">|</span> <span class="ex">dat</span></a>
<a class="sourceLine" id="cb22-13" title="13">  <span class="kw">|</span> ^</a>
<a class="sourceLine" id="cb22-14" title="14"><span class="ex">unexpected</span> <span class="st">&quot;dat&quot;</span></a>
<a class="sourceLine" id="cb22-15" title="15"><span class="ex">expecting</span> <span class="st">&quot;data&quot;</span>, <span class="st">&quot;file&quot;</span>, <span class="st">&quot;ftp&quot;</span>, <span class="st">&quot;http&quot;</span>, <span class="st">&quot;https&quot;</span>, <span class="st">&quot;irc&quot;</span>, or <span class="st">&quot;mailto&quot;</span></a>
<a class="sourceLine" id="cb22-16" title="16"></a>
<a class="sourceLine" id="cb22-17" title="17">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pScheme <span class="st">&quot;file&quot;</span></a>
<a class="sourceLine" id="cb22-18" title="18"><span class="st">&quot;file&quot;</span></a>
<a class="sourceLine" id="cb22-19" title="19"></a>
<a class="sourceLine" id="cb22-20" title="20">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pScheme <span class="st">&quot;irc&quot;</span></a>
<a class="sourceLine" id="cb22-21" title="21"><span class="st">&quot;irc&quot;</span></a></code></pre></div>
<p>見栄えは良いですが、<code>pScheme</code>の定義は少し反復的です。 <code>choice</code> コンビネータを使って <code>pScheme</code> を書く方法があります。</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" title="1"><span class="ot">pScheme ::</span> <span class="dt">Parser</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb23-2" title="2">pScheme <span class="ot">=</span> choice</a>
<a class="sourceLine" id="cb23-3" title="3">  [ string <span class="st">&quot;data&quot;</span></a>
<a class="sourceLine" id="cb23-4" title="4">  , string <span class="st">&quot;file&quot;</span></a>
<a class="sourceLine" id="cb23-5" title="5">  , string <span class="st">&quot;ftp&quot;</span></a>
<a class="sourceLine" id="cb23-6" title="6">  , string <span class="st">&quot;http&quot;</span></a>
<a class="sourceLine" id="cb23-7" title="7">  , string <span class="st">&quot;https&quot;</span></a>
<a class="sourceLine" id="cb23-8" title="8">  , string <span class="st">&quot;irc&quot;</span></a>
<a class="sourceLine" id="cb23-9" title="9">  , string <span class="st">&quot;mailto&quot;</span> ]</a></code></pre></div>
<p><code>choice</code> は要素間に <code>(&lt;|&gt;)</code> を入れてリストを畳み込む操作である <code>asum</code> の単なるシノニムであり、<code>pScheme</code> の2つの定義は実際には同じです。 <code>choice</code> を使用したほうがが少し良く見えるかもしれません。</p>
<p>スキームの後にはコロン<code>:</code>があるはずです。 何かした後で別の何かを要求するために、 モナドでの束縛またはdo記法を使います。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" title="1"><span class="kw">data</span> <span class="dt">Uri</span> <span class="ot">=</span> <span class="dt">Uri</span></a>
<a class="sourceLine" id="cb24-2" title="2">  {<span class="ot"> uriScheme ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb24-3" title="3">  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb24-4" title="4"></a>
<a class="sourceLine" id="cb24-5" title="5"><span class="ot">pUri ::</span> <span class="dt">Parser</span> <span class="dt">Uri</span></a>
<a class="sourceLine" id="cb24-6" title="6">pUri <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb24-7" title="7">  r <span class="ot">&lt;-</span> pScheme</a>
<a class="sourceLine" id="cb24-8" title="8">  _ <span class="ot">&lt;-</span> char <span class="ch">':'</span></a>
<a class="sourceLine" id="cb24-9" title="9">  <span class="fu">return</span> (<span class="dt">Uri</span> r)</a></code></pre></div>
<p><code>pUri</code>を実行しようとすると、スキーム名の後に <code>:</code> が必要であることがわかります。</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb25-1" title="1">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pUri <span class="st">&quot;irc&quot;</span></a>
<a class="sourceLine" id="cb25-2" title="2"><span class="ex">1</span>:4:</a>
<a class="sourceLine" id="cb25-3" title="3">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb25-4" title="4"><span class="ex">1</span> <span class="kw">|</span> <span class="ex">irc</span></a>
<a class="sourceLine" id="cb25-5" title="5">  <span class="kw">|</span>    ^</a>
<a class="sourceLine" id="cb25-6" title="6"><span class="ex">unexpected</span> end of input</a>
<a class="sourceLine" id="cb25-7" title="7"><span class="ex">expecting</span> <span class="st">':'</span></a>
<a class="sourceLine" id="cb25-8" title="8"></a>
<a class="sourceLine" id="cb25-9" title="9">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pUri <span class="st">&quot;irc:&quot;</span></a>
<a class="sourceLine" id="cb25-10" title="10"><span class="ex">Uri</span> {uriScheme = <span class="st">&quot;irc&quot;</span>}</a></code></pre></div>
<p>しかし、このスキームのパーサは完成していません。 良い Haskell のプログラマーは、 正しくないデータを単純に表現できないように型を定義しようとします。 すべての <code>Text</code> の値が有効なスキームであるとは限りません。 スキームを表すためにデータ型を定義し、 <code>pScheme</code> パーサにその型の値を返させます。</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1"><span class="kw">data</span> <span class="dt">Scheme</span></a>
<a class="sourceLine" id="cb26-2" title="2">  <span class="ot">=</span> <span class="dt">SchemeData</span></a>
<a class="sourceLine" id="cb26-3" title="3">  <span class="op">|</span> <span class="dt">SchemeFile</span></a>
<a class="sourceLine" id="cb26-4" title="4">  <span class="op">|</span> <span class="dt">SchemeFtp</span></a>
<a class="sourceLine" id="cb26-5" title="5">  <span class="op">|</span> <span class="dt">SchemeHttp</span></a>
<a class="sourceLine" id="cb26-6" title="6">  <span class="op">|</span> <span class="dt">SchemeHttps</span></a>
<a class="sourceLine" id="cb26-7" title="7">  <span class="op">|</span> <span class="dt">SchemeIrc</span></a>
<a class="sourceLine" id="cb26-8" title="8">  <span class="op">|</span> <span class="dt">SchemeMailto</span></a>
<a class="sourceLine" id="cb26-9" title="9">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb26-10" title="10"></a>
<a class="sourceLine" id="cb26-11" title="11"><span class="ot">pScheme ::</span> <span class="dt">Parser</span> <span class="dt">Scheme</span></a>
<a class="sourceLine" id="cb26-12" title="12">pScheme <span class="ot">=</span> choice</a>
<a class="sourceLine" id="cb26-13" title="13">  [ <span class="dt">SchemeData</span>   <span class="op">&lt;$</span> string <span class="st">&quot;data&quot;</span></a>
<a class="sourceLine" id="cb26-14" title="14">  , <span class="dt">SchemeFile</span>   <span class="op">&lt;$</span> string <span class="st">&quot;file&quot;</span></a>
<a class="sourceLine" id="cb26-15" title="15">  , <span class="dt">SchemeFtp</span>    <span class="op">&lt;$</span> string <span class="st">&quot;ftp&quot;</span></a>
<a class="sourceLine" id="cb26-16" title="16">  , <span class="dt">SchemeHttp</span>   <span class="op">&lt;$</span> string <span class="st">&quot;http&quot;</span></a>
<a class="sourceLine" id="cb26-17" title="17">  , <span class="dt">SchemeHttps</span>  <span class="op">&lt;$</span> string <span class="st">&quot;https&quot;</span></a>
<a class="sourceLine" id="cb26-18" title="18">  , <span class="dt">SchemeIrc</span>    <span class="op">&lt;$</span> string <span class="st">&quot;irc&quot;</span></a>
<a class="sourceLine" id="cb26-19" title="19">  , <span class="dt">SchemeMailto</span> <span class="op">&lt;$</span> string <span class="st">&quot;mailto&quot;</span> ]</a>
<a class="sourceLine" id="cb26-20" title="20"></a>
<a class="sourceLine" id="cb26-21" title="21"><span class="kw">data</span> <span class="dt">Uri</span> <span class="ot">=</span> <span class="dt">Uri</span></a>
<a class="sourceLine" id="cb26-22" title="22">  {<span class="ot"> uriScheme ::</span> <span class="dt">Scheme</span></a>
<a class="sourceLine" id="cb26-23" title="23">  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p><code>(&lt;$)</code> 演算子は、左側にある値をただちに関数型コンテキストに入れて、 その時点で存在しているものはすべて置き換えます。 <code>a &lt;$ f</code> は <code>const a &lt;$&gt; f</code> と同じですが、 関数によってはより効率的な場合があります。</p>
<p>引き続きパーサを使ってみましょう。</p>
<pre><code>λ&gt; parseTest pUri &quot;https:&quot;
1:5:
  |
1 | https:
  |     ^
unexpected 's'
expecting ':'</code></pre>
<p>うーん、<code>https</code> は有効なスキームであるべきです。 何がいけないのかわかりますか？ パーサは選択肢を一つずつ試し、 <code>http</code> で一致し、 <code>https</code> を試すことはありません。 解決策は、<code>SchemeHttp &lt;$ string "https"</code> という行を <code>SchemeHttp &lt;$ string "http"</code> という行の前に置くことです。 選択肢は順序が重要であることを覚えておいてください！</p>
<p><code>pUri</code> は正しく動作するようになりました。</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb28-1" title="1">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pUri <span class="st">&quot;http:&quot;</span></a>
<a class="sourceLine" id="cb28-2" title="2"><span class="ex">Uri</span> {uriScheme = SchemeHttp}</a>
<a class="sourceLine" id="cb28-3" title="3"></a>
<a class="sourceLine" id="cb28-4" title="4">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pUri <span class="st">&quot;https:&quot;</span></a>
<a class="sourceLine" id="cb28-5" title="5"><span class="ex">Uri</span> {uriScheme = SchemeHttps}</a>
<a class="sourceLine" id="cb28-6" title="6"></a>
<a class="sourceLine" id="cb28-7" title="7">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pUri <span class="st">&quot;mailto:&quot;</span></a>
<a class="sourceLine" id="cb28-8" title="8"><span class="ex">Uri</span> {uriScheme = SchemeMailto}</a>
<a class="sourceLine" id="cb28-9" title="9"></a>
<a class="sourceLine" id="cb28-10" title="10">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pUri <span class="st">&quot;foo:&quot;</span></a>
<a class="sourceLine" id="cb28-11" title="11"><span class="ex">1</span>:1:</a>
<a class="sourceLine" id="cb28-12" title="12">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb28-13" title="13"><span class="ex">1</span> <span class="kw">|</span> <span class="ex">foo</span>:</a>
<a class="sourceLine" id="cb28-14" title="14">  <span class="kw">|</span> ^</a>
<a class="sourceLine" id="cb28-15" title="15"><span class="ex">unexpected</span> <span class="st">&quot;foo:&quot;</span></a>
<a class="sourceLine" id="cb28-16" title="16"><span class="ex">expecting</span> <span class="st">&quot;data&quot;</span>, <span class="st">&quot;file&quot;</span>, <span class="st">&quot;ftp&quot;</span>, <span class="st">&quot;http&quot;</span>, <span class="st">&quot;https&quot;</span>, <span class="st">&quot;irc&quot;</span>, or <span class="st">&quot;mailto&quot;</span></a></code></pre></div>
<p><a name="Try"></a></p>
<h2 id="try-によるバックトラックの制御"><code>try</code> によるバックトラックの制御</h2>
<p>次に扱う部分は <code>[//[user:password@]host[:port]]</code> つまり認証情報です。 オプション部分のネストが含まれるので、 これを反映するように <code>Uri</code> 型 を更新しましょう。</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" title="1"><span class="kw">data</span> <span class="dt">Uri</span> <span class="ot">=</span> <span class="dt">Uri</span></a>
<a class="sourceLine" id="cb29-2" title="2">  {<span class="ot"> uriScheme    ::</span> <span class="dt">Scheme</span></a>
<a class="sourceLine" id="cb29-3" title="3">  ,<span class="ot"> uriAuthority ::</span> <span class="dt">Maybe</span> <span class="dt">Authority</span></a>
<a class="sourceLine" id="cb29-4" title="4">  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb29-5" title="5"></a>
<a class="sourceLine" id="cb29-6" title="6"><span class="kw">data</span> <span class="dt">Authority</span> <span class="ot">=</span> <span class="dt">Authority</span></a>
<a class="sourceLine" id="cb29-7" title="7">  {<span class="ot"> authUser ::</span> <span class="dt">Maybe</span> (<span class="dt">Text</span>, <span class="dt">Text</span>) <span class="co">-- (user, password)</span></a>
<a class="sourceLine" id="cb29-8" title="8">  ,<span class="ot"> authHost ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb29-9" title="9">  ,<span class="ot"> authPort ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb29-10" title="10">  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>ここで、バックトラックと呼ばれる重要な概念について議論する必要があります。 バックトラックは、入力を「消費しない」処理により時間を遡る方法です。 これは主に分岐で重要です。ここに一例を示します。</p>
<pre class="haskel"><code>alternatives :: Parser (Char, Char)
alternatives = foo &lt;|&gt; bar
  where
    foo = (,) &lt;$&gt; char 'a' &lt;*&gt; char 'b'
    bar = (,) &lt;$&gt; char 'a' &lt;*&gt; char 'c'</code></pre>
<p>合理的に見えますが、これを試してみましょう。</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb31-1" title="1">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> alternatives <span class="st">&quot;ab&quot;</span></a>
<a class="sourceLine" id="cb31-2" title="2"><span class="kw">(</span><span class="st">'a'</span>,<span class="st">'b'</span><span class="kw">)</span></a>
<a class="sourceLine" id="cb31-3" title="3"></a>
<a class="sourceLine" id="cb31-4" title="4">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> alternatives <span class="st">&quot;ac&quot;</span></a>
<a class="sourceLine" id="cb31-5" title="5"><span class="ex">1</span>:2:</a>
<a class="sourceLine" id="cb31-6" title="6">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb31-7" title="7"><span class="ex">1</span> <span class="kw">|</span> <span class="ex">ac</span></a>
<a class="sourceLine" id="cb31-8" title="8">  <span class="kw">|</span>  ^</a>
<a class="sourceLine" id="cb31-9" title="9"><span class="ex">unexpected</span> <span class="st">'c'</span></a>
<a class="sourceLine" id="cb31-10" title="10"><span class="ex">expecting</span> <span class="st">'b'</span></a></code></pre></div>
<p>ここで起きたことは、 <code>foo</code> の <code>char 'a'</code> の部分(これが最初に試行されます)の成功と、 入力ストリームからの <code>a</code> の消費です。 <code>char 'b'</code> は <code>'c'</code>とのマッチに失敗したため、エラーになりました。 ここで重要なことは、 <code>foo</code> が何らかの入力を消費しているので <code>(&lt;|&gt;)</code> は <code>bar</code> を試していないということです！</p>
<p>これはパフォーマンス上の理由から行われており、 また、<code>foo</code> の残り物を <code>bar</code> に与えて実行するのは意味が無いです。 <code>bar</code> は <code>foo</code> と同じ場所の入力ストリームから実行したいです。 <code>megaparsec</code> は <code>attoparsec</code> や前の章のトイコンビネータとは異なり、 自動で戻りません。そのため、<code>try</code> と呼ばれるプリミティブを使用して、 明示的にバックトラックしたいという願望を表現する必要があります。 <code>try p</code> は、 <code>p</code> が入力の消費に失敗した場合、 入力が消費されていないかのように失敗します (実際、パーサの状態全体をバックトラックします)。 これにより <code>(&lt;|&gt;)</code> で右側の選択肢を試すことが可能になります。</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" title="1"><span class="ot">alternatives ::</span> <span class="dt">Parser</span> (<span class="dt">Char</span>, <span class="dt">Char</span>)</a>
<a class="sourceLine" id="cb32-2" title="2">alternatives <span class="ot">=</span> try foo <span class="op">&lt;|&gt;</span> bar</a>
<a class="sourceLine" id="cb32-3" title="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-4" title="4">    foo <span class="ot">=</span> (,) <span class="op">&lt;$&gt;</span> char <span class="ch">'a'</span> <span class="op">&lt;*&gt;</span> char <span class="ch">'b'</span></a>
<a class="sourceLine" id="cb32-5" title="5">    bar <span class="ot">=</span> (,) <span class="op">&lt;$&gt;</span> char <span class="ch">'a'</span> <span class="op">&lt;*&gt;</span> char <span class="ch">'c'</span></a></code></pre></div>
<div class="sourceCode" id="cb33"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb33-1" title="1">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> alternatives <span class="st">&quot;ac&quot;</span></a>
<a class="sourceLine" id="cb33-2" title="2"><span class="kw">(</span><span class="st">'a'</span>,<span class="st">'c'</span><span class="kw">)</span></a></code></pre></div>
<p>実際に入力を消費するすべてのプリミティブ （<code>try</code> などの既存のパーサの動作を変更するプリミティブもあります）は、 入力の消費という点で「アトミック」です。 これは、失敗した場合に自動的にバックトラックするため、 入力を消費して途中で失敗することはできないことを意味します。 これが、<code>pScheme</code> の選択肢のリストが機能する理由です。 つまり、<code>string</code> は <code>tokens</code> の上に定義され、<code>tokens</code> はプリミティブです。 文字列全体を <code>string</code> でマッチさせるか、 入力ストリームをまったく消費せずに失敗します。</p>
<p>URIのパースに戻ると、 <code>(&lt;|&gt;)</code> を使った <code>optional</code> という便利なコンビネータを作ることができます。</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" title="1"><span class="ot">optional ::</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f (<span class="dt">Maybe</span> a)</a>
<a class="sourceLine" id="cb34-2" title="2">optional p <span class="ot">=</span> (<span class="dt">Just</span> <span class="op">&lt;$&gt;</span> p) <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> <span class="dt">Nothing</span></a></code></pre></div>
<p><code>optional p</code> の <code>p</code> でマッチすれば、結果は <code>Just</code> になります。 そうでなければ <code>Nothing</code> が返されます。 ちょうど欲ほしかったものです！ <code>optional</code> を定義する必要はありません、 <code>Text.Megaparsec</code> はこのコンビネータを再エクスポートします。 これを <code>pUri</code> で使うことができます。</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" title="1"><span class="ot">pUri ::</span> <span class="dt">Parser</span> <span class="dt">Uri</span></a>
<a class="sourceLine" id="cb35-2" title="2">pUri <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb35-3" title="3">  uriScheme <span class="ot">&lt;-</span> pScheme</a>
<a class="sourceLine" id="cb35-4" title="4">  void (char <span class="ch">':'</span>)</a>
<a class="sourceLine" id="cb35-5" title="5">  uriAuthority <span class="ot">&lt;-</span> optional <span class="op">.</span> try <span class="op">$</span> <span class="kw">do</span>            <span class="co">-- (1)</span></a>
<a class="sourceLine" id="cb35-6" title="6">    void (string <span class="st">&quot;//&quot;</span>)</a>
<a class="sourceLine" id="cb35-7" title="7">    authUser <span class="ot">&lt;-</span> optional <span class="op">.</span> try <span class="op">$</span> <span class="kw">do</span>              <span class="co">-- (2)</span></a>
<a class="sourceLine" id="cb35-8" title="8">      user <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar       <span class="co">-- (3)</span></a>
<a class="sourceLine" id="cb35-9" title="9">      void (char <span class="ch">':'</span>)</a>
<a class="sourceLine" id="cb35-10" title="10">      password <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar</a>
<a class="sourceLine" id="cb35-11" title="11">      void (char <span class="ch">'@'</span>)</a>
<a class="sourceLine" id="cb35-12" title="12">      <span class="fu">return</span> (user, password)</a>
<a class="sourceLine" id="cb35-13" title="13">    authHost <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some (alphaNumChar <span class="op">&lt;|&gt;</span> char <span class="ch">'.'</span>)</a>
<a class="sourceLine" id="cb35-14" title="14">    authPort <span class="ot">&lt;-</span> optional (char <span class="ch">':'</span> <span class="op">*&gt;</span> L.decimal) <span class="co">-- (4)</span></a>
<a class="sourceLine" id="cb35-15" title="15">    <span class="fu">return</span> <span class="dt">Authority</span> {<span class="op">..</span>}                        <span class="co">-- (5)</span></a>
<a class="sourceLine" id="cb35-16" title="16">  <span class="fu">return</span> <span class="dt">Uri</span> {<span class="op">..</span>}                                <span class="co">-- (6)</span></a></code></pre></div>
<p>ユーザー名とパスワードとして 任意の英数字の文字列を受け入れることができるようにし、 同様にホストの形式を単純化しました。</p>
<p>以下に重要な点を挙げます。</p>
<ul>
<li><ol type="1">
<li>と (2) では、 <code>optional</code> の引数を <code>try</code> でラップする必要があります。 これは複合パーサであり、プリミティブではないためです。</li>
</ol></li>
<li><ol start="3" type="1">
<li><code>some</code> は <code>many</code> に似ていますが、その引数のパーサが少なくとも一度はマッチすることを要求します(<code>some p =（:) &lt;$&gt; p &lt;*&gt; many p</code>)。</li>
</ol></li>
<li><ol start="4" type="1">
<li>必要でない限り <code>try</code> を使わないでください！ここでは <code>char ':'</code> が成功すると (<code>token</code> の上に構築されているので, <code>try</code> は必要はありません)、そのあとに必ずポートが続かなければならないことがわかっているので、<code>L.decimal</code> により 10進数を要求します。<code>:</code> にマッチした後は、後戻りできないので、戻る方法は必要ありません。</li>
</ol></li>
<li><ol start="5" type="1">
<li>と (6) では、<code>RecordWildCards</code> 言語拡張を使用して <code>Authority</code> と <code>Uri</code> の値を作り上げます。</li>
</ol></li>
</ul>
<p>GHCiで <code>pUri</code> を試し、それが機能することを確認してください。</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb36-1" title="1">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pUri <span class="op">&lt;</span>* eof) <span class="st">&quot;https://mark:secret@example.com&quot;</span></a>
<a class="sourceLine" id="cb36-2" title="2"><span class="ex">Uri</span></a>
<a class="sourceLine" id="cb36-3" title="3">  <span class="kw">{</span> <span class="ex">uriScheme</span> = SchemeHttps</a>
<a class="sourceLine" id="cb36-4" title="4">  , <span class="ex">uriAuthority</span> = Just (Authority</a>
<a class="sourceLine" id="cb36-5" title="5">    <span class="kw">{</span> <span class="ex">authUser</span> = Just (<span class="st">&quot;mark&quot;</span>,<span class="st">&quot;secret&quot;</span>)</a>
<a class="sourceLine" id="cb36-6" title="6">    , <span class="ex">authHost</span> = <span class="st">&quot;example.com&quot;</span></a>
<a class="sourceLine" id="cb36-7" title="7">    , <span class="ex">authPort</span> = Nothing <span class="kw">}</span> ) <span class="kw">}</span></a>
<a class="sourceLine" id="cb36-8" title="8"></a>
<a class="sourceLine" id="cb36-9" title="9">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pUri <span class="op">&lt;</span>* eof) <span class="st">&quot;https://mark:secret@example.com:123&quot;</span></a>
<a class="sourceLine" id="cb36-10" title="10"><span class="ex">Uri</span></a>
<a class="sourceLine" id="cb36-11" title="11">  <span class="kw">{</span> <span class="ex">uriScheme</span> = SchemeHttps</a>
<a class="sourceLine" id="cb36-12" title="12">  , <span class="ex">uriAuthority</span> = Just (Authority</a>
<a class="sourceLine" id="cb36-13" title="13">    <span class="kw">{</span> <span class="ex">authUser</span> = Just (<span class="st">&quot;mark&quot;</span>,<span class="st">&quot;secret&quot;</span>)</a>
<a class="sourceLine" id="cb36-14" title="14">    , <span class="ex">authHost</span> = <span class="st">&quot;example.com&quot;</span></a>
<a class="sourceLine" id="cb36-15" title="15">    , <span class="ex">authPort</span> = Just 123 <span class="kw">}</span> ) <span class="kw">}</span></a>
<a class="sourceLine" id="cb36-16" title="16"></a>
<a class="sourceLine" id="cb36-17" title="17">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pUri <span class="op">&lt;</span>* eof) <span class="st">&quot;https://example.com:123&quot;</span></a>
<a class="sourceLine" id="cb36-18" title="18"><span class="ex">Uri</span></a>
<a class="sourceLine" id="cb36-19" title="19">  <span class="kw">{</span> <span class="ex">uriScheme</span> = SchemeHttps</a>
<a class="sourceLine" id="cb36-20" title="20">  , <span class="ex">uriAuthority</span> = Just (Authority</a>
<a class="sourceLine" id="cb36-21" title="21">    <span class="kw">{</span> <span class="ex">authUser</span> = Nothing</a>
<a class="sourceLine" id="cb36-22" title="22">    , <span class="ex">authHost</span> = <span class="st">&quot;example.com&quot;</span></a>
<a class="sourceLine" id="cb36-23" title="23">    , <span class="ex">authPort</span> = Just 123 <span class="kw">}</span> ) <span class="kw">}</span></a>
<a class="sourceLine" id="cb36-24" title="24"></a>
<a class="sourceLine" id="cb36-25" title="25">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pUri <span class="op">&lt;</span>* eof) <span class="st">&quot;https://mark@example.com:123&quot;</span></a>
<a class="sourceLine" id="cb36-26" title="26"><span class="ex">1</span>:13:</a>
<a class="sourceLine" id="cb36-27" title="27">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb36-28" title="28"><span class="ex">1</span> <span class="kw">|</span> <span class="ex">https</span>://mark@example.com:123</a>
<a class="sourceLine" id="cb36-29" title="29">  <span class="kw">|</span>             ^</a>
<a class="sourceLine" id="cb36-30" title="30"><span class="ex">unexpected</span> <span class="st">'@'</span></a>
<a class="sourceLine" id="cb36-31" title="31"><span class="ex">expecting</span> <span class="st">'.'</span>, <span class="st">':'</span>, alphanumeric character, or end of input</a></code></pre></div>
<p><a name="Debug"></a></p>
<h2 id="パーサのデバッグ">パーサのデバッグ</h2>
<p>面白いことが起こっていることに気付くかもしれません。</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" title="1">λ<span class="op">&gt;</span> parseTest (pUri <span class="op">&lt;*</span> eof) <span class="st">&quot;https://mark:@example.com&quot;</span></a>
<a class="sourceLine" id="cb37-2" title="2"><span class="dv">1</span><span class="op">:</span><span class="dv">7</span><span class="op">:</span></a>
<a class="sourceLine" id="cb37-3" title="3">  <span class="op">|</span></a>
<a class="sourceLine" id="cb37-4" title="4"><span class="dv">1</span> <span class="op">|</span> https<span class="op">://</span>mark<span class="op">:@</span>example<span class="op">.</span>com</a>
<a class="sourceLine" id="cb37-5" title="5">  <span class="op">|</span>       <span class="op">^</span></a>
<a class="sourceLine" id="cb37-6" title="6">unexpected <span class="ch">'/'</span></a>
<a class="sourceLine" id="cb37-7" title="7">expecting end <span class="kw">of</span> input</a></code></pre></div>
<p>パースエラーを改善できそうです。何をすればいいでしょうか？ 何が起きているのかを知る最も簡単な方法は、 組み込みのヘルパー <code>dbg</code> を使うことです。</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" title="1"><span class="ot">dbg ::</span> (<span class="dt">Stream</span> s, <span class="dt">ShowToken</span> (<span class="dt">Token</span> s), <span class="dt">ShowErrorComponent</span> e, <span class="dt">Show</span> a)</a>
<a class="sourceLine" id="cb38-2" title="2">  <span class="ot">=&gt;</span> <span class="dt">String</span>            <span class="co">-- ^ デバッグ用のラベル</span></a>
<a class="sourceLine" id="cb38-3" title="3">  <span class="ot">-&gt;</span> <span class="dt">ParsecT</span> e s m a   <span class="co">-- ^ デバッグするパーサ</span></a>
<a class="sourceLine" id="cb38-4" title="4">  <span class="ot">-&gt;</span> <span class="dt">ParsecT</span> e s m a   <span class="co">-- ^ デバッグメッセージを出力するパーサ</span></a></code></pre></div>
<p>これを <code>pUri</code> で使ってみましょう。</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" title="1"><span class="ot">pUri ::</span> <span class="dt">Parser</span> <span class="dt">Uri</span></a>
<a class="sourceLine" id="cb39-2" title="2">pUri <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb39-3" title="3">  uriScheme <span class="ot">&lt;-</span> dbg <span class="st">&quot;scheme&quot;</span> pScheme</a>
<a class="sourceLine" id="cb39-4" title="4">  void (char <span class="ch">':'</span>)</a>
<a class="sourceLine" id="cb39-5" title="5">  uriAuthority <span class="ot">&lt;-</span> dbg <span class="st">&quot;auth&quot;</span> <span class="op">.</span> optional <span class="op">.</span> try <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb39-6" title="6">    void (string <span class="st">&quot;//&quot;</span>)</a>
<a class="sourceLine" id="cb39-7" title="7">    authUser <span class="ot">&lt;-</span> dbg <span class="st">&quot;user&quot;</span> <span class="op">.</span> optional <span class="op">.</span> try <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb39-8" title="8">      user <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar</a>
<a class="sourceLine" id="cb39-9" title="9">      void (char <span class="ch">':'</span>)</a>
<a class="sourceLine" id="cb39-10" title="10">      password <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar</a>
<a class="sourceLine" id="cb39-11" title="11">      void (char <span class="ch">'@'</span>)</a>
<a class="sourceLine" id="cb39-12" title="12">      <span class="fu">return</span> (user, password)</a>
<a class="sourceLine" id="cb39-13" title="13">    authHost <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> dbg <span class="st">&quot;host&quot;</span> (some (alphaNumChar <span class="op">&lt;|&gt;</span> char <span class="ch">'.'</span>))</a>
<a class="sourceLine" id="cb39-14" title="14">    authPort <span class="ot">&lt;-</span> dbg <span class="st">&quot;port&quot;</span> <span class="op">$</span> optional (char <span class="ch">':'</span> <span class="op">*&gt;</span> L.decimal)</a>
<a class="sourceLine" id="cb39-15" title="15">    <span class="fu">return</span> <span class="dt">Authority</span> {<span class="op">..</span>}</a>
<a class="sourceLine" id="cb39-16" title="16">  <span class="fu">return</span> <span class="dt">Uri</span> {<span class="op">..</span>}</a></code></pre></div>
<p>それでは、その不幸な入力に対してもう一度 <code>pUri</code> を実行してみましょう。</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" title="1">λ<span class="op">&gt;</span> parseTest (pUri <span class="op">&lt;*</span> eof) <span class="st">&quot;https://mark:@example.com&quot;</span></a>
<a class="sourceLine" id="cb40-2" title="2">scheme<span class="op">&gt;</span> <span class="dt">IN</span><span class="op">:</span> <span class="st">&quot;https://mark:@example.com&quot;</span></a>
<a class="sourceLine" id="cb40-3" title="3">scheme<span class="op">&gt;</span> <span class="dt">MATCH</span> (<span class="dt">COK</span>)<span class="op">:</span> <span class="st">&quot;https&quot;</span></a>
<a class="sourceLine" id="cb40-4" title="4">scheme<span class="op">&gt;</span> <span class="dt">VALUE</span><span class="op">:</span> <span class="dt">SchemeHttps</span></a>
<a class="sourceLine" id="cb40-5" title="5"></a>
<a class="sourceLine" id="cb40-6" title="6">user<span class="op">&gt;</span> <span class="dt">IN</span><span class="op">:</span> <span class="st">&quot;mark:@example.com&quot;</span></a>
<a class="sourceLine" id="cb40-7" title="7">user<span class="op">&gt;</span> <span class="dt">MATCH</span> (<span class="dt">EOK</span>)<span class="op">:</span> <span class="op">&lt;</span><span class="dt">EMPTY</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb40-8" title="8">user<span class="op">&gt;</span> <span class="dt">VALUE</span><span class="op">:</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb40-9" title="9"></a>
<a class="sourceLine" id="cb40-10" title="10">host<span class="op">&gt;</span> <span class="dt">IN</span><span class="op">:</span> <span class="st">&quot;mark:@example.com&quot;</span></a>
<a class="sourceLine" id="cb40-11" title="11">host<span class="op">&gt;</span> <span class="dt">MATCH</span> (<span class="dt">COK</span>)<span class="op">:</span> <span class="st">&quot;mark&quot;</span></a>
<a class="sourceLine" id="cb40-12" title="12">host<span class="op">&gt;</span> <span class="dt">VALUE</span><span class="op">:</span> <span class="st">&quot;mark&quot;</span></a>
<a class="sourceLine" id="cb40-13" title="13"></a>
<a class="sourceLine" id="cb40-14" title="14">port<span class="op">&gt;</span> <span class="dt">IN</span><span class="op">:</span> <span class="st">&quot;:@example.com&quot;</span></a>
<a class="sourceLine" id="cb40-15" title="15">port<span class="op">&gt;</span> <span class="dt">MATCH</span> (<span class="dt">CERR</span>)<span class="op">:</span> <span class="ch">':'</span></a>
<a class="sourceLine" id="cb40-16" title="16">port<span class="op">&gt;</span> <span class="dt">ERROR</span><span class="op">:</span></a>
<a class="sourceLine" id="cb40-17" title="17">port<span class="op">&gt;</span> <span class="dv">1</span><span class="op">:</span><span class="dv">14</span><span class="op">:</span></a>
<a class="sourceLine" id="cb40-18" title="18">port<span class="op">&gt;</span> unexpected <span class="ch">'@'</span></a>
<a class="sourceLine" id="cb40-19" title="19">port<span class="op">&gt;</span> expecting integer</a>
<a class="sourceLine" id="cb40-20" title="20"></a>
<a class="sourceLine" id="cb40-21" title="21">auth<span class="op">&gt;</span> <span class="dt">IN</span><span class="op">:</span> <span class="st">&quot;//mark:@example.com&quot;</span></a>
<a class="sourceLine" id="cb40-22" title="22">auth<span class="op">&gt;</span> <span class="dt">MATCH</span> (<span class="dt">EOK</span>)<span class="op">:</span> <span class="op">&lt;</span><span class="dt">EMPTY</span><span class="op">&gt;</span></a>
<a class="sourceLine" id="cb40-23" title="23">auth<span class="op">&gt;</span> <span class="dt">VALUE</span><span class="op">:</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb40-24" title="24"></a>
<a class="sourceLine" id="cb40-25" title="25"><span class="dv">1</span><span class="op">:</span><span class="dv">7</span><span class="op">:</span></a>
<a class="sourceLine" id="cb40-26" title="26">  <span class="op">|</span></a>
<a class="sourceLine" id="cb40-27" title="27"><span class="dv">1</span> <span class="op">|</span> https<span class="op">://</span>mark<span class="op">:@</span>example<span class="op">.</span>com</a>
<a class="sourceLine" id="cb40-28" title="28">  <span class="op">|</span>       <span class="op">^</span></a>
<a class="sourceLine" id="cb40-29" title="29">unexpected <span class="ch">'/'</span></a>
<a class="sourceLine" id="cb40-30" title="30">expecting end <span class="kw">of</span> input</a></code></pre></div>
<p><code>megaparsec</code> の内部で何が起こっているのか正確にわかります。</p>
<ul>
<li><p><code>scheme</code> のマッチに成功します。</p></li>
<li><p><code>user</code> は失敗します。<code>mark</code> の所にユーザー名がありますが、<code>:</code> の後にパスワードはありません（ここではパスワードを空にしないことを要求します）。失敗し、<code>try</code> のおかげでバックトラックします。</p></li>
<li><p><code>host</code> は <code>user</code> と同じ場所から開始し、入力をホスト名として解釈しようとします。これは成功し、ホスト名として <code>mark</code> を返すことがわかります。</p></li>
<li><p><code>host</code> の後にポート番号があるかもしれないので、<code>port</code> は機会を得ます。それは <code>:</code> を見ますが、その後に整数がないので <code>port</code> は失敗します。</p></li>
<li><p>そのため、<code>auth</code> パーサ全体が失敗します（<code>port</code> は <code>auth</code> の内側にあり、失敗しました）。</p></li>
<li><p><code>auth</code> パーサは、何もパースできなかったため、<code>Nothing</code>を返します。<code>eof</code> は入力の終わりに達したことを要求しますが、そうではないので、最終的なエラーメッセージが表示されます。</p></li>
</ul>
<p>何をすべきでしょうか？これは、<code>try</code> を使用してコードの大部分を囲むと、 パースエラーが悪化する可能性がある場合の例です。 パースしたい構文をもう一度見てみましょう。</p>
<pre><code>scheme:[//[user:password@]host[:port]][/]path[?query][#fragment]</code></pre>
<p>私たちは何を探していますか？ パースのある特定の分岐にコミットできるようにするための何か。 <code>:</code> を見たときにポート番号が続かなければならないポートのように。 注意深く見れば、二重スラッシュ<code>//</code>が、URIに認証情報の部分があることを示す記号であることがわかります。 <code>//</code> のマッチはアトミックパーサ（<code>string</code>）が使われていることにより、 マッチは自動的にバックトラックするので、 <code>//</code> にマッチした後は恐れずに、認証情報の部分を要求することができます。 最初の<code>try</code>を<code>pUri</code>から削除しましょう。</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" title="1"><span class="ot">pUri ::</span> <span class="dt">Parser</span> <span class="dt">Uri</span></a>
<a class="sourceLine" id="cb42-2" title="2">pUri <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb42-3" title="3">  uriScheme <span class="ot">&lt;-</span> pScheme</a>
<a class="sourceLine" id="cb42-4" title="4">  void (char <span class="ch">':'</span>)</a>
<a class="sourceLine" id="cb42-5" title="5">  uriAuthority <span class="ot">&lt;-</span> optional <span class="op">$</span> <span class="kw">do</span> <span class="co">-- この行から try を削除した</span></a>
<a class="sourceLine" id="cb42-6" title="6">    void (string <span class="st">&quot;//&quot;</span>)</a>
<a class="sourceLine" id="cb42-7" title="7">    authUser <span class="ot">&lt;-</span> optional <span class="op">.</span> try <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb42-8" title="8">      user <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar</a>
<a class="sourceLine" id="cb42-9" title="9">      void (char <span class="ch">':'</span>)</a>
<a class="sourceLine" id="cb42-10" title="10">      password <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar</a>
<a class="sourceLine" id="cb42-11" title="11">      void (char <span class="ch">'@'</span>)</a>
<a class="sourceLine" id="cb42-12" title="12">      <span class="fu">return</span> (user, password)</a>
<a class="sourceLine" id="cb42-13" title="13">    authHost <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some (alphaNumChar <span class="op">&lt;|&gt;</span> char <span class="ch">'.'</span>)</a>
<a class="sourceLine" id="cb42-14" title="14">    authPort <span class="ot">&lt;-</span> optional (char <span class="ch">':'</span> <span class="op">*&gt;</span> L.decimal)</a>
<a class="sourceLine" id="cb42-15" title="15">    <span class="fu">return</span> <span class="dt">Authority</span> {<span class="op">..</span>}</a>
<a class="sourceLine" id="cb42-16" title="16">  <span class="fu">return</span> <span class="dt">Uri</span> {<span class="op">..</span>}</a></code></pre></div>
<p>これで、より良いパースエラーを得られるようになりました。</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb43-1" title="1">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pUri <span class="op">&lt;</span>* eof) <span class="st">&quot;https://mark:@example.com&quot;</span></a>
<a class="sourceLine" id="cb43-2" title="2"><span class="ex">1</span>:14:</a>
<a class="sourceLine" id="cb43-3" title="3">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb43-4" title="4"><span class="ex">1</span> <span class="kw">|</span> <span class="ex">https</span>://mark:@example.com</a>
<a class="sourceLine" id="cb43-5" title="5">  <span class="kw">|</span>              ^</a>
<a class="sourceLine" id="cb43-6" title="6"><span class="ex">unexpected</span> <span class="st">'@'</span></a>
<a class="sourceLine" id="cb43-7" title="7"><span class="ex">expecting</span> integer</a></code></pre></div>
<p>まだ少し誤解を招くようですが、まあ、それは私が選んだトリッキーな例です。 たくさんの<code>optional</code>。</p>
<p><a name="Label"></a></p>
<h2 id="ラベル付けと隠蔽">ラベル付けと隠蔽</h2>
<p>時には期待されるアイテムのリストがかなり長くなるかもしれません。 認識されていないスキームを使用しようとしたときに得られるものを覚えていますか？</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb44-1" title="1">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pUri <span class="op">&lt;</span>* eof) <span class="st">&quot;foo://example.com&quot;</span></a>
<a class="sourceLine" id="cb44-2" title="2"><span class="ex">1</span>:1:</a>
<a class="sourceLine" id="cb44-3" title="3">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb44-4" title="4"><span class="ex">1</span> <span class="kw">|</span> <span class="ex">foo</span>://example.com</a>
<a class="sourceLine" id="cb44-5" title="5">  <span class="kw">|</span> ^</a>
<a class="sourceLine" id="cb44-6" title="6"><span class="ex">unexpected</span> <span class="st">&quot;foo://&quot;</span></a>
<a class="sourceLine" id="cb44-7" title="7"><span class="ex">expecting</span> <span class="st">&quot;data&quot;</span>, <span class="st">&quot;file&quot;</span>, <span class="st">&quot;ftp&quot;</span>, <span class="st">&quot;http&quot;</span>, <span class="st">&quot;https&quot;</span>, <span class="st">&quot;irc&quot;</span>, or <span class="st">&quot;mailto&quot;</span></a></code></pre></div>
<p><code>megaparsec</code> は、一般的に<em>ラベル</em>と呼ばれるカスタムで、期待されるアイテムを上書きする方法を提供します。これは、<code>label</code> プリミティブ(<code>(&lt;?&gt;)</code> 演算子の形式のシノニムを持つ)を使用して行われます。</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" title="1"><span class="ot">pUri ::</span> <span class="dt">Parser</span> <span class="dt">Uri</span></a>
<a class="sourceLine" id="cb45-2" title="2">pUri <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb45-3" title="3">  uriScheme <span class="ot">&lt;-</span> pScheme <span class="op">&lt;?&gt;</span> <span class="st">&quot;valid scheme&quot;</span></a>
<a class="sourceLine" id="cb45-4" title="4">  <span class="co">-- 残りの部分は同じ</span></a></code></pre></div>
<div class="sourceCode" id="cb46"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb46-1" title="1">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pUri <span class="op">&lt;</span>* eof) <span class="st">&quot;foo://example.com&quot;</span></a>
<a class="sourceLine" id="cb46-2" title="2"><span class="ex">1</span>:1:</a>
<a class="sourceLine" id="cb46-3" title="3">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb46-4" title="4"><span class="ex">1</span> <span class="kw">|</span> <span class="ex">foo</span>://example.com</a>
<a class="sourceLine" id="cb46-5" title="5">  <span class="kw">|</span> ^</a>
<a class="sourceLine" id="cb46-6" title="6"><span class="ex">unexpected</span> <span class="st">&quot;foo://&quot;</span></a>
<a class="sourceLine" id="cb46-7" title="7"><span class="ex">expecting</span> valid scheme</a></code></pre></div>
<p>エラーメッセージを読みやすくするために、ラベルを追加します。</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" title="1"><span class="ot">pUri ::</span> <span class="dt">Parser</span> <span class="dt">Uri</span></a>
<a class="sourceLine" id="cb47-2" title="2">pUri <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb47-3" title="3">  uriScheme <span class="ot">&lt;-</span> pScheme <span class="op">&lt;?&gt;</span> <span class="st">&quot;valid scheme&quot;</span></a>
<a class="sourceLine" id="cb47-4" title="4">  void (char <span class="ch">':'</span>)</a>
<a class="sourceLine" id="cb47-5" title="5">  uriAuthority <span class="ot">&lt;-</span> optional <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb47-6" title="6">    void (string <span class="st">&quot;//&quot;</span>)</a>
<a class="sourceLine" id="cb47-7" title="7">    authUser <span class="ot">&lt;-</span> optional <span class="op">.</span> try <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb47-8" title="8">      user <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar <span class="op">&lt;?&gt;</span> <span class="st">&quot;username&quot;</span></a>
<a class="sourceLine" id="cb47-9" title="9">      void (char <span class="ch">':'</span>)</a>
<a class="sourceLine" id="cb47-10" title="10">      password <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar <span class="op">&lt;?&gt;</span> <span class="st">&quot;password&quot;</span></a>
<a class="sourceLine" id="cb47-11" title="11">      void (char <span class="ch">'@'</span>)</a>
<a class="sourceLine" id="cb47-12" title="12">      <span class="fu">return</span> (user, password)</a>
<a class="sourceLine" id="cb47-13" title="13">    authHost <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some (alphaNumChar <span class="op">&lt;|&gt;</span> char <span class="ch">'.'</span>) <span class="op">&lt;?&gt;</span> <span class="st">&quot;hostname&quot;</span></a>
<a class="sourceLine" id="cb47-14" title="14">    authPort <span class="ot">&lt;-</span> optional (char <span class="ch">':'</span> <span class="op">*&gt;</span> label <span class="st">&quot;port number&quot;</span> L.decimal)</a>
<a class="sourceLine" id="cb47-15" title="15">    <span class="fu">return</span> <span class="dt">Authority</span> {<span class="op">..</span>}</a>
<a class="sourceLine" id="cb47-16" title="16">  <span class="fu">return</span> <span class="dt">Uri</span> {<span class="op">..</span>}</a></code></pre></div>
<p>例:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb48-1" title="1">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pUri <span class="op">&lt;</span>* eof) <span class="st">&quot;https://mark:@example.com&quot;</span></a>
<a class="sourceLine" id="cb48-2" title="2"><span class="ex">1</span>:14:</a>
<a class="sourceLine" id="cb48-3" title="3">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb48-4" title="4"><span class="ex">1</span> <span class="kw">|</span> <span class="ex">https</span>://mark:@example.com</a>
<a class="sourceLine" id="cb48-5" title="5">  <span class="kw">|</span>              ^</a>
<a class="sourceLine" id="cb48-6" title="6"><span class="ex">unexpected</span> <span class="st">'@'</span></a>
<a class="sourceLine" id="cb48-7" title="7"><span class="ex">expecting</span> port number</a></code></pre></div>
<p>もう1つのプリミティブは <code>hidden</code> と呼ばれます。 <code>label</code> が名前の変更であることに対し、 hiddenは単にそれらを完全に削除します。 比較しましょう。</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb49-1" title="1">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (many (char <span class="st">'a'</span>) <span class="op">&gt;&gt;</span> <span class="ex">many</span> (char <span class="st">'b'</span>) <span class="op">&gt;&gt;</span> <span class="ex">eof</span> :: Parser ()) <span class="st">&quot;d&quot;</span></a>
<a class="sourceLine" id="cb49-2" title="2"><span class="ex">1</span>:1:</a>
<a class="sourceLine" id="cb49-3" title="3">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb49-4" title="4"><span class="ex">1</span> <span class="kw">|</span> <span class="ex">d</span></a>
<a class="sourceLine" id="cb49-5" title="5">  <span class="kw">|</span> ^</a>
<a class="sourceLine" id="cb49-6" title="6"><span class="ex">unexpected</span> <span class="st">'d'</span></a>
<a class="sourceLine" id="cb49-7" title="7"><span class="ex">expecting</span> <span class="st">'a'</span>, <span class="st">'b'</span>, or end of input</a>
<a class="sourceLine" id="cb49-8" title="8"></a>
<a class="sourceLine" id="cb49-9" title="9">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (many (char <span class="st">'a'</span>) <span class="op">&gt;&gt;</span> <span class="ex">hidden</span> (many (char <span class="st">'b'</span>)) <span class="op">&gt;&gt;</span> <span class="ex">eof</span> :: Parser ()) <span class="st">&quot;d&quot;</span></a>
<a class="sourceLine" id="cb49-10" title="10"><span class="ex">1</span>:1:</a>
<a class="sourceLine" id="cb49-11" title="11">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb49-12" title="12"><span class="ex">1</span> <span class="kw">|</span> <span class="ex">d</span></a>
<a class="sourceLine" id="cb49-13" title="13">  <span class="kw">|</span> ^</a>
<a class="sourceLine" id="cb49-14" title="14"><span class="ex">unexpected</span> <span class="st">'d'</span></a>
<a class="sourceLine" id="cb49-15" title="15"><span class="ex">expecting</span> <span class="st">'a'</span> or end of input</a></code></pre></div>
<p>エラーメッセージのノイズを少なくすることが望ましい場合は、 <code>hidden</code> を使用してください。 例えば、プログラミング言語をパースするときは、通常、各トークンの後に空白文字がある可能性があるため、“expecting white space” というメッセージを削除することをお勧めします。</p>
<p>演習 : <code>pUri</code> パーサを完成させることは読者のための課題として残されています。完成に必要なすべてのツールは説明されました。</p>
<p><a name="Run"></a></p>
<h2 id="パーサの実行">パーサの実行</h2>
<p>パーサを構築する方法を詳細に調べました。 しかし、 <code>parseTest</code> を除いて、 それらを実行できる関数を調べていませんでした。</p>
<p>慣習的に、あなたがプログラムしたパーサを実行するための “デフォルト”の関数は <code>parse</code> でした。 しかし、<code>parse</code> は実際には <code>runParser</code> のシノニムです。</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb50-1" title="1">runParser</a>
<a class="sourceLine" id="cb50-2" title="2"><span class="ot">  ::</span> <span class="dt">Parsec</span> e s a <span class="co">-- ^ 実行するパーサ</span></a>
<a class="sourceLine" id="cb50-3" title="3">  <span class="ot">-&gt;</span> <span class="dt">String</span>     <span class="co">-- ^ ソースファイルの名前</span></a>
<a class="sourceLine" id="cb50-4" title="4">  <span class="ot">-&gt;</span> s          <span class="co">-- ^ パーサへの入力</span></a>
<a class="sourceLine" id="cb50-5" title="5">  <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">ParseErrorBundle</span> s e) a</a></code></pre></div>
<p>2番目の引数は、生成されたパースエラーに含まれる単なるファイル名です。 実際の入力は関数の3番目の引数として渡されるため、 <code>megaparsec</code> はそのファイルから何も読みません。</p>
<p><code>runParser</code> を使用すると、<code>Parsec</code> モナドを実行できます。 これは、既にご存知のとおり、変換子を使わないバージョンの <code>ParsecT</code> です。</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb51-1" title="1"><span class="kw">type</span> <span class="dt">Parsec</span> e s <span class="ot">=</span> <span class="dt">ParsecT</span> e s <span class="dt">Identity</span></a></code></pre></div>
<p><code>runParser</code> には、<code>runParser'</code>、<code>runParserT</code>、 および <code>runParserT'</code> の3つの姉妹がいます。 接尾辞 <code>T</code> の付いたバージョンは <code>PrasecT</code> モナド変換子を実行し、 「プライム」バージョンはパーサの状態を受け取り、返します。 すべての関数を表にまとめましょう。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">引数</th>
<th style="text-align: left;"><code>Parsec</code> の実行</th>
<th style="text-align: left;"><code>ParsecT</code> の実行</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">入力とファイル名</td>
<td style="text-align: left;"><code>runParser</code></td>
<td style="text-align: left;"><code>runParserT</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">カスタム初期状態</td>
<td style="text-align: left;"><code>runParser'</code></td>
<td style="text-align: left;"><code>runParserT'</code></td>
</tr>
</tbody>
</table>
<p>タブの幅を標準以外の値(デフォルトの値は8)に設定したい場合など、 カスタム初期状態が必要な場合があります。 <code>runParser'</code> はこのようになっています。</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb52-1" title="1">runParser'</a>
<a class="sourceLine" id="cb52-2" title="2"><span class="ot">  ::</span> <span class="dt">Parsec</span> e s a <span class="co">-- ^ 実行するパーサ</span></a>
<a class="sourceLine" id="cb52-3" title="3">  <span class="ot">-&gt;</span> <span class="dt">State</span> s    <span class="co">-- ^ 初期状態</span></a>
<a class="sourceLine" id="cb52-4" title="4">  <span class="ot">-&gt;</span> (<span class="dt">State</span> s, <span class="dt">Either</span> (<span class="dt">ParseErrorBundle</span> s e) a)</a></code></pre></div>
<p>手動で状態を変更することはライブラリの高度な使用法であり、 ここでは説明しません。</p>
<p><code>ParseErrorBundle</code> とは何かについて疑問に思う場合は、 <a href="#Error">この後の章のいずれか</a>で説明します。</p>
<p><a name="MonadParsec"></a></p>
<h2 id="monadparsec-型クラス"><code>MonadParsec</code> 型クラス</h2>
<p><code>megaparsec</code> のすべてのツールは、 <code>MonadParsec</code> 型クラスの任意のインスタンスと連携します。 型クラスは、プリミティブコンビネータ、 つまりすべての <code>megaparsec</code> のパーサの基本的な構成要素、 他のコンビネータでは表現できないコンビネータを抽象化します。</p>
<p>プリミティブコンビネータを型クラスに持つことで、 <code>megaarsec</code> の <code>ParsecT</code> の主要なモナド変換子を、 MTL系のよく知られている変換子にラップして、 モナドスタックのレイヤー間でさまざまな相互作用を実現することができます。 動機をよりよく理解するために、 モナドスタック内のレイヤーの順序が重要であることを思い出してください。 このように <code>ReaderT</code> と <code>State</code> を組み合わせると、</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb53-1" title="1"><span class="kw">type</span> <span class="dt">MyStack</span> a <span class="ot">=</span> <span class="dt">ReaderT</span> <span class="dt">MyContext</span> (<span class="dt">State</span> <span class="dt">MyState</span>) a</a></code></pre></div>
<p>外側のレイヤー <code>ReaderT</code> はその下のレイヤー <code>m</code> の内部構造を検査できません。 <code>ReaderT</code> の <code>Monad</code> インスタンスはバインディングの戦略を記述しています。</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb54-1" title="1"><span class="kw">newtype</span> <span class="dt">ReaderT</span> r m a <span class="ot">=</span> <span class="dt">ReaderT</span> {<span class="ot"> runReaderT ::</span> r <span class="ot">-&gt;</span> m a }</a>
<a class="sourceLine" id="cb54-2" title="2"></a>
<a class="sourceLine" id="cb54-3" title="3"><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">ReaderT</span> r m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb54-4" title="4">  m <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="dt">ReaderT</span> <span class="op">$</span> \r <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb54-5" title="5">    a <span class="ot">&lt;-</span> runReaderT m r</a>
<a class="sourceLine" id="cb54-6" title="6">    runReaderT (k a) r</a></code></pre></div>
<p>実際、<code>m</code> について私たちが知っている唯一のことは、 それが <code>Monad</code>のインスタンスであり、 したがって <code>m</code> の状態はモナディックバインドを介してのみ <code>k</code> に渡すことができるということです。 とにかくそれが <code>ReaderT</code> の <code>(&gt;&gt;=)</code> から私たちが通常欲しいものです。</p>
<p><code>Alternative</code> 型クラスの <code>(&lt;|&gt;)</code> メソッドは異なった働きをします。 それは状態を「分割」し、パーサの2つの分岐はもう接触しません。 そのため、最初の分岐が破棄されるとその状態への変更も破棄され、 2番目の分岐に影響を与えることはできないという意味で バックトラックした状態になります (最初の分岐が失敗したときの状態を「バックトラック」します。)。</p>
<p>説明のために、ReaderTのAlternativeの定義を見てみましょう。</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb55-1" title="1"><span class="kw">instance</span> <span class="dt">Alternative</span> m <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">ReaderT</span> r m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb55-2" title="2">  empty <span class="ot">=</span> liftReaderT empty</a>
<a class="sourceLine" id="cb55-3" title="3">  <span class="dt">ReaderT</span> m <span class="op">&lt;|&gt;</span> <span class="dt">ReaderT</span> n <span class="ot">=</span> <span class="dt">ReaderT</span> <span class="op">$</span> \r <span class="ot">-&gt;</span> m r <span class="op">&lt;|&gt;</span> n r</a></code></pre></div>
<p><code>ReaderT</code> は「ステートレス」なモナド変換子であり、 (何を持っていない) <code>ReaderT</code> 自体に関連するモナドの状態を組み合わせる必要なしに(ここで <code>m</code> の <code>Alternative</code> インスタンスが役に立ちます。) 実際の作業を内部のモナドに委任するのは簡単なので、 これはすべて非常に素晴らしいことです。</p>
<p>それでは、Stateを見てみましょう。 <code>State s a</code> は <code>StateT s Identity a</code> の単なるシノニムなので、 <code>StateT s m</code> 自体の <code>Alternative</code> インスタンスを見てください。</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb56-1" title="1"><span class="kw">instance</span> (<span class="dt">Functor</span> m, <span class="dt">Alternative</span> m) <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">StateT</span> s m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb56-2" title="2">  empty <span class="ot">=</span> <span class="dt">StateT</span> <span class="op">$</span> \_ <span class="ot">-&gt;</span> empty</a>
<a class="sourceLine" id="cb56-3" title="3">  <span class="dt">StateT</span> m <span class="op">&lt;|&gt;</span> <span class="dt">StateT</span> n <span class="ot">=</span> <span class="dt">StateT</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> m s <span class="op">&lt;|&gt;</span> n s</a></code></pre></div>
<p>ここでは、reader のコンテキスト <code>r</code> の共有を見たように、 状態 <code>s</code> の分割を見ることができます。 ただし、<code>m s</code> と <code>n s</code> の式はステートフルな結果を生成するため、 モナディック値と一緒に、新しい状態をタプルで返すという違いがあります。 ここでは、<code>m s</code> か <code>n s</code> のどちらかで進み、 自然にバックトラックを達成します。</p>
<p><code>ParsecT</code> はどうですか？ <code>State</code> を <code>ParsecT</code> の中に次のように置くことを考えてみましょう。</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb57-1" title="1"><span class="kw">type</span> <span class="dt">MyStack</span> a <span class="ot">=</span> <span class="dt">ParsecT</span> <span class="dt">Void</span> <span class="dt">Text</span> (<span class="dt">State</span> <span class="dt">MyState</span>) a</a></code></pre></div>
<p><code>ParsecT</code> は <code>ReaderT</code> よりも複雑で、<code>(&lt;|&gt;)</code>の実装にはもっと多くのことが必要です。</p>
<ul>
<li>パーサ自体の状態管理</li>
<li>起こるべき（適切な）パースエラーのマージ。</li>
</ul>
<p><code>ParsecT</code> の <code>Alternative</code> のインスタンスへの<code>(&lt;|&gt;)</code>の実装は、 その基盤となる <code>State MyState</code> モナドの <code>Alternative</code>インスタンスに その作業を委任することができないので、<code>MyState</code>の分割は発生せず、 バックトラックはありません。</p>
<p>例を挙げて説明しましょう。</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb58-1" title="1"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb58-2" title="2"></a>
<a class="sourceLine" id="cb58-3" title="3"><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></a>
<a class="sourceLine" id="cb58-4" title="4"></a>
<a class="sourceLine" id="cb58-5" title="5"><span class="kw">import</span> <span class="dt">Control.Applicative</span></a>
<a class="sourceLine" id="cb58-6" title="6"><span class="kw">import</span> <span class="dt">Control.Monad.State.Strict</span></a>
<a class="sourceLine" id="cb58-7" title="7"><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb58-8" title="8"><span class="kw">import</span> <span class="dt">Data.Void</span></a>
<a class="sourceLine" id="cb58-9" title="9"><span class="kw">import</span> <span class="dt">Text.Megaparsec</span> <span class="kw">hiding</span> (<span class="dt">State</span>)</a>
<a class="sourceLine" id="cb58-10" title="10"></a>
<a class="sourceLine" id="cb58-11" title="11"><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">ParsecT</span> <span class="dt">Void</span> <span class="dt">Text</span> (<span class="dt">State</span> <span class="dt">String</span>)</a>
<a class="sourceLine" id="cb58-12" title="12"></a>
<a class="sourceLine" id="cb58-13" title="13"><span class="ot">parser0 ::</span> <span class="dt">Parser</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb58-14" title="14">parser0 <span class="ot">=</span> a <span class="op">&lt;|&gt;</span> b</a>
<a class="sourceLine" id="cb58-15" title="15">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb58-16" title="16">    a <span class="ot">=</span> <span class="st">&quot;foo&quot;</span> <span class="op">&lt;$</span> put <span class="st">&quot;branch A&quot;</span></a>
<a class="sourceLine" id="cb58-17" title="17">    b <span class="ot">=</span> get   <span class="op">&lt;*</span> put <span class="st">&quot;branch B&quot;</span></a>
<a class="sourceLine" id="cb58-18" title="18"></a>
<a class="sourceLine" id="cb58-19" title="19"><span class="ot">parser1 ::</span> <span class="dt">Parser</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb58-20" title="20">parser1 <span class="ot">=</span> a <span class="op">&lt;|&gt;</span> b</a>
<a class="sourceLine" id="cb58-21" title="21">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb58-22" title="22">    a <span class="ot">=</span> <span class="st">&quot;foo&quot;</span> <span class="op">&lt;$</span> put <span class="st">&quot;branch A&quot;</span> <span class="op">&lt;*</span> empty</a>
<a class="sourceLine" id="cb58-23" title="23">    b <span class="ot">=</span> get   <span class="op">&lt;*</span> put <span class="st">&quot;branch B&quot;</span></a>
<a class="sourceLine" id="cb58-24" title="24"></a>
<a class="sourceLine" id="cb58-25" title="25"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb58-26" title="26">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb58-27" title="27">  <span class="kw">let</span> run p          <span class="ot">=</span> runState (runParserT p <span class="st">&quot;&quot;</span> <span class="st">&quot;&quot;</span>) <span class="st">&quot;initial&quot;</span></a>
<a class="sourceLine" id="cb58-28" title="28">      (<span class="dt">Right</span> a0, s0) <span class="ot">=</span> run parser0</a>
<a class="sourceLine" id="cb58-29" title="29">      (<span class="dt">Right</span> a1, s1) <span class="ot">=</span> run parser1</a>
<a class="sourceLine" id="cb58-30" title="30"></a>
<a class="sourceLine" id="cb58-31" title="31">  <span class="fu">putStrLn</span>  <span class="st">&quot;Parser 0&quot;</span></a>
<a class="sourceLine" id="cb58-32" title="32">  <span class="fu">putStrLn</span> (<span class="st">&quot;Result:      &quot;</span> <span class="op">++</span> <span class="fu">show</span> a0)</a>
<a class="sourceLine" id="cb58-33" title="33">  <span class="fu">putStrLn</span> (<span class="st">&quot;Final state: &quot;</span> <span class="op">++</span> <span class="fu">show</span> s0)</a>
<a class="sourceLine" id="cb58-34" title="34"></a>
<a class="sourceLine" id="cb58-35" title="35">  <span class="fu">putStrLn</span>  <span class="st">&quot;Parser 1&quot;</span></a>
<a class="sourceLine" id="cb58-36" title="36">  <span class="fu">putStrLn</span> (<span class="st">&quot;Result:      &quot;</span> <span class="op">++</span> <span class="fu">show</span> a1)</a>
<a class="sourceLine" id="cb58-37" title="37">  <span class="fu">putStrLn</span> (<span class="st">&quot;Final state: &quot;</span> <span class="op">++</span> <span class="fu">show</span> s1)</a></code></pre></div>
<p>これがプログラムを実行した結果です。</p>
<pre><code>Parser 0
Result:      &quot;foo&quot;
Final state: &quot;branch A&quot;
Parser 1
Result:      &quot;branch A&quot;
Final state: &quot;branch B&quot;</code></pre>
<p><code>parser0</code> を使うと、分岐 <code>b</code> が試行されていないことがわかります。 しかしparser1では、<code>empty</code> によって失敗し、 成功したのは分岐 <code>b</code> であるにもかかわらず、 最終結果（<code>get</code> によって返される値）が分岐 <code>a</code>から得られることは明らかです。 (パーサの文脈では <code>empty</code> は 「即座に失敗し、何が起こったのかについての情報がない」 という意味です。) バックトラックは発生しません。</p>
<p>パーサーでカスタム状態をバックトラックしたい場合はどうしますか？ <code>ParsecT</code> を <code>StateT</code> 内にラップすることを許可するならば、それを提供することができます。</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb60-1" title="1"><span class="kw">type</span> <span class="dt">MyStack</span> a <span class="ot">=</span> <span class="dt">StateT</span> <span class="dt">MyState</span> (<span class="dt">ParsecT</span> <span class="dt">Void</span> <span class="dt">Text</span> <span class="dt">Identity</span>) a</a></code></pre></div>
<p><code>MyStack</code> で <code>(&lt;|&gt;)</code> を使用すると、 使用されるインスタンスは <code>StateT</code> のインスタンスになります。</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb61-1" title="1"><span class="dt">StateT</span> m <span class="op">&lt;|&gt;</span> <span class="dt">StateT</span> n <span class="ot">=</span> <span class="dt">StateT</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> m s <span class="op">&lt;|&gt;</span> n s</a></code></pre></div>
<p>これは状態をバックトラックさせ、 それから残りの作業をその内部モナド<code>ParsecT</code> の <code>Alternative</code> インスタンスに委任します。 この動作はまさに私たちが望むものです。</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb62-1" title="1"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb62-2" title="2"></a>
<a class="sourceLine" id="cb62-3" title="3"><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></a>
<a class="sourceLine" id="cb62-4" title="4"></a>
<a class="sourceLine" id="cb62-5" title="5"><span class="kw">import</span> <span class="dt">Control.Applicative</span></a>
<a class="sourceLine" id="cb62-6" title="6"><span class="kw">import</span> <span class="dt">Control.Monad.Identity</span></a>
<a class="sourceLine" id="cb62-7" title="7"><span class="kw">import</span> <span class="dt">Control.Monad.State.Strict</span></a>
<a class="sourceLine" id="cb62-8" title="8"><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb62-9" title="9"><span class="kw">import</span> <span class="dt">Data.Void</span></a>
<a class="sourceLine" id="cb62-10" title="10"><span class="kw">import</span> <span class="dt">Text.Megaparsec</span> <span class="kw">hiding</span> (<span class="dt">State</span>)</a>
<a class="sourceLine" id="cb62-11" title="11"></a>
<a class="sourceLine" id="cb62-12" title="12"><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">StateT</span> <span class="dt">String</span> (<span class="dt">ParsecT</span> <span class="dt">Void</span> <span class="dt">Text</span> <span class="dt">Identity</span>)</a>
<a class="sourceLine" id="cb62-13" title="13"></a>
<a class="sourceLine" id="cb62-14" title="14"><span class="ot">parser ::</span> <span class="dt">Parser</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb62-15" title="15">parser <span class="ot">=</span> a <span class="op">&lt;|&gt;</span> b</a>
<a class="sourceLine" id="cb62-16" title="16">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb62-17" title="17">    a <span class="ot">=</span> <span class="st">&quot;foo&quot;</span> <span class="op">&lt;$</span> put <span class="st">&quot;branch A&quot;</span> <span class="op">&lt;*</span> empty</a>
<a class="sourceLine" id="cb62-18" title="18">    b <span class="ot">=</span> get   <span class="op">&lt;*</span> put <span class="st">&quot;branch B&quot;</span></a>
<a class="sourceLine" id="cb62-19" title="19"></a>
<a class="sourceLine" id="cb62-20" title="20"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb62-21" title="21">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb62-22" title="22">  <span class="kw">let</span> p            <span class="ot">=</span> runStateT parser <span class="st">&quot;initial&quot;</span></a>
<a class="sourceLine" id="cb62-23" title="23">      <span class="dt">Right</span> (a, s) <span class="ot">=</span> runParser p <span class="st">&quot;&quot;</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb62-24" title="24">  <span class="fu">putStrLn</span> (<span class="st">&quot;Result:      &quot;</span> <span class="op">++</span> <span class="fu">show</span> a)</a>
<a class="sourceLine" id="cb62-25" title="25">  <span class="fu">putStrLn</span> (<span class="st">&quot;Final state: &quot;</span> <span class="op">++</span> <span class="fu">show</span> s)</a></code></pre></div>
<p>プログラムは次のように出力します。</p>
<pre><code>Result:      &quot;initial&quot;
Final state: &quot;branch B&quot;</code></pre>
<p>このアプローチを実行可能にするために、 <code>StateT</code> はプリミティブパーサのセット全体をサポートするべきであり、 そうすることで <code>ParsecT</code> と同じようにそれを扱うことができます。 言い換えれば、 内部モナドが(MTLの)<code>MonadWriter</code>のインスタンスである場合は <code>MonadState</code> だけではなく、<code>MonadWriter</code>も <code>MonadParsec</code>のインスタンスである必要があります。</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb64-1" title="1"><span class="kw">instance</span> <span class="dt">MonadWriter</span> w m <span class="ot">=&gt;</span> <span class="dt">MonadWriter</span> w (<span class="dt">StateT</span> s m) <span class="kw">where</span> …</a></code></pre></div>
<p>確かに、<code>MonadParsec</code> の内部インスタンスから <code>StateT</code> に プリミティブを持ち上げることができます。</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb65-1" title="1"><span class="kw">instance</span> <span class="dt">MonadParsec</span> e s m <span class="ot">=&gt;</span> <span class="dt">MonadParsec</span> e s (<span class="dt">StateT</span> st m) <span class="kw">where</span> …</a></code></pre></div>
<p><code>megaparsec</code>は MTL のすべてのモナド変換子に対して <code>MonadParsec</code> のインスタンスを定義しているので、 ユーザーは変換子を <code>ParsecT</code> の内側に挿入したり、 それらの変換子で <code>ParsecT</code> をラップしたりして、 モナドスタックの層間で異なる種類の相互作用を実現できます。</p>
<p><a name="Lexing"></a></p>
<h2 id="字句解析">字句解析</h2>
<p>字句解析は、入力ストリームを整数、キーワード、シンボルなどのトークン のストリームに変換するプロセスです。 これらは、生の入力を直接パースするよりもパースが容易であるか、 またはパーサジェネレータで生成されたパーサへの入力として期待されます。 字句解析は、<code>alex</code>などの外部ツールを使用して別のパスで実行できますが、 <code>megaparsec</code>はパーサの一部として、シームレスに字句解析プログラムを書くことを簡単にする関数も提供します。</p>
<p>文字ストリーム用の <code>Text.Megaparsec.Char.Lexer</code> と バイトストリーム用の <code>Text.Megaparsec.Byte.Lexer</code> の 2つの字句解析モジュールがあります。 正格な <code>Text</code> を入力ストリームとして扱うので <code>Text.Megaparsec.Char.Lexer</code> を使いますが、 <code>ByteStrings</code> を使いたい場合はほとんどの関数は <code>Text.Megaparsec.Byte.Lexer</code> にも反映されます。</p>
<p><a name="White"></a></p>
<h2 id="空白">空白</h2>
<p>最初に取り上げる必要があるトピックは、空白の扱いです。 すべてのトークンの前またはすべてのトークンの後に、 一貫した方法で空白を消費することが役立ちます。 Megaparsec の字句解析モジュールは、 「トークンの前に空白を入れず、トークンの後にすべての空白を消費する」 という戦略に従います。</p>
<p>空白を消費するには、<em>スペースコンシューマ</em> と呼ばれる特別なパーサが必要です。 <code>Text.Megaparsec.Char.Lexer</code> モジュールは、 一般的なスペースコンシューマを構築するためのヘルパーを提供します。</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb66-1" title="1"><span class="ot">space ::</span> <span class="dt">MonadParsec</span> e s m</a>
<a class="sourceLine" id="cb66-2" title="2">  <span class="ot">=&gt;</span> m () <span class="co">-- ^ 空の入力を受け入れない空白文字のパーサ</span></a>
<a class="sourceLine" id="cb66-3" title="3">          <span class="co">-- (e.g. 'space1')</span></a>
<a class="sourceLine" id="cb66-4" title="4">  <span class="ot">-&gt;</span> m () <span class="co">-- ^ 行コメントのパーサ (e.g. 'skipLineComment')</span></a>
<a class="sourceLine" id="cb66-5" title="5">  <span class="ot">-&gt;</span> m () <span class="co">-- ^ ブロックコメントのパーサ (e.g. 'skipBlockComment')</span></a>
<a class="sourceLine" id="cb66-6" title="6">  <span class="ot">-&gt;</span> m ()</a></code></pre></div>
<p><code>space</code> 関数のドキュメンテーションはそれ自体で非常に包括的ですが、 例を挙げて補足しましょう。</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb67-1" title="1"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb67-2" title="2"></a>
<a class="sourceLine" id="cb67-3" title="3"><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></a>
<a class="sourceLine" id="cb67-4" title="4"></a>
<a class="sourceLine" id="cb67-5" title="5"><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb67-6" title="6"><span class="kw">import</span> <span class="dt">Data.Void</span></a>
<a class="sourceLine" id="cb67-7" title="7"><span class="kw">import</span> <span class="dt">Text.Megaparsec</span></a>
<a class="sourceLine" id="cb67-8" title="8"><span class="kw">import</span> <span class="dt">Text.Megaparsec.Char</span></a>
<a class="sourceLine" id="cb67-9" title="9"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Megaparsec.Char.Lexer</span> <span class="kw">as</span> <span class="dt">L</span> <span class="co">-- (1)</span></a>
<a class="sourceLine" id="cb67-10" title="10"></a>
<a class="sourceLine" id="cb67-11" title="11"><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Void</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb67-12" title="12"></a>
<a class="sourceLine" id="cb67-13" title="13"><span class="ot">sc ::</span> <span class="dt">Parser</span> ()</a>
<a class="sourceLine" id="cb67-14" title="14">sc <span class="ot">=</span> L.space</a>
<a class="sourceLine" id="cb67-15" title="15">  space1                         <span class="co">-- (2)</span></a>
<a class="sourceLine" id="cb67-16" title="16">  (L.skipLineComment <span class="st">&quot;//&quot;</span>)       <span class="co">-- (3)</span></a>
<a class="sourceLine" id="cb67-17" title="17">  (L.skipBlockComment <span class="st">&quot;/*&quot;</span> <span class="st">&quot;*/&quot;</span>) <span class="co">-- (4)</span></a></code></pre></div>
<p>いくつかのメモ：</p>
<ul>
<li><p><code>Text.Megaparsec.Char.Lexer</code>は、修飾付きでインポートされることを意図されています。なぜなら、Text.Megaparsec.Charの<code>space</code>のように衝突する名前を含んでいるからです。</p></li>
<li><p><code>L.space</code> の最初の引数は空白を拾うために使用されることになっているパーサであるべきです。重要な点は、<code>L.space</code>が無限ループに入ってしまうので、空の入力を受け入れてはいけないということです。<code>space1</code>は、要件を完全に満たす <code>Text.Megaparsec.Char</code> のパーサです。</p></li>
<li><p><code>L.space</code> の2番目の引数は、行コメント、すなわち、与えられたトークンのシーケンスで始まり行の終わりで終わるコメントをスキップする方法を定義します。<code>skipLineComment</code> ヘルパーを使用すると、行コメント用の補助パーサを簡単に作成できます。</p></li>
<li><p><code>L.space</code> の3番目の引数は、ブロックコメント、つまりトークンの開始シーケンスと終了シーケンスの間のすべてのものをを受け取る方法を定義します。<code>skipBlockComment</code> ヘルパーは、ネストされていないブロックコメントを扱うことができます。ネストされたブロックコメントをサポートする場合は、代わりに <code>skipBlockCommentNested</code> を使用してください。</p></li>
</ul>
<p>操作的には、<code>L.space</code> は3つすべてのパーサを適用できなくなるまで、順番に試行します。つまり、空白がすべて消費されたことになります。 これを知っていれば、文法にブロックコメントや行コメントが含まれていない場合は、<code>L.space</code>の2番目または3番目の引数として<code>empty</code>を渡すことができます。 <code>(&lt;|&gt;)</code> の単位元である <code>empty</code> は、<code>L.space</code> が次の空白要素のためにパーサを試みるようにします。まさに望んでいたことです。</p>
<p>スペースコンシューマ <code>sc</code> を持っているなら、 さまざまな空白関連のヘルパーを定義できます。</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb68-1" title="1"><span class="ot">lexeme ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</a>
<a class="sourceLine" id="cb68-2" title="2">lexeme <span class="ot">=</span> L.lexeme sc <span class="co">-- (1)</span></a>
<a class="sourceLine" id="cb68-3" title="3"></a>
<a class="sourceLine" id="cb68-4" title="4"><span class="ot">symbol ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb68-5" title="5">symbol <span class="ot">=</span> L.symbol sc <span class="co">-- (2)</span></a></code></pre></div>
<ul>
<li><p><code>lexeme</code> は、供給されたスペースコンシューマを使用してすべての末尾の空白を取る、語彙素のラッパーです。</p></li>
<li><p><code>symbol</code> は内部で <code>string</code> を使って与えられたテキストにマッチさせ、そして同様にすべての末尾の空白を拾うパーサです。</p></li>
</ul>
<p>私たちはすぐにそれがすべて一緒に動作する方法を見ますが、 最初に <code>Text.Megaparsec.Char.Lexer</code> からさらに2,3のヘルパーを 導入する必要があります。</p>
<p><a name="Chara"></a></p>
<h2 id="文字と文字列リテラル">文字と文字列リテラル</h2>
<p>エスケープ規則はさまざまなので、 文字リテラルおよび文字列リテラルのパースは難しい場合があります。 簡単にするために、<code>megaparsec</code> は <code>charLiteral</code> パーサを提供します。</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb69-1" title="1"><span class="ot">charLiteral ::</span> (<span class="dt">MonadParsec</span> e s m, <span class="dt">Token</span> s <span class="op">~</span> <span class="dt">Char</span>) <span class="ot">=&gt;</span> m <span class="dt">Char</span></a></code></pre></div>
<p><code>charLiteral</code> の仕事は、Haskellレポートに記述されている文字リテラルの構文に従ってエスケープされる可能性がある単一の文字をパースすることです。 ただし、次の2つの理由から、リテラルを囲む引用符はパースされません。</p>
<ul>
<li><p>ユーザーは文字リテラルの引用方法を制御できる</p></li>
<li><p>そのため、charLiteralを使用して文字列リテラルもパースできる</p></li>
</ul>
<p><code>charLiteral</code>の上に構築されたパーサの例をいくつか示します。</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb70-1" title="1"><span class="ot">charLiteral ::</span> <span class="dt">Parser</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb70-2" title="2">charLiteral <span class="ot">=</span> between (char <span class="ch">'\''</span>) (char <span class="ch">'\''</span>) L.charLiteral</a>
<a class="sourceLine" id="cb70-3" title="3"></a>
<a class="sourceLine" id="cb70-4" title="4"><span class="ot">stringLiteral ::</span> <span class="dt">Parser</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb70-5" title="5">stringLiteral <span class="ot">=</span> char <span class="ch">'\&quot;'</span> <span class="op">*&gt;</span> manyTill L.charLiteral (char <span class="ch">'\&quot;'</span>)</a></code></pre></div>
<ul>
<li><p><code>L.charLiteral</code> を文字リテラルのパーサに変えるには、囲む引用符を追加するだけです。ここではHaskellの構文に従い、シングルクオートを使います。<code>between</code>コンビネータは、単純に<code>between open close p = open *&gt; p &lt;* close</code>ように定義されます。</p></li>
<li><p><code>stringLiteral</code>はダブルクオートで囲まれた文字列リテラル内の個々の文字をパースするために <code>L.charLiteral</code> を使用します。</p></li>
</ul>
<p>2番目の関数も、<code>manyTill</code> コンビネータを使用しているため興味深いです。</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb71-1" title="1"><span class="ot">manyTill ::</span> <span class="dt">Alternative</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> m end <span class="ot">-&gt;</span> m [a]</a>
<a class="sourceLine" id="cb71-2" title="2">manyTill p end <span class="ot">=</span> go</a>
<a class="sourceLine" id="cb71-3" title="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb71-4" title="4">    go <span class="ot">=</span> ([] <span class="op">&lt;$</span> end) <span class="op">&lt;|&gt;</span> ((<span class="op">:</span>) <span class="op">&lt;$&gt;</span> p <span class="op">&lt;*&gt;</span> go)</a></code></pre></div>
<p><code>manyTill</code> は繰り返しごとにパーサ <code>end</code> を適用しようとし、 失敗するとパーサ <code>p</code> を実行して <code>p</code> の結果をリストに蓄積します。</p>
<p>少なくとも1つのアイテムが存在することを要求する <code>someTill</code> もあります。</p>
<p><a name="Numbers"></a></p>
<h2 id="数字">数字</h2>
<p>最後に、非常に一般的なニーズは数値をパースすることです。 整数の場合、10進数、8進数、および16進数の表現で 値をパースできる3つのヘルパーがあります。</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb72-1" title="1">decimal, octal, hexadecimal</a>
<a class="sourceLine" id="cb72-2" title="2"><span class="ot">  ::</span> (<span class="dt">MonadParsec</span> e s m, <span class="dt">Token</span> s <span class="op">~</span> <span class="dt">Char</span>, <span class="dt">Integral</span> a) <span class="ot">=&gt;</span> m a</a></code></pre></div>
<p>それらを使うのは簡単です。</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb73-1" title="1"><span class="ot">integer ::</span> <span class="dt">Parser</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb73-2" title="2">integer <span class="ot">=</span> lexeme L.decimal</a></code></pre></div>
<div class="sourceCode" id="cb74"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb74-1" title="1">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (integer <span class="op">&lt;</span>* eof) <span class="st">&quot;123  &quot;</span></a>
<a class="sourceLine" id="cb74-2" title="2"><span class="ex">123</span></a>
<a class="sourceLine" id="cb74-3" title="3"></a>
<a class="sourceLine" id="cb74-4" title="4">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (integer <span class="op">&lt;</span>* eof) <span class="st">&quot;12a  &quot;</span></a>
<a class="sourceLine" id="cb74-5" title="5"><span class="ex">1</span>:3:</a>
<a class="sourceLine" id="cb74-6" title="6">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb74-7" title="7"><span class="ex">1</span> <span class="kw">|</span> <span class="ex">12a</span></a>
<a class="sourceLine" id="cb74-8" title="8">  <span class="kw">|</span>   ^</a>
<a class="sourceLine" id="cb74-9" title="9"><span class="ex">unexpected</span> <span class="st">'a'</span></a>
<a class="sourceLine" id="cb74-10" title="10"><span class="ex">expecting</span> end of input or the rest of integer</a></code></pre></div>
<p><code>scientific</code> と <code>float</code> は整数と小数の文法を受け入れます。 <code>scientific</code> は<code>scientific</code>パッケージの <code>Scientific</code>型を返しますが、 <code>float</code> はその結果の型が多相的であり、 <code>RealFloat</code> の任意のインスタンスを返すことができます。</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb75-1" title="1"><span class="ot">scientific ::</span> (<span class="dt">MonadParsec</span> e s m, <span class="dt">Token</span> s <span class="op">~</span> <span class="dt">Char</span>)              <span class="ot">=&gt;</span> m <span class="dt">Scientific</span></a>
<a class="sourceLine" id="cb75-2" title="2"><span class="ot">float      ::</span> (<span class="dt">MonadParsec</span> e s m, <span class="dt">Token</span> s <span class="op">~</span> <span class="dt">Char</span>, <span class="dt">RealFloat</span> a) <span class="ot">=&gt;</span> m a</a></code></pre></div>
<p>例：</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb76-1" title="1"><span class="ot">float ::</span> <span class="dt">Parser</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb76-2" title="2">float <span class="ot">=</span> lexeme L.float</a></code></pre></div>
<div class="sourceCode" id="cb77"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb77-1" title="1">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (float <span class="op">&lt;</span>* eof) <span class="st">&quot;123&quot;</span></a>
<a class="sourceLine" id="cb77-2" title="2"><span class="ex">1</span>:4:</a>
<a class="sourceLine" id="cb77-3" title="3">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb77-4" title="4"><span class="ex">1</span> <span class="kw">|</span> <span class="ex">123</span></a>
<a class="sourceLine" id="cb77-5" title="5">  <span class="kw">|</span>    ^</a>
<a class="sourceLine" id="cb77-6" title="6"><span class="ex">unexpected</span> end of input</a>
<a class="sourceLine" id="cb77-7" title="7"><span class="ex">expecting</span> <span class="st">'.'</span>, <span class="st">'E'</span>, <span class="st">'e'</span>, or digit</a>
<a class="sourceLine" id="cb77-8" title="8"></a>
<a class="sourceLine" id="cb77-9" title="9">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (float <span class="op">&lt;</span>* eof) <span class="st">&quot;123.45&quot;</span></a>
<a class="sourceLine" id="cb77-10" title="10"><span class="ex">123.45</span></a>
<a class="sourceLine" id="cb77-11" title="11"></a>
<a class="sourceLine" id="cb77-12" title="12">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (float <span class="op">&lt;</span>* eof) <span class="st">&quot;123d&quot;</span></a>
<a class="sourceLine" id="cb77-13" title="13"><span class="ex">1</span>:4:</a>
<a class="sourceLine" id="cb77-14" title="14">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb77-15" title="15"><span class="ex">1</span> <span class="kw">|</span> <span class="ex">123d</span></a>
<a class="sourceLine" id="cb77-16" title="16">  <span class="kw">|</span>    ^</a>
<a class="sourceLine" id="cb77-17" title="17"><span class="ex">unexpected</span> <span class="st">'d'</span></a>
<a class="sourceLine" id="cb77-18" title="18"><span class="ex">expecting</span> <span class="st">'.'</span>, <span class="st">'E'</span>, <span class="st">'e'</span>, or digit</a></code></pre></div>
<p>これらすべてのパーサは符号付き数値をパースしないことに注意してください。 符号付き数値用のパーサを作成するには、 既存のパーサを <code>signed</code> コンビネータでラップする必要があります。</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb78-1" title="1"><span class="ot">signedInteger ::</span> <span class="dt">Parser</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb78-2" title="2">signedInteger <span class="ot">=</span> L.signed sc integer</a>
<a class="sourceLine" id="cb78-3" title="3"></a>
<a class="sourceLine" id="cb78-4" title="4"><span class="ot">signedFloat ::</span> <span class="dt">Parser</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb78-5" title="5">signedFloat <span class="ot">=</span> L.signed sc float</a></code></pre></div>
<p><code>signed</code> の最初の引数(スペースコンシューマ)は、符号と実際の数字の間の空白の消費を制御します。スペースを入れたくない場合は、代わりに<code>return ()</code>を渡してください。</p>
<p><a name="lookAhead"></a></p>
<h2 id="notfollowedby-と-lookahead"><code>notFollowedBy</code> と <code>lookAhead</code></h2>
<p>実際にはパーサの位置を進めずに入力ストリームの 先読みを実行できる(<code>try</code> に加えて)さらに2つのプリミティブがあります。</p>
<p>１つめは <code>notFollowedBy</code> と呼ばれるものです。</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb79-1" title="1"><span class="ot">notFollowedBy ::</span> <span class="dt">MonadParsec</span> e s m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> m ()</a></code></pre></div>
<p>引数のパーサが失敗したときにのみ成功し、 入力を消費したり、パーサの状態を変更することはありません。</p>
<p><code>notFollowedBy</code> を使いたいと思うかもしれない例として、 キーワードのパースを考えます。</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb80-1" title="1"><span class="ot">pKeyword ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb80-2" title="2">pKeyword keyword <span class="ot">=</span> lexeme (string keyword)</a></code></pre></div>
<p>このパーサは問題を抱えています。 マッチさせるキーワードが単に識別子の接頭辞であるならどうでしょうか？ その場合、それは間違いなくキーワードではありません。 したがって、<code>notFollowedBy</code> を使用して そのようなケースを排除する必要があります。</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb81-1" title="1"><span class="ot">pKeyword ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb81-2" title="2">pKeyword keyword <span class="ot">=</span> lexeme (string keyword <span class="op">&lt;*</span> notFollowedBy alphaNumChar)</a></code></pre></div>
<p>もう1つのプリミティブは<code>lookAhead</code>です。</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb82-1" title="1"><span class="ot">lookAhead ::</span> <span class="dt">MonadParsec</span> e s m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> m a</a></code></pre></div>
<p><code>lookAhead</code> の引数 <code>p</code> が成功すると、<code>lookAhead p</code> 全体も成功しますが、 入力ストリーム（およびパーサの状態全体）はそのまま残ります。 つまり、何も消費されません。</p>
<p>これが有用である可能性がある場所の一例は、 すでにパースされた入力に対してチェックを実行し、 失敗または正常に継続することです。 慣用表現として、次のようなコードで表すことができます。</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb83-1" title="1">withPredicate1</a>
<a class="sourceLine" id="cb83-2" title="2"><span class="ot">  ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)       <span class="co">-- ^ パース後の入力の振る舞いの確認</span></a>
<a class="sourceLine" id="cb83-3" title="3">  <span class="ot">-&gt;</span> <span class="dt">String</span>            <span class="co">-- ^ チェックが失敗した時に表示するメッセージ</span></a>
<a class="sourceLine" id="cb83-4" title="4">  <span class="ot">-&gt;</span> <span class="dt">Parser</span> a          <span class="co">-- ^ 実行するパーサ</span></a>
<a class="sourceLine" id="cb83-5" title="5">  <span class="ot">-&gt;</span> <span class="dt">Parser</span> a          <span class="co">-- ^ 振る舞いを確認したパーサの結果</span></a>
<a class="sourceLine" id="cb83-6" title="6">withPredicate1 f msg p <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb83-7" title="7">  r <span class="ot">&lt;-</span> lookAhead p</a>
<a class="sourceLine" id="cb83-8" title="8">  <span class="kw">if</span> f r</a>
<a class="sourceLine" id="cb83-9" title="9">    <span class="kw">then</span> p</a>
<a class="sourceLine" id="cb83-10" title="10">    <span class="kw">else</span> <span class="fu">fail</span> msg</a></code></pre></div>
<p>これは <code>lookAhead</code> を使用した例ですが、 チェックが成功した場合に2回パーサを実行しており、 良くないことにも注意してください。 ここに <code>getOffset</code> 関数を使用した代わりの解決方法があります。</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb84-1" title="1">withPredicate2</a>
<a class="sourceLine" id="cb84-2" title="2"><span class="ot">  ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)       <span class="co">-- ^ パース後の入力の振る舞いの確認</span></a>
<a class="sourceLine" id="cb84-3" title="3">  <span class="ot">-&gt;</span> <span class="dt">String</span>            <span class="co">-- ^ チェックが失敗した時に表示するメッセージ</span></a>
<a class="sourceLine" id="cb84-4" title="4">  <span class="ot">-&gt;</span> <span class="dt">Parser</span> a          <span class="co">-- ^ 実行するパーサ</span></a>
<a class="sourceLine" id="cb84-5" title="5">  <span class="ot">-&gt;</span> <span class="dt">Parser</span> a          <span class="co">-- ^ 振る舞いを確認したパーサの結果</span></a>
<a class="sourceLine" id="cb84-6" title="6">withPredicate2 f msg p <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb84-7" title="7">  o <span class="ot">&lt;-</span> getOffset</a>
<a class="sourceLine" id="cb84-8" title="8">  r <span class="ot">&lt;-</span> p</a>
<a class="sourceLine" id="cb84-9" title="9">  <span class="kw">if</span> f r</a>
<a class="sourceLine" id="cb84-10" title="10">    <span class="kw">then</span> <span class="fu">return</span> r</a>
<a class="sourceLine" id="cb84-11" title="11">    <span class="kw">else</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb84-12" title="12">      setOffset o</a>
<a class="sourceLine" id="cb84-13" title="13">      <span class="fu">fail</span> msg</a></code></pre></div>
<p>このようにして、入力ストリームの <code>offset</code> を <code>p</code> を実行する前の状態に設定してから失敗します。 未消費の残りとオフセットの位置に不一致がありますが、 <code>fail</code> を呼び出してすぐにパースを終了するので、 この場合は問題になりません。</p>
<p><a name="Expr"></a></p>
<h2 id="式のパース">式のパース</h2>
<p>「式」とは、 項とそれらの項に適用される演算子から形成される構造を意味します。 演算子は、 異なる優先順位で、前置、中置、後置、左と右の結合にすることができます。 このような構文の例として、学校でよく知られている算術式があります。</p>
<pre><code>a * (b + 2)</code></pre>
<p>2種類の項、変数(<code>a</code> と <code>b</code>)と整数(<code>2</code>)を見ることができます。 2つの演算子、<code>*</code>と<code>+</code>もあります。</p>
<p>式のパーサを書くには時間がかかるかもしれません。 これ手助けするために、 <code>megaparsec</code> には <code>Text.Megaparsec.Expr</code> モジュールが付属しています。 これは、<code>Operator</code>データ型と<code>makeExprParser</code>ヘルパーの 2つのだけをエクスポートします。</p>
<p>両方ともよくドキュメント化されているので、 このセクションではドキュメント化を繰り返すことはせず、 代わりに単純だが完全に機能する式のパーサを書くつもりです。</p>
<p>式を表すデータ型を <a href="https://ja.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E6%A7%8B%E6%96%87%E6%9C%A8">AST</a>として定義することから始めましょう。</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb86-1" title="1"><span class="kw">data</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb86-2" title="2">  <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb86-3" title="3">  <span class="op">|</span> <span class="dt">Int</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb86-4" title="4">  <span class="op">|</span> <span class="dt">Negation</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb86-5" title="5">  <span class="op">|</span> <span class="dt">Sum</span>      <span class="dt">Expr</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb86-6" title="6">  <span class="op">|</span> <span class="dt">Subtr</span>    <span class="dt">Expr</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb86-7" title="7">  <span class="op">|</span> <span class="dt">Product</span>  <span class="dt">Expr</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb86-8" title="8">  <span class="op">|</span> <span class="dt">Division</span> <span class="dt">Expr</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb86-9" title="9">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p><code>makeExprParser</code> を使用するには、 項のパーサと演算子テーブルを指定する必要があります。</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb87-1" title="1"><span class="ot">makeExprParser ::</span> <span class="dt">MonadParsec</span> e s m</a>
<a class="sourceLine" id="cb87-2" title="2">  <span class="ot">=&gt;</span> m a               <span class="co">-- ^ 項のパーサ</span></a>
<a class="sourceLine" id="cb87-3" title="3">  <span class="ot">-&gt;</span> [[<span class="dt">Operator</span> m a]]  <span class="co">-- ^ 演算子テーブル, 'Operator'を参照</span></a>
<a class="sourceLine" id="cb87-4" title="4">  <span class="ot">-&gt;</span> m a               <span class="co">-- ^ 式のパーサの結果</span></a></code></pre></div>
<p>それでは項のパーサから始めましょう。 結合性や優先順位のようなものを扱う場合、式をパースするアルゴリズムでは、 項をボックスとみなし、分割できない全体として考えることをお勧めします。 この場合、このカテゴリに分類されるものが3つあります。 変数、整数、および括弧内の式全体です。 前の章の定義を使用して、項のパーサを次のように定義できます。</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb88-1" title="1"><span class="ot">pVariable ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb88-2" title="2">pVariable <span class="ot">=</span> <span class="dt">Var</span> <span class="op">&lt;$&gt;</span> lexeme</a>
<a class="sourceLine" id="cb88-3" title="3">  ((<span class="op">:</span>) <span class="op">&lt;$&gt;</span> letterChar <span class="op">&lt;*&gt;</span> many alphaNumChar <span class="op">&lt;?&gt;</span> <span class="st">&quot;variable&quot;</span>)</a>
<a class="sourceLine" id="cb88-4" title="4"></a>
<a class="sourceLine" id="cb88-5" title="5"><span class="ot">pInteger ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb88-6" title="6">pInteger <span class="ot">=</span> <span class="dt">Int</span> <span class="op">&lt;$&gt;</span> lexeme L.decimal</a>
<a class="sourceLine" id="cb88-7" title="7"></a>
<a class="sourceLine" id="cb88-8" title="8"><span class="ot">parens ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</a>
<a class="sourceLine" id="cb88-9" title="9">parens <span class="ot">=</span> between (symbol <span class="st">&quot;(&quot;</span>) (symbol <span class="st">&quot;)&quot;</span>)</a>
<a class="sourceLine" id="cb88-10" title="10"></a>
<a class="sourceLine" id="cb88-11" title="11"><span class="ot">pTerm ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb88-12" title="12">pTerm <span class="ot">=</span> choice</a>
<a class="sourceLine" id="cb88-13" title="13">  [ parens pExpr</a>
<a class="sourceLine" id="cb88-14" title="14">  , pVariable</a>
<a class="sourceLine" id="cb88-15" title="15">  , pInteger ]</a>
<a class="sourceLine" id="cb88-16" title="16"></a>
<a class="sourceLine" id="cb88-17" title="17"><span class="ot">pExpr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb88-18" title="18">pExpr <span class="ot">=</span> makeExprParser pTerm operatorTable</a>
<a class="sourceLine" id="cb88-19" title="19"></a>
<a class="sourceLine" id="cb88-20" title="20"><span class="ot">operatorTable ::</span> [[<span class="dt">Operator</span> <span class="dt">Parser</span> <span class="dt">Expr</span>]]</a>
<a class="sourceLine" id="cb88-21" title="21">operatorTable <span class="ot">=</span> <span class="fu">undefined</span> <span class="co">-- TODO</span></a></code></pre></div>
<p><code>pVariable</code>、<code>pInteger</code>、および<code>parens</code>の定義は、 ここまでで問題なく進むはずです。 文法が重ならないので <code>pTerm</code> に <code>try</code> が必要ないという点も、 ここではとてもラッキーです。</p>
<ul>
<li><p>開き括弧 <code>(</code> がある場合は、括弧内に式が続くことを知っているので、そのブランチにコミットします。</p></li>
<li><p>文字を見れば、それが識別子の始まりであることがわかります。</p></li>
<li><p>数字が見えれば、それが整数の始まりであることがわかります。</p></li>
</ul>
<p>最後に、<code>pExpr</code> を終了するために、 <code>operatorTable</code> を定義する必要があります。 型からネストされたリストであることがわかります。 すべての内部リストはサポートしたい演算子のリストです。 それらはすべて同じ優先順位を持っています。 外側のリストは優先順位の降順で並べられているので、 高い位置に演算子のグループを配置するほど、 それらはより強く結合されます。</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb89-1" title="1"><span class="kw">data</span> <span class="dt">Operator</span> m a <span class="co">-- 注意</span></a>
<a class="sourceLine" id="cb89-2" title="2">  <span class="ot">=</span> <span class="dt">InfixN</span>  (m (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a)) <span class="co">-- ^ 非結合の中置</span></a>
<a class="sourceLine" id="cb89-3" title="3">  <span class="op">|</span> <span class="dt">InfixL</span>  (m (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a)) <span class="co">-- ^ 左結合の中置</span></a>
<a class="sourceLine" id="cb89-4" title="4">  <span class="op">|</span> <span class="dt">InfixR</span>  (m (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a)) <span class="co">-- ^ 右結合の中置</span></a>
<a class="sourceLine" id="cb89-5" title="5">  <span class="op">|</span> <span class="dt">Prefix</span>  (m (a <span class="ot">-&gt;</span> a))      <span class="co">-- ^ 前置</span></a>
<a class="sourceLine" id="cb89-6" title="6">  <span class="op">|</span> <span class="dt">Postfix</span> (m (a <span class="ot">-&gt;</span> a))      <span class="co">-- ^ 後置</span></a>
<a class="sourceLine" id="cb89-7" title="7"></a>
<a class="sourceLine" id="cb89-8" title="8"><span class="ot">operatorTable ::</span> [[<span class="dt">Operator</span> <span class="dt">Parser</span> <span class="dt">Expr</span>]]</a>
<a class="sourceLine" id="cb89-9" title="9">operatorTable <span class="ot">=</span></a>
<a class="sourceLine" id="cb89-10" title="10">  [ [ prefix <span class="st">&quot;-&quot;</span> <span class="dt">Negation</span></a>
<a class="sourceLine" id="cb89-11" title="11">    , prefix <span class="st">&quot;+&quot;</span> <span class="fu">id</span> ]</a>
<a class="sourceLine" id="cb89-12" title="12">  , [ binary <span class="st">&quot;*&quot;</span> <span class="dt">Product</span></a>
<a class="sourceLine" id="cb89-13" title="13">    , binary <span class="st">&quot;/&quot;</span> <span class="dt">Division</span> ]</a>
<a class="sourceLine" id="cb89-14" title="14">  , [ binary <span class="st">&quot;+&quot;</span> <span class="dt">Sum</span></a>
<a class="sourceLine" id="cb89-15" title="15">    , binary <span class="st">&quot;-&quot;</span> <span class="dt">Subtr</span> ]</a>
<a class="sourceLine" id="cb89-16" title="16">  ]</a>
<a class="sourceLine" id="cb89-17" title="17"></a>
<a class="sourceLine" id="cb89-18" title="18"><span class="ot">binary ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> (<span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span>) <span class="ot">-&gt;</span> <span class="dt">Operator</span> <span class="dt">Parser</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb89-19" title="19">binary  name f <span class="ot">=</span> <span class="dt">InfixL</span>  (f <span class="op">&lt;$</span> symbol name)</a>
<a class="sourceLine" id="cb89-20" title="20"></a>
<a class="sourceLine" id="cb89-21" title="21">prefix,<span class="ot"> postfix ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> (<span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span>) <span class="ot">-&gt;</span> <span class="dt">Operator</span> <span class="dt">Parser</span> <span class="dt">Expr</span></a>
<a class="sourceLine" id="cb89-22" title="22">prefix  name f <span class="ot">=</span> <span class="dt">Prefix</span>  (f <span class="op">&lt;$</span> symbol name)</a>
<a class="sourceLine" id="cb89-23" title="23">postfix name f <span class="ot">=</span> <span class="dt">Postfix</span> (f <span class="op">&lt;$</span> symbol name)</a></code></pre></div>
<p><code>binary</code> で <code>InfixL</code> 内部の <code>Parser (Expr -&gt; Expr -&gt; Expr)</code> を どのように配置し、 同様に<code>prefix</code> と <code>postfix</code> に <code>Parser (Expr -&gt; Expr)</code> を どのように配置しているのか注意してください。 すなわち、<code>symbol name</code> を実行し、 <code>Expr</code> 型の最終結果を得るために項に適用する関数を返します。</p>
<p>これでパーサを試すことができます。準備は完了です！</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb90-1" title="1">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pExpr <span class="op">&lt;</span>* eof) <span class="st">&quot;a * (b + 2)&quot;</span></a>
<a class="sourceLine" id="cb90-2" title="2"><span class="ex">Product</span> (Var <span class="st">&quot;a&quot;</span>) <span class="kw">(</span><span class="ex">Sum</span> (Var <span class="st">&quot;b&quot;</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">Int</span> 2<span class="kw">)</span>)</a>
<a class="sourceLine" id="cb90-3" title="3"></a>
<a class="sourceLine" id="cb90-4" title="4">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pExpr <span class="op">&lt;</span>* eof) <span class="st">&quot;a * b + 2&quot;</span></a>
<a class="sourceLine" id="cb90-5" title="5"><span class="ex">Sum</span> (Product (Var <span class="st">&quot;a&quot;</span>) <span class="kw">(</span><span class="ex">Var</span> <span class="st">&quot;b&quot;</span><span class="kw">)</span>) <span class="kw">(</span><span class="ex">Int</span> 2<span class="kw">)</span></a>
<a class="sourceLine" id="cb90-6" title="6"></a>
<a class="sourceLine" id="cb90-7" title="7">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pExpr <span class="op">&lt;</span>* eof) <span class="st">&quot;a * b / 2&quot;</span></a>
<a class="sourceLine" id="cb90-8" title="8"><span class="ex">Division</span> (Product (Var <span class="st">&quot;a&quot;</span>) <span class="kw">(</span><span class="ex">Var</span> <span class="st">&quot;b&quot;</span><span class="kw">)</span>) <span class="kw">(</span><span class="ex">Int</span> 2<span class="kw">)</span></a>
<a class="sourceLine" id="cb90-9" title="9"></a>
<a class="sourceLine" id="cb90-10" title="10">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pExpr <span class="op">&lt;</span>* eof) <span class="st">&quot;a * (b $ 2)&quot;</span></a>
<a class="sourceLine" id="cb90-11" title="11"><span class="ex">1</span>:8:</a>
<a class="sourceLine" id="cb90-12" title="12">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb90-13" title="13"><span class="ex">1</span> <span class="kw">|</span> <span class="ex">a</span> * (b $ 2)</a>
<a class="sourceLine" id="cb90-14" title="14">  <span class="kw">|</span>        ^</a>
<a class="sourceLine" id="cb90-15" title="15"><span class="ex">unexpected</span> <span class="st">'$'</span></a>
<a class="sourceLine" id="cb90-16" title="16"><span class="ex">expecting</span> <span class="st">')'</span> or operator</a></code></pre></div>
<p><code>Text.Megaparsec.Expr</code> モジュールのドキュメントには、 あまり標準的ではない状況で役立つヒントがいくつか含まれているので、 それを読むことをお勧めします。</p>
<p><a name="Indentation"></a></p>
<h2 id="indentation-sensitiveなパース">Indentation-sensitiveなパース</h2>
<p><code>Text.Megaparsec.Char.Lexer</code> モジュールには、 Indentation-sensitive な文法をパースするときに役立つツールが含まれています。 最初に利用可能なコンビネータを見直し、 次にIndentation-sensitiveなパーサを書くことによって それらを使えるようにします。</p>
<p><a name="nonIndented"></a></p>
<h2 id="nonindented-と-indentblock"><code>nonIndented</code> と <code>indentBlock</code></h2>
<p>最も単純な<code>nonIndented</code> から始めましょう。</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb91-1" title="1"><span class="ot">nonIndented ::</span> <span class="dt">MonadParsec</span> e s m</a>
<a class="sourceLine" id="cb91-2" title="2">  <span class="ot">=&gt;</span> m ()              <span class="co">-- ^ インデント (スペース) の消費方法</span></a>
<a class="sourceLine" id="cb91-3" title="3">  <span class="ot">-&gt;</span> m a               <span class="co">-- ^ 内側のパーサ</span></a>
<a class="sourceLine" id="cb91-4" title="4">  <span class="ot">-&gt;</span> m a</a></code></pre></div>
<p>それはその内側のパーサが インデントされていない入力を消費することを確認できます。 これは、Indentation-sensitiveな入力による 高レベルなパーサの背後にあるモデルの一部です。 インデントされていないトップレベルの項目があり、 すべてのインデントされたトークンはそれらのトップレベル定義の 直接的または間接的な子であると述べます。 <code>megaparsec</code>では、これを表現するために追加の状態を必要としません。 インデントは常に相対的なので、 私たちの考えは、参照トークンとインデントトークンのために パーサを明示的に結び付けることです。 そして、パーサの純粋な組み合わせによって Indentation-sensitiveな文法を定義することです。</p>
<p>それでは、インデントブロックのパーサを どのように定義すればよいのでしょうか。 <code>indentBlock</code>のシグネチャを見てみましょう。</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb92-1" title="1"><span class="ot">indentBlock ::</span> (<span class="dt">MonadParsec</span> e s m, <span class="dt">Token</span> s <span class="op">~</span> <span class="dt">Char</span>)</a>
<a class="sourceLine" id="cb92-2" title="2">  <span class="ot">=&gt;</span> m ()              <span class="co">-- ^ インデント (スペース) の消費方法</span></a>
<a class="sourceLine" id="cb92-3" title="3">  <span class="ot">-&gt;</span> m (<span class="dt">IndentOpt</span> m a b) <span class="co">-- ^ 「参照」トークン の消費方法</span></a>
<a class="sourceLine" id="cb92-4" title="4">  <span class="ot">-&gt;</span> m a</a></code></pre></div>
<p>はじめに、インデントの消費方法を指定します。 ここで注意すべき重要なことは、 このスペースを消費するパーサは改行も消費しなければならないのに対し、 トークン(参照トークンとインデントトークン)は 通常改行をそれらの後に消費するべきではないということです。</p>
<p>ご覧のとおり、2番目の引数を使用すると参照トークンをパースし、 次に<code>indentBlock</code>に何をするかを指示するデータ構造を返すことができます。 いくつかのオプションがあります。</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb93-1" title="1"><span class="kw">data</span> <span class="dt">IndentOpt</span> m a b</a>
<a class="sourceLine" id="cb93-2" title="2">  <span class="ot">=</span> <span class="dt">IndentNone</span> a</a>
<a class="sourceLine" id="cb93-3" title="3">    <span class="co">-- ^ インデントトークンを消費せず、値を返すだけ</span></a>
<a class="sourceLine" id="cb93-4" title="4">  <span class="op">|</span> <span class="dt">IndentMany</span> (<span class="dt">Maybe</span> <span class="dt">Pos</span>) ([b] <span class="ot">-&gt;</span> m a) (m b)</a>
<a class="sourceLine" id="cb93-5" title="5">    <span class="co">-- ^ 多くの(0個の場合を含む)インデントトークンをパースし, 与えられたインデント</span></a>
<a class="sourceLine" id="cb93-6" title="6">    <span class="co">-- レベルを使う ('Nothing' の場合は最初にインデントされたトークンのレベルを使う)。</span></a>
<a class="sourceLine" id="cb93-7" title="7">    <span class="co">-- 2番目の引数は最終結果を取得する方法を示し、三番目の</span></a>
<a class="sourceLine" id="cb93-8" title="8">    <span class="co">-- 引数はインデントされたトークンをパースする方法を示す。</span></a>
<a class="sourceLine" id="cb93-9" title="9">  <span class="op">|</span> <span class="dt">IndentSome</span> (<span class="dt">Maybe</span> <span class="dt">Pos</span>) ([b] <span class="ot">-&gt;</span> m a) (m b)</a>
<a class="sourceLine" id="cb93-10" title="10">    <span class="co">-- ^ 'IndentMany'に似ているが、少なくとも1つのインデントトークンが</span></a>
<a class="sourceLine" id="cb93-11" title="11">    <span class="co">-- 出現することを要求する。</span></a></code></pre></div>
<p>考えを変えてインデントのないトークンをパースすることができます。 多くの（つまり、場合によっては0個の）インデントトークンをパースするか、 少なくとも1つのそのようなトークンを要求することができます。 <code>indentBlock</code>が最初のインデントトークンのインデントレベルを検出して それを使用するか、手動でインデントレベルを指定することができます。</p>
<p><a name="SimpleIndented"></a></p>
<h2 id="単純なインデントされたリストのパース">単純なインデントされたリストのパース</h2>
<p>いくつかの項目の単純なインデントされたリストをパースしましょう。 インポートセクションから始めます。</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb94-1" title="1"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb94-2" title="2"><span class="ot">{-# LANGUAGE TupleSections     #-}</span></a>
<a class="sourceLine" id="cb94-3" title="3"></a>
<a class="sourceLine" id="cb94-4" title="4"><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></a>
<a class="sourceLine" id="cb94-5" title="5"></a>
<a class="sourceLine" id="cb94-6" title="6"><span class="kw">import</span> <span class="dt">Control.Applicative</span></a>
<a class="sourceLine" id="cb94-7" title="7"><span class="kw">import</span> <span class="dt">Control.Monad</span> (void)</a>
<a class="sourceLine" id="cb94-8" title="8"><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb94-9" title="9"><span class="kw">import</span> <span class="dt">Data.Void</span></a>
<a class="sourceLine" id="cb94-10" title="10"><span class="kw">import</span> <span class="dt">Text.Megaparsec</span></a>
<a class="sourceLine" id="cb94-11" title="11"><span class="kw">import</span> <span class="dt">Text.Megaparsec.Char</span></a>
<a class="sourceLine" id="cb94-12" title="12"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Megaparsec.Char.Lexer</span> <span class="kw">as</span> <span class="dt">L</span></a>
<a class="sourceLine" id="cb94-13" title="13"></a>
<a class="sourceLine" id="cb94-14" title="14"><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Void</span> <span class="dt">Text</span></a></code></pre></div>
<p>2種類のスペースコンシューマが必要になります。 1つは改行を消費する<code>scn</code>、もう1つは消費しない<code>sc</code>です（実際にはここではスペースとタブのみをパースします）。</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb95-1" title="1"><span class="ot">lineComment ::</span> <span class="dt">Parser</span> ()</a>
<a class="sourceLine" id="cb95-2" title="2">lineComment <span class="ot">=</span> L.skipLineComment <span class="st">&quot;#&quot;</span></a>
<a class="sourceLine" id="cb95-3" title="3"></a>
<a class="sourceLine" id="cb95-4" title="4"><span class="ot">scn ::</span> <span class="dt">Parser</span> ()</a>
<a class="sourceLine" id="cb95-5" title="5">scn <span class="ot">=</span> L.space space1 lineComment empty</a>
<a class="sourceLine" id="cb95-6" title="6"></a>
<a class="sourceLine" id="cb95-7" title="7"><span class="ot">sc ::</span> <span class="dt">Parser</span> ()</a>
<a class="sourceLine" id="cb95-8" title="8">sc <span class="ot">=</span> L.space (void <span class="op">$</span> some (char <span class="ch">' '</span> <span class="op">&lt;|&gt;</span> char <span class="ch">'\t'</span>)) lineComment empty</a>
<a class="sourceLine" id="cb95-9" title="9"></a>
<a class="sourceLine" id="cb95-10" title="10"><span class="ot">lexeme ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</a>
<a class="sourceLine" id="cb95-11" title="11">lexeme <span class="ot">=</span> L.lexeme sc</a></code></pre></div>
<p>楽しみのために、<code>#</code>で始まる行のコメントを許可します。</p>
<p><code>pItemList</code> は、それ自体が参照トークン（リストのヘッダー） とインデントトークン（リストの項目）の組み合わせである トップレベルの形式です。</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb96-1" title="1"><span class="ot">pItemList ::</span> <span class="dt">Parser</span> (<span class="dt">String</span>, [<span class="dt">String</span>]) <span class="co">-- ヘッダとアイテムのリスト</span></a>
<a class="sourceLine" id="cb96-2" title="2">pItemList <span class="ot">=</span> L.nonIndented scn (L.indentBlock scn p)</a>
<a class="sourceLine" id="cb96-3" title="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb96-4" title="4">    p <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb96-5" title="5">      header <span class="ot">&lt;-</span> pItem</a>
<a class="sourceLine" id="cb96-6" title="6">      <span class="fu">return</span> (<span class="dt">L.IndentMany</span> <span class="dt">Nothing</span> (<span class="fu">return</span> <span class="op">.</span> (header, )) pItem)</a></code></pre></div>
<p>私たちの目的であるアイテムは、英数字とハイフンのシーケンスです。</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb97-1" title="1"><span class="ot">pItem ::</span> <span class="dt">Parser</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb97-2" title="2">pItem <span class="ot">=</span> lexeme (some (alphaNumChar <span class="op">&lt;|&gt;</span> char <span class="ch">'-'</span>)) <span class="op">&lt;?&gt;</span> <span class="st">&quot;list item&quot;</span></a></code></pre></div>
<p>GHCiでコードをロードし、 組み込みの<code>parseTest</code>の助けを借りて試してみましょう。</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb98-1" title="1">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb98-2" title="2"><span class="ex">1</span>:1:</a>
<a class="sourceLine" id="cb98-3" title="3">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb98-4" title="4"><span class="ex">1</span> <span class="kw">|</span> <span class="op">&lt;</span><span class="ex">empty</span> line<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb98-5" title="5">  <span class="kw">|</span> ^</a>
<a class="sourceLine" id="cb98-6" title="6"><span class="ex">unexpected</span> end of input</a>
<a class="sourceLine" id="cb98-7" title="7"><span class="ex">expecting</span> list item</a>
<a class="sourceLine" id="cb98-8" title="8"></a>
<a class="sourceLine" id="cb98-9" title="9">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;something&quot;</span></a>
<a class="sourceLine" id="cb98-10" title="10"><span class="kw">(</span><span class="st">&quot;something&quot;</span>,[]<span class="kw">)</span></a>
<a class="sourceLine" id="cb98-11" title="11"></a>
<a class="sourceLine" id="cb98-12" title="12">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;  something&quot;</span></a>
<a class="sourceLine" id="cb98-13" title="13"><span class="ex">1</span>:3:</a>
<a class="sourceLine" id="cb98-14" title="14">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb98-15" title="15"><span class="ex">1</span> <span class="kw">|</span>   <span class="ex">something</span></a>
<a class="sourceLine" id="cb98-16" title="16">  <span class="kw">|</span>   ^</a>
<a class="sourceLine" id="cb98-17" title="17"><span class="ex">incorrect</span> indentation (got 3, should be equal to 1)</a>
<a class="sourceLine" id="cb98-18" title="18"></a>
<a class="sourceLine" id="cb98-19" title="19">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;something\none\ntwo\nthree&quot;</span></a>
<a class="sourceLine" id="cb98-20" title="20"><span class="ex">2</span>:1:</a>
<a class="sourceLine" id="cb98-21" title="21">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb98-22" title="22"><span class="ex">2</span> <span class="kw">|</span> <span class="ex">one</span></a>
<a class="sourceLine" id="cb98-23" title="23">  <span class="kw">|</span> ^</a>
<a class="sourceLine" id="cb98-24" title="24"><span class="ex">unexpected</span> <span class="st">'o'</span></a>
<a class="sourceLine" id="cb98-25" title="25"><span class="ex">expecting</span> end of input</a></code></pre></div>
<p><code>IndentMany</code> オプションを使用しているので、 空のリストでも問題ありませんが、 組み込みのコンビネータ<code>space</code>はエラーメッセージから 「より多くのスペースを期待する」というフレーズを隠しているので、 このエラーメッセージは完全に妥当です。</p>
<p>続けましょう。</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb99-1" title="1">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;something\n  one\n    two\n  three&quot;</span></a>
<a class="sourceLine" id="cb99-2" title="2"><span class="ex">3</span>:5:</a>
<a class="sourceLine" id="cb99-3" title="3">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb99-4" title="4"><span class="ex">3</span> <span class="kw">|</span>     <span class="ex">two</span></a>
<a class="sourceLine" id="cb99-5" title="5">  <span class="kw">|</span>     ^</a>
<a class="sourceLine" id="cb99-6" title="6"><span class="ex">incorrect</span> indentation (got 5, should be equal to 3)</a>
<a class="sourceLine" id="cb99-7" title="7"></a>
<a class="sourceLine" id="cb99-8" title="8">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;something\n  one\n  two\n three&quot;</span></a>
<a class="sourceLine" id="cb99-9" title="9"><span class="ex">4</span>:2:</a>
<a class="sourceLine" id="cb99-10" title="10">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb99-11" title="11"><span class="ex">4</span> <span class="kw">|</span>  <span class="ex">three</span></a>
<a class="sourceLine" id="cb99-12" title="12">  <span class="kw">|</span>  ^</a>
<a class="sourceLine" id="cb99-13" title="13"><span class="ex">incorrect</span> indentation (got 2, should be equal to 3)</a>
<a class="sourceLine" id="cb99-14" title="14"></a>
<a class="sourceLine" id="cb99-15" title="15">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;something\n  one\n  two\n  three&quot;</span></a>
<a class="sourceLine" id="cb99-16" title="16"><span class="kw">(</span><span class="st">&quot;something&quot;</span>,[<span class="st">&quot;one&quot;</span>,<span class="st">&quot;two&quot;</span>,<span class="st">&quot;three&quot;</span>]<span class="kw">)</span></a></code></pre></div>
<p>これは確かにうまくいきそうです。 <code>IndentMany</code> を <code>IndentSome</code> に、<code>Nothing</code> を<code>Just (mkPos 5)</code>に 置き換えます（インデントレベルは1から数えられるため、 インデントされる項目の前に4つのスペースが必要になります）。</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb100-1" title="1"><span class="ot">pItemList ::</span> <span class="dt">Parser</span> (<span class="dt">String</span>, [<span class="dt">String</span>])</a>
<a class="sourceLine" id="cb100-2" title="2">pItemList <span class="ot">=</span> L.nonIndented scn (L.indentBlock scn p)</a>
<a class="sourceLine" id="cb100-3" title="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb100-4" title="4">    p <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb100-5" title="5">      header <span class="ot">&lt;-</span> pItem</a>
<a class="sourceLine" id="cb100-6" title="6">      <span class="fu">return</span> (<span class="dt">L.IndentSome</span> (<span class="dt">Just</span> (mkPos <span class="dv">5</span>)) (<span class="fu">return</span> <span class="op">.</span> (header, )) pItem)</a></code></pre></div>
<p>ここで、</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb101-1" title="1">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;something\n&quot;</span></a>
<a class="sourceLine" id="cb101-2" title="2"><span class="ex">2</span>:1:</a>
<a class="sourceLine" id="cb101-3" title="3">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb101-4" title="4"><span class="ex">2</span> <span class="kw">|</span> <span class="op">&lt;</span><span class="ex">empty</span> line<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb101-5" title="5">  <span class="kw">|</span> ^</a>
<a class="sourceLine" id="cb101-6" title="6"><span class="ex">incorrect</span> indentation (got 1, should be greater than 1)</a>
<a class="sourceLine" id="cb101-7" title="7"></a>
<a class="sourceLine" id="cb101-8" title="8">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;something\n  one&quot;</span></a>
<a class="sourceLine" id="cb101-9" title="9"><span class="ex">2</span>:3:</a>
<a class="sourceLine" id="cb101-10" title="10">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb101-11" title="11"><span class="ex">2</span> <span class="kw">|</span>   <span class="ex">one</span></a>
<a class="sourceLine" id="cb101-12" title="12">  <span class="kw">|</span>   ^</a>
<a class="sourceLine" id="cb101-13" title="13"><span class="ex">incorrect</span> indentation (got 3, should be equal to 5)</a>
<a class="sourceLine" id="cb101-14" title="14"></a>
<a class="sourceLine" id="cb101-15" title="15">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;something\n    one&quot;</span></a>
<a class="sourceLine" id="cb101-16" title="16"><span class="kw">(</span><span class="st">&quot;something&quot;</span>,[<span class="st">&quot;one&quot;</span>]<span class="kw">)</span></a></code></pre></div>
<p>最初のメッセージは少し驚くかもしれませんが、 リスト内に少なくとも1つの項目がなければならないことを <code>megaparsec</code>は知っているので、インデントレベルをチェックし、 そしてそれは1であり、間違っているので報告します。</p>
<p><a name="NestedIndented"></a></p>
<h2 id="ネストされたインデントのあるリスト">ネストされたインデントのあるリスト</h2>
<p>リストのアイテムにサブアイテムを含めることを許可しましょう。 これには、新しいパーサ<code>pComplexItem</code>が必要になります。</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb102-1" title="1"><span class="ex">pComplexItem</span> :: Parser (String, [String])</a>
<a class="sourceLine" id="cb102-2" title="2"><span class="ex">pComplexItem</span> = L.indentBlock scn p</a>
<a class="sourceLine" id="cb102-3" title="3">  <span class="ex">where</span></a>
<a class="sourceLine" id="cb102-4" title="4">    <span class="ex">p</span> = do</a>
<a class="sourceLine" id="cb102-5" title="5">      <span class="ex">header</span> <span class="op">&lt;</span>- pItem</a>
<a class="sourceLine" id="cb102-6" title="6">      <span class="bu">return</span> (L.IndentMany Nothing (return . (header, )) <span class="ex">pItem</span>)</a>
<a class="sourceLine" id="cb102-7" title="7"></a>
<a class="sourceLine" id="cb102-8" title="8"><span class="ex">pItemList</span> :: Parser (String, [(String, [String])])</a>
<a class="sourceLine" id="cb102-9" title="9"><span class="ex">pItemList</span> = L.nonIndented scn (L.indentBlock scn p)</a>
<a class="sourceLine" id="cb102-10" title="10">  <span class="ex">where</span></a>
<a class="sourceLine" id="cb102-11" title="11">    <span class="ex">p</span> = do</a>
<a class="sourceLine" id="cb102-12" title="12">      <span class="ex">header</span> <span class="op">&lt;</span>- pItem</a>
<a class="sourceLine" id="cb102-13" title="13">      <span class="bu">return</span> (L.IndentSome Nothing (return . (header, )) <span class="ex">pComplexItem</span>)</a></code></pre></div>
<p>次のような入力を与えます。</p>
<pre><code>first-chapter
  paragraph-one
      note-A # an important note here!
      note-B
  paragraph-two
    note-1
    note-2
  paragraph-three</code></pre>
<p>このような結果が得られます。</p>
<pre><code>Right
  ( &quot;first-chapter&quot;
  , [ (&quot;paragraph-one&quot;,   [&quot;note-A&quot;,&quot;note-B&quot;])
    , (&quot;paragraph-two&quot;,   [&quot;note-1&quot;,&quot;note-2&quot;])
    , (&quot;paragraph-three&quot;, []) ] )</code></pre>
<p>これは、このアプローチがネストされたインデントのある構造に対して 追加の状態を必要とせずにどのように拡張するかを示しています。</p>
<p><a name="LineFold"></a></p>
<h2 id="行の畳み込みの追加">行の畳み込みの追加</h2>
<p>行の畳み込みは、後続の項目のインデントレベルが 最初の項目のインデントレベルよりも大きい限り、 1行または複数行に配置できる複数の要素で構成されます。</p>
<p><code>lineFold</code> という別のヘルパーを利用しましょう。</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb105-1" title="1"><span class="ot">pComplexItem ::</span> <span class="dt">Parser</span> (<span class="dt">String</span>, [<span class="dt">String</span>])</a>
<a class="sourceLine" id="cb105-2" title="2">pComplexItem <span class="ot">=</span> L.indentBlock scn p</a>
<a class="sourceLine" id="cb105-3" title="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb105-4" title="4">    p <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb105-5" title="5">      header <span class="ot">&lt;-</span> pItem</a>
<a class="sourceLine" id="cb105-6" title="6">      <span class="fu">return</span> (<span class="dt">L.IndentMany</span> <span class="dt">Nothing</span> (<span class="fu">return</span> <span class="op">.</span> (header, )) pLineFold)</a>
<a class="sourceLine" id="cb105-7" title="7"></a>
<a class="sourceLine" id="cb105-8" title="8"><span class="ot">pLineFold ::</span> <span class="dt">Parser</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb105-9" title="9">pLineFold <span class="ot">=</span> L.lineFold scn <span class="op">$</span> \sc' <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb105-10" title="10">  <span class="kw">let</span> ps <span class="ot">=</span> some (alphaNumChar <span class="op">&lt;|&gt;</span> char <span class="ch">'-'</span>) <span class="ot">`sepBy1`</span> try sc'</a>
<a class="sourceLine" id="cb105-11" title="11">  <span class="kw">in</span> <span class="fu">unwords</span> <span class="op">&lt;$&gt;</span> ps <span class="op">&lt;*</span> scn <span class="co">-- (1)</span></a></code></pre></div>
<p><code>lineFold</code>は次のように機能します。 改行を受理するスペースコンシューマ<code>scn</code>を提供し、 行の畳み込みの要素間のスペースを消費するために コールバックで使用できる特別なスペースコンシューマ<code>sc'</code>を返します。</p>
<p>なぜ <code>try sc'</code> と (1) の行で <code>scn</code>を使うのですか？状況は以下のとおりです。</p>
<ul>
<li><p>行の畳込みの要素は、開始位置よりもインデントが大きくなります。</p></li>
<li><p><code>sc'</code>は、空白を消費した後の列が最初の列よりも大きくなるように、改行とともに空白を消費します。</p></li>
<li><p>停止させるには、<code>sc'</code> は逆の状況に遭遇する必要があります。つまり、消費後の列は最初の列以下になります。その時点では (tryのおかげで) 入力を消費せずに失敗し、<code>scn</code> はその列から始まる新しいものの前の空白を取り上げるために使用されます。</p></li>
<li><p>先程使用していた <code>sc'</code> はすでに改行文字を消費するスペースコンシューマによって空白を調べています。したがって、末尾の空白を拾うときに改行も消費するのは論理的なことです。(1) の行で <code>sc</code>ではなく<code>scn</code>が使用されるのはこのためです。</p></li>
</ul>
<p>練習問題：私たちのパーサーの最終版で遊ぶことは 読者のための練習として残されています。 複数の単語からなる「項目」を作成することができ、 それらが折り返されている限り、 それらはそれらの間の単一のスペースでパースされ連結されます。</p>
<p><a name="Efficient"></a></p>
<h2 id="効率のよいパーサを書く">効率のよいパーサを書く</h2>
<p><code>megaparsec</code> のパーサの性能を向上させるために 何を試みるべきか議論しましょう。 プロファイリングとベンチマークによって 改善があるかどうかを常に確認する必要があることに注意してください。 これは、パフォーマンスを調整するときに正しいことを 行っているかどうかを理解するための唯一の方法です。</p>
<p>一般的なアドバイス：</p>
<ul>
<li><p>あなたのパーサが普通の<code>Parsec</code>モナド (これは<code>Identity</code>を組み合わせた<code>ParsecT</code>のモナド変換子であることを思い出してください。これは非常に軽量です) の代わりにモナドスタックを使っている場合、少なくとも<code>transformer</code>ライブラリのバージョン0.5と、<code>megaparsec</code> のバージョン7.0以上を必ず使用してください。これらのバージョンでは、どちらのライブラリもパフォーマンスが大幅に向上しているため、何もしなくても優れたパフォーマンスを得ることができます。</p></li>
<li><p><code>Parsec</code> モナドは、 <code>ParsecT</code> ベースのモナド変換子よりも常に高速になります。どうしても必要な場合以外は、<code>StateT</code>、<code>WriterT</code>、およびその他のモナド変換子を使用しないでください。スタックに追加すればするほど遅くなります。</p></li>
<li><p>バックトラックはコストの高い操作です。すべての分岐が失敗する前に入力に深く入り込むことができるような長い分岐の連鎖を作ることを避けてください。</p></li>
<li><p>あなたが本当にそうしたい理由がない限り、パーサの多相性を保ってはいけません。トップレベルの定義ごとに、<code>Parser = Parsec Void Text</code> などの具体的な型を指定して、パーサの型を修正することをお勧めします。このようにすればGHCはより良く最適化できるでしょう。</p></li>
<li><p>惜しみなくインライン展開しましょう(もちろん、理にかなっているときに)。特に短い関数では、インライン展開による違いを見たとき、あなたは目を疑うでしょう。 これは特に、あるモジュールで定義され、別のモジュールで使用されるパーサに当てはまります。なぜなら<code>INLINE</code>および<code>INLINEABLE</code>プラグマはGHCに関数定義をインタフェースファイルにダンプさせるので、特殊化が容易になるからです。</p></li>
<li><p>可能な場合は、<code>takeWhileP</code>、<code>takeWhile1P</code>、および<code>takeP</code>などの高速なプリミティブを使用してください。<a href="https://markkarpov.com/post/megaparsec-more-speed-more-power.html#there-is-hope">このブログ記事</a>では、なぜそれらがとても速いのかを説明します。</p></li>
<li><p>可能であれば <code>oneOf</code>と<code>noneOf</code>を避け、<code>satisfy</code> と <code>notChar</code> を選択してください。</p></li>
</ul>
<p>上記の点のほとんどは追加のコメントを必要としませんが、 新しい高速のプリミティブ、<code>takeWhileP</code> 、 <code>takeWhile1P</code> 、 および <code>takeP</code> を使用する習慣を身に付けることが有益であると思います。 最初の2つは、いくつかの<code>many</code>と<code>some</code>ベースの構造を置き換え、 それらを早くし、返されるデータの型を入力ストリームのチャンクに変更すること、つまり以前議論した <code>Tokens s</code> 型に変更できるため、特に一般的です。</p>
<p>たとえば、URIをパースしたときに、 認証の構成要素内でユーザ名をパースするための 次のコードがあったことを思い出してください。</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb106-1" title="1">  user <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar</a></code></pre></div>
<p>これは <code>takeWhile1P</code> に置き換え可能です。</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb107-1" title="1">user <span class="ot">&lt;-</span> takeWhile1P (<span class="dt">Just</span> <span class="st">&quot;alpha num character&quot;</span>) <span class="fu">isAlphaNum</span></a>
<a class="sourceLine" id="cb107-2" title="2">  <span class="co">--                  ^                            ^</span></a>
<a class="sourceLine" id="cb107-3" title="3">  <span class="co">--                  |                            |</span></a>
<a class="sourceLine" id="cb107-4" title="4">  <span class="co">-- マッチさせるトークンのラベル                 述語</span></a></code></pre></div>
<p><code>ByteStrings</code> と <code>Text</code>をパースすると、 これは元の方法よりはるかに高速になります。 また、<code>takeWhile1P</code> から直接 <code>Text</code>を取得するため、 <code>T.pack</code>は不要になりました。</p>
<p>以下の式は、<code>takeWhileP</code> と <code>takeWhile1P</code> の <code>Maybe String</code> 引数の意味を理解するのに役立ちます。</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb108-1" title="1">takeWhileP  (<span class="dt">Just</span> <span class="st">&quot;foo&quot;</span>) f <span class="ot">=</span> many (satisfy f <span class="op">&lt;?&gt;</span> <span class="st">&quot;foo&quot;</span>)</a>
<a class="sourceLine" id="cb108-2" title="2">takeWhileP  <span class="dt">Nothing</span>      f <span class="ot">=</span> many (satisfy f)</a>
<a class="sourceLine" id="cb108-3" title="3">takeWhile1P (<span class="dt">Just</span> <span class="st">&quot;foo&quot;</span>) f <span class="ot">=</span> some (satisfy f <span class="op">&lt;?&gt;</span> <span class="st">&quot;foo&quot;</span>)</a>
<a class="sourceLine" id="cb108-4" title="4">takeWhile1P <span class="dt">Nothing</span>      f <span class="ot">=</span> some (satisfy f)</a></code></pre></div>
<p><a name="Error"></a></p>
<h2 id="パースエラー">パースエラー</h2>
<p><code>megaparsec</code> のほとんどの機能の使い方を調べてきたので、 パースエラーの定義する方法、通知する方法、 実行中のパーサ内での処理方法について学びましょう。</p>
<p><a name="ErrDef"></a></p>
<h2 id="パースエラーの定義">パースエラーの定義</h2>
<p>型<code>ParseError</code> は次のように定義されています。</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb109-1" title="1"><span class="kw">data</span> <span class="dt">ParseError</span> s e</a>
<a class="sourceLine" id="cb109-2" title="2">  <span class="ot">=</span> <span class="dt">TrivialError</span> <span class="dt">Int</span> (<span class="dt">Maybe</span> (<span class="dt">ErrorItem</span> (<span class="dt">Token</span> s))) (<span class="dt">Set</span> (<span class="dt">ErrorItem</span> (<span class="dt">Token</span> s)))</a>
<a class="sourceLine" id="cb109-3" title="3">    <span class="co">-- ^ Megaparsecの機構によって生成された自明なエラー。 データコンストラクタには、</span></a>
<a class="sourceLine" id="cb109-4" title="4">    <span class="co">-- エラーのオフセット、予期しないトークン（存在する場合）、</span></a>
<a class="sourceLine" id="cb109-5" title="5">    <span class="co">-- および予期するトークンが含まれます。</span></a>
<a class="sourceLine" id="cb109-6" title="6">  <span class="op">|</span> <span class="dt">FancyError</span> <span class="dt">Int</span> (<span class="dt">Set</span> (<span class="dt">ErrorFancy</span> e))</a>
<a class="sourceLine" id="cb109-7" title="7">    <span class="co">-- ^ ファンシーなカスタムエラー。</span></a></code></pre></div>
<p><code>ParseError</code>は、多くても1つの予期しないアイテムと 予期するアイテムの（空かもしれない）コレクションを持つ <code>TrivialError</code>、 または <code>FancyError</code> のいずれかです。</p>
<p><code>ParseError s e</code> は、2つの型変数によってパラメータ化されています。</p>
<ul>
<li><code>s</code> は入力ストリームの型です。</li>
<li><code>e</code> は、パースエラーのカスタムコンポーネントの型です。</li>
</ul>
<p><code>ErrorItem</code> は次のように定義されています。</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb110-1" title="1"><span class="kw">data</span> <span class="dt">ErrorItem</span> t</a>
<a class="sourceLine" id="cb110-2" title="2">  <span class="ot">=</span> <span class="dt">Tokens</span> (<span class="dt">NonEmpty</span> t)      <span class="co">-- ^ 空ではないトークンのストリーム</span></a>
<a class="sourceLine" id="cb110-3" title="3">  <span class="op">|</span> <span class="dt">Label</span> (<span class="dt">NonEmpty</span> <span class="dt">Char</span>)    <span class="co">-- ^ ラベル (空ではない)</span></a>
<a class="sourceLine" id="cb110-4" title="4">  <span class="op">|</span> <span class="dt">EndOfInput</span>               <span class="co">-- ^ 入力の終わり</span></a></code></pre></div>
<p>これが<code>ErrorFancy</code> です。</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb111-1" title="1"><span class="kw">data</span> <span class="dt">ErrorFancy</span> e</a>
<a class="sourceLine" id="cb111-2" title="2">  <span class="ot">=</span> <span class="dt">ErrorFail</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb111-3" title="3">    <span class="co">-- ^ パーサモナドで 'fail'が使われている</span></a>
<a class="sourceLine" id="cb111-4" title="4">  <span class="op">|</span> <span class="dt">ErrorIndentation</span> <span class="dt">Ordering</span> <span class="dt">Pos</span> <span class="dt">Pos</span></a>
<a class="sourceLine" id="cb111-5" title="5">    <span class="co">-- ^ インデントの誤りによるエラー：参照レベルと実際のレベルの間の</span></a>
<a class="sourceLine" id="cb111-6" title="6">    <span class="co">-- 望ましい順序、参照インデントレベル、実際のインデントレベル。</span></a>
<a class="sourceLine" id="cb111-7" title="7">  <span class="op">|</span> <span class="dt">ErrorCustom</span> e</a>
<a class="sourceLine" id="cb111-8" title="8">    <span class="co">-- ^ カスタムエラーデータ、 'Error Fancy'の'e'を'Void'に</span></a>
<a class="sourceLine" id="cb111-9" title="9">    <span class="co">-- することで都合に応じて無効にすることができます。</span></a></code></pre></div>
<p><code>ErrorFancy</code>には、2つの一般的なケースのための データコンストラクタが含まれており、 <code>megaparsec</code>はそのまま使えるようになっています。</p>
<ul>
<li><p><code>fail</code>関数の使用により、パーサが任意の<code>String</code> で失敗の報告をする。</p></li>
<li><p>前の章で見たインデント関連の問題です。 すぐに使えるindentation-sensitive な文法を扱うためのツールを 提供しているので、インデントの問題に関する正しく型付けされた 情報を保存する方法が必要です。</p></li>
</ul>
<p>最後に、<code>ErrorCustom</code>は<code>ErrorFancy</code>型に任意のデータを 埋め込むことを可能にする一種の「拡張スロット」です。 パースエラーにカスタムデータが必要ない場合は、 <code>ErrorFancy</code>を<code>Void</code>でパラメータ化します。 <code>Void</code>はボトムしか含まないため、<code>ErrorCustom</code>は「キャンセル」されるか、 または代数データ型と数値の間の類推に従うと「0倍」になります。</p>
<p>ライブラリの古いバージョンでは、<code>ParseError</code> は <code>parse</code>のような 関数によって直接返していました。しかしバージョン7はエラーごとの 行と列の計算が遅れます。 同様にエラーが発生した場合に表示するために入力から関連する行を取得します。 この情報は通常、パーサが失敗した場合にのみ役立つので、 パースを高速化するために行われます。 古いバージョンのライブラリのもう1つの問題は、 一度に複数のパースエラーを表示する場合（高度な使用法の一例）では、 正しい行を取得するために毎回入力を再びトラバースする必要があることです。</p>
<p>この問題は<code>ParseErrorBundle</code>データ型で解決されます。</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb112-1" title="1"><span class="co">-- | エラーの効率的かつ正確なプリティプリントが可能な、</span></a>
<a class="sourceLine" id="cb112-2" title="2"><span class="co">-- 'PosState'を備えた 'ParseError'の空でないコレクション。</span></a>
<a class="sourceLine" id="cb112-3" title="3"></a>
<a class="sourceLine" id="cb112-4" title="4"><span class="kw">data</span> <span class="dt">ParseErrorBundle</span> s e <span class="ot">=</span> <span class="dt">ParseErrorBundle</span></a>
<a class="sourceLine" id="cb112-5" title="5">  {<span class="ot"> bundleErrors ::</span> <span class="dt">NonEmpty</span> (<span class="dt">ParseError</span> s e)</a>
<a class="sourceLine" id="cb112-6" title="6">    <span class="co">-- ^ パースエラーのオフセットでソートされた 'ParseError'のコレクション</span></a>
<a class="sourceLine" id="cb112-7" title="7">  ,<span class="ot"> bundlePosState ::</span> <span class="dt">PosState</span> s</a>
<a class="sourceLine" id="cb112-8" title="8">    <span class="co">-- ^ 行と列の計算に使用される状態</span></a>
<a class="sourceLine" id="cb112-9" title="9">  }</a></code></pre></div>
<p>パーサを実行するすべての関数は、正しく設定された <code>bundlePosState</code>と 単一の<code>ParseError</code>を内部に持つ<code>ParseErrorBundle</code>を返します。 <code>ParseErrorBundle</code>をユーザに表示する前に、 内部の<code>ParseError</code>のコレクションを拡張できます。 <code>ParseErrors</code>をそれらのオフセットでソートしておくことはユーザーの責任です。</p>
<p><a name="SigErr"></a></p>
<h2 id="パースエラーを通知する方法">パースエラーを通知する方法</h2>
<p>パースエラーを通知するためのさまざまな方法について説明しましょう。 最も簡単な関数は<code>fail</code>です。</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb113-1" title="1">λ<span class="op">&gt;</span> parseTest (<span class="fu">fail</span> <span class="st">&quot;I'm failing, help me!&quot;</span><span class="ot"> ::</span> <span class="dt">Parser</span> ()) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb113-2" title="2"><span class="dv">1</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span></a>
<a class="sourceLine" id="cb113-3" title="3">  <span class="op">|</span></a>
<a class="sourceLine" id="cb113-4" title="4"><span class="dv">1</span> <span class="op">|</span> <span class="op">&lt;</span>empty line<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb113-5" title="5">  <span class="op">|</span> <span class="op">^</span></a>
<a class="sourceLine" id="cb113-6" title="6"><span class="dt">I'm</span> failing, help me<span class="op">!</span></a></code></pre></div>
<p><code>parsec</code>のような、より単純なパーサライブラリに精通している 多くの人々にとってはこれで十分です。 しかし、パースエラーをユーザーに表示することだけではなく、 それを分析したり操作したりする必要があるかもしれません。 これが<code>String</code>があまり便利ではないところです。</p>
<p>自明なパースエラーは通常 <code>megaparsec</code> によって生成されますが、 プリミティブ<code>failure</code>を使って自分自身でそのようなエラーを 知らせることができます。</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb114-1" title="1"><span class="ot">failure ::</span> <span class="dt">MonadParsec</span> e s m</a>
<a class="sourceLine" id="cb114-2" title="2">  <span class="ot">=&gt;</span> <span class="dt">Maybe</span> (<span class="dt">ErrorItem</span> (<span class="dt">Token</span> s)) <span class="co">-- ^ 予期しないアイテム（ある場合）</span></a>
<a class="sourceLine" id="cb114-3" title="3">  <span class="ot">-&gt;</span> <span class="dt">Set</span> (<span class="dt">ErrorItem</span> (<span class="dt">Token</span> s)) <span class="co">-- ^ 予期するアイテム</span></a>
<a class="sourceLine" id="cb114-4" title="4">  <span class="ot">-&gt;</span> m a</a></code></pre></div>
<div class="sourceCode" id="cb115"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb115-1" title="1"><span class="ot">unfortunateParser ::</span> <span class="dt">Parser</span> ()</a>
<a class="sourceLine" id="cb115-2" title="2">unfortunateParser <span class="ot">=</span> failure (<span class="dt">Just</span> <span class="dt">EndOfInput</span>) (Set.fromList es)</a>
<a class="sourceLine" id="cb115-3" title="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb115-4" title="4">    es <span class="ot">=</span> [<span class="dt">Tokens</span> (NE.fromList <span class="st">&quot;a&quot;</span>), <span class="dt">Tokens</span> (NE.fromList <span class="st">&quot;b&quot;</span>)]</a></code></pre></div>
<div class="sourceCode" id="cb116"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb116-1" title="1">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> unfortunateParser <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb116-2" title="2"><span class="ex">1</span>:1:</a>
<a class="sourceLine" id="cb116-3" title="3">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb116-4" title="4"><span class="ex">1</span> <span class="kw">|</span> <span class="op">&lt;</span><span class="ex">empty</span> line<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb116-5" title="5">  <span class="kw">|</span> ^</a>
<a class="sourceLine" id="cb116-6" title="6"><span class="ex">unexpected</span> end of input</a>
<a class="sourceLine" id="cb116-7" title="7"><span class="ex">expecting</span> <span class="st">'a'</span> or <span class="st">'b'</span></a></code></pre></div>
<p><code>fail</code>に基づいたアプローチとは異なり、 簡単なパースエラーはパターンマッチによる検査や変更が容易です。</p>
<p>ファンシーエラーについては、 プリミティブ<code>fancyFaliure</code>で対応します。</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb117-1" title="1"><span class="ot">fancyFailure ::</span> <span class="dt">MonadParsec</span> e s m</a>
<a class="sourceLine" id="cb117-2" title="2">  <span class="ot">=&gt;</span> <span class="dt">Set</span> (<span class="dt">ErrorFancy</span> e) <span class="co">-- ^ ファンシーエラーのコンポーネント</span></a>
<a class="sourceLine" id="cb117-3" title="3">  <span class="ot">-&gt;</span> m a</a></code></pre></div>
<p><code>fancyFailure</code> を使う際には、直接 <code>fancyFailure</code> を呼び出すのではなく、 字句解析モジュールにある次のようなヘルパーとして定義するのが 望ましいことがよくあります。</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb118-1" title="1"><span class="ot">incorrectIndent ::</span> <span class="dt">MonadParsec</span> e s m</a>
<a class="sourceLine" id="cb118-2" title="2">  <span class="ot">=&gt;</span> <span class="dt">Ordering</span>  <span class="co">-- ^ 参照レベルと実際のレベル間の望ましい順序</span></a>
<a class="sourceLine" id="cb118-3" title="3">  <span class="ot">-&gt;</span> <span class="dt">Pos</span>               <span class="co">-- ^ 参照インデントレベル</span></a>
<a class="sourceLine" id="cb118-4" title="4">  <span class="ot">-&gt;</span> <span class="dt">Pos</span>               <span class="co">-- ^ 実際のインデントレベル</span></a>
<a class="sourceLine" id="cb118-5" title="5">  <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb118-6" title="6">incorrectIndent <span class="fu">ord</span> ref actual <span class="ot">=</span> fancyFailure <span class="op">.</span> E.singleton <span class="op">$</span></a>
<a class="sourceLine" id="cb118-7" title="7">  <span class="dt">ErrorIndentation</span> <span class="fu">ord</span> ref actual</a></code></pre></div>
<p>あなたのパーサにカスタムパースエラーコンポーネントを追加する例として、 与えられた<code>Text</code>の値がキーワードではないことを示す、 特別なパースエラーを定義することを通して見てみましょう。</p>
<p>まず、サポートしたいシナリオを表現するコンストラクタを使用して データ型を定義する必要があります。</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb119-1" title="1"><span class="kw">data</span> <span class="dt">Custom</span> <span class="ot">=</span> <span class="dt">NotKeyword</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb119-2" title="2">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Ord</span>)</a></code></pre></div>
<p>そしてそれをパースエラーで表示する方法を<code>megaparsec</code>に伝えてください。</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb120-1" title="1"><span class="kw">instance</span> <span class="dt">ShowErrorComponent</span> <span class="dt">Custom</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb120-2" title="2">  showErrorComponent (<span class="dt">NotKeyword</span> txt) <span class="ot">=</span> T.unpack txt <span class="op">++</span> <span class="st">&quot; is not a keyword&quot;</span></a></code></pre></div>
<p>次に、<code>Parser</code>型シノニムを更新します。</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb121-1" title="1"><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Custom</span> <span class="dt">Text</span></a></code></pre></div>
<p>その後、<code>notKeyword</code>ヘルパーを定義できます。</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb122-1" title="1"><span class="ot">notKeyword ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</a>
<a class="sourceLine" id="cb122-2" title="2">notKeyword <span class="ot">=</span> customFailure <span class="op">.</span> <span class="dt">NotKeyword</span></a></code></pre></div>
<p><code>customFailure</code>は<code>Text.Megaparsec</code>モジュールの便利なヘルパーです。</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb123-1" title="1"><span class="ot">customFailure ::</span> <span class="dt">MonadParsec</span> e s m <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb123-2" title="2">customFailure <span class="ot">=</span> fancyFailure <span class="op">.</span> E.singleton <span class="op">.</span> <span class="dt">ErrorCustom</span></a></code></pre></div>
<p>最後に試してみましょう。</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb124-1" title="1">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (notKeyword <span class="st">&quot;foo&quot;</span> :: Parser ()) <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb124-2" title="2"><span class="ex">1</span>:1:</a>
<a class="sourceLine" id="cb124-3" title="3">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb124-4" title="4"><span class="ex">1</span> <span class="kw">|</span> <span class="op">&lt;</span><span class="ex">empty</span> line<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb124-5" title="5">  <span class="kw">|</span> ^</a>
<a class="sourceLine" id="cb124-6" title="6"><span class="ex">foo</span> is not a keyword</a></code></pre></div>
<p><a name="DispErr"></a></p>
<h2 id="パースエラーの表示">パースエラーの表示</h2>
<p><code>ParseErrorBundle</code>の表示は<code>errorBundlePretty</code>関数で行われます。</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb125-1" title="1"><span class="co">-- | 'ParseErrorBundle'をプリティプリントします。バンドル内のすべての 'ParseError'は、</span></a>
<a class="sourceLine" id="cb125-2" title="2"><span class="co">-- 入力ストリームに対して単一の効率的なパスを実行することによって、</span></a>
<a class="sourceLine" id="cb125-3" title="3"><span class="co">-- 対応する問題が起きている行とともに順番にプリティプリントされます。</span></a>
<a class="sourceLine" id="cb125-4" title="4"><span class="co">-- レンダリングされた 'String'は常に改行で終わります。</span></a>
<a class="sourceLine" id="cb125-5" title="5"></a>
<a class="sourceLine" id="cb125-6" title="6">errorBundlePretty</a>
<a class="sourceLine" id="cb125-7" title="7"><span class="ot">  ::</span> ( <span class="dt">Stream</span> s</a>
<a class="sourceLine" id="cb125-8" title="8">     , <span class="dt">ShowErrorComponent</span> e</a>
<a class="sourceLine" id="cb125-9" title="9">     )</a>
<a class="sourceLine" id="cb125-10" title="10">  <span class="ot">=&gt;</span> <span class="dt">ParseErrorBundle</span> s e <span class="co">-- ^ 表示するパースエラーバンドル</span></a>
<a class="sourceLine" id="cb125-11" title="11">  <span class="ot">-&gt;</span> <span class="dt">String</span>               <span class="co">-- ^ バンドルのテキスト表現</span></a></code></pre></div>
<p>95％のケースで、あなたはこの1つの関数だけを必要とするでしょう。</p>
<p><a name="ChatchErr"></a></p>
<h2 id="実行中のパーサでパースエラーをチャッチする">実行中のパーサでパースエラーをチャッチする</h2>
<p><code>megaparsec</code> のもう1つの便利な機能は、 パースエラーを「キャッチ」し、それを何らかの方法で変更してから、 例外のように再びスローすることが可能なことです。 これはプリミティブ <code>observing</code> によって有効になります。</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb126-1" title="1"><span class="co">-- | @'observing' p@ はパーサ @p@ の失敗を「観察」することを可能にします.</span></a>
<a class="sourceLine" id="cb126-2" title="2"><span class="co">-- 実際にはパーサを終了せずに、代わりに 'Left'の 'ParseError'を取得します。</span></a>
<a class="sourceLine" id="cb126-3" title="3"><span class="co">-- 成功すると、パースされた値はいつものように 'Right' で返されます。</span></a>
<a class="sourceLine" id="cb126-4" title="4"><span class="co">-- このプリミティブは、発生したパースエラーを観察することを可能にするだけで、</span></a>
<a class="sourceLine" id="cb126-5" title="5"><span class="co">-- パーサ @p@ の動作をバックトラックしたり変更したりすることはありません。</span></a>
<a class="sourceLine" id="cb126-6" title="6"></a>
<a class="sourceLine" id="cb126-7" title="7"><span class="ot">observing ::</span> <span class="dt">MonadParsec</span> e s m</a>
<a class="sourceLine" id="cb126-8" title="8">  <span class="ot">=&gt;</span> m a             <span class="co">-- ^ The parser to run</span></a>
<a class="sourceLine" id="cb126-9" title="9">  <span class="ot">-&gt;</span> m (<span class="dt">Either</span> (<span class="dt">ParseError</span> (<span class="dt">Token</span> s) e) a)</a></code></pre></div>
<p>これは、の典型的な <code>observing</code> の使い方を示す完全なプログラムです。</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb127-1" title="1"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb127-2" title="2"><span class="ot">{-# LANGUAGE TypeApplications  #-}</span></a>
<a class="sourceLine" id="cb127-3" title="3"></a>
<a class="sourceLine" id="cb127-4" title="4"><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></a>
<a class="sourceLine" id="cb127-5" title="5"></a>
<a class="sourceLine" id="cb127-6" title="6"><span class="co">-- import Control.Applicative</span></a>
<a class="sourceLine" id="cb127-7" title="7"><span class="kw">import</span> <span class="dt">Data.List</span> (intercalate)</a>
<a class="sourceLine" id="cb127-8" title="8"><span class="kw">import</span> <span class="dt">Data.Set</span> (<span class="dt">Set</span>)</a>
<a class="sourceLine" id="cb127-9" title="9"><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb127-10" title="10"><span class="kw">import</span> <span class="dt">Data.Void</span></a>
<a class="sourceLine" id="cb127-11" title="11"><span class="kw">import</span> <span class="dt">Text.Megaparsec</span></a>
<a class="sourceLine" id="cb127-12" title="12"><span class="kw">import</span> <span class="dt">Text.Megaparsec.Char</span></a>
<a class="sourceLine" id="cb127-13" title="13"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">Set</span></a>
<a class="sourceLine" id="cb127-14" title="14"></a>
<a class="sourceLine" id="cb127-15" title="15"><span class="kw">data</span> <span class="dt">Custom</span></a>
<a class="sourceLine" id="cb127-16" title="16">  <span class="ot">=</span> <span class="dt">TrivialWithLocation</span></a>
<a class="sourceLine" id="cb127-17" title="17">    [<span class="dt">String</span>] <span class="co">-- 位置スタック</span></a>
<a class="sourceLine" id="cb127-18" title="18">    (<span class="dt">Maybe</span> (<span class="dt">ErrorItem</span> <span class="dt">Char</span>))</a>
<a class="sourceLine" id="cb127-19" title="19">    (<span class="dt">Set</span> (<span class="dt">ErrorItem</span> <span class="dt">Char</span>))</a>
<a class="sourceLine" id="cb127-20" title="20">  <span class="op">|</span> <span class="dt">FancyWithLocation</span></a>
<a class="sourceLine" id="cb127-21" title="21">    [<span class="dt">String</span>] <span class="co">-- 位置スタック</span></a>
<a class="sourceLine" id="cb127-22" title="22">    (<span class="dt">ErrorFancy</span> <span class="dt">Void</span>) <span class="co">-- Custom をネストさせないように Void になっている</span></a>
<a class="sourceLine" id="cb127-23" title="23">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb127-24" title="24"></a>
<a class="sourceLine" id="cb127-25" title="25"><span class="kw">instance</span> <span class="dt">ShowErrorComponent</span> <span class="dt">Custom</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb127-26" title="26">  showErrorComponent (<span class="dt">TrivialWithLocation</span> stack us es) <span class="ot">=</span></a>
<a class="sourceLine" id="cb127-27" title="27">    parseErrorTextPretty (<span class="dt">TrivialError</span> <span class="op">@</span><span class="dt">Text</span> <span class="op">@</span><span class="dt">Void</span> <span class="fu">undefined</span> us es)</a>
<a class="sourceLine" id="cb127-28" title="28">      <span class="op">++</span> showPosStack stack</a>
<a class="sourceLine" id="cb127-29" title="29">  showErrorComponent (<span class="dt">FancyWithLocation</span> stack cs) <span class="ot">=</span></a>
<a class="sourceLine" id="cb127-30" title="30">    parseErrorTextPretty (<span class="dt">FancyError</span> <span class="op">@</span><span class="dt">Text</span> <span class="op">@</span><span class="dt">Void</span> <span class="fu">undefined</span> (Set.singleton cs))</a>
<a class="sourceLine" id="cb127-31" title="31">      <span class="op">++</span> showPosStack stack</a>
<a class="sourceLine" id="cb127-32" title="32"></a>
<a class="sourceLine" id="cb127-33" title="33"><span class="ot">showPosStack ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb127-34" title="34">showPosStack <span class="ot">=</span> intercalate <span class="st">&quot;, &quot;</span> <span class="op">.</span> <span class="fu">fmap</span> (<span class="st">&quot;in &quot;</span> <span class="op">++</span>)</a>
<a class="sourceLine" id="cb127-35" title="35"></a>
<a class="sourceLine" id="cb127-36" title="36"><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Custom</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb127-37" title="37"></a>
<a class="sourceLine" id="cb127-38" title="38"><span class="ot">inside ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</a>
<a class="sourceLine" id="cb127-39" title="39">inside location p <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb127-40" title="40">  r <span class="ot">&lt;-</span> observing p</a>
<a class="sourceLine" id="cb127-41" title="41">  <span class="kw">case</span> r <span class="kw">of</span></a>
<a class="sourceLine" id="cb127-42" title="42">    <span class="dt">Left</span> (<span class="dt">TrivialError</span> _ us es) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb127-43" title="43">      fancyFailure <span class="op">.</span> Set.singleton <span class="op">.</span> <span class="dt">ErrorCustom</span> <span class="op">$</span></a>
<a class="sourceLine" id="cb127-44" title="44">        <span class="dt">TrivialWithLocation</span> [location] us es</a>
<a class="sourceLine" id="cb127-45" title="45">    <span class="dt">Left</span> (<span class="dt">FancyError</span> _ xs) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb127-46" title="46">      <span class="kw">let</span> f (<span class="dt">ErrorFail</span> msg) <span class="ot">=</span> <span class="dt">ErrorCustom</span> <span class="op">$</span></a>
<a class="sourceLine" id="cb127-47" title="47">            <span class="dt">FancyWithLocation</span> [location] (<span class="dt">ErrorFail</span> msg)</a>
<a class="sourceLine" id="cb127-48" title="48">          f (<span class="dt">ErrorIndentation</span> <span class="fu">ord</span> rlvl alvl) <span class="ot">=</span> <span class="dt">ErrorCustom</span> <span class="op">$</span></a>
<a class="sourceLine" id="cb127-49" title="49">            <span class="dt">FancyWithLocation</span> [location] (<span class="dt">ErrorIndentation</span> <span class="fu">ord</span> rlvl alvl)</a>
<a class="sourceLine" id="cb127-50" title="50">          f (<span class="dt">ErrorCustom</span> (<span class="dt">TrivialWithLocation</span> ps us es)) <span class="ot">=</span> <span class="dt">ErrorCustom</span> <span class="op">$</span></a>
<a class="sourceLine" id="cb127-51" title="51">            <span class="dt">TrivialWithLocation</span> (location<span class="op">:</span>ps) us es</a>
<a class="sourceLine" id="cb127-52" title="52">          f (<span class="dt">ErrorCustom</span> (<span class="dt">FancyWithLocation</span> ps cs)) <span class="ot">=</span> <span class="dt">ErrorCustom</span> <span class="op">$</span></a>
<a class="sourceLine" id="cb127-53" title="53">            <span class="dt">FancyWithLocation</span> (location<span class="op">:</span>ps) cs</a>
<a class="sourceLine" id="cb127-54" title="54">      fancyFailure (Set.map f xs)</a>
<a class="sourceLine" id="cb127-55" title="55">    <span class="dt">Right</span> x <span class="ot">-&gt;</span> <span class="fu">return</span> x</a>
<a class="sourceLine" id="cb127-56" title="56"></a>
<a class="sourceLine" id="cb127-57" title="57"><span class="ot">myParser ::</span> <span class="dt">Parser</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb127-58" title="58">myParser <span class="ot">=</span> some (char <span class="ch">'a'</span>) <span class="op">*&gt;</span> some (char <span class="ch">'b'</span>)</a>
<a class="sourceLine" id="cb127-59" title="59"></a>
<a class="sourceLine" id="cb127-60" title="60"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb127-61" title="61">main <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb127-62" title="62">  parseTest (inside <span class="st">&quot;foo&quot;</span> myParser) <span class="st">&quot;aaacc&quot;</span></a>
<a class="sourceLine" id="cb127-63" title="63">  parseTest (inside <span class="st">&quot;foo&quot;</span> <span class="op">$</span> inside <span class="st">&quot;bar&quot;</span> myParser) <span class="st">&quot;aaacc&quot;</span></a></code></pre></div>
<p>演習: このプログラムがどのように機能するのか詳細に理解しなさい。</p>
<p>このプログラムを実行すると、次のように出力されます。</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb128-1" title="1"><span class="dv">1</span><span class="op">:</span><span class="dv">4</span><span class="op">:</span></a>
<a class="sourceLine" id="cb128-2" title="2">  <span class="op">|</span></a>
<a class="sourceLine" id="cb128-3" title="3"><span class="dv">1</span> <span class="op">|</span> aaacc</a>
<a class="sourceLine" id="cb128-4" title="4">  <span class="op">|</span>    <span class="op">^</span></a>
<a class="sourceLine" id="cb128-5" title="5">unexpected <span class="ch">'c'</span></a>
<a class="sourceLine" id="cb128-6" title="6">expecting <span class="ch">'a'</span> <span class="fu">or</span> <span class="ch">'b'</span></a>
<a class="sourceLine" id="cb128-7" title="7"><span class="kw">in</span> foo</a>
<a class="sourceLine" id="cb128-8" title="8"><span class="dv">1</span><span class="op">:</span><span class="dv">4</span><span class="op">:</span></a>
<a class="sourceLine" id="cb128-9" title="9">  <span class="op">|</span></a>
<a class="sourceLine" id="cb128-10" title="10"><span class="dv">1</span> <span class="op">|</span> aaacc</a>
<a class="sourceLine" id="cb128-11" title="11">  <span class="op">|</span>    <span class="op">^</span></a>
<a class="sourceLine" id="cb128-12" title="12">unexpected <span class="ch">'c'</span></a>
<a class="sourceLine" id="cb128-13" title="13">expecting <span class="ch">'a'</span> <span class="fu">or</span> <span class="ch">'b'</span></a>
<a class="sourceLine" id="cb128-14" title="14"><span class="kw">in</span> foo, <span class="kw">in</span> bar</a></code></pre></div>
<p>したがって、この機能を使用してパースエラーに対する位置ラベルの添付や、 実際にパースエラーが何らかの方法で処理される領域を定義できます。 このイディオムは非常に便利なので、 プリミティブ <code>observing</code> の観点から構築された <code>region</code> と呼ばれる非プリミティブヘルパーもあります。</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb129-1" title="1"><span class="co">-- | 内部のラッパーで発生する 'ParseError'の処理方法を指定します。</span></a>
<a class="sourceLine" id="cb129-2" title="2"><span class="co">-- 現在の実装の副作用として、このコンビネータで 'errorPos' を変更すると、</span></a>
<a class="sourceLine" id="cb129-3" title="3"><span class="co">-- 最終的にパーサの状態 'statePos'も変更されま('statePos' が</span></a>
<a class="sourceLine" id="cb129-4" title="4"><span class="co">-- 入力ストリームの実際の位置と同期しなくなるので、それを避けてください。</span></a>
<a class="sourceLine" id="cb129-5" title="5"><span class="co">-- 直後にパースを終了すれば、おそらく問題ありませんが、注意してください)。</span></a>
<a class="sourceLine" id="cb129-6" title="6"></a>
<a class="sourceLine" id="cb129-7" title="7"><span class="ot">region ::</span> <span class="dt">MonadParsec</span> e s m</a>
<a class="sourceLine" id="cb129-8" title="8">  <span class="ot">=&gt;</span> (<span class="dt">ParseError</span> s e <span class="ot">-&gt;</span> <span class="dt">ParseError</span> s e)</a>
<a class="sourceLine" id="cb129-9" title="9">     <span class="co">-- ^ 'ParseError' を処理する方法</span></a>
<a class="sourceLine" id="cb129-10" title="10">  <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb129-11" title="11">     <span class="co">-- ^ 処理を適用する 「領域」</span></a>
<a class="sourceLine" id="cb129-12" title="12">  <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb129-13" title="13">region f m <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb129-14" title="14">  r <span class="ot">&lt;-</span> observing m</a>
<a class="sourceLine" id="cb129-15" title="15">  <span class="kw">case</span> r <span class="kw">of</span></a>
<a class="sourceLine" id="cb129-16" title="16">    <span class="dt">Left</span> err <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb129-17" title="17">      <span class="kw">case</span> f err <span class="kw">of</span></a>
<a class="sourceLine" id="cb129-18" title="18">        <span class="dt">TrivialError</span> o us ps <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb129-19" title="19">          updateParserState <span class="op">$</span> \st <span class="ot">-&gt;</span> st { stateOffset <span class="ot">=</span> o }</a>
<a class="sourceLine" id="cb129-20" title="20">          failure us ps</a>
<a class="sourceLine" id="cb129-21" title="21">        <span class="dt">FancyError</span> o xs <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb129-22" title="22">          updateParserState <span class="op">$</span> \st <span class="ot">-&gt;</span> st { stateOffset <span class="ot">=</span> o }</a>
<a class="sourceLine" id="cb129-23" title="23">          fancyFailure xs</a>
<a class="sourceLine" id="cb129-24" title="24">    <span class="dt">Right</span> x <span class="ot">-&gt;</span> <span class="fu">return</span> x</a></code></pre></div>
<p>演習: 上記のプログラムで <code>region</code> を使用して <code>inside</code> 関数を書き換えなさい。</p>
<p>回答例:</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb130-1" title="1"><span class="ot">inside' ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</a>
<a class="sourceLine" id="cb130-2" title="2">inside' location p <span class="ot">=</span> region (processParseError location) p</a>
<a class="sourceLine" id="cb130-3" title="3"></a>
<a class="sourceLine" id="cb130-4" title="4"><span class="ot">processParseError ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ParseError</span> <span class="dt">Text</span> <span class="dt">Custom</span> <span class="ot">-&gt;</span> <span class="dt">ParseError</span> <span class="dt">Text</span> <span class="dt">Custom</span></a>
<a class="sourceLine" id="cb130-5" title="5">processParseError location (<span class="dt">TrivialError</span> i us es) <span class="ot">=</span></a>
<a class="sourceLine" id="cb130-6" title="6">  <span class="dt">FancyError</span> i <span class="op">.</span> Set.singleton <span class="op">.</span> <span class="dt">ErrorCustom</span> <span class="op">$</span></a>
<a class="sourceLine" id="cb130-7" title="7">    <span class="dt">TrivialWithLocation</span> [location] us es</a>
<a class="sourceLine" id="cb130-8" title="8">processParseError location (<span class="dt">FancyError</span> i xs) <span class="ot">=</span></a>
<a class="sourceLine" id="cb130-9" title="9">  <span class="dt">FancyError</span> i <span class="op">$</span> Set.map (processErrorFancy location) xs</a>
<a class="sourceLine" id="cb130-10" title="10"></a>
<a class="sourceLine" id="cb130-11" title="11"><span class="ot">processErrorFancy ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ErrorFancy</span> <span class="dt">Custom</span> <span class="ot">-&gt;</span> <span class="dt">ErrorFancy</span> <span class="dt">Custom</span></a>
<a class="sourceLine" id="cb130-12" title="12">processErrorFancy location (<span class="dt">ErrorFail</span> msg) <span class="ot">=</span> <span class="dt">ErrorCustom</span> <span class="op">$</span></a>
<a class="sourceLine" id="cb130-13" title="13">  <span class="dt">FancyWithLocation</span> [location] (<span class="dt">ErrorFail</span> msg)</a>
<a class="sourceLine" id="cb130-14" title="14">processErrorFancy location (<span class="dt">ErrorIndentation</span> <span class="fu">ord</span> rlvl alvl) <span class="ot">=</span> <span class="dt">ErrorCustom</span> <span class="op">$</span></a>
<a class="sourceLine" id="cb130-15" title="15">  <span class="dt">FancyWithLocation</span> [location] (<span class="dt">ErrorIndentation</span> <span class="fu">ord</span> rlvl alvl)</a>
<a class="sourceLine" id="cb130-16" title="16">processErrorFancy location (<span class="dt">ErrorCustom</span> (<span class="dt">TrivialWithLocation</span> ps us es)) <span class="ot">=</span></a>
<a class="sourceLine" id="cb130-17" title="17">  <span class="dt">ErrorCustom</span> <span class="op">$</span> <span class="dt">TrivialWithLocation</span> (location<span class="op">:</span>ps) us es</a>
<a class="sourceLine" id="cb130-18" title="18">processErrorFancy location (<span class="dt">ErrorCustom</span> (<span class="dt">FancyWithLocation</span> ps cs)) <span class="ot">=</span></a>
<a class="sourceLine" id="cb130-19" title="19">  <span class="dt">ErrorCustom</span> <span class="op">$</span> <span class="dt">FancyWithLocation</span> (location<span class="op">:</span>ps) cs</a></code></pre></div>
<p><a name="Testing"></a></p>
<h2 id="megaparsec-パーサのテスト">Megaparsec パーサのテスト</h2>
<p>パーサのテストは、ほとんどの人が遅かれ早かれ直面する実践的なタスクであり、 それをカバーしなければなりません。 <code>megaparsec</code> のパーサをテストするための推奨される方法は <a href="https://hackage.haskell.org/package/hspec-megaparsec"><code>hspec-megaparsec</code></a>パッケージを使うことです。 このパッケージは、<code>hspec</code> テストフレームワークで動作する <code>shouldParse</code>、 <code>parseSatisfies</code> などのユーティリティテスト関数のを追加します。</p>
<p>次の例から見てみましょう。</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb131-1" title="1"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb131-2" title="2"></a>
<a class="sourceLine" id="cb131-3" title="3"><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></a>
<a class="sourceLine" id="cb131-4" title="4"></a>
<a class="sourceLine" id="cb131-5" title="5"><span class="kw">import</span> <span class="dt">Control.Applicative</span></a>
<a class="sourceLine" id="cb131-6" title="6"><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb131-7" title="7"><span class="kw">import</span> <span class="dt">Data.Void</span></a>
<a class="sourceLine" id="cb131-8" title="8"><span class="kw">import</span> <span class="dt">Test.Hspec</span></a>
<a class="sourceLine" id="cb131-9" title="9"><span class="kw">import</span> <span class="dt">Test.Hspec.Megaparsec</span></a>
<a class="sourceLine" id="cb131-10" title="10"><span class="kw">import</span> <span class="dt">Text.Megaparsec</span></a>
<a class="sourceLine" id="cb131-11" title="11"><span class="kw">import</span> <span class="dt">Text.Megaparsec.Char</span></a>
<a class="sourceLine" id="cb131-12" title="12"></a>
<a class="sourceLine" id="cb131-13" title="13"><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Void</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb131-14" title="14"></a>
<a class="sourceLine" id="cb131-15" title="15"><span class="ot">myParser ::</span> <span class="dt">Parser</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb131-16" title="16">myParser <span class="ot">=</span> some (char <span class="ch">'a'</span>)</a>
<a class="sourceLine" id="cb131-17" title="17"></a>
<a class="sourceLine" id="cb131-18" title="18"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb131-19" title="19">main <span class="ot">=</span> hspec <span class="op">$</span></a>
<a class="sourceLine" id="cb131-20" title="20">  describe <span class="st">&quot;myParser&quot;</span> <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb131-21" title="21">    it <span class="st">&quot;returns correct result&quot;</span> <span class="op">$</span></a>
<a class="sourceLine" id="cb131-22" title="22">      parse myParser <span class="st">&quot;&quot;</span> <span class="st">&quot;aaa&quot;</span> <span class="ot">`shouldParse`</span> <span class="st">&quot;aaa&quot;</span></a>
<a class="sourceLine" id="cb131-23" title="23">    it <span class="st">&quot;result of parsing satisfies what it should&quot;</span> <span class="op">$</span></a>
<a class="sourceLine" id="cb131-24" title="24">      parse myParser <span class="st">&quot;&quot;</span> <span class="st">&quot;aaaa&quot;</span> <span class="ot">`parseSatisfies`</span> ((<span class="op">==</span> <span class="dv">4</span>) <span class="op">.</span> <span class="fu">length</span>)</a></code></pre></div>
<p><code>shouldParse</code> は、パース結果 <code>Either（ParseErrorBundle s e）a</code> と比較する型 <code>a</code> の値を引数として受け取ります。 おそらく最も一般的なヘルパーです。 <code>parseSatisfies</code> は非常に似ていますが、期待される結果と等しいかどうかを比較する代わりに、任意の述語を適用することによって結果をチェックすることができます。</p>
<p>その他の単純なテスト関数は、 <code>shouldSucceedOn</code> と <code>shouldFailOn</code> です（これらはめったに使われません）。</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb132-1" title="1">    it <span class="st">&quot;should parse 'a's all right&quot;</span> <span class="op">$</span></a>
<a class="sourceLine" id="cb132-2" title="2">      parse myParser <span class="st">&quot;&quot;</span> <span class="ot">`shouldSucceedOn`</span> <span class="st">&quot;aaaa&quot;</span></a>
<a class="sourceLine" id="cb132-3" title="3">    it <span class="st">&quot;should fail on 'b's&quot;</span> <span class="op">$</span></a>
<a class="sourceLine" id="cb132-4" title="4">      parse myParser <span class="st">&quot;&quot;</span> <span class="ot">`shouldFailOn`</span> <span class="st">&quot;bbb&quot;</span></a></code></pre></div>
<p><code>megaparsec</code> で、パーサが生み出すパースエラーを詳細にテストしたいです。 パースエラーをテストするには <code>shouldFailWith</code> があります。 これは次のように使用できます。</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb133-1" title="1">    it <span class="st">&quot;fails on 'b's producing correct error message&quot;</span> <span class="op">$</span></a>
<a class="sourceLine" id="cb133-2" title="2">      parse myParser <span class="st">&quot;&quot;</span> <span class="st">&quot;bbb&quot;</span> <span class="ot">`shouldFailWith`</span></a>
<a class="sourceLine" id="cb133-3" title="3">        <span class="dt">TrivialError</span></a>
<a class="sourceLine" id="cb133-4" title="4">          <span class="dv">0</span></a>
<a class="sourceLine" id="cb133-5" title="5">          (<span class="dt">Just</span> (<span class="dt">Tokens</span> (<span class="ch">'b'</span> <span class="op">:|</span> [])))</a>
<a class="sourceLine" id="cb133-6" title="6">          (Set.singleton (<span class="dt">Tokens</span> (<span class="ch">'a'</span> <span class="op">:|</span> [])))</a></code></pre></div>
<p>このように <code>TrivialError</code> を書き出すのは面倒です。 <code>ParseError</code> の定義には、<code>Set</code> や <code>NonEmpty</code> のような 「不便な」型が含まれています。これらは、 今見たとおり直接入力するのには便利ではありません。 幸い、<code>Test.Hspec.Megaparsec</code> は、 <code>ParserErrors</code>をより簡単に構築するためのAPIを提供する <code>Text.Megaparsec.Error.Builder</code> モジュールも再エクスポートします。 代わりに <code>err</code> ヘルパーを使用しましょう。</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb134-1" title="1">    it <span class="st">&quot;fails on 'b's producing correct error message&quot;</span> <span class="op">$</span></a>
<a class="sourceLine" id="cb134-2" title="2">      parse myParser <span class="st">&quot;&quot;</span> <span class="st">&quot;bbb&quot;</span> <span class="ot">`shouldFailWith`</span> err <span class="dv">0</span> (utok <span class="ch">'b'</span> <span class="op">&lt;&gt;</span> etok <span class="ch">'a'</span>)</a></code></pre></div>
<ul>
<li><p><code>err</code> の最初の引数は、パースエラーのオフセット（エラーが発生する前に消費されたトークンの数）です。今回はそれは単に0です。</p></li>
<li><p><code>utok</code> は「期待しないトークン」を表し、同様に <code>etok</code> は「期待するトークン」を意味します。</p></li>
</ul>
<p>演習: ファンシーパースエラーを構築するために、<code>errFancy</code> と呼ばれる同様のヘルパーがありますので、それをよく理解してください。</p>
<p>最後に、<code>failsLeaving</code> と <code>succeedsLeaving</code> を使用して、 パース後に入力のどの部分が未消費のままであるかをテストすることができます。</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb135-1" title="1">    it <span class="st">&quot;consumes all 'a's but does not touch 'b's&quot;</span> <span class="op">$</span></a>
<a class="sourceLine" id="cb135-2" title="2">      runParser' myParser (initialState <span class="st">&quot;aaabbb&quot;</span>) <span class="ot">`succeedsLeaving`</span> <span class="st">&quot;bbb&quot;</span></a>
<a class="sourceLine" id="cb135-3" title="3">    it <span class="st">&quot;fails without consuming anything&quot;</span> <span class="op">$</span></a>
<a class="sourceLine" id="cb135-4" title="4">      runParser' myParser (initialState <span class="st">&quot;bbbccc&quot;</span>) <span class="ot">`failsLeaving`</span> <span class="st">&quot;bbbccc&quot;</span></a></code></pre></div>
<p>これらは、パーサのカスタム初期状態を受け取り、 その最終状態を返す <code>runParser'</code> または <code>runParserT'</code> と共に 使用する必要があります（これにより、 パース後に入力ストリームの残りをチェックすることができます）。</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb136-1" title="1">runParser'</a>
<a class="sourceLine" id="cb136-2" title="2"><span class="ot">  ::</span> <span class="dt">Parsec</span> e s a      <span class="co">-- ^ Parser to run</span></a>
<a class="sourceLine" id="cb136-3" title="3">  <span class="ot">-&gt;</span> <span class="dt">State</span> s           <span class="co">-- ^ Initial state</span></a>
<a class="sourceLine" id="cb136-4" title="4">  <span class="ot">-&gt;</span> (<span class="dt">State</span> s, <span class="dt">Either</span> (<span class="dt">ParseError</span> (<span class="dt">Token</span> s) e) a)</a>
<a class="sourceLine" id="cb136-5" title="5"></a>
<a class="sourceLine" id="cb136-6" title="6"><span class="ot">runParserT' ::</span> <span class="dt">Monad</span> m</a>
<a class="sourceLine" id="cb136-7" title="7">  <span class="ot">=&gt;</span> <span class="dt">ParsecT</span> e s m a   <span class="co">-- ^ Parser to run</span></a>
<a class="sourceLine" id="cb136-8" title="8">  <span class="ot">-&gt;</span> <span class="dt">State</span> s           <span class="co">-- ^ Initial state</span></a>
<a class="sourceLine" id="cb136-9" title="9">  <span class="ot">-&gt;</span> m (<span class="dt">State</span> s, <span class="dt">Either</span> (<span class="dt">ParseError</span> (<span class="dt">Token</span> s) e) a)</a></code></pre></div>
<p><code>initialState</code> 関数は入力ストリームを受け取り、 その入力ストリームとデフォルト値で埋められた レコードフィールドの初期状態を返します。</p>
<p><code>hspec-megaparsec</code> を使用するためのその他のヒントは次のとおりです。</p>
<ul>
<li><p><a href="https://github.com/mrkkrp/megaparsec/tree/master/megaparsec-tests">Megaparsec自身のテスト</a> はhspec-megaparsecを使って書かれています。</p></li>
<li><p><code>hspec-megaparsec</code> 自体に付属している<a href="https://github.com/mrkkrp/hspec-megaparsec/blob/master/tests/Main.hs">トイテストスイート</a>。</p></li>
</ul>
<p><a name="CustomInput"></a></p>
<h2 id="カスタム入力ストリームの操作">カスタム入力ストリームの操作</h2>
<p><code>megaparsec</code> は、 <code>Stream</code> 型クラスのインスタンスである入力をパースできます。 これは、<code>alex</code>などの字句解析ツールと組み合わせて使用できることを 意味します。</p>
<p>主題から離れないようにするため、 <code>alex</code> がどのようにしてトークンのストリーム生成するのかは説明しません。 また、次の形式を想定します。</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb137-1" title="1"><span class="ot">{-# LANGUAGE LambdaCase        #-}</span></a>
<a class="sourceLine" id="cb137-2" title="2"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb137-3" title="3"><span class="ot">{-# LANGUAGE TypeFamilies      #-}</span></a>
<a class="sourceLine" id="cb137-4" title="4"></a>
<a class="sourceLine" id="cb137-5" title="5"><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></a>
<a class="sourceLine" id="cb137-6" title="6"></a>
<a class="sourceLine" id="cb137-7" title="7"><span class="kw">import</span> <span class="dt">Data.List.NonEmpty</span> (<span class="dt">NonEmpty</span> (..))</a>
<a class="sourceLine" id="cb137-8" title="8"><span class="kw">import</span> <span class="dt">Data.Proxy</span></a>
<a class="sourceLine" id="cb137-9" title="9"><span class="kw">import</span> <span class="dt">Data.Void</span></a>
<a class="sourceLine" id="cb137-10" title="10"><span class="kw">import</span> <span class="dt">Text.Megaparsec</span></a>
<a class="sourceLine" id="cb137-11" title="11"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.List</span>          <span class="kw">as</span> <span class="dt">DL</span></a>
<a class="sourceLine" id="cb137-12" title="12"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.List.NonEmpty</span> <span class="kw">as</span> <span class="dt">NE</span></a>
<a class="sourceLine" id="cb137-13" title="13"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span>           <span class="kw">as</span> <span class="dt">Set</span></a>
<a class="sourceLine" id="cb137-14" title="14"></a>
<a class="sourceLine" id="cb137-15" title="15"><span class="kw">data</span> <span class="dt">MyToken</span></a>
<a class="sourceLine" id="cb137-16" title="16">  <span class="ot">=</span> <span class="dt">Int</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb137-17" title="17">  <span class="op">|</span> <span class="dt">Plus</span></a>
<a class="sourceLine" id="cb137-18" title="18">  <span class="op">|</span> <span class="dt">Mul</span></a>
<a class="sourceLine" id="cb137-19" title="19">  <span class="op">|</span> <span class="dt">Div</span></a>
<a class="sourceLine" id="cb137-20" title="20">  <span class="op">|</span> <span class="dt">OpenParen</span></a>
<a class="sourceLine" id="cb137-21" title="21">  <span class="op">|</span> <span class="dt">CloseParen</span></a>
<a class="sourceLine" id="cb137-22" title="22">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>パースエラーを報告するために、 トークンの開始位置と終了位置を知る方法が必要なので、 <code>WithPos</code> を追加しましょう。</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb138-1" title="1"><span class="kw">data</span> <span class="dt">WithPos</span> a <span class="ot">=</span> <span class="dt">WithPos</span></a>
<a class="sourceLine" id="cb138-2" title="2">  {<span class="ot"> startPos ::</span> <span class="dt">SourcePos</span></a>
<a class="sourceLine" id="cb138-3" title="3">  ,<span class="ot"> endPos   ::</span> <span class="dt">SourcePos</span></a>
<a class="sourceLine" id="cb138-4" title="4">  ,<span class="ot"> tokenVal ::</span> a</a>
<a class="sourceLine" id="cb138-5" title="5">  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>これでストリームのデータ型ができます。</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb139-1" title="1"><span class="kw">newtype</span> <span class="dt">MyStream</span> <span class="ot">=</span> <span class="dt">MyStream</span></a>
<a class="sourceLine" id="cb139-2" title="2">  {<span class="ot"> unMyStream ::</span> [<span class="dt">WithPos</span> <span class="dt">MyToken</span>]</a>
<a class="sourceLine" id="cb139-3" title="3">  }</a></code></pre></div>
<p>次に、<code>MyStream</code> を <code>Stream</code> 型クラスのインスタンスにする必要があります。 関連型関数 <code>Token</code> と <code>Tokens</code> を定義したいので、 <code>TypeFamilies</code> の言語拡張が必要です。</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb140-1" title="1"><span class="kw">instance</span> <span class="dt">Stream</span> <span class="dt">MyStream</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb140-2" title="2">  <span class="kw">type</span> <span class="dt">Token</span>  <span class="dt">MyStream</span> <span class="ot">=</span> <span class="dt">WithPos</span> <span class="dt">MyToken</span></a>
<a class="sourceLine" id="cb140-3" title="3">  <span class="kw">type</span> <span class="dt">Tokens</span> <span class="dt">MyStream</span> <span class="ot">=</span> [<span class="dt">WithPos</span> <span class="dt">MyToken</span>]</a>
<a class="sourceLine" id="cb140-4" title="4">  <span class="co">-- …</span></a></code></pre></div>
<p><code>Stream</code> は <code>Text.Megaparsec.Stream</code> モジュールに 詳しいドキュメントがあります。 足りないメソッドを定義していきましょう。</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb141-1" title="1"><span class="co">-- …</span></a>
<a class="sourceLine" id="cb141-2" title="2">  tokenToChunk <span class="dt">Proxy</span> x <span class="ot">=</span> [x]</a>
<a class="sourceLine" id="cb141-3" title="3">  tokensToChunk <span class="dt">Proxy</span> xs <span class="ot">=</span> xs</a>
<a class="sourceLine" id="cb141-4" title="4">  chunkToTokens <span class="dt">Proxy</span> <span class="ot">=</span> <span class="fu">id</span></a>
<a class="sourceLine" id="cb141-5" title="5">  chunkLength <span class="dt">Proxy</span> <span class="ot">=</span> <span class="fu">length</span></a>
<a class="sourceLine" id="cb141-6" title="6">  chunkEmpty <span class="dt">Proxy</span> <span class="ot">=</span> <span class="fu">null</span></a>
<a class="sourceLine" id="cb141-7" title="7">  take1_ (<span class="dt">MyStream</span> []) <span class="ot">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb141-8" title="8">  take1_ (<span class="dt">MyStream</span> (t<span class="op">:</span>ts)) <span class="ot">=</span> <span class="dt">Just</span> (t, <span class="dt">MyStream</span> ts)</a>
<a class="sourceLine" id="cb141-9" title="9">  takeN_ n (<span class="dt">MyStream</span> s)</a>
<a class="sourceLine" id="cb141-10" title="10">    <span class="op">|</span> n <span class="op">&lt;=</span> <span class="dv">0</span>    <span class="ot">=</span> <span class="dt">Just</span> ([], <span class="dt">MyStream</span> s)</a>
<a class="sourceLine" id="cb141-11" title="11">    <span class="op">|</span> <span class="fu">null</span> s    <span class="ot">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb141-12" title="12">    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span></a>
<a class="sourceLine" id="cb141-13" title="13">        <span class="kw">let</span> (x, s') <span class="ot">=</span> <span class="fu">splitAt</span> n s</a>
<a class="sourceLine" id="cb141-14" title="14">        <span class="kw">in</span> <span class="dt">Just</span> (x, <span class="dt">MyStream</span> s')</a>
<a class="sourceLine" id="cb141-15" title="15">  takeWhile_ f (<span class="dt">MyStream</span> s) <span class="ot">=</span></a>
<a class="sourceLine" id="cb141-16" title="16">    <span class="kw">let</span> (x, s') <span class="ot">=</span> DL.span f s</a>
<a class="sourceLine" id="cb141-17" title="17">    <span class="kw">in</span> (x, <span class="dt">MyStream</span> s')</a>
<a class="sourceLine" id="cb141-18" title="18">  showTokens <span class="dt">Proxy</span> <span class="ot">=</span> DL.intercalate <span class="st">&quot;, &quot;</span></a>
<a class="sourceLine" id="cb141-19" title="19">    <span class="op">.</span> NE.toList</a>
<a class="sourceLine" id="cb141-20" title="20">    <span class="op">.</span> <span class="fu">fmap</span> (showMyToken <span class="op">.</span> tokenVal)</a>
<a class="sourceLine" id="cb141-21" title="21">  reachOffset o pst<span class="op">@</span><span class="dt">PosState</span> {<span class="op">..</span>} <span class="ot">=</span></a>
<a class="sourceLine" id="cb141-22" title="22">    <span class="kw">case</span> <span class="fu">drop</span> (o <span class="op">-</span> pstateOffset) (unMyStream pstateInput) <span class="kw">of</span></a>
<a class="sourceLine" id="cb141-23" title="23">      [] <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb141-24" title="24">        ( pstateSourcePos</a>
<a class="sourceLine" id="cb141-25" title="25">        , <span class="st">&quot;&lt;missing input&gt;&quot;</span></a>
<a class="sourceLine" id="cb141-26" title="26">        , pst { pstateInput <span class="ot">=</span> <span class="dt">MyStream</span> [] }</a>
<a class="sourceLine" id="cb141-27" title="27">        )</a>
<a class="sourceLine" id="cb141-28" title="28">      (x<span class="op">:</span>xs) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb141-29" title="29">        ( startPos x</a>
<a class="sourceLine" id="cb141-30" title="30">        , <span class="st">&quot;&lt;missing input&gt;&quot;</span></a>
<a class="sourceLine" id="cb141-31" title="31">        , pst { pstateInput <span class="ot">=</span> <span class="dt">MyStream</span> (x<span class="op">:</span>xs) }</a>
<a class="sourceLine" id="cb141-32" title="32">        )</a>
<a class="sourceLine" id="cb141-33" title="33"></a>
<a class="sourceLine" id="cb141-34" title="34"><span class="ot">showMyToken ::</span> <span class="dt">MyToken</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb141-35" title="35">showMyToken <span class="ot">=</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb141-36" title="36">  (<span class="dt">Int</span> n)    <span class="ot">-&gt;</span> <span class="fu">show</span> n</a>
<a class="sourceLine" id="cb141-37" title="37">  <span class="dt">Plus</span>       <span class="ot">-&gt;</span> <span class="st">&quot;+&quot;</span></a>
<a class="sourceLine" id="cb141-38" title="38">  <span class="dt">Mul</span>        <span class="ot">-&gt;</span> <span class="st">&quot;*&quot;</span></a>
<a class="sourceLine" id="cb141-39" title="39">  <span class="dt">Div</span>        <span class="ot">-&gt;</span> <span class="st">&quot;/&quot;</span></a>
<a class="sourceLine" id="cb141-40" title="40">  <span class="dt">OpenParen</span>  <span class="ot">-&gt;</span> <span class="st">&quot;(&quot;</span></a>
<a class="sourceLine" id="cb141-41" title="41">  <span class="dt">CloseParen</span> <span class="ot">-&gt;</span> <span class="st">&quot;)&quot;</span></a></code></pre></div>
<p><code>Stream</code> 型クラスに関する詳しい参考資料 (そしてなぜこのようになっているのか)は <a href="https://markkarpov.com/post/megaparsec-more-speed-more-power.html">このブログ記事</a> に書いてあります。 <code>reachOffset</code> 関数では、元の入力ストリームが不足しているため、 問題のある行を実際に表示することはできません。 これは解決できますが、解決策はこの記事の範囲外です。</p>
<p>これで <code>Parser</code> 型が定義できます。</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb142-1" title="1"><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Void</span> <span class="dt">MyStream</span></a></code></pre></div>
<p>次のステップは、 <code>token</code> と (意味があるなら)<code>tokens</code> のプリミティブを使って、 基本的なパーサを定義することです。 そのまま使用できるストリームには、 <code>Text.Megaparsec.Byte</code> および <code>Text.Megaparsec.Char</code> モジュールが ありますが、カスタムトークンを使用する場合はカスタムヘルパーが必要です。</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb143-1" title="1"><span class="ot">liftMyToken ::</span> <span class="dt">MyToken</span> <span class="ot">-&gt;</span> <span class="dt">WithPos</span> <span class="dt">MyToken</span></a>
<a class="sourceLine" id="cb143-2" title="2">liftMyToken myToken <span class="ot">=</span> <span class="dt">WithPos</span> pos pos myToken</a>
<a class="sourceLine" id="cb143-3" title="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb143-4" title="4">    pos <span class="ot">=</span> initialPos <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb143-5" title="5"></a>
<a class="sourceLine" id="cb143-6" title="6"><span class="ot">pToken ::</span> <span class="dt">MyToken</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">MyToken</span></a>
<a class="sourceLine" id="cb143-7" title="7">pToken c <span class="ot">=</span> token test (Set.singleton <span class="op">.</span> <span class="dt">Tokens</span> <span class="op">.</span> nes <span class="op">.</span> liftMyToken <span class="op">$</span> c)</a>
<a class="sourceLine" id="cb143-8" title="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb143-9" title="9">    test wpos<span class="op">@</span>(<span class="dt">WithPos</span> _ _ x) <span class="ot">=</span></a>
<a class="sourceLine" id="cb143-10" title="10">      <span class="kw">if</span> x <span class="op">==</span> c</a>
<a class="sourceLine" id="cb143-11" title="11">        <span class="kw">then</span> <span class="dt">Just</span> x</a>
<a class="sourceLine" id="cb143-12" title="12">        <span class="kw">else</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb143-13" title="13">    nes x <span class="ot">=</span> x <span class="op">:|</span> []</a>
<a class="sourceLine" id="cb143-14" title="14"></a>
<a class="sourceLine" id="cb143-15" title="15"><span class="ot">pInt ::</span> <span class="dt">Parser</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb143-16" title="16">pInt <span class="ot">=</span> token test Set.empty <span class="op">&lt;?&gt;</span> <span class="st">&quot;integer&quot;</span></a>
<a class="sourceLine" id="cb143-17" title="17">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb143-18" title="18">    test (<span class="dt">WithPos</span> _ _ (<span class="dt">Int</span> n)) <span class="ot">=</span> <span class="dt">Just</span> n</a>
<a class="sourceLine" id="cb143-19" title="19">    test _ <span class="ot">=</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>最後に、足し算をパースするテストパーサを用意しましょう。</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb144-1" title="1"><span class="ot">pSum ::</span> <span class="dt">Parser</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb144-2" title="2">pSum <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb144-3" title="3">  a <span class="ot">&lt;-</span> pInt</a>
<a class="sourceLine" id="cb144-4" title="4">  _ <span class="ot">&lt;-</span> pToken <span class="dt">Plus</span></a>
<a class="sourceLine" id="cb144-5" title="5">  b <span class="ot">&lt;-</span> pInt</a>
<a class="sourceLine" id="cb144-6" title="6">  <span class="fu">return</span> (a, b)</a></code></pre></div>
<p>入力例は次のようにします。</p>
<div class="sourceCode" id="cb145"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb145-1" title="1"><span class="ot">exampleStream ::</span> <span class="dt">MyStream</span></a>
<a class="sourceLine" id="cb145-2" title="2">exampleStream <span class="ot">=</span> <span class="dt">MyStream</span></a>
<a class="sourceLine" id="cb145-3" title="3">  [ at <span class="dv">1</span> <span class="dv">1</span> (<span class="dt">Int</span> <span class="dv">5</span>)</a>
<a class="sourceLine" id="cb145-4" title="4">  , at <span class="dv">1</span> <span class="dv">3</span> <span class="dt">Plus</span>         <span class="co">-- (1)</span></a>
<a class="sourceLine" id="cb145-5" title="5">  , at <span class="dv">1</span> <span class="dv">5</span> (<span class="dt">Int</span> <span class="dv">6</span>) ]</a>
<a class="sourceLine" id="cb145-6" title="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb145-7" title="7">    at  l c <span class="ot">=</span> <span class="dt">WithPos</span> (at' l c) (at' l (c <span class="op">+</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb145-8" title="8">    at' l c <span class="ot">=</span> <span class="dt">SourcePos</span> <span class="st">&quot;&quot;</span> (mkPos l) (mkPos c)</a></code></pre></div>
<p>試してみましょう。</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb146-1" title="1">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pSum <span class="op">&lt;</span>* eof) <span class="ex">exampleStream</span></a>
<a class="sourceLine" id="cb146-2" title="2"><span class="kw">(</span><span class="ex">5</span>,6<span class="kw">)</span></a></code></pre></div>
<p>行(1)の <code>Plus</code> を <code>Div</code> に変更すると、正しいパースエラーが発生します。</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb147-1" title="1">λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pSum <span class="op">&lt;</span>* eof) <span class="ex">exampleStream</span></a>
<a class="sourceLine" id="cb147-2" title="2"><span class="ex">1</span>:3:</a>
<a class="sourceLine" id="cb147-3" title="3">  <span class="kw">|</span></a>
<a class="sourceLine" id="cb147-4" title="4"><span class="ex">1</span> <span class="kw">|</span> <span class="op">&lt;</span><span class="ex">missing</span> input<span class="op">&gt;</span></a>
<a class="sourceLine" id="cb147-5" title="5">  <span class="kw">|</span>   ^</a>
<a class="sourceLine" id="cb147-6" title="6"><span class="ex">unexpected</span> /</a>
<a class="sourceLine" id="cb147-7" title="7"><span class="ex">expecting</span> +</a></code></pre></div>
<p>言い換えると、カスタムストリームのパースが可能な 十分に機能するパーサができました。</p>
<h2 id="演習の回答例puri-を完成させる">演習の回答例(<code>pUri</code> を完成させる)</h2>
<div class="sourceCode" id="cb148"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb148-1" title="1"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb148-2" title="2"><span class="ot">{-# LANGUAGE RecordWildCards   #-}</span></a>
<a class="sourceLine" id="cb148-3" title="3"></a>
<a class="sourceLine" id="cb148-4" title="4"><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></a>
<a class="sourceLine" id="cb148-5" title="5"></a>
<a class="sourceLine" id="cb148-6" title="6"><span class="kw">import</span> <span class="dt">Control.Applicative</span> <span class="kw">hiding</span> (some,many)</a>
<a class="sourceLine" id="cb148-7" title="7"><span class="kw">import</span> <span class="dt">Control.Monad</span></a>
<a class="sourceLine" id="cb148-8" title="8"><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb148-9" title="9"><span class="kw">import</span> <span class="dt">Data.Void</span></a>
<a class="sourceLine" id="cb148-10" title="10"><span class="kw">import</span> <span class="dt">Data.Char</span></a>
<a class="sourceLine" id="cb148-11" title="11"><span class="kw">import</span> <span class="dt">Text.Megaparsec</span> <span class="kw">hiding</span> (<span class="dt">State</span>)</a>
<a class="sourceLine" id="cb148-12" title="12"><span class="kw">import</span> <span class="dt">Text.Megaparsec.Char</span></a>
<a class="sourceLine" id="cb148-13" title="13"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></a>
<a class="sourceLine" id="cb148-14" title="14"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Megaparsec.Char.Lexer</span> <span class="kw">as</span> <span class="dt">L</span></a>
<a class="sourceLine" id="cb148-15" title="15"></a>
<a class="sourceLine" id="cb148-16" title="16"><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Void</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb148-17" title="17"></a>
<a class="sourceLine" id="cb148-18" title="18"><span class="kw">data</span> <span class="dt">Uri</span> <span class="ot">=</span> <span class="dt">Uri</span></a>
<a class="sourceLine" id="cb148-19" title="19">  {<span class="ot"> uriScheme    ::</span> <span class="dt">Scheme</span></a>
<a class="sourceLine" id="cb148-20" title="20">  ,<span class="ot"> uriAuthority ::</span> <span class="dt">Maybe</span> <span class="dt">Authority</span></a>
<a class="sourceLine" id="cb148-21" title="21">  ,<span class="ot"> uriPath      ::</span> [<span class="dt">Text</span>]</a>
<a class="sourceLine" id="cb148-22" title="22">  ,<span class="ot"> uriQuery     ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb148-23" title="23">  ,<span class="ot"> uriFlagment  ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb148-24" title="24">  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb148-25" title="25"></a>
<a class="sourceLine" id="cb148-26" title="26"><span class="kw">data</span> <span class="dt">Scheme</span></a>
<a class="sourceLine" id="cb148-27" title="27">  <span class="ot">=</span> <span class="dt">SchemeData</span></a>
<a class="sourceLine" id="cb148-28" title="28">  <span class="op">|</span> <span class="dt">SchemeFile</span></a>
<a class="sourceLine" id="cb148-29" title="29">  <span class="op">|</span> <span class="dt">SchemeFtp</span></a>
<a class="sourceLine" id="cb148-30" title="30">  <span class="op">|</span> <span class="dt">SchemeHttp</span></a>
<a class="sourceLine" id="cb148-31" title="31">  <span class="op">|</span> <span class="dt">SchemeHttps</span></a>
<a class="sourceLine" id="cb148-32" title="32">  <span class="op">|</span> <span class="dt">SchemeIrc</span></a>
<a class="sourceLine" id="cb148-33" title="33">  <span class="op">|</span> <span class="dt">SchemeMailto</span></a>
<a class="sourceLine" id="cb148-34" title="34">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb148-35" title="35"></a>
<a class="sourceLine" id="cb148-36" title="36"><span class="kw">data</span> <span class="dt">Authority</span> <span class="ot">=</span> <span class="dt">Authority</span></a>
<a class="sourceLine" id="cb148-37" title="37">  {<span class="ot"> authUser ::</span> <span class="dt">Maybe</span> (<span class="dt">Text</span>, <span class="dt">Text</span>) <span class="co">-- (user, password)</span></a>
<a class="sourceLine" id="cb148-38" title="38">  ,<span class="ot"> authHost ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb148-39" title="39">  ,<span class="ot"> authPort ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb148-40" title="40">  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb148-41" title="41"></a>
<a class="sourceLine" id="cb148-42" title="42"><span class="ot">pScheme ::</span> <span class="dt">Parser</span> <span class="dt">Scheme</span></a>
<a class="sourceLine" id="cb148-43" title="43">pScheme <span class="ot">=</span> choice</a>
<a class="sourceLine" id="cb148-44" title="44">  [ <span class="dt">SchemeData</span>   <span class="op">&lt;$</span> string <span class="st">&quot;data&quot;</span></a>
<a class="sourceLine" id="cb148-45" title="45">  , <span class="dt">SchemeFile</span>   <span class="op">&lt;$</span> string <span class="st">&quot;file&quot;</span></a>
<a class="sourceLine" id="cb148-46" title="46">  , <span class="dt">SchemeFtp</span>    <span class="op">&lt;$</span> string <span class="st">&quot;ftp&quot;</span></a>
<a class="sourceLine" id="cb148-47" title="47">  , <span class="dt">SchemeHttps</span>  <span class="op">&lt;$</span> string <span class="st">&quot;https&quot;</span></a>
<a class="sourceLine" id="cb148-48" title="48">  , <span class="dt">SchemeHttp</span>   <span class="op">&lt;$</span> string <span class="st">&quot;http&quot;</span></a>
<a class="sourceLine" id="cb148-49" title="49">  , <span class="dt">SchemeIrc</span>    <span class="op">&lt;$</span> string <span class="st">&quot;irc&quot;</span></a>
<a class="sourceLine" id="cb148-50" title="50">  , <span class="dt">SchemeMailto</span> <span class="op">&lt;$</span> string <span class="st">&quot;mailto&quot;</span> ]</a>
<a class="sourceLine" id="cb148-51" title="51"></a>
<a class="sourceLine" id="cb148-52" title="52"><span class="ot">alternatives ::</span> <span class="dt">Parser</span> (<span class="dt">Char</span>, <span class="dt">Char</span>)</a>
<a class="sourceLine" id="cb148-53" title="53">alternatives <span class="ot">=</span> try foo <span class="op">&lt;|&gt;</span> bar</a>
<a class="sourceLine" id="cb148-54" title="54">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb148-55" title="55">    foo <span class="ot">=</span> (,) <span class="op">&lt;$&gt;</span> char <span class="ch">'a'</span> <span class="op">&lt;*&gt;</span> char <span class="ch">'b'</span></a>
<a class="sourceLine" id="cb148-56" title="56">    bar <span class="ot">=</span> (,) <span class="op">&lt;$&gt;</span> char <span class="ch">'a'</span> <span class="op">&lt;*&gt;</span> char <span class="ch">'c'</span></a>
<a class="sourceLine" id="cb148-57" title="57"></a>
<a class="sourceLine" id="cb148-58" title="58"><span class="ot">pPath ::</span> <span class="dt">Parser</span> [<span class="dt">Text</span>]</a>
<a class="sourceLine" id="cb148-59" title="59">pPath <span class="ot">=</span> choice</a>
<a class="sourceLine" id="cb148-60" title="60">  [ pPathAbempty</a>
<a class="sourceLine" id="cb148-61" title="61">  , pPathAbsolute</a>
<a class="sourceLine" id="cb148-62" title="62">  , pPathNoScheme</a>
<a class="sourceLine" id="cb148-63" title="63">  , pPathRootless</a>
<a class="sourceLine" id="cb148-64" title="64">  , pPathEmpty</a>
<a class="sourceLine" id="cb148-65" title="65">  ]</a>
<a class="sourceLine" id="cb148-66" title="66"></a>
<a class="sourceLine" id="cb148-67" title="67"><span class="ot">pPathAbempty ::</span> <span class="dt">Parser</span> [<span class="dt">Text</span>]</a>
<a class="sourceLine" id="cb148-68" title="68">pPathAbempty <span class="ot">=</span> many (char <span class="ch">'/'</span> <span class="op">*&gt;</span> pSegment)</a>
<a class="sourceLine" id="cb148-69" title="69"></a>
<a class="sourceLine" id="cb148-70" title="70"><span class="ot">pPathAbsolute ::</span> <span class="dt">Parser</span> [<span class="dt">Text</span>]</a>
<a class="sourceLine" id="cb148-71" title="71">pPathAbsolute <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb148-72" title="72">  void (char <span class="ch">'/'</span>)</a>
<a class="sourceLine" id="cb148-73" title="73">  option [] <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb148-74" title="74">    seg <span class="ot">&lt;-</span> pSegmentNz</a>
<a class="sourceLine" id="cb148-75" title="75">    segs <span class="ot">&lt;-</span>  many (char <span class="ch">'/'</span> <span class="op">*&gt;</span> pSegment)</a>
<a class="sourceLine" id="cb148-76" title="76">    <span class="fu">return</span> (seg<span class="op">:</span>segs)</a>
<a class="sourceLine" id="cb148-77" title="77"></a>
<a class="sourceLine" id="cb148-78" title="78"><span class="ot">pPathNoScheme ::</span> <span class="dt">Parser</span> [<span class="dt">Text</span>]</a>
<a class="sourceLine" id="cb148-79" title="79">pPathNoScheme <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb148-80" title="80">  seg <span class="ot">&lt;-</span> pSegmentNzNc</a>
<a class="sourceLine" id="cb148-81" title="81">  segs <span class="ot">&lt;-</span> many (char <span class="ch">'/'</span> <span class="op">*&gt;</span> pSegment)</a>
<a class="sourceLine" id="cb148-82" title="82">  <span class="fu">return</span> (seg<span class="op">:</span>segs)</a>
<a class="sourceLine" id="cb148-83" title="83"></a>
<a class="sourceLine" id="cb148-84" title="84"><span class="ot">pPathRootless ::</span> <span class="dt">Parser</span> [<span class="dt">Text</span>]</a>
<a class="sourceLine" id="cb148-85" title="85">pPathRootless <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb148-86" title="86">  seg <span class="ot">&lt;-</span> pSegmentNz</a>
<a class="sourceLine" id="cb148-87" title="87">  segs <span class="ot">&lt;-</span> many (char <span class="ch">'/'</span> <span class="op">*&gt;</span> pSegment)</a>
<a class="sourceLine" id="cb148-88" title="88">  <span class="fu">return</span> (seg<span class="op">:</span>segs)</a>
<a class="sourceLine" id="cb148-89" title="89"></a>
<a class="sourceLine" id="cb148-90" title="90"><span class="ot">pPathEmpty ::</span> <span class="dt">Parser</span> [<span class="dt">Text</span>]</a>
<a class="sourceLine" id="cb148-91" title="91">pPathEmpty <span class="ot">=</span> <span class="fu">return</span> []</a>
<a class="sourceLine" id="cb148-92" title="92"></a>
<a class="sourceLine" id="cb148-93" title="93"><span class="ot">pSegment ::</span> <span class="dt">Parser</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb148-94" title="94">pSegment <span class="ot">=</span> T.pack <span class="op">&lt;$&gt;</span> many pPchar</a>
<a class="sourceLine" id="cb148-95" title="95"></a>
<a class="sourceLine" id="cb148-96" title="96"><span class="ot">pSegmentNz ::</span> <span class="dt">Parser</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb148-97" title="97">pSegmentNz <span class="ot">=</span> T.pack <span class="op">&lt;$&gt;</span> some pPchar</a>
<a class="sourceLine" id="cb148-98" title="98"></a>
<a class="sourceLine" id="cb148-99" title="99"><span class="ot">pSegmentNzNc ::</span> <span class="dt">Parser</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb148-100" title="100">pSegmentNzNc <span class="ot">=</span> T.pack <span class="op">&lt;$&gt;</span> some (pUnreserved <span class="op">&lt;|&gt;</span> pPctEncoded <span class="op">&lt;|&gt;</span> pSubDelims <span class="op">&lt;|&gt;</span> char <span class="ch">'@'</span>)</a>
<a class="sourceLine" id="cb148-101" title="101"></a>
<a class="sourceLine" id="cb148-102" title="102"><span class="ot">pPchar ::</span> <span class="dt">Parser</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb148-103" title="103">pPchar <span class="ot">=</span> pUnreserved <span class="op">&lt;|&gt;</span> pPctEncoded <span class="op">&lt;|&gt;</span> pSubDelims <span class="op">&lt;|&gt;</span> char <span class="ch">':'</span> <span class="op">&lt;|&gt;</span> char <span class="ch">'@'</span></a>
<a class="sourceLine" id="cb148-104" title="104"></a>
<a class="sourceLine" id="cb148-105" title="105"><span class="ot">pUnreserved ::</span> <span class="dt">Parser</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb148-106" title="106">pUnreserved <span class="ot">=</span> alphaNumChar <span class="op">&lt;|&gt;</span> char <span class="ch">'-'</span> <span class="op">&lt;|&gt;</span> char <span class="ch">'.'</span> <span class="op">&lt;|&gt;</span> char <span class="ch">'_'</span> <span class="op">&lt;|&gt;</span> char <span class="ch">'~'</span></a>
<a class="sourceLine" id="cb148-107" title="107"></a>
<a class="sourceLine" id="cb148-108" title="108"><span class="ot">pPctEncoded ::</span> <span class="dt">Parser</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb148-109" title="109">pPctEncoded <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb148-110" title="110">  void (char <span class="ch">'%'</span>)</a>
<a class="sourceLine" id="cb148-111" title="111">  a <span class="ot">&lt;-</span> hexDigitChar</a>
<a class="sourceLine" id="cb148-112" title="112">  b <span class="ot">&lt;-</span> hexDigitChar</a>
<a class="sourceLine" id="cb148-113" title="113">  <span class="fu">return</span> <span class="op">.</span> <span class="fu">chr</span> <span class="op">$</span> (<span class="fu">digitToInt</span> a)<span class="op">*</span><span class="dv">16</span> <span class="op">+</span> <span class="fu">digitToInt</span> b</a>
<a class="sourceLine" id="cb148-114" title="114"></a>
<a class="sourceLine" id="cb148-115" title="115"><span class="ot">pSubDelims ::</span> <span class="dt">Parser</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb148-116" title="116">pSubDelims <span class="ot">=</span> choice <span class="op">$</span> <span class="fu">map</span> char <span class="st">&quot;!$&amp;'()*+,;=&quot;</span></a>
<a class="sourceLine" id="cb148-117" title="117"></a>
<a class="sourceLine" id="cb148-118" title="118"><span class="ot">pUri ::</span> <span class="dt">Parser</span> <span class="dt">Uri</span></a>
<a class="sourceLine" id="cb148-119" title="119">pUri <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb148-120" title="120">  uriScheme <span class="ot">&lt;-</span> pScheme <span class="op">&lt;?&gt;</span> <span class="st">&quot;valid scheme&quot;</span></a>
<a class="sourceLine" id="cb148-121" title="121">  void (char <span class="ch">':'</span>)</a>
<a class="sourceLine" id="cb148-122" title="122">  uriAuthority <span class="ot">&lt;-</span> optional <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb148-123" title="123">    void (string <span class="st">&quot;//&quot;</span>)</a>
<a class="sourceLine" id="cb148-124" title="124">    authUser <span class="ot">&lt;-</span> optional <span class="op">.</span> try <span class="op">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb148-125" title="125">      user <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar <span class="op">&lt;?&gt;</span> <span class="st">&quot;username&quot;</span></a>
<a class="sourceLine" id="cb148-126" title="126">      void (char <span class="ch">':'</span>)</a>
<a class="sourceLine" id="cb148-127" title="127">      password <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar <span class="op">&lt;?&gt;</span> <span class="st">&quot;password&quot;</span></a>
<a class="sourceLine" id="cb148-128" title="128">      void (char <span class="ch">'@'</span>)</a>
<a class="sourceLine" id="cb148-129" title="129">      <span class="fu">return</span> (user, password)</a>
<a class="sourceLine" id="cb148-130" title="130">    authHost <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some (alphaNumChar <span class="op">&lt;|&gt;</span> char <span class="ch">'.'</span>) <span class="op">&lt;?&gt;</span> <span class="st">&quot;hostname&quot;</span></a>
<a class="sourceLine" id="cb148-131" title="131">    authPort <span class="ot">&lt;-</span> optional (char <span class="ch">':'</span> <span class="op">*&gt;</span> label <span class="st">&quot;port number&quot;</span> L.decimal)</a>
<a class="sourceLine" id="cb148-132" title="132">    <span class="fu">return</span> <span class="dt">Authority</span> {<span class="op">..</span>}</a>
<a class="sourceLine" id="cb148-133" title="133">  uriPath <span class="ot">&lt;-</span> pPath</a>
<a class="sourceLine" id="cb148-134" title="134">  uriQuery <span class="ot">&lt;-</span> optional (T.pack <span class="op">&lt;$&gt;</span> (char <span class="ch">'?'</span> <span class="op">*&gt;</span> many (pPchar <span class="op">&lt;|&gt;</span> char <span class="ch">'/'</span> <span class="op">&lt;|&gt;</span> char <span class="ch">'?'</span>)))</a>
<a class="sourceLine" id="cb148-135" title="135">  uriFlagment <span class="ot">&lt;-</span> optional (T.pack <span class="op">&lt;$&gt;</span> (char <span class="ch">'#'</span> <span class="op">*&gt;</span> many (pPchar <span class="op">&lt;|&gt;</span> char <span class="ch">'/'</span> <span class="op">&lt;|&gt;</span> char <span class="ch">'?'</span>)) <span class="op">&lt;?&gt;</span> <span class="st">&quot;flagment&quot;</span>)</a>
<a class="sourceLine" id="cb148-136" title="136">  <span class="fu">return</span> <span class="dt">Uri</span> {<span class="op">..</span>}</a></code></pre></div>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>RFC 3986 に従ってURIのパースが可能であり Megaparsec パーサを含む <a href="https://hackage.haskell.org/package/modern-uri"><code>modern-uri</code></a> パッケージが実際にあります。ただし、パッケージのパーサはここで説明したものよりもはるかに複雑です。<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</section>
      </article>

      <div class="row pager">
        <div class="col s6">
          
            <a class="waves-effect waves-light btn white-text left prev" href="../../posts/2019/02-13-sum-monoid.html"><i class="material-icons left">navigate_before</i>Sum Monoid</a>
          
        </div>
        <div class="col s6">
          
        </div>
      </div>

      <div class="row">
        <div class="col s6 offset-s6" style="position: relative; height: 100px;">
          <div class="fixed-action-btn horizontal" style="position: absolute; display: inline-block; right: 24px;">
  <a class="btn-floating btn-large red">
    <i class="large material-icons">share</i>
  </a>
  <ul>
    <li>
      <a class="btn-floating waves-effect waves-light blue tooltipped" data-position="bottom" data-delay="20" data-tooltip="Share on Twitter" href="https://twitter.com/intent/tweet?text=Megaparsec tutorial from IH book&url=https://haskell.e-bigmoon.com/posts/2019/07-14-megaparsec-tutorial.html"><i class="mdi mdi-twitter white-text"></i></a>
    </li>
    <li>
      <a class="btn-floating waves-effect waves-light indigo tooltipped" data-position="bottom" data-delay="20" data-tooltip="Share on Facebook" href="https://facebook.com/sharer.php?u=https://haskell.e-bigmoon.com/posts/2019/07-14-megaparsec-tutorial.html"><i class="mdi mdi-facebook white-text"></i></a>
    </li>
    <li>
      <a class="btn-floating waves-effect waves-light red tooltipped" data-position="bottom" data-delay="20" data-tooltip="Share on Google+" href="https://plus.google.com/share?url=https://haskell.e-bigmoon.com/posts/2019/07-14-megaparsec-tutorial.html"><i class="mdi mdi-google-plus white-text"></i></a>
    </li>
  </ul>
</div>
        </div>
      </div>

    </div>
  </div>

  <!-- {% if page.mathjax %} -->
  <!--   {% include mathjax_support.html %} -->
  <!-- {% endif %} -->

</div>

      </div>
    </div>

    <footer class="page-footer indigo lighten-1">

  <div class="footer-copyright">

    <div class="container">
      © 2017-2019 BIGMOON&nbsp;
      Site proudly generated by <a class="red-text text-accent-1" href="http://jaspervdj.be/hakyll">Hakyll</a>,&nbsp;
      original Jekyll theme by <a class="red-text text-accent-1" href="https://github.com/mumuxme/materialize-jekyll">mumuxme</a>.
    </div>

  </div>

</footer>


    <!-- scrolltop button -->
    <button class="material-scrolltop waves-effect waves-light hide-on-small-only" type="button">
      <i class="mdi mdi-arrow-up-bold small white-text"></i>
    </button>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-19322672-9"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-19322672-9');
    </script>

    <!-- jquery -->
    <script type="text/javascript" src="../../lib/jquery-min.js"></script>
    <!-- materialize -->
    <script src="../../lib/materialize/js/materialize.min.js"></script>
    <!-- <\!-- Material ScrollTop plugin -\-> -->
    <script src="../../lib/material-scrolltop/material-scrolltop.js"></script>
    <!-- main -->
    <script src="../../js/init.js"></script>
    <script src="../../js/main.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/haskell.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>

</html>
