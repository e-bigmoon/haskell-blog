<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>BIG MOON</title>
    <link href="https://haskell.e-bigmoon.com/feed.xml" rel="self" />
    <link href="https://haskell.e-bigmoon.com" />
    <id>https://haskell.e-bigmoon.com/feed.xml</id>
    <author>
        <name>BIG MOON</name>
        <email>it@e-bigmoon.com</email>
    </author>
    <updated>2018-03-30T00:00:00Z</updated>
    <entry>
    <title>prettyprinter パッケージ</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-30-prettyprinter.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-30-prettyprinter.html</id>
    <published>2018-03-30T00:00:00Z</published>
    <updated>2018-03-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>今回は <a href="https://www.stackage.org/package/prettyprinter">prettyprinter</a> を使ってみました。</p>
<p>使おうと思ったモチベーションとしては、以下のようなデータ型をデバッグ表示させる際に <code>prettyprinter</code> 系パッケージを使って良い感じに表示してみようかな？という感じです。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span> <span class="dt">Text</span> <span class="dt">String</span></a></code></pre></div>
<p>表示をカスタマイズするために <code>Show</code> クラスのインスタンスを書き換えることは、経験上嫌なことしか起きないです・・。</p>
<p>自分でそれっぽい型クラスを作っても良いのですが、普通は素直に <code>prettyprinter</code> 系のパッケージを使った方が良いと思います！</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1">$ <span class="ex">stack</span> repl --package text</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ex">Prelude</span><span class="op">&gt;</span> import Data.Text</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ex">Prelude</span> Data.Text<span class="op">&gt;</span> data Person = Person Text String deriving Show</a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ex">Prelude</span> Data.Text<span class="op">&gt;</span> :set -XOverloadedStrings</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ex">Prelude</span> Data.Text<span class="op">&gt;</span> Person <span class="st">&quot;はすける&quot;</span> <span class="st">&quot;らむだ&quot;</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="ex">Person</span> <span class="st">&quot;\12399\12377\12369\12427&quot;</span> <span class="st">&quot;\12425\12416\12384&quot;</span></a></code></pre></div>
<!--more-->
<h2 id="パッケージの選定理由">パッケージの選定理由</h2>
<p>ぐぐって一番始めに出てきたのは <a href="https://github.com/haskell/pretty">pretty</a> というパッケージだったんですが <code>String</code> にしか対応してない感じだったので見送りました。</p>
<p><code>prettyprinter</code> は <strong>A modern, easy to use, well-documented, extensible prettyprinter.</strong> というコメント通り、とても使いやすいです。</p>
<h2 id="使ってみました">使ってみました</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="co">-- stack --resolver lts-11.2 script</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Data.Text.Prettyprint.Doc</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Data.Text.Prettyprint.Doc.Render.Text</span> (putDoc)</a>
<a class="sourceLine" id="cb3-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb3-10" data-line-number="10"></a>
<a class="sourceLine" id="cb3-11" data-line-number="11"><span class="kw">data</span> <span class="dt">A</span> <span class="fu">=</span> <span class="dt">A</span> <span class="dt">Text</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12">  <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13"></a>
<a class="sourceLine" id="cb3-14" data-line-number="14"><span class="kw">data</span> <span class="dt">B</span> <span class="fu">=</span> <span class="dt">B</span> <span class="dt">Text</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb3-15" data-line-number="15"></a>
<a class="sourceLine" id="cb3-16" data-line-number="16"><span class="kw">instance</span> <span class="dt">Pretty</span> <span class="dt">B</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-17" data-line-number="17">  pretty (<span class="dt">B</span> l r) <span class="fu">=</span> <span class="st">&quot;B&quot;</span> <span class="fu">&lt;+&gt;</span> pretty l <span class="fu">&lt;+&gt;</span> pretty r</a>
<a class="sourceLine" id="cb3-18" data-line-number="18"></a>
<a class="sourceLine" id="cb3-19" data-line-number="19"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-20" data-line-number="20">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-21" data-line-number="21">  print <span class="fu">$</span> <span class="dt">A</span> <span class="st">&quot;あ&quot;</span> <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb3-22" data-line-number="22">  putDoc <span class="fu">$</span> pretty <span class="fu">$</span> <span class="dt">B</span> <span class="st">&quot;あ&quot;</span> <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb3-23" data-line-number="23">  putStrLn <span class="st">&quot;&quot;</span></a></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1">$ <span class="fu">chmod</span> u+x Pretty.hs</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">$ <span class="ex">./Pretty.hs</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="ex">A</span> <span class="st">&quot;\12354&quot;</span> <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="ex">B</span> あ a</a></code></pre></div>
<p><a href="https://www.stackage.org/haddock/lts-11.2/prettyprinter-1.2.0.1/Data-Text-Prettyprint-Doc.html#t:Pretty">Pretty</a> 型クラスのインスタンスを普通に定義するだけです。</p>
<p>適当に改行したい場合は <a href="https://www.stackage.org/haddock/lts-11.2/prettyprinter-1.2.0.1/Data-Text-Prettyprint-Doc.html#v:line">line</a> を追加するだけです。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Pretty</span> <span class="dt">B</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  pretty (<span class="dt">B</span> l r) <span class="fu">=</span> <span class="st">&quot;B&quot;</span> <span class="fu">&lt;&gt;</span> line</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">                <span class="fu">&lt;+&gt;</span> pretty l <span class="fu">&lt;&gt;</span> line</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">                <span class="fu">&lt;+&gt;</span> pretty r</a></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" data-line-number="1">$ <span class="ex">./test.hs</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ex">A</span> <span class="st">&quot;\12354&quot;</span> <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="ex">B</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"> あ</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"> <span class="ex">a</span></a></code></pre></div>
<p>先頭の空白が不必要な場合は <a href="https://www.stackage.org/haddock/lts-11.2/prettyprinter-1.2.0.1/Data-Text-Prettyprint-Doc.html#v:-60--43--62-">&lt;+&gt;</a> を <a href="https://www.stackage.org/haddock/lts-11.2/prettyprinter-1.2.0.1/Data-Text-Prettyprint-Doc.html#v:-60--62-">&lt;&gt;</a> にするだけです。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Pretty</span> <span class="dt">B</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  pretty (<span class="dt">B</span> l r) <span class="fu">=</span> <span class="st">&quot;B&quot;</span> <span class="fu">&lt;&gt;</span> line</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">                <span class="fu">&lt;&gt;</span> pretty l <span class="fu">&lt;&gt;</span> line</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">                <span class="fu">&lt;&gt;</span> pretty r</a></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" data-line-number="1">$ <span class="ex">./test.hs</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ex">A</span> <span class="st">&quot;\12354&quot;</span> <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="ex">B</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">あ</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="ex">a</span></a></code></pre></div>
<p>適当にネストさせたい場合も簡単です。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Pretty</span> <span class="dt">B</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  pretty (<span class="dt">B</span> l r) <span class="fu">=</span> nest <span class="dv">4</span> (<span class="st">&quot;B&quot;</span> <span class="fu">&lt;&gt;</span> line</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">                <span class="fu">&lt;&gt;</span> pretty l <span class="fu">&lt;&gt;</span> line</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">                <span class="fu">&lt;&gt;</span> pretty r)</a></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb10-1" data-line-number="1">$ <span class="ex">./test.hs</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ex">A</span> <span class="st">&quot;\12354&quot;</span> <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="ex">B</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">    あ</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">    <span class="ex">a</span></a></code></pre></div>
<h2 id="まとめ">まとめ</h2>
<p>めちゃめちゃ簡単だったので、使ってみると楽しいですよー。ドキュメントが充実しているのが良いですね。</p>
<p>今回は短めでした。</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Haskell Quiz No.4 幅優先探索と深さ優先探索</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-28-quiz-4.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-28-quiz-4.html</id>
    <published>2018-03-28T00:00:00Z</published>
    <updated>2018-03-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="haskell-quiz-no.4">Haskell Quiz No.4</h2>
<p>難易度: λ</p>
<p>今回は、与えられた値がリストのリストに含まれているかどうかを判定する問題です。</p>
<p>幅優先で探索する関数 <code>bfs</code> と深さ優先で探索する関数 <code>dfs</code> をそれぞれ定義してみましょう。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">bfs ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [[<span class="dt">Int</span>]] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">bfs <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">dfs ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [[<span class="dt">Int</span>]] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">dfs <span class="fu">=</span> undefined</a></code></pre></div>
<p>実行結果はだいたいこんな感じです。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1">$ <span class="ex">stack</span> repl -- Quiz4.hs</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ex">*Quiz4</span><span class="op">&gt;</span> xs = [[10..],[4,5,6],[7,8,9]]</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ex">*Quiz4</span><span class="op">&gt;</span> bfs 9 xs</a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ex">True</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ex">*Quiz4</span><span class="op">&gt;</span> dfs 9 xs</a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="ex">.....</span></a></code></pre></div>
<p>答えは次回。</p>
<!--more-->
<h2 id="はじめに">はじめに</h2>
<p><a href="./03-27-quiz-3.html">前回</a>の問題と答えは以下の通りです。</p>
<h3 id="問題">問題</h3>
<p>難易度: λ</p>
<p><code>propIsDigit</code> テストをパスするように <code>Digit</code> 型の <code>Arbitrary</code> インスタンスを定義してみましょう。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Quiz3</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Test.QuickCheck</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Data.Char</span> (isDigit)</a>
<a class="sourceLine" id="cb3-5" data-line-number="5"></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="kw">newtype</span> <span class="dt">Digit</span> <span class="fu">=</span> <span class="dt">Digit</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"></a>
<a class="sourceLine" id="cb3-9" data-line-number="9"><span class="ot">propIsDigit ::</span> <span class="dt">Digit</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10">propIsDigit (<span class="dt">Digit</span> c) <span class="fu">=</span> isDigit c</a>
<a class="sourceLine" id="cb3-11" data-line-number="11"></a>
<a class="sourceLine" id="cb3-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Digit</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13">  arbitrary <span class="fu">=</span> undefined</a></code></pre></div>
<p>テストは以下のように実行します。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1">$ <span class="ex">stack</span> repl --package QuickCheck -- Quiz3.hs</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ex">*Quiz3</span><span class="op">&gt;</span> quickCheck propIsDigit</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="ex">+++</span> OK, passed 100 tests.</a></code></pre></div>
<h3 id="こたえ">こたえ</h3>
<p>実装方法はいくつかあるのですが、例えば <a href="https://www.stackage.org/haddock/lts-11.2/QuickCheck-2.10.1/Test-QuickCheck.html#v:elements">elements</a> を使う方法だとこんな感じです。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Digit</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  arbitrary <span class="fu">=</span> <span class="dt">Digit</span> <span class="fu">&lt;$&gt;</span> elements <span class="st">&quot;1234567890&quot;</span></a></code></pre></div>
<p>ちょっと反則っぽいですが <a href="https://www.stackage.org/haddock/lts-11.2/QuickCheck-2.10.1/Test-QuickCheck.html#v:suchThat">suchThat</a> を使う方法もありそうですね。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Digit</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  arbitrary <span class="fu">=</span> <span class="dt">Digit</span> <span class="fu">&lt;$&gt;</span> arbitrary <span class="ot">`suchThat`</span> isDigit</a></code></pre></div>
<p>こんな方法もあるよーと言う方は教えてください！</p>
<h2 id="haskell-quiz-no.3-の解説">Haskell Quiz No.3 の解説</h2>
<p><code>QuickCheck</code> を使っている人にとっては簡単な問題だったと思います。</p>
<p>逆に全く使ったこと無い人にとっては、結構難しかったのではないでしょうか。</p>
<h3 id="arbitrary-型クラス">Arbitrary 型クラス</h3>
<p><a href="https://www.stackage.org/haddock/lts-11.2/QuickCheck-2.10.1/Test-QuickCheck.html#t:Arbitrary">Arbitrary</a> 型クラスは <a href="https://www.stackage.org/lts-11.2/package/QuickCheck-2.10.1">QuickCheck</a> パッケージの <a href="https://www.stackage.org/haddock/lts-11.2/QuickCheck-2.10.1/Test-QuickCheck-Arbitrary.html#t:Arbitrary">Test.QuickCheck.Arbitrary</a> で定義されています。</p>
<p><code>Minimal complete definition</code> は <code>arbitrary</code> メソッド (関数) です。</p>
<p><code>Minimal complete definition</code> とは、型クラスのインスタンスを全て実装しなくても <code>Minimal complete definition</code> だけ実装すれば全てのメソッドが (デフォルト実装で) 利用できるというものです。効率が悪い場合もあるので、その場合は自分で定義を上書きします。</p>
<p>つまり、今回の場合だと <code>arbitrary</code> メソッドさえ定義してしまえば <a href="https://www.stackage.org/haddock/lts-11.2/QuickCheck-2.10.1/Test-QuickCheck-Arbitrary.html#v:shrink">shrink</a> メソッドも同様に利用可能になるということです。</p>
<p>実際の定義は以下の通りです。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Arbitrary</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">  arbitrary ::</span> <span class="dt">Gen</span> a</a>
<a class="sourceLine" id="cb7-3" data-line-number="3"></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="ot">  shrink ::</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  shrink _ <span class="fu">=</span> []</a></code></pre></div>
<h3 id="arbitrary-メソッド">arbitrary メソッド</h3>
<p><code>arbitrary</code> の型は <code>Arbitrary a =&gt; Gen a</code> なので、最初はどうやって定義して良いのか困惑してしまうかもしれません。</p>
<p><code>Gen a</code> はランダムな値を生成するジェネレータを意味する型です。</p>
<p>定義の方法は本当に色々ありますが、まずは基本のユーティリティ関数を抑えておきましょう。</p>
<p><a href="https://www.stackage.org/haddock/lts-11.2/QuickCheck-2.10.1/Test-QuickCheck.html#g:6">Generator combinators</a> に列挙されている関数の一部をご紹介します。</p>
<h4 id="elements">elements</h4>
<p>与えられたリストの値を元に <code>Gen a</code> を作ります。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> <span class="fu">:</span>t elements</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ot">elements ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Gen</span> a</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> sample&#39; <span class="fu">$</span> elements <span class="st">&quot;1234567890&quot;</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="st">&quot;55316502254&quot;</span></a></code></pre></div>
<p>今回の問題もこれを使って <code>isDigit</code> に通る値のみをリストに含めてあげたら良いのです。</p>
<h4 id="choose">choose</h4>
<p>タプルで指定した範囲で値を生成します。その際 <code>Random</code> 型クラスのクラス制約が発生することに注意してください。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> <span class="fu">:</span>t choose</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="ot">choose ::</span> random<span class="fu">-</span><span class="fl">1.1</span><span class="fu">:</span><span class="dt">System.Random.Random</span> a <span class="ot">=&gt;</span> (a, a) <span class="ot">-&gt;</span> <span class="dt">Gen</span> a</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> sample&#39; <span class="fu">$</span> choose (<span class="dv">1</span>,<span class="dv">10</span>)</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">[<span class="dv">3</span>,<span class="dv">7</span>,<span class="dv">5</span>,<span class="dv">9</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">1</span>]</a></code></pre></div>
<h4 id="oneof">oneof</h4>
<p><code>oneof</code> は <code>[Gen a]</code> からランダムに1つ <code>Gen a</code> を選びます。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> <span class="fu">:</span>t oneof</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ot">oneof ::</span> [<span class="dt">Gen</span> a] <span class="ot">-&gt;</span> <span class="dt">Gen</span> a</a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> sample&#39; <span class="fu">$</span> oneof [choose (<span class="dv">1</span>,<span class="dv">3</span>)]</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> sample&#39; <span class="fu">$</span> oneof [choose (<span class="dv">1</span>,<span class="dv">3</span>), choose (<span class="dv">10</span>,<span class="dv">30</span>)]</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">[<span class="dv">18</span>,<span class="dv">26</span>,<span class="dv">2</span>,<span class="dv">17</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">25</span>,<span class="dv">13</span>,<span class="dv">25</span>,<span class="dv">16</span>,<span class="dv">2</span>]</a></code></pre></div>
<h4 id="frequency">frequency</h4>
<p><code>oneof</code> と似ていますが、完全にランダムではなく頻出度合いを制御することができます。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> <span class="fu">:</span>t frequency</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="ot">frequency ::</span> [(<span class="dt">Int</span>, <span class="dt">Gen</span> a)] <span class="ot">-&gt;</span> <span class="dt">Gen</span> a</a>
<a class="sourceLine" id="cb11-3" data-line-number="3"></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> sample&#39; <span class="fu">$</span> frequency  [(<span class="dv">1</span>,choose (<span class="dv">1</span>,<span class="dv">1</span>)), (<span class="dv">100</span>,choose (<span class="dv">100</span>,<span class="dv">100</span>))]</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">[<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">100</span>]</a>
<a class="sourceLine" id="cb11-6" data-line-number="6"></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> sample&#39; <span class="fu">$</span> frequency  [(<span class="dv">30</span>,choose (<span class="dv">1</span>,<span class="dv">1</span>)), (<span class="dv">70</span>,choose (<span class="dv">100</span>,<span class="dv">100</span>))]</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">[<span class="dv">100</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">1</span>,<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">1</span>]</a></code></pre></div>
<h4 id="suchthat">suchThat</h4>
<p>第二引数の述語を満たす値だけで <code>Gen a</code> を作ります。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> <span class="fu">:</span>t suchThat</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="ot">suchThat ::</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Gen</span> a</a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> sample&#39; <span class="fu">$</span> suchThat arbitrary even</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="fu">-</span><span class="dv">8</span>,<span class="dv">10</span>,<span class="fu">-</span><span class="dv">10</span>,<span class="fu">-</span><span class="dv">6</span>,<span class="fu">-</span><span class="dv">6</span>,<span class="fu">-</span><span class="dv">6</span>,<span class="fu">-</span><span class="dv">22</span>]</a>
<a class="sourceLine" id="cb12-6" data-line-number="6"></a>
<a class="sourceLine" id="cb12-7" data-line-number="7"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> sample&#39; <span class="fu">$</span> suchThat arbitrary odd</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">[<span class="fu">-</span><span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="fu">-</span><span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">11</span>,<span class="fu">-</span><span class="dv">9</span>,<span class="dv">7</span>,<span class="fu">-</span><span class="dv">11</span>,<span class="fu">-</span><span class="dv">13</span>]</a></code></pre></div>
<h4 id="vectorof">vectorOf</h4>
<p>与えられた長さの <code>[Gen a]</code> を作ります。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> <span class="fu">:</span>t vectorOf</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="ot">vectorOf ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> <span class="dt">Gen</span> [a]</a>
<a class="sourceLine" id="cb13-3" data-line-number="3"></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> sample&#39; <span class="fu">$</span> vectorOf <span class="dv">2</span> (<span class="ot">arbitrary ::</span> <span class="dt">Gen</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">[[<span class="dv">0</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="fu">-</span><span class="dv">2</span>],[<span class="dv">0</span>,<span class="dv">4</span>],[<span class="fu">-</span><span class="dv">3</span>,<span class="fu">-</span><span class="dv">2</span>],[<span class="dv">2</span>,<span class="fu">-</span><span class="dv">5</span>],[<span class="dv">6</span>,<span class="fu">-</span><span class="dv">8</span>],[<span class="dv">1</span>,<span class="fu">-</span><span class="dv">10</span>],[<span class="fu">-</span><span class="dv">12</span>,<span class="dv">9</span>],[<span class="dv">3</span>,<span class="fu">-</span><span class="dv">5</span>],[<span class="dv">13</span>,<span class="dv">4</span>],[<span class="fu">-</span><span class="dv">8</span>,<span class="dv">12</span>]]</a></code></pre></div>
<h3 id="shrink-メソッド">shrink メソッド</h3>
<p>参考: <a href="https://stackoverflow.com/questions/16968549/what-is-a-shrink-with-regard-to-haskells-quickcheck/16970029">What is a shrink, with regard to Haskell’s QuickCheck?</a></p>
<p><code>shrink</code> はテストに失敗した際にできるだけ小さな反例を返すために利用されるようです。</p>
<p><a href="https://www.stackage.org/haddock/lts-11.2/QuickCheck-2.10.1/Test-QuickCheck.html#v:verboseCheck">verboseCheck</a> 関数を使えば、実際に生成されたテストケースと結果を全てみることができます。</p>
<p>例として <code>5</code> を含まないリストという <code>prop</code> でチェックしてみましょう。(結果は少し見やすいように整形してあります)</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="op">&gt;&gt;&gt;</span> <span class="ex">prop</span> l = all (/= 5) <span class="ex">l</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="op">&gt;&gt;&gt;</span> <span class="ex">verboseCheck</span> prop</a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="ex">Passed</span>:[]</a>
<a class="sourceLine" id="cb14-4" data-line-number="4"><span class="ex">Passed</span>:[]</a>
<a class="sourceLine" id="cb14-5" data-line-number="5"><span class="ex">Passed</span>:[1,2]</a>
<a class="sourceLine" id="cb14-6" data-line-number="6"><span class="ex">Passed</span>:[2,2]</a>
<a class="sourceLine" id="cb14-7" data-line-number="7"><span class="ex">Passed</span>:[-1,1,2]</a>
<a class="sourceLine" id="cb14-8" data-line-number="8"><span class="ex">Passed</span>:[3,-1]</a>
<a class="sourceLine" id="cb14-9" data-line-number="9"><span class="ex">Passed</span>:[-4,-4,-5,3,-4]</a>
<a class="sourceLine" id="cb14-10" data-line-number="10"><span class="ex">Passed</span>:[-6,1,4,-6,-5]</a>
<a class="sourceLine" id="cb14-11" data-line-number="11"><span class="ex">Passed</span>:[4]</a>
<a class="sourceLine" id="cb14-12" data-line-number="12"><span class="ex">Passed</span>:[2,-2]</a>
<a class="sourceLine" id="cb14-13" data-line-number="13"><span class="ex">Passed</span>:[2,8,7]</a>
<a class="sourceLine" id="cb14-14" data-line-number="14"><span class="ex">Passed</span>:[-7,-8,7,6,9,-10,1]</a>
<a class="sourceLine" id="cb14-15" data-line-number="15"><span class="ex">Passed</span>:[-10,11,2]</a>
<a class="sourceLine" id="cb14-16" data-line-number="16"><span class="ex">Passed</span>:[12,0,3,-12,7,-13,-6,9,-8,7,-10,9]</a>
<a class="sourceLine" id="cb14-17" data-line-number="17"><span class="ex">Passed</span>:[4,4,-11,3,-7]</a>
<a class="sourceLine" id="cb14-18" data-line-number="18"><span class="ex">Passed</span>:[2,1,-9]</a>
<a class="sourceLine" id="cb14-19" data-line-number="19"><span class="ex">Passed</span>:[16,3,-8,14,-7,-7,9,-3,-15,3,-10,-14,9,-8,-3]</a>
<a class="sourceLine" id="cb14-20" data-line-number="20"><span class="ex">Passed</span>:[-2,0,-6,0,4,8,17,13]</a>
<a class="sourceLine" id="cb14-21" data-line-number="21"><span class="ex">Passed</span>:[1,15,17]</a>
<a class="sourceLine" id="cb14-22" data-line-number="22"><span class="ex">Passed</span>:[9,-17,-15,-16,-18,16,-19,15]</a>
<a class="sourceLine" id="cb14-23" data-line-number="23"><span class="ex">Passed</span>:[0,10,6,8,0,4,-9,-12,20,0,3,1,-2,14,13,-11]</a>
<a class="sourceLine" id="cb14-24" data-line-number="24"><span class="ex">Passed</span>:[16,-5,-21,2,2,-6,6]</a>
<a class="sourceLine" id="cb14-25" data-line-number="25"><span class="ex">Passed</span>:[-22,14,10,-18,-22,-10,8,8,-14,12,-22]</a>
<a class="sourceLine" id="cb14-26" data-line-number="26"><span class="ex">Passed</span>:[-18,18,0,-1,-16,-4,13,0,11,-20,10,11,0,-9]</a>
<a class="sourceLine" id="cb14-27" data-line-number="27"><span class="ex">Passed</span>:[-9,22,-2,-18,-9,-4,21,-7,0,9,-11]</a>
<a class="sourceLine" id="cb14-28" data-line-number="28"><span class="ex">Passed</span>:[9,21,11,-17,8,-10,0,6,16,17,6,-16,10,24,-7,9,-1,11,-14,-22,-1,-5,2,11,12]</a>
<a class="sourceLine" id="cb14-29" data-line-number="29"><span class="ex">Passed</span>:[-9,-21,25,-11,9,-11,-14,16,-9,-17,-8,9,4,-10,-6,-6,-17,-21,-26,-12]</a>
<a class="sourceLine" id="cb14-30" data-line-number="30"><span class="ex">Passed</span>:[-8,-11,-21,3,4,13,27,-24,-13,-12,-21,-13,-25,10]</a>
<a class="sourceLine" id="cb14-31" data-line-number="31"></a>
<a class="sourceLine" id="cb14-32" data-line-number="32"><span class="ex">Failed</span>:[25,10,-17,27,8,17,5,14,-1,22,-13,13,-9,-23,26,16,0,10]</a></code></pre></div>
<p>生成されるリストがどんどん大きくなり、やっとリストに <code>5</code> を含む反例 <code>[25,10,-17,27,8,17,5,14,-1,22,-13,13,-9,-23,26,16,0,10]</code> を見つけました。この反例をそのまま返しても良いのですが、もしかしたらもっと小さな反例が見つかるかもしれません。</p>
<p><code>verboseCheck</code> は実際にさきほどの反例を、今度は逆に減らしてテストしていきます。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ex">***</span> Failed!</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="ex">Passed</span>:[]</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="ex">Passed</span>:[22,-13,13,-9,-23,26,16,0,10]</a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="ex">Failed</span>:[25,10,-17,27,8,17,5,14,-1]   -- より小さい反例が見つかった</a>
<a class="sourceLine" id="cb15-5" data-line-number="5"><span class="ex">Passed</span>:[]</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"><span class="ex">Failed</span>:[8,17,5,14,-1]                -- より小さい反例が見つかった</a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="ex">Passed</span>:[]</a>
<a class="sourceLine" id="cb15-8" data-line-number="8"><span class="ex">Failed</span>:[5,14,-1]                     -- より小さい反例が見つかった</a>
<a class="sourceLine" id="cb15-9" data-line-number="9"><span class="ex">Passed</span>:[]</a>
<a class="sourceLine" id="cb15-10" data-line-number="10"><span class="ex">Passed</span>:[14,-1]</a>
<a class="sourceLine" id="cb15-11" data-line-number="11"><span class="ex">Failed</span>:[5,-1]                        -- より小さい反例が見つかった</a>
<a class="sourceLine" id="cb15-12" data-line-number="12"><span class="ex">Passed</span>:[]</a>
<a class="sourceLine" id="cb15-13" data-line-number="13"><span class="ex">Passed</span>:[-1]</a>
<a class="sourceLine" id="cb15-14" data-line-number="14"><span class="ex">Failed</span>:[5]                           -- 最小の反例が見つかった</a>
<a class="sourceLine" id="cb15-15" data-line-number="15"><span class="ex">Passed</span>:[]</a>
<a class="sourceLine" id="cb15-16" data-line-number="16"><span class="ex">Passed</span>:[0]</a>
<a class="sourceLine" id="cb15-17" data-line-number="17"><span class="ex">Passed</span>:[3]</a>
<a class="sourceLine" id="cb15-18" data-line-number="18"><span class="ex">Passed</span>:[4]</a>
<a class="sourceLine" id="cb15-19" data-line-number="19"></a>
<a class="sourceLine" id="cb15-20" data-line-number="20"><span class="ex">Falsifiable</span> (after 29 tests and 5 shrinks)<span class="bu">:</span></a>
<a class="sourceLine" id="cb15-21" data-line-number="21">[<span class="ex">5</span>]</a></code></pre></div>
<p>ということで <code>Falsifiable (after 29 tests and 5 shrinks): [5]</code> は <strong>テストの29回目に反例が見つかりました。さらにその反例を5回小さくしたよ</strong> という意味になります。</p>
<p>デフォルト実装では <code>shrink _ = []</code> となっていたので、見つかった反例をそのまま返すようですね。(<a href="https://www.stackage.org/haddock/lts-11.2/QuickCheck-2.10.1/Test-QuickCheck.html#v:shrink">haddock</a> を見るともっと詳しく書いてあるので、気になる方はそちらをご参照ください)</p>
<h2 id="quickcheck-instances-パッケージ">quickcheck-instances パッケージ</h2>
<p>ここまでで <code>QuickCheck</code> がどんなものか何となくわかってもらえたと思います。</p>
<p><code>base</code> パッケージで提供されている型については、ほとんどデフォルトで <code>Arbitrary</code> のインスタンス定義があります。</p>
<p>しかしながら、<a href="https://www.stackage.org/lts-11.2/package/time-1.8.0.2">time</a> パッケージの <a href="https://www.stackage.org/haddock/lts-11.2/time-1.8.0.2/Data-Time-Clock.html#t:UTCTime">UTCTime</a> 型や <a href="https://www.stackage.org/lts-11.2/package/text-1.2.3.0">text</a> パッケージの <a href="https://www.stackage.org/haddock/lts-11.2/text-1.2.3.0/Data-Text.html#t:Text">Text</a> 型などのインスタンス定義は別途自分で書かなくてはなりません。</p>
<p><a href="https://www.stackage.org/package/quickcheck-instances">quickcheck-instances</a> パッケージはそういった、よく使うパッケージのインスタンス定義をまとめたものです。</p>
<p>このパッケージの定義で満足いかない場合は自分でカスタマイズするというようにすれば、効率的に開発が進むと思いますよ！</p>
<h2 id="haskell-の入門書を読み終えたあとは">Haskell の入門書を読み終えたあとは・・・？</h2>
<p><code>Haskell</code> の入門書を読み終わった後のオススメの勉強法は以下の2つです。</p>
<ul>
<li>アカデミックコース: 論文を読む</li>
<li>エンジニアコース: ライブラリとアプリケーションのソースコードを読む</li>
</ul>
<p>論文の知識が無いと読めないライブラリもありますし、実装力がないと深い理解が得られない論文もあると思いますが、続けていると不思議とわかるようになります。</p>
<p>また、驚くべきことに <code>Haskell</code> 界隈ではカジュアルにドキュメントのリンクが論文だったりしますが、時間が経てばわかりやすい解説がいくつも出てくるものなので、その時はわからなくてもそのうちわかるようになるかもしれません。</p>
<p>ちなみに <code>QuickCheck</code> に関連する論文も (いくつか) ありますよ。</p>
<h2 id="まとめ">まとめ</h2>
<p><code>shrink</code> なんて使ったことなかったので、今まで良くわかんない関数でしたが、今後機会があれば定義してみようと思います。</p>
<p><code>QuickCheck</code> はランダムテストだと思えば、すぐに理解できますよ！性質テストって言われると難しい感じがしてしまいます・・・。(僕だけかも)</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Haskell Quiz No.3 QuickCheck の Arbitrary 型クラス</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-27-quiz-3.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-27-quiz-3.html</id>
    <published>2018-03-27T00:00:00Z</published>
    <updated>2018-03-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="haskell-quiz-no.3">Haskell Quiz No.3</h2>
<p>難易度: λ</p>
<p><code>propIsDigit</code> テストをパスするように <code>Digit</code> 型の <code>Arbitrary</code> インスタンスを定義してみましょう。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Quiz3</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Test.QuickCheck</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Data.Char</span> (isDigit)</a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">newtype</span> <span class="dt">Digit</span> <span class="fu">=</span> <span class="dt">Digit</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="ot">propIsDigit ::</span> <span class="dt">Digit</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">propIsDigit (<span class="dt">Digit</span> c) <span class="fu">=</span> isDigit c</a>
<a class="sourceLine" id="cb1-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Digit</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  arbitrary <span class="fu">=</span> undefined</a></code></pre></div>
<p>テストは以下のように実行します。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1">$ <span class="ex">stack</span> repl --package QuickCheck -- Quiz3.hs</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ex">*Quiz3</span><span class="op">&gt;</span> quickCheck propIsDigit</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ex">+++</span> OK, passed 100 tests.</a></code></pre></div>
<p>上記のように <code>OK</code> になれば (たぶん) 正解です！</p>
<p>ヒント: 生成される値をデバッグしたい場合は <code>sample'</code> 関数が便利です。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ex">*Quiz3</span><span class="op">&gt;</span> sample<span class="st">&#39; (arbitrary :: Gen Digit)</span></a></code></pre></div>
<p>答えは<a href="03-28-quiz-4.html">次回</a>。</p>
<!--more-->
<h2 id="はじめに">はじめに</h2>
<p><a href="./03-25-quiz-2.html">前回</a>の問題と答えは以下の通りです。</p>
<h3 id="問題">問題</h3>
<p>難易度: λλ</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">foldr (<span class="fu">&amp;&amp;</span>) <span class="dt">True</span> <span class="fu">$</span> cycle [<span class="dt">True</span>, <span class="dt">False</span>]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">foldl (<span class="fu">&amp;&amp;</span>) <span class="dt">True</span> <span class="fu">$</span> cycle [<span class="dt">True</span>, <span class="dt">False</span>]</a></code></pre></div>
<p>上記の2つの式の挙動の違いを説明してください。</p>
<p>また、なぜそうなるのか考えてみましょう！</p>
<h3 id="こたえ">こたえ</h3>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> foldr (<span class="fu">&amp;&amp;</span>) <span class="dt">True</span> <span class="fu">$</span> cycle [<span class="dt">True</span>, <span class="dt">False</span>]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="dt">False</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="fu">&gt;&gt;&gt;</span> foldl (<span class="fu">&amp;&amp;</span>) <span class="dt">True</span> <span class="fu">$</span> cycle [<span class="dt">True</span>, <span class="dt">False</span>]</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="fu">^</span><span class="dt">CInterrupted</span><span class="fu">.</span></a></code></pre></div>
<p>ということで <code>foldr</code> は無限リストに対しても停止して値を返しますが、<code>foldl</code> は停止せず、値を返さない。</p>
<p>でした。</p>
<h2 id="haskell-quiz-no.2-の解説">Haskell Quiz No.2 の解説</h2>
<p><code>Haskell</code> は遅延評価なので <code>foldr</code> が無限リストを扱えるということは、知っておいて欲しいです。</p>
<p>また実際のアプリケーションではスペースリークの問題があるため <code>foldr</code> &lt; <code>foldl</code> &lt; <code>foldl'</code> の順で好まれるかもしません。(最適化されるから気にしなくても良いという話も聞いたことありますが、詳しくないので良くわかんないです。)</p>
<h3 id="cycle">cycle</h3>
<p><a href="https://www.stackage.org/haddock/lts-11.2/base-4.10.1.0/src/GHC-List.html#cycle">cycle</a> 関数は <code>base</code> パッケージの <a href="https://www.stackage.org/haddock/lts-11.2/base-4.10.1.0/src/GHC-List.html#cycle">GHC.List</a> で定義されています。また <a href="https://www.stackage.org/haddock/lts-11.2/base-4.10.1.0/Prelude.html#v:cycle">Prelude</a> モジュールにも含まれています。</p>
<p>以下は実際の定義です。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">cycle<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">cycle [] <span class="fu">=</span> errorEmptyList <span class="st">&quot;cycle&quot;</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">cycle xs <span class="fu">=</span> xs&#39;</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  <span class="kw">where</span> xs&#39; <span class="fu">=</span> xs <span class="fu">++</span> xs&#39;</a></code></pre></div>
<p>この定義を見ればわかるように <code>cycle</code> 関数は空リストを与えると実行時エラーになります。</p>
<p>それ以外の場合では与えられたリストを繰り返して無限リストを作ります。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="op">&gt;&gt;&gt;</span> <span class="ex">cycle</span> <span class="st">&quot;Haskell&quot;</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="st">&quot;HaskellHaskellHaskell...</span></a></code></pre></div>
<h3 id="prelude-モジュールについて">Prelude モジュールについて</h3>
<p><code>Prelude</code> モジュールは良く使う基本的な関数や型の集まりです。とても良く使うので自動的に <code>import</code> されています。</p>
<p><code>Prelude</code> で定義されている関数の <code>型</code>・<code>定義</code>・<code>動作</code> は全部わかるようにしておきましょう。</p>
<p>これは本当に基礎知識です。(Haskell が苦手だなーと思う人はまずは <code>Prelude</code> で定義されている関数に慣れてください。それだけでも十分楽しめます。)</p>
<p>また、暗記して覚えることは非常に無駄なのでやめましょう。</p>
<p>何年か <code>Haskell</code> を使っていれば自然に覚えますし、感覚的には覚えている関数を書き下すのではなく、<code>関数名</code> と <code>型</code> または <code>関数の動作</code> から実装を導いている感じです。</p>
<h3 id="foldable">Foldable</h3>
<p><a href="https://www.stackage.org/haddock/lts-11.2/base-4.10.1.0/src/Data-Foldable.html#line-117">Foldable</a> 型クラスは <code>base</code> パッケージの <a href="https://www.stackage.org/haddock/lts-11.2/base-4.10.1.0/Data-Foldable.html">Data.Foldable</a> で定義されています。また <a href="https://www.stackage.org/haddock/lts-11.2/base-4.10.1.0/Prelude.html#t:Foldable">Prelude</a> モジュールにも含まれています。</p>
<p>昔の <code>foldr</code> はリストに対してのみ適用可能な関数でしたが、比較的最近 <code>Foldable</code> クラスのメソッドになりました。そのため、リスト以外でも利用できます。</p>
<p><code>Foldable</code> のクラス定義とリストのインスタンス定義はこんな感じです。(実際にはもっと多くのメソッドがあります)</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Foldable</span> t <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ot">  foldr ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  foldr f z t <span class="fu">=</span> appEndo (foldMap (<span class="dt">Endo</span> <span class="fu">#.</span> f) t) z</a>
<a class="sourceLine" id="cb8-4" data-line-number="4"></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Foldable</span> [] <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  foldr <span class="fu">=</span> List.foldr</a></code></pre></div>
<p>初学者に優しくない世界になりましたね・・・。なかなか定義にたどり着きません。</p>
<p><code>import</code> 宣言のあたりを見ると <code>import qualified GHC.List as List</code> とあるので <code>List.foldr</code> は <code>GHC.List.foldr</code> だとわかります。</p>
<p><code>GHC.List</code> を <code>base</code> パッケージの<a href="https://www.stackage.org/lts-11.2/package/base-4.10.1.0">一覧</a>から探しても見つかりません。これはわざと利用者に見えないようにしているためです。</p>
<p>実際に <a href="https://www.stackage.org/haddock/lts-11.2/base-4.10.1.0/src/GHC-List.html">GHC.List</a> は存在しますが <code>{-# OPTIONS_HADDOCK hide #-}</code> プラグマによって隠されているのです。</p>
<p><code>GHC.List</code> を探してもリストの <code>foldr</code> の定義は見つかりません。どうやら <a href="https://www.stackage.org/haddock/lts-11.2/base-4.10.1.0/src/GHC-Base.html">GHC.Base</a> で定義しているようです。</p>
<h3 id="foldr">foldr</h3>
<p><a href="https://www.stackage.org/haddock/lts-11.2/base-4.10.1.0/src/GHC-Base.html#line-850">foldr</a> の実際の定義は以下の通りです。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">foldr<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">foldr k z <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">    go [] <span class="fu">=</span> z</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    go (y<span class="fu">:</span>ys) <span class="fu">=</span> y <span class="ot">`k`</span> go ys</a></code></pre></div>
<p>これではわかりずらいので少し変形してみましょう。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">foldr<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">foldr k z []     <span class="fu">=</span> z</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">foldr k z (y<span class="fu">:</span>ys) <span class="fu">=</span> y <span class="ot">`k`</span> foldr k z ys</a></code></pre></div>
<p>変数名もいつもの感じに変えちゃいましょう。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">foldr<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">foldr _  e []     <span class="fu">=</span> e</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">foldr f  e (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="ot">`f`</span> foldr f e xs <span class="co">-- f x (foldr f e xs) と同じ</span></a></code></pre></div>
<p>だいぶ見慣れた形に近づいてきました。</p>
<p><code>foldr</code> (<code>foldl</code>) はほどよく抽象化されているので、色々な理解があると思いますので、僕がいつも使っている説明をいくつかご紹介します。</p>
<p>ここからの <code>foldr</code>, <code>foldl</code> は全てリストについての話です。</p>
<h4 id="直感的な説明">直感的な説明</h4>
<p>例えば <code>foldr (+) 0 [1,2,3,4,5]</code> は以下のように考えることができます。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">[<span class="dv">1</span> , <span class="dv">2</span> , <span class="dv">3</span> , <span class="dv">4</span> , <span class="dv">5</span>]</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="co">-- リストの括弧 (`[`, `]`) を外します</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="dv">1</span> , <span class="dv">2</span> , <span class="dv">3</span> , <span class="dv">4</span> , <span class="dv">5</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="co">-- foldr(ight) なのでに 0 を追加します</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="dv">1</span> , <span class="dv">2</span> , <span class="dv">3</span> , <span class="dv">4</span> , <span class="dv">5</span> , <span class="dv">0</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="co">-- , を (+) に置き換えます</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7"><span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">4</span> <span class="fu">+</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8"><span class="co">-- foldr(ight) なので右結合で括弧をつけていきます</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9"><span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> (<span class="dv">3</span> <span class="fu">+</span> (<span class="dv">4</span> <span class="fu">+</span> (<span class="dv">5</span> <span class="fu">+</span> <span class="dv">0</span>))))</a>
<a class="sourceLine" id="cb12-10" data-line-number="10"></a>
<a class="sourceLine" id="cb12-11" data-line-number="11"><span class="co">-- 一般化すると</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">x1 <span class="ot">`f`</span> (x2 <span class="ot">`f`</span> (x3 <span class="ot">`f`</span> (x4 <span class="ot">`f`</span> (x5 <span class="ot">`f`</span> e))))</a></code></pre></div>
<p>簡単ですね！この考え方をすれば <code>foldr</code> の型を暗記する必要はありません。</p>
<p><code>foldr f e xs</code> の型はこのように考えれば良いのです。</p>
<ul>
<li><code>f :: a -&gt; b -&gt; ?</code>。この時 <code>?</code> が <code>a</code> か <code>b</code> か迷いそうですが、上の図で考えれば <code>x5 `f` e</code> の結果は <code>x4 `f`</code> の第二引数に再び適用されます。そのため <code>f :: a -&gt; b -&gt; b</code> でなければ型が合いません。</li>
<li><code>f</code> の型がわかれば <code>e</code> の型は自然に <code>b</code> しか有りえません。</li>
<li>当然 <code>xs</code> は <code>x1, x2, x3, ・・・</code> とリストの形式なので <code>[a]</code> しかありえません。</li>
<li><code>foldr</code> の結果の型は最終的に <code>x1 `f` ...</code> となるので <code>f :: a -&gt; b -&gt; b</code> から <code>b</code> です。</li>
</ul>
<p>以上により <code>foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</code> が導かれました。</p>
<h4 id="universal-property-を使った説明">universal property を使った説明</h4>
<p>普遍性 (<code>universal property</code>) の詳しいことは有識者の方に任せるとして</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">myFunc []     <span class="fu">=</span> e</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">myFunc (x<span class="fu">:</span>xs) <span class="fu">=</span> f x (myFunc xs)</a></code></pre></div>
<p>上記のような再帰パターンの関数は全て <code>foldr f e</code> として書けるという性質です。この説明はどちらかと言うと、ベタに再帰で書いた関数を <code>foldr</code> を使った形式に書き直す際の理解の手助けとして有用かと思います。</p>
<p>具体例を見ればすぐにわかります。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">sum [] <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">sum (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">+</span> sum xs</a></code></pre></div>
<p><code>sum</code> 関数は <code>foldr (+) 0</code> と同じです。(この時の <code>e</code> は <code>0</code>, <code>f</code> は <code>(+)</code> に対応します)</p>
<p>では先程の <code>cycle</code> は普遍性を使って <code>foldr</code> で書けるの？という疑問になりますよね。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">cycle [] <span class="fu">=</span> errorEmptyList <span class="st">&quot;cycle&quot;</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">cycle xs <span class="fu">=</span> xs&#39;</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  <span class="kw">where</span> xs&#39; <span class="fu">=</span> xs <span class="fu">++</span> xs&#39;</a></code></pre></div>
<p>先程のパターンと微妙に違うので合わせてみましょう。</p>
<p>また <code>xs' = cycle xs</code> なので以下のように変形できます。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">cycle [] <span class="fu">=</span> errorEmptyList <span class="st">&quot;cycle&quot;</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">cycle xs <span class="fu">=</span> xs <span class="fu">++</span> cycle xs</a></code></pre></div>
<p>さらに変形します。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">cycle []     <span class="fu">=</span> errorEmptyList <span class="st">&quot;cycle&quot;</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">cycle (x<span class="fu">:</span>xs) <span class="fu">=</span> (x<span class="fu">:</span>xs) <span class="fu">++</span> cycle (x<span class="fu">:</span>xs)</a></code></pre></div>
<p>ここで、最初のパターンと比較しやすいように <code>cycle</code> を <code>myFunc</code> という名前に変更します。</p>
<p>ついでに <code>++</code> の位置も変更しておきます。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="co">-- cycle</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">myFunc []     <span class="fu">=</span> errorEmptyList <span class="st">&quot;cycle&quot;</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">myFunc (x<span class="fu">:</span>xs) <span class="fu">=</span> (<span class="fu">++</span>) (x<span class="fu">:</span>xs) (myFunc (x<span class="fu">:</span>xs))</a>
<a class="sourceLine" id="cb18-4" data-line-number="4"></a>
<a class="sourceLine" id="cb18-5" data-line-number="5"><span class="co">-- foldr として書き直すことが出来る再帰パターン</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6">myFunc []     <span class="fu">=</span> e</a>
<a class="sourceLine" id="cb18-7" data-line-number="7">myFunc (x<span class="fu">:</span>xs) <span class="fu">=</span> f x (myFunc xs)</a></code></pre></div>
<p>どうですか、微妙に違いますよね。</p>
<p><code>x</code> と <code>xs</code> に分解しなければいけないのにどちらも <code>(x:xs)</code> になってしまっています。</p>
<p>ということで <code>foldr</code> を使った <code>cycle</code> の定義を普遍性を使って導出することはできません。</p>
<h3 id="cycle-関数を-foldr-を使って定義する">cycle 関数を foldr を使って定義する</h3>
<p>普遍性を使った方法では <code>cycle</code> を導出することができませんでした。</p>
<p>けど、本当に <code>foldr</code> を使って定義することはできないのでしょうか？ (参考: <a href="https://mail.haskell.org/pipermail/beginners/2009-March/001184.html">[Haskell-beginners] folds again – myCycle</a>)</p>
<p>僕はいつもこのような感じで <code>foldr</code> の定義を考えます。<code>acc</code> は蓄積変数 (<code>accumulate variable</code>) の略です。</p>
<p><code>go</code> の第二引数は常に <code>foldr</code> で畳み込んだ結果として考えることができます。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">cycle<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">cycle xs <span class="fu">=</span> foldr go e undefined</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    e        <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">    go x acc <span class="fu">=</span> undefined</a></code></pre></div>
<p>少し考えると <code>xs</code> を <code>xs ++ xs ++ xs ...</code> という形式にできれば良さそうです。</p>
<p>無限リストになるため初期値 <code>e</code> は絶対に評価されません。そのため <code>[]</code> でも <code>xs</code> でも <code>undefined</code> でも好きな値が使えそうです。ここでは何となく <code>xs</code> にしておきます。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1">cycle<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">cycle xs <span class="fu">=</span> foldr go e undefined</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4">    e        <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    go x acc <span class="fu">=</span> undefined</a></code></pre></div>
<p>次に <code>go</code> 関数ですが <code>xs ++ (xs ++ (xs ++ (...)))</code> となれば良いので、 <code>go x acc = xs ++ acc</code> です。</p>
<p><code>go</code> が <code>cycle</code> の引数 <code>xs</code> を参照している点が通常の使い方と異なる点です。</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1">cycle<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">cycle xs <span class="fu">=</span> foldr go e undefined</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">    e        <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">    go _ acc <span class="fu">=</span> xs <span class="fu">++</span> acc</a></code></pre></div>
<p>ここが一番のポイントですが <code>foldr</code> に与えるリストは <code>xs</code> ではありません。</p>
<p>無限リストを生成するために適当な無限リストを与えます。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1">cycle<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">cycle xs <span class="fu">=</span> foldr go e [<span class="dv">0</span><span class="fu">..</span>]</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4">    e        <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">    go _ acc <span class="fu">=</span> xs <span class="fu">++</span> acc</a></code></pre></div>
<p>つまりこのような感じです。</p>
<pre class="text"><code>0 `go` (1 `go` (2 `go` (3 `go` ...)))
xs ++ (1 `go` (2 `go` (3 `go` ...)))
xs ++ (xs ++ (2 `go` (3 `go` ...)))
xs ++ (xs ++ (xs ++ (3 `go` ...)))
xs ++ (xs ++ (xs ++ (xs ++ ...)))</code></pre>
<p>これは完全に <code>cycle</code> ですね！</p>
<p>こんな感じで頑張れば <code>foldr</code> を使って <code>cycle</code> を定義することができます。</p>
<p>ただ、本質的には <code>unfoldr</code> を使うべき問題だと思います！(そのうちクイズにします)</p>
<h3 id="遅延評価を追ってみよう">遅延評価を追ってみよう！</h3>
<p>やっと問題の本題です・・・。</p>
<p><code>foldr</code>, <code>cycle</code>, <a href="https://www.stackage.org/haddock/lts-11.2/ghc-prim-0.5.1.1/src/GHC-Classes.html#%26%26">(&amp;&amp;)</a> の定義は以下を使います。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1">foldr<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">foldr _  e []     <span class="fu">=</span> e</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">foldr f  e (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="ot">`f`</span> foldr f e xs</a>
<a class="sourceLine" id="cb24-4" data-line-number="4"></a>
<a class="sourceLine" id="cb24-5" data-line-number="5">cycle<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb24-6" data-line-number="6">cycle xs <span class="fu">=</span> xs <span class="fu">++</span> cycle xs</a>
<a class="sourceLine" id="cb24-7" data-line-number="7"></a>
<a class="sourceLine" id="cb24-8" data-line-number="8"><span class="ot">(&amp;&amp;) ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9"><span class="dt">True</span>  <span class="fu">&amp;&amp;</span> x  <span class="fu">=</span>  x</a>
<a class="sourceLine" id="cb24-10" data-line-number="10"><span class="dt">False</span> <span class="fu">&amp;&amp;</span> _ <span class="fu">=</span>  <span class="dt">False</span></a></code></pre></div>
<p>それでは実際に遅延評価で簡約していきましょう。</p>
<pre class="text"><code>foldr (&amp;&amp;) True (cycle [True, False])
  = { cycle を適用 }
foldr (&amp;&amp;) True ([True, False] ++ cycle [True, False])
  = { foldr を適用 }
True &amp;&amp; foldr (&amp;&amp;) True ([False] ++ cycle [True, False])
  = { (&amp;&amp;) を適用 }
foldr (&amp;&amp;) True ([False] ++ cycle [True, False])
  = { fodlr を適用 }
False &amp;&amp; foldr (&amp;&amp;) True (cycle [True, False])
  = { (&amp;&amp;) を適用 }
False</code></pre>
<p>つまり、<code>(&amp;&amp;)</code> の定義に秘密があったのです。</p>
<p><code>(&amp;&amp;)</code> 第一引数が <code>False</code> であれば第二引数を評価することなく <code>False</code> を返します。そのため <code>False &amp;&amp; _ =  False</code> のような定義になっています。(このような関数を非正格関数 (<code>non-strict function</code>) と言います。定義は <code>f undefined = undefined</code> であれば正格関数 (<code>strict function</code>) です。<code>(&amp;&amp;)</code> は第一引数に関しては正格ですが、第二引数に関しては非正格です)</p>
<p>これが <code>foldr</code> の場合に計算が停止する理由です。</p>
<p>ではなぜ <code>foldl</code> の場合は停止しないのでしょうか？</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1">foldl<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">foldl _ acc []     <span class="fu">=</span> acc</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">foldl f acc (x<span class="fu">:</span>xs) <span class="fu">=</span> foldl f (acc <span class="ot">`f`</span> x) xs</a></code></pre></div>
<p><code>foldl</code> の場合も同様に簡約してみましょう。</p>
<pre class="text"><code>foldl (&amp;&amp;) True (cycle [True, False])
  = { cycle を適用 }
foldl (&amp;&amp;) True ([True, False] ++ cycle [True, False])
  = { foldl を適用 }
foldl (&amp;&amp;) (True &amp;&amp; True) ([False] ++ cycle [True, False])
  = { foldl を適用 }
foldl (&amp;&amp;) ((True &amp;&amp; True) &amp;&amp; False) (cycle [True, False])
  = ...</code></pre>
<p>ということで <code>foldl</code> はリストの最後にたどり着くまで値を返せないのです。</p>
<p>そのため、無限リストを処理しようとすると停止しなくなります。</p>
<h2 id="まとめ">まとめ</h2>
<p>いつも解説が長くなってしまいます・・・。</p>
<p><code>fold</code> の融合則とかめちゃめちゃ好きなのでいつかまとめたいですね。</p>
<p>また、<code>fold</code> が好きな人には <a href="https://www.stackage.org/package/foldl">foldl</a> パッケージがオススメです。</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Haskell IDE Engine を Emacs で使う</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-26-hie-emacs.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-26-hie-emacs.html</id>
    <published>2018-03-26T00:00:00Z</published>
    <updated>2018-03-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p><a href="https://github.com/haskell/haskell-ide-engine">HIE (Haskell IDE Engine)</a> を <code>Emacs</code> に導入する方法が <code>HIE</code> の <a href="https://github.com/haskell/haskell-ide-engine/pull/502/files">README.md</a> に追記されたので、それに従いインストールしてみました。</p>
<p>本記事では、導入手順を紹介します。</p>
<!--more-->
<h2 id="導入手順">導入手順</h2>
<h3 id="hie-をインストールする">1. HIE をインストールする。</h3>
<pre class="bssh"><code>$ git clone https://github.com/haskell/haskell-ide-engine.git
$ cd haskell-ide-engine
$ make

...

* Missing C libraries: icuuc, icui18n, icudata</code></pre>
<p><code>make</code> 実行時、以下のようにライブラリが足りなかったので、必要なパッケージをインストールして、もう一度 <code>make</code> しました。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1">$ <span class="fu">sudo</span> apt install libicu-dev</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">$ <span class="fu">make</span></a></code></pre></div>
<p>普通に <code>stack install</code> で導入することもできますが、 <code>HIE</code> はビルド時の <code>GHC</code> バージョンでしか使えないという弱点があるため、<code>GHC</code> の バージョンが異なるプロジェクトでは利用できません。</p>
<p>そのため <code>make</code> を使って <code>hie-8.2.1</code> のように <code>GHC</code> のそれぞれのバージョンでビルドした <code>HIE</code> のバイナリを用意して解決しています。</p>
<h3 id="必要なパッケージを入手する">2. 必要なパッケージを入手する。</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1">$ <span class="fu">git</span> clone git@github.com:emacs-lsp/lsp-mode.git</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">$ <span class="fu">git</span> clone git@github.com:emacs-lsp/lsp-ui.git</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">$ <span class="fu">git</span> clone git@github.com:emacs-lsp/lsp-haskell.git</a></code></pre></div>
<h3 id="emacs-の設定ファイル-init.el-など-に以下を追加する">3. emacs の設定ファイル (init.el など) に以下を追加する。</h3>
<pre class="elisp"><code>(add-to-list &#39;load-path &quot;/path/to/lsp-mode&quot;)
(add-to-list &#39;load-path &quot;/path/to/lsp-ui&quot;)
(add-to-list &#39;load-path &quot;/path/to/lsp-haskell&quot;)

(require &#39;lsp-mode)
(require &#39;lsp-ui)
(require &#39;lsp-haskell)

(add-hook &#39;lsp-mode-hook &#39;lsp-ui-mode)
(add-hook &#39;haskell-mode-hook #&#39;lsp-haskell-enable)
(add-hook &#39;haskell-mode-hook &#39;flycheck-mode)</code></pre>
<p>上記内容を記述した後で Emacs を起動したときに、依存するパッケージのインストールを要求される場合があるので、<code>Cask</code> や <code>package-install</code> などでインストールしましょう。</p>
<p>インストールが成功すると、<code>Haskell</code> のファイルを読み込んだときに、カーソルを当てたところにある関数の型の表示、エラーの表示、補完、コマンド <code>M-.</code> で定義のところにジャンプなどができるようになります。</p>
<h2 id="おわりに">おわりに</h2>
<p><code>HIE</code> は <code>ghc-mod</code> の実行ファイルを使っているかのように見えますが、実際はライブラリを通しているだけでバイナリは使っていないそうです。</p>]]></summary>
</entry>
<entry>
    <title>Haskell Quiz No.2 foldl と foldr</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-25-quiz-2.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-25-quiz-2.html</id>
    <published>2018-03-25T00:00:00Z</published>
    <updated>2018-03-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="haskell-quiz-no.2">Haskell Quiz No.2</h2>
<p>難易度: λλ</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">foldr (<span class="fu">&amp;&amp;</span>) <span class="dt">True</span> <span class="fu">$</span> cycle [<span class="dt">True</span>, <span class="dt">False</span>]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">foldl (<span class="fu">&amp;&amp;</span>) <span class="dt">True</span> <span class="fu">$</span> cycle [<span class="dt">True</span>, <span class="dt">False</span>]</a></code></pre></div>
<p>上記の2つの式の挙動の違いを説明してください。</p>
<p>また、なぜそうなるのか考えてみましょう！</p>
<p>答えは<a href="03-27-quiz-3.html">次回</a>。</p>
<!--more-->
<h2 id="はじめに">はじめに</h2>
<p><a href="./03-24-quiz-1.html">前回</a>の問題と答えは以下の通りです。</p>
<h3 id="問題">問題</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Foo</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Foo1</span> <span class="fu">=</span> <span class="dt">Foo1</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">data</span> <span class="dt">Foo2</span> <span class="fu">=</span> <span class="dt">Foo2</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="kw">newtype</span> <span class="dt">Foo3</span> <span class="fu">=</span> <span class="dt">Foo3</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">x1 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo1</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">     <span class="dt">Foo1</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">x2 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo2</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">     <span class="dt">Foo2</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12"></a>
<a class="sourceLine" id="cb2-13" data-line-number="13">x3 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo3</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-14" data-line-number="14">     <span class="dt">Foo3</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15"></a>
<a class="sourceLine" id="cb2-16" data-line-number="16">y1 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-17" data-line-number="17">     <span class="dt">Foo1</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-18" data-line-number="18"></a>
<a class="sourceLine" id="cb2-19" data-line-number="19">y2 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-20" data-line-number="20">     <span class="dt">Foo2</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-21" data-line-number="21"></a>
<a class="sourceLine" id="cb2-22" data-line-number="22">y3 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-23" data-line-number="23">     <span class="dt">Foo3</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-24" data-line-number="24"></a>
<a class="sourceLine" id="cb2-25" data-line-number="25"><span class="ot">int ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-26" data-line-number="26">int <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb2-27" data-line-number="27"></a>
<a class="sourceLine" id="cb2-28" data-line-number="28">yInt <span class="fu">=</span> <span class="kw">case</span> int <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-29" data-line-number="29">       _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>以下の値はそれぞれ何になるでしょう？</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">x1   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">x2   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">x3   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">y1   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">y2   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">y3   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">yInt <span class="fu">=</span> <span class="fu">???</span></a></code></pre></div>
<h3 id="答え">答え</h3>
<p><code>GHC</code> のバージョン <code>8.0.2</code>, <code>8.2.2</code>, <code>8.4.1</code> で確認しました。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">x1   <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">x2   <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">x3   <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">y1   <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">y2   <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">y3   <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">yInt <span class="fu">=</span> <span class="dv">1</span></a></code></pre></div>
<p>どうですか？自信を持って全部回答できた人は少ないのではないでしょうか。</p>
<p>ちなみに、この知識を披露するタイミングは・・・ほぼ無いでしょうね・・・。</p>
<p>よくある <code>Haskell</code> 雑学のうちの1つです。こういう内容はチームメンバーの誰かが理解していれば良いので、最初のうちはわからなくても大丈夫です。わかる人に解説してもらいましょう。</p>
<h3 id="どうでも良い話">どうでも良い話</h3>
<p>Haskell Quiz は <code>Haskell</code> と言いつつ <code>GHC</code> の話だったりする場合もありますが、実用上それが問題になることは無いので気にしないことにします。</p>
<p><code>Haskell</code> は言語仕様で <code>GHC</code> が処理系だというのは、ただの雑学です。このことを知ってると、割とHaskellに詳しそうだな思ってもらえますよ！(ついでに <code>G</code> が <code>Glasgow</code> の略でイギリスにある大学なんだよってことも伝えてあげると、バイトの学生とかは <code>へー</code> って顔をしてくれるのでオススメです！)</p>
<h2 id="haskell-quiz-no.1-の解説">Haskell Quiz No.1 の解説</h2>
<h3 id="x1">x1</h3>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Foo1</span> <span class="fu">=</span> <span class="dt">Foo1</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">x1 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo1</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  <span class="dt">Foo1</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p><code>Foo1</code> はよくあるデータ定義です。</p>
<p>気にしておくべき点は以下の2つです。</p>
<ul>
<li><code>Foo1 Int</code> の <code>Int</code> はまだ評価されていない<strong>サンク</strong>という状態です。</li>
<li><code>undefined</code> は実際に評価された時にエラーとなります。(逆に、最後まで評価されなければエラーにならない)</li>
</ul>
<p><code>Foo1</code> 型の値で、例えば <code>Foo1 (1+1)</code> の <code>1+1</code> はまだ必要になっていないので、評価されていないサンクです。(つまり <code>Foo1 2</code> ではありません)</p>
<p>本当かなぁ？と思う人は実際に以下のコードを実行すれば、何となくわかってもらえると思います。(<code>sum [1..100000000000000]</code> は評価された時にとても時間がかかる処理です)</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ex">ghci</span><span class="op">&gt;</span> Foo1 (sum [1..100000000000000])</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ex">Foo1</span> ^CInterrupted.</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="ex">ghci</span><span class="op">&gt;</span> case Foo1 (sum [1..100000000000000]) <span class="ex">of</span> Foo1 i -<span class="op">&gt;</span> i</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">^<span class="ex">CInterrupted.</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="ex">ghci</span><span class="op">&gt;</span> case Foo1 (sum [1..100000000000000]) <span class="ex">of</span> Foo1 _ -<span class="op">&gt;</span> 0</a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="ex">0</span></a></code></pre></div>
<p>ということで以下のコードは <code>case</code> で <code>Foo1</code> とのパターンマッチは行われますが、 <code>undefined</code> は評価されない (する必要がない) ため <code>1</code> が返ってくることになります。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Foo1</span> <span class="fu">=</span> <span class="dt">Foo1</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">x1 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo1</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">     <span class="dt">Foo1</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">x1 <span class="fu">=</span> <span class="dv">1</span></a></code></pre></div>
<p><code>Haskell</code> のアプリケーションがスペースリークしてしまう原因は、主にこのデータ構造のサンクが原因になっている場合が多いようです。</p>
<h3 id="x2">x2</h3>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Foo2</span> <span class="fu">=</span> <span class="dt">Foo2</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">x2 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo2</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">     <span class="dt">Foo2</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>このコードには見慣れない <code>!</code> という記号が出てきました。</p>
<p>ここで抑えておくポイントは1つだけです。</p>
<ul>
<li><code>!</code> はサンクを潰してくれる (評価する) マークです。つまり、値が使われない場合でも評価されるということです。(計算が無駄になる場合も当然ある)</li>
</ul>
<p>以下の結果から、<code>Foo2</code> の値を作る時には、必ず先に <code>sum [1..100000000000000]</code> が計算されていることがわかります。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ex">ghci</span><span class="op">&gt;</span> Foo2 (sum [1..100000000000000])</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">^<span class="ex">CInterrupted.</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="ex">ghci</span><span class="op">&gt;</span> case Foo2 (sum [1..100000000000000]) <span class="ex">of</span> Foo2 i -<span class="op">&gt;</span> i</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">^<span class="ex">CInterrupted.</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="ex">ghci</span><span class="op">&gt;</span> case Foo2 (sum [1..100000000000000]) <span class="ex">of</span> Foo2 _ -<span class="op">&gt;</span> 0</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">^<span class="ex">CInterrupted.</span></a></code></pre></div>
<p>そのため、今回の結果は <code>undefined</code> になります。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Foo2</span> <span class="fu">=</span> <span class="dt">Foo2</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">x2 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo2</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">     <span class="dt">Foo2</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">x2 <span class="fu">=</span> undefined</a></code></pre></div>
<p>専門家は <code>undefined</code> のことを <code>bottom</code> (<code>⊥</code>) というテクニカルタームで呼ぶこともありますが、普通の人は <code>停止しない計算</code> や <code>エラー</code> という意味だと思えば十分です。(たぶん)</p>
<h3 id="x3">x3</h3>
<div class="sourceCode" id="cb13"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Foo3</span> <span class="fu">=</span> <span class="dt">Foo3</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">x3 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo3</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">     <span class="dt">Foo3</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>ここで抑えておくポイントは2つです。</p>
<ul>
<li><code>newtype</code> のデータコンストラクタは型チェックが終わったら剥がされる</li>
<li>そのため <code>newtype</code> は実行時に余分なコストが発生しない</li>
</ul>
<p>つまり、雰囲気はこんな感じです。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Nat</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2"></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="co">-- 型チェック前</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">x <span class="fu">=</span> <span class="dt">Nat</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5"></a>
<a class="sourceLine" id="cb14-6" data-line-number="6"><span class="co">-- 型チェック後</span></a>
<a class="sourceLine" id="cb14-7" data-line-number="7">x <span class="fu">=</span> <span class="dv">1</span></a></code></pre></div>
<p>Haskell の学習でわけわかんないポイントの1つに <code>type</code>, <code>newtype</code>, <code>data</code> の違いがあると思います。(少なくとも僕は最初全然わかりませんでした)</p>
<p>僕と同じように学習で困っている人は、以下の表で考えれば理解の手助けになるかもしれません。</p>
<div class="row">
<table class="col s8 offset-s2 centered">
<thead>
<tr>
<th>
</th>
<th>
型 (type)
</th>
<th>
値 (value)
</th>
<th>
具体例
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
type
</td>
<td>
X
</td>
<td>
X
</td>
<td>
<code>type FilePath = String</code>
</td>
</tr>
<tr>
<td>
newtype
</td>
<td>
O
</td>
<td>
X
</td>
<td>
<code>newtype Nat = Nat Int</code>
</td>
</tr>
<tr>
<td>
data
</td>
<td>
O
</td>
<td>
O
</td>
<td>
<code>data Bool = True | False</code>
</td>
</tr>
</tbody>
</table>
</div>
<p><code>X</code> は既存の型や値を再利用する、<code>O</code> は型や値を新しく作るという意味です。</p>
<ul>
<li><code>type</code> は型も値も既存のものを再利用します。</li>
<li><code>newtype</code> は型は新しく作りますが、値は既存のものを再利用します。</li>
<li><code>data</code> は型も値も新しく作ります。</li>
</ul>
<p>ということで、このように変形できます。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Foo3</span> <span class="fu">=</span> <span class="dt">Foo3</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="co">-- 定義</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">x3 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo3</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">     <span class="dt">Foo3</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6"></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="co">-- newtype なので</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">x3 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb15-9" data-line-number="9"></a>
<a class="sourceLine" id="cb15-10" data-line-number="10"><span class="co">-- 1 を返すために undefined を評価する必要が無いため</span></a>
<a class="sourceLine" id="cb15-11" data-line-number="11">x3 <span class="fu">=</span> <span class="dv">1</span></a></code></pre></div>
<h3 id="y1">y1</h3>
<div class="sourceCode" id="cb16"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Foo1</span> <span class="fu">=</span> <span class="dt">Foo1</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">y1 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">     <span class="dt">Foo1</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>この場合は <code>case</code> 式で <code>Foo1 _</code> のパターンマッチを行う際に <code>undefined</code> の評価をしなければならないため <code>y1</code> は <code>undefined</code> になります。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">y1 <span class="fu">=</span> undefined</a></code></pre></div>
<h3 id="y2">y2</h3>
<div class="sourceCode" id="cb18"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Foo2</span> <span class="fu">=</span> <span class="dt">Foo2</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2"></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">y2 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">     <span class="dt">Foo2</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>この場合も <code>y1</code> と同じケースです。やはり <code>Foo1</code> のパターンマッチが発生するため <code>undefined</code> です。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">y2 <span class="fu">=</span> undefined</a></code></pre></div>
<h3 id="y3">y3</h3>
<div class="sourceCode" id="cb20"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Foo3</span> <span class="fu">=</span> <span class="dt">Foo3</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">y3 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4">     <span class="dt">Foo3</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>この結果が一番おもしろい気がしますが、これは <code>1</code> を返します。</p>
<p>今までの話から <code>Foo3</code> は実行時には存在しないコンストラクタです。すなわち実行時にはこのような形式になります。</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1">y3 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">     _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>これは <code>x3</code> の場合と同じですね。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1">y3 <span class="fu">=</span> <span class="dv">1</span></a></code></pre></div>
<h3 id="yint">yInt</h3>
<div class="sourceCode" id="cb23"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">int ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">int <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb23-3" data-line-number="3"></a>
<a class="sourceLine" id="cb23-4" data-line-number="4">yInt <span class="fu">=</span> <span class="kw">case</span> int <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">       _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>ここまで来たらこれはもう簡単ですよね！</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1">yInt <span class="fu">=</span> <span class="dv">1</span></a></code></pre></div>
<h2 id="まとめ">まとめ</h2>
<p>解説がとても長くなってしまいました・・・。間違ってたらご報告ください。</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Haskell Quiz はじめました。 No.1 type, newtype, data</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-24-quiz-1.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-24-quiz-1.html</id>
    <published>2018-03-24T00:00:00Z</published>
    <updated>2018-03-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>何となくクイズはじめました！(頑張って続けます・・・)</p>
<p>間違ってたら <code>twitter</code> や <a href="https://github.com/e-bigmoon/haskell-blog/issues">github の issue</a> で教えてください！</p>
<!--more-->
<h2 id="haskell-quiz-no.1-type-newtype-data">Haskell Quiz No.1 type, newtype, data</h2>
<p>難易度: λλλ</p>
<p>元ネタは <code>Haskell wiki</code> だったと思いますが、忘れてしまいました・・・。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Foo</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Foo1</span> <span class="fu">=</span> <span class="dt">Foo1</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">data</span> <span class="dt">Foo2</span> <span class="fu">=</span> <span class="dt">Foo2</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">newtype</span> <span class="dt">Foo3</span> <span class="fu">=</span> <span class="dt">Foo3</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">x1 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo1</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">     <span class="dt">Foo1</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">x2 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo2</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">     <span class="dt">Foo2</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">x3 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo3</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">     <span class="dt">Foo3</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15"></a>
<a class="sourceLine" id="cb1-16" data-line-number="16">y1 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17">     <span class="dt">Foo1</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18"></a>
<a class="sourceLine" id="cb1-19" data-line-number="19">y2 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-20" data-line-number="20">     <span class="dt">Foo2</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-21" data-line-number="21"></a>
<a class="sourceLine" id="cb1-22" data-line-number="22">y3 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23">     <span class="dt">Foo3</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-24" data-line-number="24"></a>
<a class="sourceLine" id="cb1-25" data-line-number="25"><span class="ot">int ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-26" data-line-number="26">int <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb1-27" data-line-number="27"></a>
<a class="sourceLine" id="cb1-28" data-line-number="28">yInt <span class="fu">=</span> <span class="kw">case</span> int <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-29" data-line-number="29">       _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>以下の値はそれぞれ何になるでしょう？</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">x1   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">x2   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">x3   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">y1   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">y2   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">y3   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">yInt <span class="fu">=</span> <span class="fu">???</span></a></code></pre></div>
<p>全部正解できたら普通にすごいです。</p>
<p>答えは<a href="./03-25-quiz-2.html">次回</a>！</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>アプリケーションのバージョンに Git の情報を出してみよう！</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-20-gitrev.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-20-gitrev.html</id>
    <published>2018-03-20T00:00:00Z</published>
    <updated>2018-03-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>今回は <a href="https://www.stackage.org/package/gitrev">gitrev</a> パッケージと <a href="https://www.stackage.org/package/optparse-simple">optparse-simple</a> パッケージを使ってアプリケーションに <code>Git</code> の情報を含めてみようと思います！</p>
<p>利用者の多いアプリケーションだと、バグ報告時にどのコミットでビルドしたものなのか知りたい場合に便利です。</p>
<p>表示されるバージョン情報はこんな感じになります。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot"># gitrev の例</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="fu">$</span> <span class="fu">./</span>Main.hs</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">Main.hs<span class="fu">:</span> [panic master<span class="fu">@</span>3a0bd17fdfb8a3e334292a560280e8e0791e941c (<span class="dt">Tue</span> <span class="dt">Mar</span> <span class="dv">20</span> <span class="dv">02</span><span class="fu">:</span><span class="dv">00</span><span class="fu">:</span><span class="dv">17</span> <span class="dv">2018</span> <span class="fu">+</span><span class="dv">0900</span>) (<span class="dv">1</span> commits <span class="kw">in</span> <span class="dt">HEAD</span>)]</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot"># optparse-simple の例</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="fu">$</span> stack exec <span class="co">-- example-version-exe</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="dt">Version</span> <span class="fl">0.1</span><span class="fu">.</span><span class="fl">0.0</span>, <span class="dt">Git</span> revision <span class="fl">341e785</span>b02c4c599f64b922b4aa9cfff3c006945</a></code></pre></div>
<p>以下のアプリケーション等でも利用されているように、実用度はとても高めです。</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack">stack</a></li>
<li><a href="https://github.com/haskell/haskell-ide-engine">hie</a></li>
<li><a href="https://github.com/ucsd-progsys/liquidhaskell">liquidhaskell</a></li>
</ul>
<p>また、実装コストもそれほどかからないため、オススメです！</p>
<!--more-->
<h2 id="gitrev-パッケージ">gitrev パッケージ</h2>
<p><a href="https://www.stackage.org/haddock/lts-11.1/gitrev-1.3.1/Development-GitRev.html">gitrev</a> パッケージは <code>Template Haskell</code> の機能を使ってコンパイル時に以下の情報を取得可能です。</p>
<ul>
<li>ブランチ名および、タグ名</li>
<li>コミット数</li>
<li>コミット日</li>
<li>コミットの describe</li>
<li>コミットのハッシュ</li>
</ul>
<p>そのため、表示する情報を自分の好きなようにカスタマイズしたい場合に便利でしょう。</p>
<h3 id="サンプルアプリケーション">サンプルアプリケーション</h3>
<p>以下のコードは <code>Hackage</code> に載っているコードです。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">-- stack --resolver lts-11.1 script</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Development.GitRev</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="ot">panic ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">panic msg <span class="fu">=</span> error panicMsg</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  <span class="kw">where</span> panicMsg <span class="fu">=</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">          concat [ <span class="st">&quot;[panic &quot;</span>, <span class="fu">$</span>(gitBranch), <span class="st">&quot;@&quot;</span>, <span class="fu">$</span>(gitHash)</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">                 , <span class="st">&quot; (&quot;</span>, <span class="fu">$</span>(gitCommitDate), <span class="st">&quot;)&quot;</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">                 , <span class="st">&quot; (&quot;</span>, <span class="fu">$</span>(gitCommitCount), <span class="st">&quot; commits in HEAD)&quot;</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">                 , dirty, <span class="st">&quot;] &quot;</span>, msg ]</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">        dirty <span class="fu">|</span> <span class="fu">$</span>(gitDirty) <span class="fu">=</span> <span class="st">&quot; (uncommitted files present)&quot;</span></a>
<a class="sourceLine" id="cb2-14" data-line-number="14">              <span class="fu">|</span> otherwise   <span class="fu">=</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15"></a>
<a class="sourceLine" id="cb2-16" data-line-number="16">main <span class="fu">=</span> panic <span class="st">&quot;oh no!&quot;</span></a></code></pre></div>
<p>実際に実行してみましょう。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1">$ <span class="ex">tree</span> .</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="ex">.</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">└── <span class="ex">Main.hs</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ex">0</span> directories, 1 file</a>
<a class="sourceLine" id="cb3-6" data-line-number="6"></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">$ <span class="fu">chmod</span> u+x Main.hs</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">$ <span class="ex">./Main.hs</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9"><span class="ex">Main.hs</span>: [panic UNKNOWN@UNKNOWN (UNKNOWN) <span class="kw">(</span><span class="ex">UNKNOWN</span> commits in HEAD<span class="kw">)</span>] <span class="ex">oh</span> no!</a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="ex">CallStack</span> (from HasCallStack)<span class="bu">:</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">  <span class="ex">error</span>, called at /home/bm12/Desktop/gitrev-sample/Main.hs:7:13 in main:Main</a></code></pre></div>
<p>現状は <code>git</code> のコミットが無いため、全て <code>UNKNOWN</code> として表示されています。</p>
<p>実際に <code>git</code> リポジトリを作ってコミットしてみましょう。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1">$ <span class="fu">git</span> init</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ex">Initialized</span> empty Git repository in /home/bm12/Desktop/gitrev-sample/.git/</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">$ <span class="fu">git</span> add -A</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">$ <span class="fu">git</span> commit -m <span class="st">&quot;TEST&quot;</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">[<span class="ex">master</span> (root-commit) <span class="ex">3a0bd17</span>] TEST</a>
<a class="sourceLine" id="cb4-7" data-line-number="7"> <span class="ex">1</span> file changed, 16 insertions(+)</a>
<a class="sourceLine" id="cb4-8" data-line-number="8"> <span class="ex">create</span> mode 100755 Main.hs</a>
<a class="sourceLine" id="cb4-9" data-line-number="9"></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">$ <span class="ex">./Main.hs</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11"><span class="ex">Main.hs</span>: [panic master@3a0bd17fdfb8a3e334292a560280e8e0791e941c (Tue Mar 20 02:00:17 2018 +0900) <span class="kw">(</span><span class="ex">1</span> commits in HEAD<span class="kw">)</span>] <span class="ex">oh</span> no!</a></code></pre></div>
<p>こんな感じで <code>git</code> の情報を自由に組み合わせることができます。</p>
<h2 id="optparse-simple-パッケージ">optparse-simple パッケージ</h2>
<p>あまり書式を気にせず、定形で良い場合はもっと簡単な方法があります。</p>
<p>それは <code>optparse-simple</code> パッケージの <a href="https://www.stackage.org/haddock/lts-11.1/optparse-simple-0.1.0/Options-Applicative-Simple.html#v:simpleVersion">simpleVersion</a> を使う方法です。</p>
<p><code>simpleVersion</code> では <code>git</code> の情報だけでなく、アプリケーションのバージョンも一緒に表示することができます。</p>
<h3 id="simpleversion">simpleVersion</h3>
<p><a href="https://www.stackage.org/haddock/lts-11.1/optparse-simple-0.1.0/src/Options.Applicative.Simple.html#simpleVersion">simpleVersion</a> の定義は以下のようになっています。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">simpleVersion ::</span> <span class="dt">Version</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">simpleVersion version <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  [<span class="fu">|</span>concat ([<span class="st">&quot;Version &quot;</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">           ,<span class="fu">$</span>(TH.lift <span class="fu">$</span> showVersion version)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">           ] <span class="fu">++</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">           <span class="kw">if</span> <span class="fu">$</span>gitHash <span class="fu">==</span> (<span class="st">&quot;UNKNOWN&quot;</span><span class="ot"> ::</span> <span class="dt">String</span>)</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">             <span class="kw">then</span> []</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">             <span class="kw">else</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">               [<span class="st">&quot;, Git revision &quot;</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">               ,<span class="fu">$</span>gitHash</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">               ,<span class="kw">if</span> <span class="fu">$</span>gitDirty</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">                   <span class="kw">then</span> <span class="st">&quot; (dirty)&quot;</span></a>
<a class="sourceLine" id="cb5-13" data-line-number="13">                   <span class="kw">else</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb5-14" data-line-number="14">               ])<span class="fu">|</span>]</a></code></pre></div>
<p><code>$gitHash</code> や <code>$gitDirty</code> を見ればわかる通り、内部的に <code>gitrev</code> パッケージを利用して <code>git</code> の情報を取得しています。</p>
<p>また、第一引数の <code>Version</code> 型は <code>base</code> パッケージの <a href="https://www.stackage.org/haddock/lts-11.1/base-4.10.1.0/Data-Version.html">Data.Version</a> で定義されている型です。</p>
<p>以下のように <code>makeVersion :: [Int] -&gt; Version</code> 関数を使って <code>Version</code> 型の値を作ることができます。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">{-# LANGUAGE TemplateHaskell   #-}</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Options.Applicative.Simple</span> (simpleVersion)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="kw">import</span>           <span class="dt">Data.Version</span> (makeVersion)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">main <span class="fu">=</span> putStrLn <span class="fu">$</span>(simpleVersion <span class="fu">$</span> makeVersion [<span class="dv">100</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>])</a></code></pre></div>
<p>適当にプロジェクトを作って、上記の内容を実行してみましょう。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" data-line-number="1">$ <span class="ex">stack</span> exec example-exe </a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ex">Version</span> 100.0.0.0</a></code></pre></div>
<p>まだ <code>git</code> で管理していないため、バージョン情報のみが表示されます。</p>
<p>では、先ほどの例と同様に <code>git</code> リポジトリを作ってコミットした結果を見てみましょう。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" data-line-number="1">$ <span class="fu">git</span> init</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ex">Initialized</span> empty Git repository in /home/bm12/Desktop/gitrev-sample/.git/</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">$ <span class="fu">git</span> add -A</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">$ <span class="fu">git</span> commit -m <span class="st">&quot;TEST&quot;</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">[<span class="ex">master</span> (root-commit) <span class="ex">3a0bd17</span>] TEST</a>
<a class="sourceLine" id="cb8-7" data-line-number="7"> <span class="ex">1</span> file changed, 16 insertions(+)</a>
<a class="sourceLine" id="cb8-8" data-line-number="8"> <span class="ex">create</span> mode 100755 Main.hs</a>
<a class="sourceLine" id="cb8-9" data-line-number="9"></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">$ <span class="ex">stack</span> clean</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">$ <span class="ex">stack</span> build</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">$ <span class="ex">stack</span> exec example-exe </a>
<a class="sourceLine" id="cb8-13" data-line-number="13"><span class="ex">Version</span> 100.0.0.0, Git revision e106394f7fdded0c9908cbf8edc87c5d5d5b4309</a></code></pre></div>
<p>このようにちゃんとリビジョンが表示されるようになりました。</p>
<h3 id="アプリケーションのバージョンを自動的に更新する">アプリケーションのバージョンを自動的に更新する</h3>
<p>アプリケーションのリリースごとに <code>makeVersion</code> を使って更新する作業はとても面倒ですし、いつか間違えてしまうかもしれません。</p>
<p>これを解決するためには <code>.cabal</code> ファイルからバージョン情報を自動取得して <code>simpleVersion</code> 関数に渡してあげるようにすれば良いのです。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">{-# LANGUAGE TemplateHaskell   #-}</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Options.Applicative.Simple</span> (simpleVersion)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Paths_XXXX</span>               <span class="kw">as</span> <span class="dt">Meta</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"></a>
<a class="sourceLine" id="cb9-6" data-line-number="6"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">main <span class="fu">=</span> putStrLn <span class="fu">$</span>(simpleVersion Meta.version)</a></code></pre></div>
<p><code>Paths_XXXX</code> の <code>XXXX</code> はアプリケーション名 (<code>cabal</code> ファイルの <code>name</code> の値) を指定します。これで <code>cabal</code> ファイルのバージョン情報を直接取得できるようになります。</p>
<p>表示される結果はこんな感じです。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb10-1" data-line-number="1">$ <span class="ex">stack</span> exec -- example-version-exe</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ex">Version</span> 0.1.0.0, Git revision 341e785b02c4c599f64b922b4aa9cfff3c006945</a></code></pre></div>
<p>めちゃめちゃ簡単なのでオススメの方法です。</p>
<h2 id="まとめ">まとめ</h2>
<p>自分のアプリケーションがとてもカッコよくなるので是非ためしてみてください！</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Yesod v1.6 のサブサイト</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-19-yesod-subsite.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-19-yesod-subsite.html</id>
    <published>2018-03-19T00:00:00Z</published>
    <updated>2018-03-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>今回は <code>Yesod</code> を使っているマニア向け情報です。</p>
<p><code>Yesod</code> にはサブサイトという機能があり、Yesod Book の <a href="https://www.yesodweb.com/book/creating-a-subsite">Creating a Subsite</a> で一通りの使い方が説明されています。</p>
<p>簡単に言えば、異なる <code>Yesod</code> アプリケーションで共通のコンポーネント (認証システム等) を利用するために使えるようです。</p>
<p><code>scaffolded site</code> を使っている人は <a href="https://www.stackage.org/lts-11.1/package/yesod-static-1.6.0">yesod-static</a> パッケージで提供されている <code>Static</code> 型をサブサイトとして利用していることでしょう。</p>
<p><code>Yesod</code> のバージョンが <code>1.6</code> に上がった影響により <code>Yesod Book</code> の内容がそのままでは動かなくなっていたため、コードを修正して実際に動かしてみたいと思います。</p>
<!--more-->
<h2 id="修正ポイント">修正ポイント</h2>
<ul>
<li><code>HandlerT site IO a</code> のような形式は何も考えずに <code>HandlerFor site a</code> に書き換える</li>
<li>サブサイトのハンドラ関数の型は <code>SubHandlerFor sub master a</code> という形式に書き換える</li>
<li><code>HandlerFor</code> から <code>SubHandlerFor</code> へ持ち上げる時は <code>liftHandler</code> を使う</li>
<li>サブサイトの <code>YesodDispatch</code> 型クラスのインスタンスは <code>HandlerT</code> ではなく <code>instance Yesod master =&gt; YesodSubDispatch HelloSub master where</code> のように <code>Yesod</code> 型クラスのインスタンスを直接指定できるようになった</li>
</ul>
<h2 id="修正後のソースコード">修正後のソースコード</h2>
<p>ここでは公式サイトのコードと同様のディレクトリ構造及び、ファイル名とします。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1">$ <span class="ex">tree</span> .</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ex">.</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">├── <span class="ex">HelloSub</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">│   └── <span class="ex">Data.hs</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">├── <span class="ex">HelloSub.hs</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">└── <span class="ex">Main.hs</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="ex">1</span> directory, 3 files</a></code></pre></div>
<p>ファイルを分割しているのは <code>TH</code> の <code>GHC stage restriction</code> を回避するためです。</p>
<h3 id="hellosubdata.hs">HelloSub/Data.hs</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">{-# LANGUAGE QuasiQuotes     #-}</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ot">{-# LANGUAGE TypeFamilies    #-}</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">module</span> <span class="dt">HelloSub.Data</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Yesod</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="kw">data</span> <span class="dt">HelloSub</span> <span class="fu">=</span> <span class="dt">HelloSub</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">mkYesodSubData <span class="st">&quot;HelloSub&quot;</span> [parseRoutes|</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">/ SubHomeR GET</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">|]</a></code></pre></div>
<p>サブサイトのファウンデーション型 <code>HelloSub</code> とルートを定義しています。</p>
<p>通常であれば <code>mkYesod</code> を利用しますが <code>mkYesodSubData</code> を利用している点がサブサイトの特徴です。</p>
<h3 id="hellosub.hs">HelloSub.hs</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">{-# LANGUAGE FlexibleInstances     #-}</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="ot">{-# LANGUAGE OverloadedStrings     #-}</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ot">{-# LANGUAGE QuasiQuotes           #-}</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">{-# LANGUAGE TemplateHaskell       #-}</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="kw">module</span> <span class="dt">HelloSub</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  ( <span class="kw">module</span> <span class="dt">HelloSub.Data</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">  , <span class="kw">module</span> <span class="dt">HelloSub</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">  ) <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10"></a>
<a class="sourceLine" id="cb3-11" data-line-number="11"><span class="kw">import</span>           <span class="dt">HelloSub.Data</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12"><span class="kw">import</span>           <span class="dt">Yesod</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13"><span class="kw">import</span>           <span class="dt">Yesod.Core.Types</span></a>
<a class="sourceLine" id="cb3-14" data-line-number="14"></a>
<a class="sourceLine" id="cb3-15" data-line-number="15"><span class="ot">getSubHomeR ::</span> <span class="dt">Yesod</span> master <span class="ot">=&gt;</span> <span class="dt">SubHandlerFor</span> <span class="dt">HelloSub</span> master <span class="dt">Html</span></a>
<a class="sourceLine" id="cb3-16" data-line-number="16">getSubHomeR <span class="fu">=</span> liftHandler <span class="fu">$</span> defaultLayout [whamlet|Welcome to the subsite!|]</a>
<a class="sourceLine" id="cb3-17" data-line-number="17"></a>
<a class="sourceLine" id="cb3-18" data-line-number="18"><span class="kw">instance</span> <span class="dt">Yesod</span> master <span class="ot">=&gt;</span> <span class="dt">YesodSubDispatch</span> <span class="dt">HelloSub</span> master <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-19" data-line-number="19">  yesodSubDispatch <span class="fu">=</span> <span class="fu">$</span>(mkYesodSubDispatch resourcesHelloSub)</a></code></pre></div>
<p>サブサイトのハンドラと <code>dispatch</code> の定義です。</p>
<p><code>resourcesHelloSub</code> は <code>HelloSub/Data.hs</code> で定義した <code>mkYesodSubData</code> でコンパイル時に自動生成されます。</p>
<h3 id="main.hs">Main.hs</h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="co">-- stack --resolver lts-11.0 script --package yesod-core --package yesod</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="ot">{-# LANGUAGE QuasiQuotes       #-}</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="ot">{-# LANGUAGE TemplateHaskell   #-}</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="ot">{-# LANGUAGE TypeFamilies      #-}</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">HelloSub</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="kw">import</span>           <span class="dt">Yesod</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10"></a>
<a class="sourceLine" id="cb4-11" data-line-number="11"><span class="kw">data</span> <span class="dt">Master</span> <span class="fu">=</span> <span class="dt">Master</span></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">  {<span class="ot"> getHelloSub ::</span> <span class="dt">HelloSub</span></a>
<a class="sourceLine" id="cb4-13" data-line-number="13">  }</a>
<a class="sourceLine" id="cb4-14" data-line-number="14"></a>
<a class="sourceLine" id="cb4-15" data-line-number="15">mkYesod <span class="st">&quot;Master&quot;</span> [parseRoutes|</a>
<a class="sourceLine" id="cb4-16" data-line-number="16">/ HomeR GET</a>
<a class="sourceLine" id="cb4-17" data-line-number="17">/subsite SubsiteR HelloSub getHelloSub</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">|]</a>
<a class="sourceLine" id="cb4-19" data-line-number="19"></a>
<a class="sourceLine" id="cb4-20" data-line-number="20"><span class="kw">instance</span> <span class="dt">Yesod</span> <span class="dt">Master</span></a>
<a class="sourceLine" id="cb4-21" data-line-number="21"></a>
<a class="sourceLine" id="cb4-22" data-line-number="22"><span class="ot">getHomeR ::</span> <span class="dt">HandlerFor</span> <span class="dt">Master</span> <span class="dt">Html</span></a>
<a class="sourceLine" id="cb4-23" data-line-number="23">getHomeR <span class="fu">=</span> defaultLayout</a>
<a class="sourceLine" id="cb4-24" data-line-number="24">  [whamlet|</a>
<a class="sourceLine" id="cb4-25" data-line-number="25">    <span class="kw">&lt;h1&gt;</span>Welcome to the homepage</a>
<a class="sourceLine" id="cb4-26" data-line-number="26">    <span class="kw">&lt;p&gt;</span></a>
<a class="sourceLine" id="cb4-27" data-line-number="27">      Feel free to visit the #</a>
<a class="sourceLine" id="cb4-28" data-line-number="28">      <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="kw">@{</span><span class="dt">SubsiteR</span> <span class="dt">SubHomeR</span><span class="kw">}&gt;</span>subsite</a>
<a class="sourceLine" id="cb4-29" data-line-number="29">      \ as well.</a>
<a class="sourceLine" id="cb4-30" data-line-number="30">  |]</a>
<a class="sourceLine" id="cb4-31" data-line-number="31"></a>
<a class="sourceLine" id="cb4-32" data-line-number="32">main <span class="fu">=</span> warp <span class="dv">3000</span> <span class="fu">$</span> <span class="dt">Master</span> <span class="dt">HelloSub</span></a></code></pre></div>
<p>重要なポイントは以下の3点です。</p>
<ul>
<li><code>Master</code> ファウンデーション型にサブサイトの型を含ませる (さらにアクセサ <code>getHelloSub</code> を定義)</li>
<li><code>/subsite SubsiteR HelloSub getHelloSub</code> という形式でサブサイトへのルートを定義</li>
<li>サブサイトへの参照は <code>@{SubsiteR SubHomeR}</code> という形式の型安全URLとなる</li>
</ul>
<h2 id="実行">実行</h2>
<p><code>stack interpreter</code> 形式で実行します。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" data-line-number="1">$ <span class="fu">chmod</span> u+x Main.hs</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">$ <span class="ex">./Main.hs</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="ex">19/Mar</span>/2018:<span class="ex">00</span>:37:27 +0900 [Info#yesod-core] Application launched @(yesod-core-1.6.2-JztYji0NiLuH8rcbB3eMBP:Yesod.Core.Dispatch ./Yesod/Core/Dispatch.hs:167:11)</a></code></pre></div>
<p>この状態で <a href="http://localhost:3000/" class="uri">http://localhost:3000/</a> にアクセスしてみましょう。以下のようなページが表示されるはずです。</p>
<figure>
<img src="/images/2018/03-19/img01.png" alt="トップページ" /><figcaption>トップページ</figcaption>
</figure>
<p>サブサイトにアクセスするとこんな感じです。</p>
<figure>
<img src="/images/2018/03-19/img02.png" alt="サブサイト" /><figcaption>サブサイト</figcaption>
</figure>
<h2 id="scaffolded-site">Scaffolded Site</h2>
<p>ここではさらに一歩踏み込んで <code>Scaffolded Site</code> を利用する際、どのファイルに何を書いたら良いのか簡単に解説しておこうと思います。</p>
<p><code>Scaffolded Site</code> は一番素朴な <code>yesod-simple</code> を利用することとします。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" data-line-number="1">$ <span class="ex">stack</span> new example-subsite yesod-simple</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">$ <span class="bu">cd</span> example-subsite</a></code></pre></div>
<p>サブサイトの内容は上記で定義した内容を再利用します。</p>
<h3 id="stack.yaml">stack.yaml</h3>
<div class="sourceCode" id="cb7"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="fu">resolver:</span><span class="at"> lts-11.0</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="fu">packages:</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="kw">-</span> .</a></code></pre></div>
<p>現状落ちてくるものは <code>yesod-1.6.0</code> ではないので、書き換えます。</p>
<h3 id="package.yaml">package.yaml</h3>
<div class="sourceCode" id="cb8"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="fu">dependencies:</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">-</span> base</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="kw">-</span> classy-prelude-yesod</a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="kw">-</span> yesod</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="kw">-</span> yesod-core</a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="kw">-</span> yesod-static</a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="kw">-</span> yesod-form</a>
<a class="sourceLine" id="cb8-8" data-line-number="8"><span class="kw">-</span> classy-prelude</a>
<a class="sourceLine" id="cb8-9" data-line-number="9"><span class="kw">-</span> classy-prelude-conduit</a>
<a class="sourceLine" id="cb8-10" data-line-number="10"><span class="kw">-</span> bytestring</a>
<a class="sourceLine" id="cb8-11" data-line-number="11"><span class="kw">-</span> text</a>
<a class="sourceLine" id="cb8-12" data-line-number="12"><span class="kw">-</span> template-haskell</a>
<a class="sourceLine" id="cb8-13" data-line-number="13"><span class="kw">-</span> shakespeare</a>
<a class="sourceLine" id="cb8-14" data-line-number="14"><span class="kw">-</span> hjsmin</a>
<a class="sourceLine" id="cb8-15" data-line-number="15"><span class="kw">-</span> monad-control</a>
<a class="sourceLine" id="cb8-16" data-line-number="16"><span class="kw">-</span> wai-extra</a>
<a class="sourceLine" id="cb8-17" data-line-number="17"><span class="kw">-</span> yaml</a>
<a class="sourceLine" id="cb8-18" data-line-number="18"><span class="kw">-</span> http-conduit</a>
<a class="sourceLine" id="cb8-19" data-line-number="19"><span class="kw">-</span> directory</a>
<a class="sourceLine" id="cb8-20" data-line-number="20"><span class="kw">-</span> warp</a>
<a class="sourceLine" id="cb8-21" data-line-number="21"><span class="kw">-</span> data-default</a>
<a class="sourceLine" id="cb8-22" data-line-number="22"><span class="kw">-</span> aeson</a>
<a class="sourceLine" id="cb8-23" data-line-number="23"><span class="kw">-</span> conduit</a>
<a class="sourceLine" id="cb8-24" data-line-number="24"><span class="kw">-</span> monad-logger</a>
<a class="sourceLine" id="cb8-25" data-line-number="25"><span class="kw">-</span> fast-logger</a>
<a class="sourceLine" id="cb8-26" data-line-number="26"><span class="kw">-</span> wai-logger</a>
<a class="sourceLine" id="cb8-27" data-line-number="27"><span class="kw">-</span> file-embed</a>
<a class="sourceLine" id="cb8-28" data-line-number="28"><span class="kw">-</span> safe</a>
<a class="sourceLine" id="cb8-29" data-line-number="29"><span class="kw">-</span> unordered-containers</a>
<a class="sourceLine" id="cb8-30" data-line-number="30"><span class="kw">-</span> containers</a>
<a class="sourceLine" id="cb8-31" data-line-number="31"><span class="kw">-</span> vector</a>
<a class="sourceLine" id="cb8-32" data-line-number="32"><span class="kw">-</span> time</a>
<a class="sourceLine" id="cb8-33" data-line-number="33"><span class="kw">-</span> case-insensitive</a>
<a class="sourceLine" id="cb8-34" data-line-number="34"><span class="kw">-</span> wai</a>
<a class="sourceLine" id="cb8-35" data-line-number="35"><span class="kw">-</span> foreign-store</a></code></pre></div>
<p>バージョンを全部消しただけです。</p>
<h3 id="srcfoundation.hs">src/Foundation.hs</h3>
<p><code>App</code> データ型にサブサイトを含め、さらに <code>import</code> を追加します。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">import</span> <span class="dt">HelloSub</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="kw">data</span> <span class="dt">App</span> <span class="fu">=</span> <span class="dt">App</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  {<span class="ot"> appSettings    ::</span> <span class="dt">AppSettings</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  ,<span class="ot"> appStatic      ::</span> <span class="dt">Static</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  ,<span class="ot"> appHttpManager ::</span> <span class="dt">Manager</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  ,<span class="ot"> appLogger      ::</span> <span class="dt">Logger</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">  ,<span class="ot"> getHelloSub    ::</span> <span class="dt">HelloSub</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">  }</a></code></pre></div>
<p><code>yesod-1.6.0</code> した影響でコンパイルエラーが出るため、<code>shouldLog</code> をコメントアウトします。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">    <span class="co">-- shouldLog app _source level =</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">    <span class="co">--     appShouldLogAll (appSettings app)</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">    <span class="co">--         || level == LevelWarn</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">    <span class="co">--         || level == LevelError</span></a></code></pre></div>
<h3 id="configroute">config/route</h3>
<p>サブサイトへのルートを追加します。</p>
<pre class="txt"><code>/subsite SubsiteR HelloSub getHelloSub</code></pre>
<h3 id="srcapplication.hs">src/Application.hs</h3>
<p>以下の2点を追記します。</p>
<ul>
<li><code>import HelloSub</code> を追加</li>
<li><code>makeFoundation</code> 関数に <code>let getHelloSub = HelloSub</code> を追記</li>
</ul>
<div class="sourceCode" id="cb12"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">import</span> <span class="dt">HelloSub</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="ot">makeFoundation ::</span> <span class="dt">AppSettings</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">App</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">makeFoundation appSettings <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  <span class="kw">let</span> getHelloSub <span class="fu">=</span> <span class="dt">HelloSub</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">  appHttpManager <span class="ot">&lt;-</span> newManager</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">  appLogger <span class="ot">&lt;-</span> newStdoutLoggerSet defaultBufSize <span class="fu">&gt;&gt;=</span> makeYesodLogger</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">  appStatic <span class="ot">&lt;-</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">    (<span class="kw">if</span> appMutableStatic appSettings <span class="kw">then</span> staticDevel <span class="kw">else</span> static)</a>
<a class="sourceLine" id="cb12-11" data-line-number="11">    (appStaticDir appSettings)</a>
<a class="sourceLine" id="cb12-12" data-line-number="12"></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">  return <span class="dt">App</span> {<span class="fu">..</span>}</a></code></pre></div>
<p><code>App {..}</code> は <code>GHC</code> の <code>RecordWildCards</code> 言語拡張です。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Example</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  { a <span class="fu">=</span> a</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  , b <span class="fu">=</span> b</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  , c <span class="fu">=</span> c</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  }</a></code></pre></div>
<p>僕はあまり使いませんが、雰囲気はこんな感じです。</p>
<h3 id="実行-1">実行</h3>
<div class="sourceCode" id="cb14"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb14-1" data-line-number="1">$ <span class="ex">stack</span> build</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">$ <span class="ex">stack</span> exec example-subsite</a></code></pre></div>
<p><a href="http://localhost:3000/subsite" class="uri">http://localhost:3000/subsite</a> にアクセスすると次のような画面が現れます。</p>
<figure>
<img src="/images/2018/03-19/img03.png" alt="実行結果" /><figcaption>実行結果</figcaption>
</figure>
<h2 id="まとめ">まとめ</h2>
<p><code>Yesod</code> を使っていてもサブサイトについて知らないという人は多いと思いますが、<code>Yesod</code> のアプリケーションが増えてきた時に使える、とても便利な仕組みだと思います。</p>
<p>サブサイトについて、もっと詳しく知りたい人は <a href="https://www.stackage.org/lts-11.1/package/yesod-static-1.6.0">yesod-static</a> パッケージの実装を見てみると良いでしょう。</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>extra-deps に github の短縮形が指定できるようになります</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-13-stack-extra-deps-shorthand.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-13-stack-extra-deps-shorthand.html</id>
    <published>2018-03-13T00:00:00Z</published>
    <updated>2018-03-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>今日マージされた <a href="https://github.com/commercialhaskell/stack/pull/3890">Allow ‘github’ shorthand for extra-deps (fixes #3873) #3890</a> がとても便利だと思いますのでご紹介します。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1">$ <span class="ex">stack</span> --version</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ex">Version</span> 1.7.0, Git revision 4a140342f9b28005bf2fdd5335bdcd32c9370265 (5702 commits) <span class="ex">x86_64</span> hpack-0.21.2</a></code></pre></div>
<!--more-->
<p><code>stack.yaml</code> に記述する <code>extra-deps</code> は主に2つの理由で記述することが多いです。</p>
<ul>
<li><code>lts</code> に含まれていないパッケージのバージョンを指定するため</li>
<li>そもそも <code>Hackage</code> に上がっていないパッケージを使うため</li>
</ul>
<p>今回は <code>extra-deps</code> の指定方法に <code>github</code> 専用の短縮形が導入されました。</p>
<p>こんな感じで指定可能です。(コミットの短縮形はいつから使えていたのかわかりませんが、使えます)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="fu">extra-deps:</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">-</span> <span class="fu">github:</span><span class="at"> haskell/text</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="fu">commit:</span><span class="at"> 9fac5d</span></a></code></pre></div>
<p>1.6.5 ではまだ利用できない機能となっております。</p>
<h2 id="試し方">試し方</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1">$ <span class="ex">stack</span> upgrade --git</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="co"># コンパイルするので時間かかります</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">$ <span class="ex">stack</span> --version</a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ex">Version</span> 1.7.0, Git revision 4a140342f9b28005bf2fdd5335bdcd32c9370265 (5702 commits) <span class="ex">x86_64</span> hpack-0.21.2</a></code></pre></div>
<p>遊んでから、元の <code>stack</code> のバージョンに戻す時は以下のようにするだけです。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1">$ <span class="ex">stack</span> upgrade --binary-version 1.6.5</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ex">...</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">$ <span class="ex">stack</span> --version</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="ex">Version</span> 1.6.5, Git revision 24ab0d6ff07f28276e082c3ce74dfdeb1a2ca9e9 (5514 commits) <span class="ex">x86_64</span> hpack-0.20.0</a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="co"># バイナリが落ちてくるのですぐ終わります</span></a></code></pre></div>
<h2 id="まとめ">まとめ</h2>
<ul>
<li><code>stack 1.7.0</code> ぐらいから利用できるようになるはず</li>
<li><code>github</code> が新たに追加され <code>user/repo</code> の短縮形で記述できるようになった</li>
<li><code>commit</code> もいつからか短縮形で記述できるようになっていた</li>
<li><code>subdirs</code> を指定すれば <code>Yesod</code> のような mega-repo でも指定できる</li>
</ul>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>wizard モノイド</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-07-The-wizard-monoid.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-07-The-wizard-monoid.html</id>
    <published>2018-03-07T00:00:00Z</published>
    <updated>2018-03-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="wizard-モノイド-翻訳">wizard モノイド (翻訳)</h2>
<p>Original post: <a href="http://www.haskellforall.com/2018/02/the-wizard-monoid.html">The wizard monoid</a></p>
<p>最近の GHC 8.0 は、<code>IO</code> 用の <code>Monoid</code> インスタンスを提供しています。このブログ記事では、組み合わせ可能な “wizard” を作りつつ、なぜこのインスタンスが便利なのかを示す例をお見せします。</p>
<!--more-->
<h3 id="wizard">Wizard</h3>
<p>ここで使う “wizard” とは、ユーザーに複数の入力を促し、全ての入力が完了したら、いくつかのアクションを実行するようなプログラムです。</p>
<p>簡単な wizard の例です:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    <span class="co">-- First, we request all inputs:</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    putStrLn <span class="st">&quot;What is your name?&quot;</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    name <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    putStrLn <span class="st">&quot;What is your age?&quot;</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    age <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb1-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">    <span class="co">-- Then, we perform all actions:</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">    putStrLn (<span class="st">&quot;Your name is: &quot;</span> <span class="fu">++</span> name)</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">    putStrLn (<span class="st">&quot;Your age is: &quot;</span> <span class="fu">++</span> age)</a></code></pre></div>
<p>… 実行例:</p>
<pre class="plain"><code>What is your name?
Gabriel&lt;Enter&gt;
What is your age?
31&lt;Enter&gt;
Your name is: Gabriel
Your age is: 31</code></pre>
<p>… それで、以下はもう少し複雑な wizard の例です:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">System.Directory</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    <span class="co">-- First, we request all inputs:</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    files <span class="ot">&lt;-</span> System.Directory.listDirectory <span class="st">&quot;.&quot;</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    <span class="kw">let</span> askFile file <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">            putStrLn (<span class="st">&quot;Would you like to delete &quot;</span> <span class="fu">++</span> file <span class="fu">++</span> <span class="st">&quot;?&quot;</span>)</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">            response <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">            <span class="kw">case</span> response <span class="kw">of</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">                <span class="st">&quot;y&quot;</span> <span class="ot">-&gt;</span> return [file]</a>
<a class="sourceLine" id="cb3-12" data-line-number="12">                _   <span class="ot">-&gt;</span> return []</a>
<a class="sourceLine" id="cb3-13" data-line-number="13"></a>
<a class="sourceLine" id="cb3-14" data-line-number="14">    listOfListOfFilesToRemove <span class="ot">&lt;-</span> mapM askFile files</a>
<a class="sourceLine" id="cb3-15" data-line-number="15">    <span class="kw">let</span> listOfFilesToRemove <span class="fu">=</span> concat listOfListOfFilesToRemove</a>
<a class="sourceLine" id="cb3-16" data-line-number="16"></a>
<a class="sourceLine" id="cb3-17" data-line-number="17">    <span class="co">-- Then, we perform all actions:</span></a>
<a class="sourceLine" id="cb3-18" data-line-number="18">    <span class="kw">let</span> removeFile file <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-19" data-line-number="19">            putStrLn (<span class="st">&quot;Removing &quot;</span> <span class="fu">++</span> file)</a>
<a class="sourceLine" id="cb3-20" data-line-number="20">            System.Directory.removeFile file</a>
<a class="sourceLine" id="cb3-21" data-line-number="21">    mapM_ removeFile listOfFilesToRemove</a></code></pre></div>
<p>… 実行例:</p>
<pre class="plain"><code>Would you like to delete file1.txt?
y&lt;Enter&gt;
Would you like to delete file2.txt?
n&lt;Enter&gt;
Would you like to delete file3.txt?
y&lt;Enter&gt;
Removing file1.txt
Removing file3.txt</code></pre>
<p>以上に挙げた例では、ユーザーが要求された入力を全て入力し終えるまで、変更ができないアクションを実行するのは避けたいという要求があります。</p>
<h3 id="モジュール性">モジュール性</h3>
<p>最初の例を見直してみましょう:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    <span class="co">-- First, we request all inputs:</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    putStrLn <span class="st">&quot;What is your name?&quot;</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    name <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    putStrLn <span class="st">&quot;What is your age?&quot;</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">    age <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb5-9" data-line-number="9"></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    <span class="co">-- Then, we perform all actions:</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    putStrLn (<span class="st">&quot;Your name is: &quot;</span> <span class="fu">++</span> name)</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">    putStrLn (<span class="st">&quot;Your age is: &quot;</span> <span class="fu">++</span> age)</a></code></pre></div>
<p>この例は、実質的には2つの独立した wizard を組み合わせています:</p>
<ul>
<li>最初の wizard はユーザーの名前を要求し、表示している</li>
<li>2つ目の wizard はユーザーの年齢を要求し、表示している</li>
</ul>
<p>しかし、アクションを実行する前に全ての入力が必要だったので、2つの wizard のロジックをそれぞれ混ぜる必要がありました。</p>
<p>これら2つの wizard を別々に定義し、より大きな wizard に合体させる方法があったらどうでしょう? <code>IO</code> の <code>Monoid</code> インスタンスの長所を活かせば可能です。こんな感じ:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Monoid</span> ((&lt;&gt;))</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="ot">name ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">name <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    putStrLn <span class="st">&quot;What is your name?&quot;</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    x <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    return (putStrLn (<span class="st">&quot;Your name is: &quot;</span> <span class="fu">++</span> x))</a>
<a class="sourceLine" id="cb6-8" data-line-number="8"></a>
<a class="sourceLine" id="cb6-9" data-line-number="9"><span class="ot">age ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">age <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">    putStrLn <span class="st">&quot;What is your age?&quot;</span></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">    x <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb6-13" data-line-number="13">    return (putStrLn (<span class="st">&quot;Your age is: &quot;</span> <span class="fu">++</span> x))</a>
<a class="sourceLine" id="cb6-14" data-line-number="14"></a>
<a class="sourceLine" id="cb6-15" data-line-number="15"><span class="ot">runWizard ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb6-16" data-line-number="16">runWizard request <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-17" data-line-number="17">    respond <span class="ot">&lt;-</span> request</a>
<a class="sourceLine" id="cb6-18" data-line-number="18">    respond</a>
<a class="sourceLine" id="cb6-19" data-line-number="19"></a>
<a class="sourceLine" id="cb6-20" data-line-number="20"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb6-21" data-line-number="21">main <span class="fu">=</span> runWizard (name <span class="fu">&lt;&gt;</span> age)</a></code></pre></div>
<p>このプログラムはさっきの例と完全に同じ動きをします。が、ユーザーの名前を扱うロジックは、ユーザーの年齢を扱うロジックと完全に分離されています。</p>
<p>この方法でうまくいくのは、それぞれの wizard を2つの部分に分けたからです:</p>
<ul>
<li>リクエストの部分 (ユーザーに入力を求める部分など)</li>
<li>レスポンスの部分 (その入力に応じたアクションを実行する部分など)</li>
</ul>
<p>… そしてそれぞれの wizard に <code>IO (IO ())</code> という型を与えることによって、型レベルでこれを実現しています:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">name ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="ot">age ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a></code></pre></div>
<p>外側の <code>IO</code> アクションは“リクエスト”です。リクエストが終了したとき、外側の <code>IO</code> アクションは内側の <code>IO</code> アクション、つまり“レスポンス”を返します。例えば:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">--      ↓ リクエスト</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ot">name ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="co">--          ↑ レスポンス</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">name <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    putStrLn <span class="st">&quot;What is your name?&quot;</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">    x <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    <span class="co">-- ↑ ここから上の部分全てが、外側の `IO` アクションの一部 (例えばリクエスト)</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    <span class="co">--      ↓ この return される値は、内側の `IO` アクション (例えばレスポンス)</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">    return (putStrLn (<span class="st">&quot;Your name is: &quot;</span> <span class="fu">++</span> x))</a></code></pre></div>
<p>wizard は <code>(&lt;&gt;)</code> 演算子を使って組み合わせることができます。<code>IO</code> アクションに限って言うなら、以下のような動作をします:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">ioLeft <span class="fu">&lt;&gt;</span> ioRight</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="fu">=</span> <span class="kw">do</span> resultLeft  <span class="ot">&lt;-</span> ioLeft</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">     resultRight <span class="ot">&lt;-</span> ioRight</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">     return (resultLeft <span class="fu">&lt;&gt;</span> resultRight)</a></code></pre></div>
<p>言い換えるなら、<code>IO</code> アクションを2つ組み合わせるということは、それぞれの <code>IO</code> アクションを実行して結果を組み合わせるということなのです。これは、2つの <code>IO</code> アクションをネストさせると、アクションを実行して結果を組み合わせるという処理を2回実行する、ということも示しています:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">requestLeft <span class="fu">&lt;&gt;</span> requestRight</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="fu">=</span> <span class="kw">do</span> respondLeft  <span class="ot">&lt;-</span> requestLeft</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">     respondRight <span class="ot">&lt;-</span> requestRight</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">     return (respondLeft <span class="fu">&lt;&gt;</span> respondRight)</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="fu">=</span> <span class="kw">do</span> respondLeft  <span class="ot">&lt;-</span> requestLeft</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">     respondRight <span class="ot">&lt;-</span> requestRight</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">     return (<span class="kw">do</span></a>
<a class="sourceLine" id="cb10-10" data-line-number="10">         unitLeft  <span class="ot">&lt;-</span> respondLeft</a>
<a class="sourceLine" id="cb10-11" data-line-number="11">         unitRight <span class="ot">&lt;-</span> respondRight</a>
<a class="sourceLine" id="cb10-12" data-line-number="12">         return (unitLeft <span class="fu">&lt;&gt;</span> unitRight) )</a>
<a class="sourceLine" id="cb10-13" data-line-number="13"></a>
<a class="sourceLine" id="cb10-14" data-line-number="14"><span class="co">-- Both `unitLeft` and `unitRight` are `()` and `() &lt;&gt; () = ()`, so we can</span></a>
<a class="sourceLine" id="cb10-15" data-line-number="15"><span class="co">-- simplify this further to:</span></a>
<a class="sourceLine" id="cb10-16" data-line-number="16"></a>
<a class="sourceLine" id="cb10-17" data-line-number="17"><span class="co">-- `unitLeft` も `unitRight` も `()` で、`() &lt;&gt; () = ()` なので、</span></a>
<a class="sourceLine" id="cb10-18" data-line-number="18"><span class="co">-- 以下のように簡約化することができます:</span></a>
<a class="sourceLine" id="cb10-19" data-line-number="19"><span class="fu">=</span> <span class="kw">do</span> respondLeft  <span class="ot">&lt;-</span> requestLeft</a>
<a class="sourceLine" id="cb10-20" data-line-number="20">     respondRight <span class="ot">&lt;-</span> requestRight</a>
<a class="sourceLine" id="cb10-21" data-line-number="21">     return (<span class="kw">do</span></a>
<a class="sourceLine" id="cb10-22" data-line-number="22">         respondLeft</a>
<a class="sourceLine" id="cb10-23" data-line-number="23">         respondRight )</a></code></pre></div>
<p>つまり、2つの wizard を組み合わせると、リクエストを組み合わせてレスポンスも組み合わせたことになるのです。</p>
<p>この方法は2つ以上の wizard でもうまくいきます。例えば:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">request0 <span class="fu">&lt;&gt;</span> request1 <span class="fu">&lt;&gt;</span> request2 <span class="fu">&lt;&gt;</span> request3</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="fu">=</span> <span class="kw">do</span> respond0 <span class="ot">&lt;-</span> request0</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">     respond1 <span class="ot">&lt;-</span> request1</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">     respond2 <span class="ot">&lt;-</span> request2</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">     respond3 <span class="ot">&lt;-</span> request3</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">     return (<span class="kw">do</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">         respond0</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">         respond1</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">         respond2</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">         respond3 )</a></code></pre></div>
<p>これをアクションの形で表現するために、さっきの例をもう一度見てみましょう:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Monoid</span> ((&lt;&gt;))</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="ot">name ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">name <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">    putStrLn <span class="st">&quot;What is your name?&quot;</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">    x <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">    return (putStrLn (<span class="st">&quot;Your name is: &quot;</span> <span class="fu">++</span> x))</a>
<a class="sourceLine" id="cb12-8" data-line-number="8"></a>
<a class="sourceLine" id="cb12-9" data-line-number="9"><span class="ot">age ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">age <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-11" data-line-number="11">    putStrLn <span class="st">&quot;What is your age?&quot;</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">    x <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb12-13" data-line-number="13">    return (putStrLn (<span class="st">&quot;Your age is: &quot;</span> <span class="fu">++</span> x))</a>
<a class="sourceLine" id="cb12-14" data-line-number="14"></a>
<a class="sourceLine" id="cb12-15" data-line-number="15"><span class="ot">runWizard ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb12-16" data-line-number="16">runWizard request <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-17" data-line-number="17">    respond <span class="ot">&lt;-</span> request</a>
<a class="sourceLine" id="cb12-18" data-line-number="18">    respond</a>
<a class="sourceLine" id="cb12-19" data-line-number="19"></a>
<a class="sourceLine" id="cb12-20" data-line-number="20"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb12-21" data-line-number="21">main <span class="fu">=</span> runWizard (name <span class="fu">&lt;&gt;</span> age)</a></code></pre></div>
<p>…<code>name</code> と <code>age</code> はかなり似ているので、共通の関数を使うような実装にすることができますね:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Monoid</span> ((&lt;&gt;))</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="ot">prompt ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">prompt attribute <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    putStrLn (<span class="st">&quot;What is your &quot;</span> <span class="fu">++</span> attribute <span class="fu">++</span> <span class="st">&quot;?&quot;</span>)</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    x <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    return (putStrLn (<span class="st">&quot;Your &quot;</span> <span class="fu">++</span> attribute <span class="fu">++</span> <span class="st">&quot; is: &quot;</span> <span class="fu">++</span> x))</a>
<a class="sourceLine" id="cb13-8" data-line-number="8"></a>
<a class="sourceLine" id="cb13-9" data-line-number="9"><span class="ot">runWizard ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb13-10" data-line-number="10">runWizard request <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-11" data-line-number="11">    respond <span class="ot">&lt;-</span> request</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">    respond</a>
<a class="sourceLine" id="cb13-13" data-line-number="13"></a>
<a class="sourceLine" id="cb13-14" data-line-number="14"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb13-15" data-line-number="15">main <span class="fu">=</span> runWizard (prompt <span class="st">&quot;name&quot;</span> <span class="fu">&lt;&gt;</span> prompt <span class="st">&quot;age&quot;</span>)</a></code></pre></div>
<p>2つの wizard のロジックが混ざっていたとき、この共通化のロジックを使うことはできませんでした。しかしロジック毎に別々の wizard に分割すると、プログラムを小さくするための共通構造を突くことができます。</p>
<p>このプログラムの圧縮によって、簡単に新しい wizard を追加することができます:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Monoid</span> ((&lt;&gt;))</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="ot">prompt ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">prompt attribute <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    putStrLn (<span class="st">&quot;What is your &quot;</span> <span class="fu">++</span> attribute <span class="fu">++</span> <span class="st">&quot;?&quot;</span>)</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    x <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    return (putStrLn (<span class="st">&quot;Your &quot;</span> <span class="fu">++</span> attribute <span class="fu">++</span> <span class="st">&quot; is: &quot;</span> <span class="fu">++</span> x))</a>
<a class="sourceLine" id="cb14-8" data-line-number="8"></a>
<a class="sourceLine" id="cb14-9" data-line-number="9"><span class="ot">runWizard ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">runWizard request <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-11" data-line-number="11">    respond <span class="ot">&lt;-</span> request</a>
<a class="sourceLine" id="cb14-12" data-line-number="12">    respond</a>
<a class="sourceLine" id="cb14-13" data-line-number="13"></a>
<a class="sourceLine" id="cb14-14" data-line-number="14"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb14-15" data-line-number="15">main <span class="fu">=</span> runWizard (prompt <span class="st">&quot;name&quot;</span> <span class="fu">&lt;&gt;</span> prompt <span class="st">&quot;age&quot;</span> <span class="fu">&lt;&gt;</span> prompt <span class="st">&quot;favorite color&quot;</span>)</a></code></pre></div>
<p>… そして、モノイド関連の標準ライブラリ関数を活用しましょう。例えば <code>foldMap</code> を使えば wizard を大量に作ることができます。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Monoid</span> ((&lt;&gt;))</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="ot">prompt ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">prompt attribute <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    putStrLn (<span class="st">&quot;What is your &quot;</span> <span class="fu">++</span> attribute <span class="fu">++</span> <span class="st">&quot;?&quot;</span>)</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">    x <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb15-7" data-line-number="7">    return (putStrLn (<span class="st">&quot;Your &quot;</span> <span class="fu">++</span> attribute <span class="fu">++</span> <span class="st">&quot; is: &quot;</span> <span class="fu">++</span> x))</a>
<a class="sourceLine" id="cb15-8" data-line-number="8"></a>
<a class="sourceLine" id="cb15-9" data-line-number="9"><span class="ot">runWizard ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb15-10" data-line-number="10">runWizard request <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb15-11" data-line-number="11">    respond <span class="ot">&lt;-</span> request</a>
<a class="sourceLine" id="cb15-12" data-line-number="12">    respond</a>
<a class="sourceLine" id="cb15-13" data-line-number="13"></a>
<a class="sourceLine" id="cb15-14" data-line-number="14"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb15-15" data-line-number="15">main <span class="fu">=</span> runWizard (foldMap prompt [ <span class="st">&quot;name&quot;</span>, <span class="st">&quot;age&quot;</span>, <span class="st">&quot;favorite color&quot;</span>, <span class="st">&quot;sign&quot;</span> ])</a></code></pre></div>
<p>より重要なのは、プログラムが何をしているのか一目瞭然になりました。読みやすさは書きやすさに比べ、大きな美徳です。</p>
<h3 id="最後の例">最後の例</h3>
<p>ファイル削除の例も同じ観点から見直してみましょう:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">System.Directory</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    <span class="co">-- 最初に全ての入力をリクエストする:</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    files <span class="ot">&lt;-</span> System.Directory.listDirectory <span class="st">&quot;.&quot;</span></a>
<a class="sourceLine" id="cb16-7" data-line-number="7">    <span class="kw">let</span> askFile file <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-8" data-line-number="8">            putStrLn (<span class="st">&quot;Would you like to delete &quot;</span> <span class="fu">++</span> file <span class="fu">++</span> <span class="st">&quot;?&quot;</span>)</a>
<a class="sourceLine" id="cb16-9" data-line-number="9">            response <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb16-10" data-line-number="10">            <span class="kw">case</span> response <span class="kw">of</span></a>
<a class="sourceLine" id="cb16-11" data-line-number="11">                <span class="st">&quot;y&quot;</span> <span class="ot">-&gt;</span> return [file]</a>
<a class="sourceLine" id="cb16-12" data-line-number="12">                _   <span class="ot">-&gt;</span> return []</a>
<a class="sourceLine" id="cb16-13" data-line-number="13"></a>
<a class="sourceLine" id="cb16-14" data-line-number="14">    listOfListOfFilesToRemove <span class="ot">&lt;-</span> mapM askFile files</a>
<a class="sourceLine" id="cb16-15" data-line-number="15">    <span class="kw">let</span> listOfFilesToRemove <span class="fu">=</span> concat listOfListOfFilesToRemove</a>
<a class="sourceLine" id="cb16-16" data-line-number="16"></a>
<a class="sourceLine" id="cb16-17" data-line-number="17">    <span class="co">-- 次に全てのアクションを実行する</span></a>
<a class="sourceLine" id="cb16-18" data-line-number="18">    <span class="kw">let</span> removeFile file <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-19" data-line-number="19">            putStrLn (<span class="st">&quot;Removing &quot;</span> <span class="fu">++</span> file)</a>
<a class="sourceLine" id="cb16-20" data-line-number="20">            System.Directory.removeFile file</a>
<a class="sourceLine" id="cb16-21" data-line-number="21">    mapM_ removeFile listOfFilesToRemove</a></code></pre></div>
<p>さっきと同じパターンで、シンプルにすることができます:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">System.Directory</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5">    files <span class="ot">&lt;-</span> System.Directory.listDirectory <span class="st">&quot;.&quot;</span></a>
<a class="sourceLine" id="cb17-6" data-line-number="6">    runWizard (foldMap prompt files)</a>
<a class="sourceLine" id="cb17-7" data-line-number="7"></a>
<a class="sourceLine" id="cb17-8" data-line-number="8"><span class="ot">prompt ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb17-9" data-line-number="9">prompt file <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-10" data-line-number="10">    putStrLn (<span class="st">&quot;Would you like to delete &quot;</span> <span class="fu">++</span> file <span class="fu">++</span> <span class="st">&quot;?&quot;</span>)</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">    response <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb17-12" data-line-number="12">    <span class="kw">case</span> response <span class="kw">of</span></a>
<a class="sourceLine" id="cb17-13" data-line-number="13">        <span class="st">&quot;y&quot;</span> <span class="ot">-&gt;</span> return (<span class="kw">do</span></a>
<a class="sourceLine" id="cb17-14" data-line-number="14">            putStrLn (<span class="st">&quot;Removing &quot;</span> <span class="fu">++</span> file)</a>
<a class="sourceLine" id="cb17-15" data-line-number="15">            System.Directory.removeFile file )</a>
<a class="sourceLine" id="cb17-16" data-line-number="16">        _   <span class="ot">-&gt;</span> return (return ())</a>
<a class="sourceLine" id="cb17-17" data-line-number="17"></a>
<a class="sourceLine" id="cb17-18" data-line-number="18"><span class="ot">runWizard ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb17-19" data-line-number="19">runWizard request <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-20" data-line-number="20">    respond <span class="ot">&lt;-</span> request</a>
<a class="sourceLine" id="cb17-21" data-line-number="21">    respond</a></code></pre></div>
<p>やるべきなのは、1つのファイルに対して処理を行う wizard を定義すること、そして <code>foldMap</code> を使って wizard を大量に生成することだけです。<code>IO</code> の <code>Monoid</code> インスタンスは、全てのリクエストを束ねて表示し、後で選択したファイルを削除してくれます。</p>
<h3 id="結論">結論</h3>
<p>ユーザーが望む wizard の全てにこのパターンが適用できるわけではありません。例えば、wizard が互いに依存しているような状況では、このパターンはすぐに使い物にならなくなります。しかし、このパターンは <code>Monoid</code> の <code>IO</code> インスタンスを他の <code>Monoid</code> のインスタンスと (もしくは自分自身と!) 連結させ、新しい動作を生成するような一例にはなっています。</p>]]></summary>
</entry>

</feed>
