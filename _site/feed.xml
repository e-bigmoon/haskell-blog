<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>BIG MOON</title>
    <link href="https://haskell.e-bigmoon.com/feed.xml" rel="self" />
    <link href="https://haskell.e-bigmoon.com" />
    <id>https://haskell.e-bigmoon.com/feed.xml</id>
    <author>
        <name>BIG MOON</name>
        <email>it@e-bigmoon.com</email>
    </author>
    <updated>2018-03-26T00:00:00Z</updated>
    <entry>
    <title>Haskell IDE Engine を Emacs で使う</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-26-hie-emacs.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-26-hie-emacs.html</id>
    <published>2018-03-26T00:00:00Z</published>
    <updated>2018-03-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p><a href="https://github.com/haskell/haskell-ide-engine">HIE (Haskell IDE Engine)</a> を <code>Emacs</code> に導入する方法が <code>HIE</code> の <a href="https://github.com/haskell/haskell-ide-engine/pull/502/files">README.md</a> に追記されたので、それに従いインストールしてみました。</p>
<p>本記事では、導入手順を紹介します。</p>
<!--more-->
<h2 id="導入手順">導入手順</h2>
<h3 id="hie-をインストールする">1. HIE をインストールする。</h3>
<pre class="bssh"><code>$ git clone https://github.com/haskell/haskell-ide-engine.git
$ cd haskell-ide-engine
$ make

...

* Missing C libraries: icuuc, icui18n, icudata</code></pre>
<p><code>make</code> 実行時、以下のようにライブラリが足りなかったので、必要なパッケージをインストールして、もう一度 <code>make</code> しました。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1">$ <span class="fu">sudo</span> apt install libicu-dev</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">$ <span class="fu">make</span></a></code></pre></div>
<p>普通に <code>stack install</code> で導入することもできますが、 <code>HIE</code> はビルド時の <code>GHC</code> バージョンでしか使えないという弱点があるため、<code>GHC</code> の バージョンが異なるプロジェクトでは利用できません。</p>
<p>そのため <code>make</code> を使って <code>hie-8.2.1</code> のように <code>GHC</code> のそれぞれのバージョンでビルドした <code>HIE</code> のバイナリを用意して解決しています。</p>
<h3 id="必要なパッケージを入手する">2. 必要なパッケージを入手する。</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1">$ <span class="fu">git</span> clone git@github.com:emacs-lsp/lsp-mode.git</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">$ <span class="fu">git</span> clone git@github.com:emacs-lsp/lsp-ui.git</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">$ <span class="fu">git</span> clone git@github.com:emacs-lsp/lsp-haskell.git</a></code></pre></div>
<h3 id="emacs-の設定ファイル-init.el-など-に以下を追加する">3. emacs の設定ファイル (init.el など) に以下を追加する。</h3>
<pre class="elisp"><code>(add-to-list &#39;load-path &quot;/path/to/lsp-mode&quot;)
(add-to-list &#39;load-path &quot;/path/to/lsp-ui&quot;)
(add-to-list &#39;load-path &quot;/path/to/lsp-haskell&quot;)

(require &#39;lsp-mode)
(require &#39;lsp-ui)
(require &#39;lsp-haskell)

(add-hook &#39;lsp-mode-hook &#39;lsp-ui-mode)
(add-hook &#39;haskell-mode-hook #&#39;lsp-haskell-enable)
(add-hook &#39;haskell-mode-hook &#39;flycheck-mode)</code></pre>
<p>上記内容を記述した後で Emacs を起動したときに、依存するパッケージのインストールを要求される場合があるので、<code>Cask</code> や <code>package-install</code> などでインストールしましょう。</p>
<p>インストールが成功すると、<code>Haskell</code> のファイルを読み込んだときに、カーソルを当てたところにある関数の型の表示、エラーの表示、補完、コマンド <code>M-.</code> で定義のところにジャンプなどができるようになります。</p>
<h2 id="おわりに">おわりに</h2>
<p><code>HIE</code> は <code>ghc-mod</code> の実行ファイルを使っているかのように見えますが、実際はライブラリを通しているだけでバイナリは使っていないそうです。</p>]]></summary>
</entry>
<entry>
    <title>Haskell Quiz No.2 foldl と foldr</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-25-quiz-2.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-25-quiz-2.html</id>
    <published>2018-03-25T00:00:00Z</published>
    <updated>2018-03-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="haskell-quiz-no.2">Haskell Quiz No.2</h2>
<p>難易度: λλ</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">foldr (<span class="fu">&amp;&amp;</span>) <span class="dt">True</span> <span class="fu">$</span> cycle [<span class="dt">True</span>, <span class="dt">False</span>]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">foldl (<span class="fu">&amp;&amp;</span>) <span class="dt">True</span> <span class="fu">$</span> cycle [<span class="dt">True</span>, <span class="dt">False</span>]</a></code></pre></div>
<p>上記の2つの式の挙動の違いを説明してください。</p>
<p>また、なぜそうなるのか考えてみましょう！</p>
<p>答えは次回。</p>
<!--more-->
<h2 id="はじめに">はじめに</h2>
<p><a href="./03-24-quiz-1.html">前回</a>の問題と答えは以下の通りです。</p>
<h3 id="問題">問題</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Foo</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Foo1</span> <span class="fu">=</span> <span class="dt">Foo1</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">data</span> <span class="dt">Foo2</span> <span class="fu">=</span> <span class="dt">Foo2</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="kw">newtype</span> <span class="dt">Foo3</span> <span class="fu">=</span> <span class="dt">Foo3</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">x1 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo1</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">     <span class="dt">Foo1</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">x2 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo2</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">     <span class="dt">Foo2</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12"></a>
<a class="sourceLine" id="cb2-13" data-line-number="13">x3 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo3</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-14" data-line-number="14">     <span class="dt">Foo3</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15"></a>
<a class="sourceLine" id="cb2-16" data-line-number="16">y1 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-17" data-line-number="17">     <span class="dt">Foo1</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-18" data-line-number="18"></a>
<a class="sourceLine" id="cb2-19" data-line-number="19">y2 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-20" data-line-number="20">     <span class="dt">Foo2</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-21" data-line-number="21"></a>
<a class="sourceLine" id="cb2-22" data-line-number="22">y3 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-23" data-line-number="23">     <span class="dt">Foo3</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-24" data-line-number="24"></a>
<a class="sourceLine" id="cb2-25" data-line-number="25"><span class="ot">int ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-26" data-line-number="26">int <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb2-27" data-line-number="27"></a>
<a class="sourceLine" id="cb2-28" data-line-number="28">yInt <span class="fu">=</span> <span class="kw">case</span> int <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-29" data-line-number="29">       _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>以下の値はそれぞれ何になるでしょう？</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">x1   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">x2   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">x3   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">y1   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">y2   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">y3   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">yInt <span class="fu">=</span> <span class="fu">???</span></a></code></pre></div>
<h3 id="答え">答え</h3>
<p><code>GHC</code> のバージョン <code>8.0.2</code>, <code>8.2.2</code>, <code>8.4.1</code> で確認しました。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">x1   <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">x2   <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">x3   <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">y1   <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">y2   <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">y3   <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">yInt <span class="fu">=</span> <span class="dv">1</span></a></code></pre></div>
<p>どうですか？自信を持って全部回答できた人は少ないのではないでしょうか。</p>
<p>ちなみに、この知識を披露するタイミングは・・・ほぼ無いでしょうね・・・。</p>
<p>よくある <code>Haskell</code> 雑学のうちの1つです。こういう内容はチームメンバーの誰かが理解していれば良いので、最初のうちはわからなくても大丈夫です。わかる人に解説してもらいましょう。</p>
<h3 id="どうでも良い話">どうでも良い話</h3>
<p>Haskell Quiz は <code>Haskell</code> と言いつつ <code>GHC</code> の話だったりする場合もありますが、実用上それが問題になることは無いので気にしないことにします。</p>
<p><code>Haskell</code> は言語仕様で <code>GHC</code> が処理系だというのは、ただの雑学です。このことを知ってると、割とHaskellに詳しそうだな思ってもらえますよ！(ついでに <code>G</code> が <code>Glasgow</code> の略でイギリスにある大学なんだよってことも伝えてあげると、バイトの学生とかは <code>へー</code> って顔をしてくれるのでオススメです！)</p>
<h2 id="haskell-quiz-no.1-の解説">Haskell Quiz No.1 の解説</h2>
<h3 id="x1">x1</h3>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Foo1</span> <span class="fu">=</span> <span class="dt">Foo1</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">x1 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo1</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  <span class="dt">Foo1</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p><code>Foo1</code> はよくあるデータ定義です。</p>
<p>気にしておくべき点は以下の2つです。</p>
<ul>
<li><code>Foo1 Int</code> の <code>Int</code> はまだ評価されていない<strong>サンク</strong>という状態です。</li>
<li><code>undefined</code> は実際に評価された時にエラーとなります。(逆に、最後まで評価されなければエラーにならない)</li>
</ul>
<p><code>Foo1</code> 型の値で、例えば <code>Foo1 (1+1)</code> の <code>1+1</code> はまだ必要になっていないので、評価されていないサンクです。(つまり <code>Foo1 2</code> ではありません)</p>
<p>本当かなぁ？と思う人は実際に以下のコードを実行すれば、何となくわかってもらえると思います。(<code>sum [1..100000000000000]</code> は評価された時にとても時間がかかる処理です)</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ex">ghci</span><span class="op">&gt;</span> Foo1 (sum [1..100000000000000])</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ex">Foo1</span> ^CInterrupted.</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="ex">ghci</span><span class="op">&gt;</span> case Foo1 (sum [1..100000000000000]) <span class="ex">of</span> Foo1 i -<span class="op">&gt;</span> i</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">^<span class="ex">CInterrupted.</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="ex">ghci</span><span class="op">&gt;</span> case Foo1 (sum [1..100000000000000]) <span class="ex">of</span> Foo1 _ -<span class="op">&gt;</span> 0</a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="ex">0</span></a></code></pre></div>
<p>ということで以下のコードは <code>case</code> で <code>Foo1</code> とのパターンマッチは行われますが、 <code>undefined</code> は評価されない (する必要がない) ため <code>1</code> が返ってくることになります。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Foo1</span> <span class="fu">=</span> <span class="dt">Foo1</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">x1 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo1</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">     <span class="dt">Foo1</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">x1 <span class="fu">=</span> <span class="dv">1</span></a></code></pre></div>
<p><code>Haskell</code> のアプリケーションがスペースリークしてしまう原因は、主にこのデータ構造のサンクが原因になっている場合が多いようです。</p>
<h3 id="x2">x2</h3>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Foo2</span> <span class="fu">=</span> <span class="dt">Foo2</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">x2 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo2</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">     <span class="dt">Foo2</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>このコードには見慣れない <code>!</code> という記号が出てきました。</p>
<p>ここで抑えておくポイントは1つだけです。</p>
<ul>
<li><code>!</code> はサンクを潰してくれる (評価する) マークです。つまり、値が使われない場合でも評価されるということです。(計算が無駄になる場合も当然ある)</li>
</ul>
<p>以下の結果から、<code>Foo2</code> の値を作る時には、必ず先に <code>sum [1..100000000000000]</code> が計算されていることがわかります。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ex">ghci</span><span class="op">&gt;</span> Foo2 (sum [1..100000000000000])</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">^<span class="ex">CInterrupted.</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="ex">ghci</span><span class="op">&gt;</span> case Foo2 (sum [1..100000000000000]) <span class="ex">of</span> Foo2 i -<span class="op">&gt;</span> i</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">^<span class="ex">CInterrupted.</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="ex">ghci</span><span class="op">&gt;</span> case Foo2 (sum [1..100000000000000]) <span class="ex">of</span> Foo2 _ -<span class="op">&gt;</span> 0</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">^<span class="ex">CInterrupted.</span></a></code></pre></div>
<p>そのため、今回の結果は <code>undefined</code> になります。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Foo2</span> <span class="fu">=</span> <span class="dt">Foo2</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">x2 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo2</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">     <span class="dt">Foo2</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">x2 <span class="fu">=</span> undefined</a></code></pre></div>
<p>専門家は <code>undefined</code> のことを <code>bottom</code> (<code>⊥</code>) というテクニカルタームで呼ぶこともありますが、普通の人は <code>停止しない計算</code> や <code>エラー</code> という意味だと思えば十分です。(たぶん)</p>
<h3 id="x3">x3</h3>
<div class="sourceCode" id="cb13"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Foo3</span> <span class="fu">=</span> <span class="dt">Foo3</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">x3 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo3</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">     <span class="dt">Foo3</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>ここで抑えておくポイントは2つです。</p>
<ul>
<li><code>newtype</code> のデータコンストラクタは型チェックが終わったら剥がされる</li>
<li>そのため <code>newtype</code> は実行時に余分なコストが発生しない</li>
</ul>
<p>つまり、雰囲気はこんな感じです。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Nat</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2"></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="co">-- 型チェック前</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">x <span class="fu">=</span> <span class="dt">Nat</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5"></a>
<a class="sourceLine" id="cb14-6" data-line-number="6"><span class="co">-- 型チェック後</span></a>
<a class="sourceLine" id="cb14-7" data-line-number="7">x <span class="fu">=</span> <span class="dv">1</span></a></code></pre></div>
<p>Haskell の学習でわけわかんないポイントの1つに <code>type</code>, <code>newtype</code>, <code>data</code> の違いがあると思います。(少なくとも僕は最初全然わかりませんでした)</p>
<p>僕と同じように学習で困っている人は、以下の表で考えれば理解の手助けになるかもしれません。</p>
<div class="row">
<table class="col s8 offset-s2 centered">
<thead>
<tr>
<th>
</th>
<th>
型 (type)
</th>
<th>
値 (value)
</th>
<th>
具体例
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
type
</td>
<td>
X
</td>
<td>
X
</td>
<td>
<code>type FilePath = String</code>
</td>
</tr>
<tr>
<td>
newtype
</td>
<td>
O
</td>
<td>
X
</td>
<td>
<code>newtype Nat = Nat Int</code>
</td>
</tr>
<tr>
<td>
data
</td>
<td>
O
</td>
<td>
O
</td>
<td>
<code>data Bool = True | False</code>
</td>
</tr>
</tbody>
</table>
</div>
<p><code>X</code> は既存の型や値を再利用する、<code>O</code> は型や値を新しく作るという意味です。</p>
<ul>
<li><code>type</code> は型も値も既存のものを再利用します。</li>
<li><code>newtype</code> は型は新しく作りますが、値は既存のものを再利用します。</li>
<li><code>data</code> は型も値も新しく作ります。</li>
</ul>
<p>ということで、このように変形できます。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Foo3</span> <span class="fu">=</span> <span class="dt">Foo3</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="co">-- 定義</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">x3 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo3</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">     <span class="dt">Foo3</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6"></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="co">-- newtype なので</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">x3 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb15-9" data-line-number="9"></a>
<a class="sourceLine" id="cb15-10" data-line-number="10"><span class="co">-- 1 を返すために undefined を評価する必要が無いため</span></a>
<a class="sourceLine" id="cb15-11" data-line-number="11">x3 <span class="fu">=</span> <span class="dv">1</span></a></code></pre></div>
<h3 id="y1">y1</h3>
<div class="sourceCode" id="cb16"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Foo1</span> <span class="fu">=</span> <span class="dt">Foo1</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">y1 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">     <span class="dt">Foo1</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>この場合は <code>case</code> 式で <code>Foo1 _</code> のパターンマッチを行う際に <code>undefined</code> の評価をしなければならないため <code>y1</code> は <code>undefined</code> になります。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">y1 <span class="fu">=</span> undefined</a></code></pre></div>
<h3 id="y2">y2</h3>
<div class="sourceCode" id="cb18"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Foo2</span> <span class="fu">=</span> <span class="dt">Foo2</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2"></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">y2 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">     <span class="dt">Foo2</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>この場合も <code>y1</code> と同じケースです。やはり <code>Foo1</code> のパターンマッチが発生するため <code>undefined</code> です。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">y2 <span class="fu">=</span> undefined</a></code></pre></div>
<h3 id="y3">y3</h3>
<div class="sourceCode" id="cb20"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Foo3</span> <span class="fu">=</span> <span class="dt">Foo3</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">y3 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4">     <span class="dt">Foo3</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>この結果が一番おもしろい気がしますが、これは <code>1</code> を返します。</p>
<p>今までの話から <code>Foo3</code> は実行時には存在しないコンストラクタです。すなわち実行時にはこのような形式になります。</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1">y3 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">     _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>これは <code>x3</code> の場合と同じですね。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1">y3 <span class="fu">=</span> <span class="dv">1</span></a></code></pre></div>
<h3 id="yint">yInt</h3>
<div class="sourceCode" id="cb23"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">int ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">int <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb23-3" data-line-number="3"></a>
<a class="sourceLine" id="cb23-4" data-line-number="4">yInt <span class="fu">=</span> <span class="kw">case</span> int <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">       _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>ここまで来たらこれはもう簡単ですよね！</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1">yInt <span class="fu">=</span> <span class="dv">1</span></a></code></pre></div>
<h2 id="まとめ">まとめ</h2>
<p>解説がとても長くなってしまいました・・・。間違ってたらご報告ください。</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Haskell Quiz はじめました。 No.1 type, newtype, data</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-24-quiz-1.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-24-quiz-1.html</id>
    <published>2018-03-24T00:00:00Z</published>
    <updated>2018-03-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>何となくクイズはじめました！(頑張って続けます・・・)</p>
<p>間違ってたら <code>twitter</code> や <a href="https://github.com/e-bigmoon/haskell-blog/issues">github の issue</a> で教えてください！</p>
<!--more-->
<h2 id="haskell-quiz-no.1-type-newtype-data">Haskell Quiz No.1 type, newtype, data</h2>
<p>難易度: λλλ</p>
<p>元ネタは <code>Haskell wiki</code> だったと思いますが、忘れてしまいました・・・。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Foo</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Foo1</span> <span class="fu">=</span> <span class="dt">Foo1</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">data</span> <span class="dt">Foo2</span> <span class="fu">=</span> <span class="dt">Foo2</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">newtype</span> <span class="dt">Foo3</span> <span class="fu">=</span> <span class="dt">Foo3</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">x1 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo1</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">     <span class="dt">Foo1</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">x2 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo2</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">     <span class="dt">Foo2</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">x3 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo3</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">     <span class="dt">Foo3</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15"></a>
<a class="sourceLine" id="cb1-16" data-line-number="16">y1 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17">     <span class="dt">Foo1</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18"></a>
<a class="sourceLine" id="cb1-19" data-line-number="19">y2 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-20" data-line-number="20">     <span class="dt">Foo2</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-21" data-line-number="21"></a>
<a class="sourceLine" id="cb1-22" data-line-number="22">y3 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23">     <span class="dt">Foo3</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-24" data-line-number="24"></a>
<a class="sourceLine" id="cb1-25" data-line-number="25"><span class="ot">int ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-26" data-line-number="26">int <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb1-27" data-line-number="27"></a>
<a class="sourceLine" id="cb1-28" data-line-number="28">yInt <span class="fu">=</span> <span class="kw">case</span> int <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-29" data-line-number="29">       _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>以下の値はそれぞれ何になるでしょう？</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">x1   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">x2   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">x3   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">y1   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">y2   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">y3   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">yInt <span class="fu">=</span> <span class="fu">???</span></a></code></pre></div>
<p>全部正解できたら普通にすごいです。</p>
<p>答えは<a href="./03-25-quiz-2.html">次回</a>！</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>アプリケーションのバージョンに Git の情報を出してみよう！</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-20-gitrev.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-20-gitrev.html</id>
    <published>2018-03-20T00:00:00Z</published>
    <updated>2018-03-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>今回は <a href="https://www.stackage.org/package/gitrev">gitrev</a> パッケージと <a href="https://www.stackage.org/package/optparse-simple">optparse-simple</a> パッケージを使ってアプリケーションに <code>Git</code> の情報を含めてみようと思います！</p>
<p>利用者の多いアプリケーションだと、バグ報告時にどのコミットでビルドしたものなのか知りたい場合に便利です。</p>
<p>表示されるバージョン情報はこんな感じになります。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot"># gitrev の例</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="fu">$</span> <span class="fu">./</span>Main.hs</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">Main.hs<span class="fu">:</span> [panic master<span class="fu">@</span>3a0bd17fdfb8a3e334292a560280e8e0791e941c (<span class="dt">Tue</span> <span class="dt">Mar</span> <span class="dv">20</span> <span class="dv">02</span><span class="fu">:</span><span class="dv">00</span><span class="fu">:</span><span class="dv">17</span> <span class="dv">2018</span> <span class="fu">+</span><span class="dv">0900</span>) (<span class="dv">1</span> commits <span class="kw">in</span> <span class="dt">HEAD</span>)]</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot"># optparse-simple の例</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="fu">$</span> stack exec <span class="co">-- example-version-exe</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="dt">Version</span> <span class="fl">0.1</span><span class="fu">.</span><span class="fl">0.0</span>, <span class="dt">Git</span> revision <span class="fl">341e785</span>b02c4c599f64b922b4aa9cfff3c006945</a></code></pre></div>
<p>以下のアプリケーション等でも利用されているように、実用度はとても高めです。</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack">stack</a></li>
<li><a href="https://github.com/haskell/haskell-ide-engine">hie</a></li>
<li><a href="https://github.com/ucsd-progsys/liquidhaskell">liquidhaskell</a></li>
</ul>
<p>また、実装コストもそれほどかからないため、オススメです！</p>
<!--more-->
<h2 id="gitrev-パッケージ">gitrev パッケージ</h2>
<p><a href="https://www.stackage.org/haddock/lts-11.1/gitrev-1.3.1/Development-GitRev.html">gitrev</a> パッケージは <code>Template Haskell</code> の機能を使ってコンパイル時に以下の情報を取得可能です。</p>
<ul>
<li>ブランチ名および、タグ名</li>
<li>コミット数</li>
<li>コミット日</li>
<li>コミットの describe</li>
<li>コミットのハッシュ</li>
</ul>
<p>そのため、表示する情報を自分の好きなようにカスタマイズしたい場合に便利でしょう。</p>
<h3 id="サンプルアプリケーション">サンプルアプリケーション</h3>
<p>以下のコードは <code>Hackage</code> に載っているコードです。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">-- stack --resolver lts-11.1 script</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Development.GitRev</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="ot">panic ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">panic msg <span class="fu">=</span> error panicMsg</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  <span class="kw">where</span> panicMsg <span class="fu">=</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">          concat [ <span class="st">&quot;[panic &quot;</span>, <span class="fu">$</span>(gitBranch), <span class="st">&quot;@&quot;</span>, <span class="fu">$</span>(gitHash)</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">                 , <span class="st">&quot; (&quot;</span>, <span class="fu">$</span>(gitCommitDate), <span class="st">&quot;)&quot;</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">                 , <span class="st">&quot; (&quot;</span>, <span class="fu">$</span>(gitCommitCount), <span class="st">&quot; commits in HEAD)&quot;</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">                 , dirty, <span class="st">&quot;] &quot;</span>, msg ]</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">        dirty <span class="fu">|</span> <span class="fu">$</span>(gitDirty) <span class="fu">=</span> <span class="st">&quot; (uncommitted files present)&quot;</span></a>
<a class="sourceLine" id="cb2-14" data-line-number="14">              <span class="fu">|</span> otherwise   <span class="fu">=</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15"></a>
<a class="sourceLine" id="cb2-16" data-line-number="16">main <span class="fu">=</span> panic <span class="st">&quot;oh no!&quot;</span></a></code></pre></div>
<p>実際に実行してみましょう。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1">$ <span class="ex">tree</span> .</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="ex">.</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">└── <span class="ex">Main.hs</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ex">0</span> directories, 1 file</a>
<a class="sourceLine" id="cb3-6" data-line-number="6"></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">$ <span class="fu">chmod</span> u+x Main.hs</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">$ <span class="ex">./Main.hs</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9"><span class="ex">Main.hs</span>: [panic UNKNOWN@UNKNOWN (UNKNOWN) <span class="kw">(</span><span class="ex">UNKNOWN</span> commits in HEAD<span class="kw">)</span>] <span class="ex">oh</span> no!</a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="ex">CallStack</span> (from HasCallStack)<span class="bu">:</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">  <span class="ex">error</span>, called at /home/bm12/Desktop/gitrev-sample/Main.hs:7:13 in main:Main</a></code></pre></div>
<p>現状は <code>git</code> のコミットが無いため、全て <code>UNKNOWN</code> として表示されています。</p>
<p>実際に <code>git</code> リポジトリを作ってコミットしてみましょう。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1">$ <span class="fu">git</span> init</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ex">Initialized</span> empty Git repository in /home/bm12/Desktop/gitrev-sample/.git/</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">$ <span class="fu">git</span> add -A</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">$ <span class="fu">git</span> commit -m <span class="st">&quot;TEST&quot;</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">[<span class="ex">master</span> (root-commit) <span class="ex">3a0bd17</span>] TEST</a>
<a class="sourceLine" id="cb4-7" data-line-number="7"> <span class="ex">1</span> file changed, 16 insertions(+)</a>
<a class="sourceLine" id="cb4-8" data-line-number="8"> <span class="ex">create</span> mode 100755 Main.hs</a>
<a class="sourceLine" id="cb4-9" data-line-number="9"></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">$ <span class="ex">./Main.hs</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11"><span class="ex">Main.hs</span>: [panic master@3a0bd17fdfb8a3e334292a560280e8e0791e941c (Tue Mar 20 02:00:17 2018 +0900) <span class="kw">(</span><span class="ex">1</span> commits in HEAD<span class="kw">)</span>] <span class="ex">oh</span> no!</a></code></pre></div>
<p>こんな感じで <code>git</code> の情報を自由に組み合わせることができます。</p>
<h2 id="optparse-simple-パッケージ">optparse-simple パッケージ</h2>
<p>あまり書式を気にせず、定形で良い場合はもっと簡単な方法があります。</p>
<p>それは <code>optparse-simple</code> パッケージの <a href="https://www.stackage.org/haddock/lts-11.1/optparse-simple-0.1.0/Options-Applicative-Simple.html#v:simpleVersion">simpleVersion</a> を使う方法です。</p>
<p><code>simpleVersion</code> では <code>git</code> の情報だけでなく、アプリケーションのバージョンも一緒に表示することができます。</p>
<h3 id="simpleversion">simpleVersion</h3>
<p><a href="https://www.stackage.org/haddock/lts-11.1/optparse-simple-0.1.0/src/Options.Applicative.Simple.html#simpleVersion">simpleVersion</a> の定義は以下のようになっています。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">simpleVersion ::</span> <span class="dt">Version</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">simpleVersion version <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  [<span class="fu">|</span>concat ([<span class="st">&quot;Version &quot;</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">           ,<span class="fu">$</span>(TH.lift <span class="fu">$</span> showVersion version)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">           ] <span class="fu">++</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">           <span class="kw">if</span> <span class="fu">$</span>gitHash <span class="fu">==</span> (<span class="st">&quot;UNKNOWN&quot;</span><span class="ot"> ::</span> <span class="dt">String</span>)</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">             <span class="kw">then</span> []</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">             <span class="kw">else</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">               [<span class="st">&quot;, Git revision &quot;</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">               ,<span class="fu">$</span>gitHash</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">               ,<span class="kw">if</span> <span class="fu">$</span>gitDirty</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">                   <span class="kw">then</span> <span class="st">&quot; (dirty)&quot;</span></a>
<a class="sourceLine" id="cb5-13" data-line-number="13">                   <span class="kw">else</span> <span class="st">&quot;&quot;</span></a>
<a class="sourceLine" id="cb5-14" data-line-number="14">               ])<span class="fu">|</span>]</a></code></pre></div>
<p><code>$gitHash</code> や <code>$gitDirty</code> を見ればわかる通り、内部的に <code>gitrev</code> パッケージを利用して <code>git</code> の情報を取得しています。</p>
<p>また、第一引数の <code>Version</code> 型は <code>base</code> パッケージの <a href="https://www.stackage.org/haddock/lts-11.1/base-4.10.1.0/Data-Version.html">Data.Version</a> で定義されている型です。</p>
<p>以下のように <code>makeVersion :: [Int] -&gt; Version</code> 関数を使って <code>Version</code> 型の値を作ることができます。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">{-# LANGUAGE TemplateHaskell   #-}</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Options.Applicative.Simple</span> (simpleVersion)</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="kw">import</span>           <span class="dt">Data.Version</span> (makeVersion)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">main <span class="fu">=</span> putStrLn <span class="fu">$</span>(simpleVersion <span class="fu">$</span> makeVersion [<span class="dv">100</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>])</a></code></pre></div>
<p>適当にプロジェクトを作って、上記の内容を実行してみましょう。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" data-line-number="1">$ <span class="ex">stack</span> exec example-exe </a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ex">Version</span> 100.0.0.0</a></code></pre></div>
<p>まだ <code>git</code> で管理していないため、バージョン情報のみが表示されます。</p>
<p>では、先ほどの例と同様に <code>git</code> リポジトリを作ってコミットした結果を見てみましょう。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" data-line-number="1">$ <span class="fu">git</span> init</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ex">Initialized</span> empty Git repository in /home/bm12/Desktop/gitrev-sample/.git/</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">$ <span class="fu">git</span> add -A</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">$ <span class="fu">git</span> commit -m <span class="st">&quot;TEST&quot;</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">[<span class="ex">master</span> (root-commit) <span class="ex">3a0bd17</span>] TEST</a>
<a class="sourceLine" id="cb8-7" data-line-number="7"> <span class="ex">1</span> file changed, 16 insertions(+)</a>
<a class="sourceLine" id="cb8-8" data-line-number="8"> <span class="ex">create</span> mode 100755 Main.hs</a>
<a class="sourceLine" id="cb8-9" data-line-number="9"></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">$ <span class="ex">stack</span> clean</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">$ <span class="ex">stack</span> build</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">$ <span class="ex">stack</span> exec example-exe </a>
<a class="sourceLine" id="cb8-13" data-line-number="13"><span class="ex">Version</span> 100.0.0.0, Git revision e106394f7fdded0c9908cbf8edc87c5d5d5b4309</a></code></pre></div>
<p>このようにちゃんとリビジョンが表示されるようになりました。</p>
<h3 id="アプリケーションのバージョンを自動的に更新する">アプリケーションのバージョンを自動的に更新する</h3>
<p>アプリケーションのリリースごとに <code>makeVersion</code> を使って更新する作業はとても面倒ですし、いつか間違えてしまうかもしれません。</p>
<p>これを解決するためには <code>.cabal</code> ファイルからバージョン情報を自動取得して <code>simpleVersion</code> 関数に渡してあげるようにすれば良いのです。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">{-# LANGUAGE TemplateHaskell   #-}</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Options.Applicative.Simple</span> (simpleVersion)</a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Paths_XXXX</span>               <span class="kw">as</span> <span class="dt">Meta</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"></a>
<a class="sourceLine" id="cb9-6" data-line-number="6"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">main <span class="fu">=</span> putStrLn <span class="fu">$</span>(simpleVersion Meta.version)</a></code></pre></div>
<p><code>Paths_XXXX</code> の <code>XXXX</code> はアプリケーション名 (<code>cabal</code> ファイルの <code>name</code> の値) を指定します。これで <code>cabal</code> ファイルのバージョン情報を直接取得できるようになります。</p>
<p>表示される結果はこんな感じです。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb10-1" data-line-number="1">$ <span class="ex">stack</span> exec -- example-version-exe</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ex">Version</span> 0.1.0.0, Git revision 341e785b02c4c599f64b922b4aa9cfff3c006945</a></code></pre></div>
<p>めちゃめちゃ簡単なのでオススメの方法です。</p>
<h2 id="まとめ">まとめ</h2>
<p>自分のアプリケーションがとてもカッコよくなるので是非ためしてみてください！</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Yesod v1.6 のサブサイト</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-19-yesod-subsite.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-19-yesod-subsite.html</id>
    <published>2018-03-19T00:00:00Z</published>
    <updated>2018-03-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>今回は <code>Yesod</code> を使っているマニア向け情報です。</p>
<p><code>Yesod</code> にはサブサイトという機能があり、Yesod Book の <a href="https://www.yesodweb.com/book/creating-a-subsite">Creating a Subsite</a> で一通りの使い方が説明されています。</p>
<p>簡単に言えば、異なる <code>Yesod</code> アプリケーションで共通のコンポーネント (認証システム等) を利用するために使えるようです。</p>
<p><code>scaffolded site</code> を使っている人は <a href="https://www.stackage.org/lts-11.1/package/yesod-static-1.6.0">yesod-static</a> パッケージで提供されている <code>Static</code> 型をサブサイトとして利用していることでしょう。</p>
<p><code>Yesod</code> のバージョンが <code>1.6</code> に上がった影響により <code>Yesod Book</code> の内容がそのままでは動かなくなっていたため、コードを修正して実際に動かしてみたいと思います。</p>
<!--more-->
<h2 id="修正ポイント">修正ポイント</h2>
<ul>
<li><code>HandlerT site IO a</code> のような形式は何も考えずに <code>HandlerFor site a</code> に書き換える</li>
<li>サブサイトのハンドラ関数の型は <code>SubHandlerFor sub master a</code> という形式に書き換える</li>
<li><code>HandlerFor</code> から <code>SubHandlerFor</code> へ持ち上げる時は <code>liftHandler</code> を使う</li>
<li>サブサイトの <code>YesodDispatch</code> 型クラスのインスタンスは <code>HandlerT</code> ではなく <code>instance Yesod master =&gt; YesodSubDispatch HelloSub master where</code> のように <code>Yesod</code> 型クラスのインスタンスを直接指定できるようになった</li>
</ul>
<h2 id="修正後のソースコード">修正後のソースコード</h2>
<p>ここでは公式サイトのコードと同様のディレクトリ構造及び、ファイル名とします。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1">$ <span class="ex">tree</span> .</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ex">.</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">├── <span class="ex">HelloSub</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">│   └── <span class="ex">Data.hs</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">├── <span class="ex">HelloSub.hs</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">└── <span class="ex">Main.hs</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="ex">1</span> directory, 3 files</a></code></pre></div>
<p>ファイルを分割しているのは <code>TH</code> の <code>GHC stage restriction</code> を回避するためです。</p>
<h3 id="hellosubdata.hs">HelloSub/Data.hs</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">{-# LANGUAGE QuasiQuotes     #-}</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ot">{-# LANGUAGE TypeFamilies    #-}</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">module</span> <span class="dt">HelloSub.Data</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Yesod</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="kw">data</span> <span class="dt">HelloSub</span> <span class="fu">=</span> <span class="dt">HelloSub</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">mkYesodSubData <span class="st">&quot;HelloSub&quot;</span> [parseRoutes|</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">/ SubHomeR GET</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">|]</a></code></pre></div>
<p>サブサイトのファウンデーション型 <code>HelloSub</code> とルートを定義しています。</p>
<p>通常であれば <code>mkYesod</code> を利用しますが <code>mkYesodSubData</code> を利用している点がサブサイトの特徴です。</p>
<h3 id="hellosub.hs">HelloSub.hs</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">{-# LANGUAGE FlexibleInstances     #-}</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="ot">{-# LANGUAGE OverloadedStrings     #-}</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ot">{-# LANGUAGE QuasiQuotes           #-}</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">{-# LANGUAGE TemplateHaskell       #-}</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="kw">module</span> <span class="dt">HelloSub</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  ( <span class="kw">module</span> <span class="dt">HelloSub.Data</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">  , <span class="kw">module</span> <span class="dt">HelloSub</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">  ) <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10"></a>
<a class="sourceLine" id="cb3-11" data-line-number="11"><span class="kw">import</span>           <span class="dt">HelloSub.Data</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12"><span class="kw">import</span>           <span class="dt">Yesod</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13"><span class="kw">import</span>           <span class="dt">Yesod.Core.Types</span></a>
<a class="sourceLine" id="cb3-14" data-line-number="14"></a>
<a class="sourceLine" id="cb3-15" data-line-number="15"><span class="ot">getSubHomeR ::</span> <span class="dt">Yesod</span> master <span class="ot">=&gt;</span> <span class="dt">SubHandlerFor</span> <span class="dt">HelloSub</span> master <span class="dt">Html</span></a>
<a class="sourceLine" id="cb3-16" data-line-number="16">getSubHomeR <span class="fu">=</span> liftHandler <span class="fu">$</span> defaultLayout [whamlet|Welcome to the subsite!|]</a>
<a class="sourceLine" id="cb3-17" data-line-number="17"></a>
<a class="sourceLine" id="cb3-18" data-line-number="18"><span class="kw">instance</span> <span class="dt">Yesod</span> master <span class="ot">=&gt;</span> <span class="dt">YesodSubDispatch</span> <span class="dt">HelloSub</span> master <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-19" data-line-number="19">  yesodSubDispatch <span class="fu">=</span> <span class="fu">$</span>(mkYesodSubDispatch resourcesHelloSub)</a></code></pre></div>
<p>サブサイトのハンドラと <code>dispatch</code> の定義です。</p>
<p><code>resourcesHelloSub</code> は <code>HelloSub/Data.hs</code> で定義した <code>mkYesodSubData</code> でコンパイル時に自動生成されます。</p>
<h3 id="main.hs">Main.hs</h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="co">-- stack --resolver lts-11.0 script --package yesod-core --package yesod</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="ot">{-# LANGUAGE QuasiQuotes       #-}</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="ot">{-# LANGUAGE TemplateHaskell   #-}</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="ot">{-# LANGUAGE TypeFamilies      #-}</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">HelloSub</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="kw">import</span>           <span class="dt">Yesod</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10"></a>
<a class="sourceLine" id="cb4-11" data-line-number="11"><span class="kw">data</span> <span class="dt">Master</span> <span class="fu">=</span> <span class="dt">Master</span></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">  {<span class="ot"> getHelloSub ::</span> <span class="dt">HelloSub</span></a>
<a class="sourceLine" id="cb4-13" data-line-number="13">  }</a>
<a class="sourceLine" id="cb4-14" data-line-number="14"></a>
<a class="sourceLine" id="cb4-15" data-line-number="15">mkYesod <span class="st">&quot;Master&quot;</span> [parseRoutes|</a>
<a class="sourceLine" id="cb4-16" data-line-number="16">/ HomeR GET</a>
<a class="sourceLine" id="cb4-17" data-line-number="17">/subsite SubsiteR HelloSub getHelloSub</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">|]</a>
<a class="sourceLine" id="cb4-19" data-line-number="19"></a>
<a class="sourceLine" id="cb4-20" data-line-number="20"><span class="kw">instance</span> <span class="dt">Yesod</span> <span class="dt">Master</span></a>
<a class="sourceLine" id="cb4-21" data-line-number="21"></a>
<a class="sourceLine" id="cb4-22" data-line-number="22"><span class="ot">getHomeR ::</span> <span class="dt">HandlerFor</span> <span class="dt">Master</span> <span class="dt">Html</span></a>
<a class="sourceLine" id="cb4-23" data-line-number="23">getHomeR <span class="fu">=</span> defaultLayout</a>
<a class="sourceLine" id="cb4-24" data-line-number="24">  [whamlet|</a>
<a class="sourceLine" id="cb4-25" data-line-number="25">    <span class="kw">&lt;h1&gt;</span>Welcome to the homepage</a>
<a class="sourceLine" id="cb4-26" data-line-number="26">    <span class="kw">&lt;p&gt;</span></a>
<a class="sourceLine" id="cb4-27" data-line-number="27">      Feel free to visit the #</a>
<a class="sourceLine" id="cb4-28" data-line-number="28">      <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="kw">@{</span><span class="dt">SubsiteR</span> <span class="dt">SubHomeR</span><span class="kw">}&gt;</span>subsite</a>
<a class="sourceLine" id="cb4-29" data-line-number="29">      \ as well.</a>
<a class="sourceLine" id="cb4-30" data-line-number="30">  |]</a>
<a class="sourceLine" id="cb4-31" data-line-number="31"></a>
<a class="sourceLine" id="cb4-32" data-line-number="32">main <span class="fu">=</span> warp <span class="dv">3000</span> <span class="fu">$</span> <span class="dt">Master</span> <span class="dt">HelloSub</span></a></code></pre></div>
<p>重要なポイントは以下の3点です。</p>
<ul>
<li><code>Master</code> ファウンデーション型にサブサイトの型を含ませる (さらにアクセサ <code>getHelloSub</code> を定義)</li>
<li><code>/subsite SubsiteR HelloSub getHelloSub</code> という形式でサブサイトへのルートを定義</li>
<li>サブサイトへの参照は <code>@{SubsiteR SubHomeR}</code> という形式の型安全URLとなる</li>
</ul>
<h2 id="実行">実行</h2>
<p><code>stack interpreter</code> 形式で実行します。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" data-line-number="1">$ <span class="fu">chmod</span> u+x Main.hs</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">$ <span class="ex">./Main.hs</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="ex">19/Mar</span>/2018:<span class="ex">00</span>:37:27 +0900 [Info#yesod-core] Application launched @(yesod-core-1.6.2-JztYji0NiLuH8rcbB3eMBP:Yesod.Core.Dispatch ./Yesod/Core/Dispatch.hs:167:11)</a></code></pre></div>
<p>この状態で <a href="http://localhost:3000/" class="uri">http://localhost:3000/</a> にアクセスしてみましょう。以下のようなページが表示されるはずです。</p>
<figure>
<img src="/images/2018/03-19/img01.png" alt="トップページ" /><figcaption>トップページ</figcaption>
</figure>
<p>サブサイトにアクセスするとこんな感じです。</p>
<figure>
<img src="/images/2018/03-19/img02.png" alt="サブサイト" /><figcaption>サブサイト</figcaption>
</figure>
<h2 id="scaffolded-site">Scaffolded Site</h2>
<p>ここではさらに一歩踏み込んで <code>Scaffolded Site</code> を利用する際、どのファイルに何を書いたら良いのか簡単に解説しておこうと思います。</p>
<p><code>Scaffolded Site</code> は一番素朴な <code>yesod-simple</code> を利用することとします。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" data-line-number="1">$ <span class="ex">stack</span> new example-subsite yesod-simple</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">$ <span class="bu">cd</span> example-subsite</a></code></pre></div>
<p>サブサイトの内容は上記で定義した内容を再利用します。</p>
<h3 id="stack.yaml">stack.yaml</h3>
<div class="sourceCode" id="cb7"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="fu">resolver:</span><span class="at"> lts-11.0</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="fu">packages:</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="kw">-</span> .</a></code></pre></div>
<p>現状落ちてくるものは <code>yesod-1.6.0</code> ではないので、書き換えます。</p>
<h3 id="package.yaml">package.yaml</h3>
<div class="sourceCode" id="cb8"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="fu">dependencies:</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">-</span> base</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="kw">-</span> classy-prelude-yesod</a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="kw">-</span> yesod</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="kw">-</span> yesod-core</a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="kw">-</span> yesod-static</a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="kw">-</span> yesod-form</a>
<a class="sourceLine" id="cb8-8" data-line-number="8"><span class="kw">-</span> classy-prelude</a>
<a class="sourceLine" id="cb8-9" data-line-number="9"><span class="kw">-</span> classy-prelude-conduit</a>
<a class="sourceLine" id="cb8-10" data-line-number="10"><span class="kw">-</span> bytestring</a>
<a class="sourceLine" id="cb8-11" data-line-number="11"><span class="kw">-</span> text</a>
<a class="sourceLine" id="cb8-12" data-line-number="12"><span class="kw">-</span> template-haskell</a>
<a class="sourceLine" id="cb8-13" data-line-number="13"><span class="kw">-</span> shakespeare</a>
<a class="sourceLine" id="cb8-14" data-line-number="14"><span class="kw">-</span> hjsmin</a>
<a class="sourceLine" id="cb8-15" data-line-number="15"><span class="kw">-</span> monad-control</a>
<a class="sourceLine" id="cb8-16" data-line-number="16"><span class="kw">-</span> wai-extra</a>
<a class="sourceLine" id="cb8-17" data-line-number="17"><span class="kw">-</span> yaml</a>
<a class="sourceLine" id="cb8-18" data-line-number="18"><span class="kw">-</span> http-conduit</a>
<a class="sourceLine" id="cb8-19" data-line-number="19"><span class="kw">-</span> directory</a>
<a class="sourceLine" id="cb8-20" data-line-number="20"><span class="kw">-</span> warp</a>
<a class="sourceLine" id="cb8-21" data-line-number="21"><span class="kw">-</span> data-default</a>
<a class="sourceLine" id="cb8-22" data-line-number="22"><span class="kw">-</span> aeson</a>
<a class="sourceLine" id="cb8-23" data-line-number="23"><span class="kw">-</span> conduit</a>
<a class="sourceLine" id="cb8-24" data-line-number="24"><span class="kw">-</span> monad-logger</a>
<a class="sourceLine" id="cb8-25" data-line-number="25"><span class="kw">-</span> fast-logger</a>
<a class="sourceLine" id="cb8-26" data-line-number="26"><span class="kw">-</span> wai-logger</a>
<a class="sourceLine" id="cb8-27" data-line-number="27"><span class="kw">-</span> file-embed</a>
<a class="sourceLine" id="cb8-28" data-line-number="28"><span class="kw">-</span> safe</a>
<a class="sourceLine" id="cb8-29" data-line-number="29"><span class="kw">-</span> unordered-containers</a>
<a class="sourceLine" id="cb8-30" data-line-number="30"><span class="kw">-</span> containers</a>
<a class="sourceLine" id="cb8-31" data-line-number="31"><span class="kw">-</span> vector</a>
<a class="sourceLine" id="cb8-32" data-line-number="32"><span class="kw">-</span> time</a>
<a class="sourceLine" id="cb8-33" data-line-number="33"><span class="kw">-</span> case-insensitive</a>
<a class="sourceLine" id="cb8-34" data-line-number="34"><span class="kw">-</span> wai</a>
<a class="sourceLine" id="cb8-35" data-line-number="35"><span class="kw">-</span> foreign-store</a></code></pre></div>
<p>バージョンを全部消しただけです。</p>
<h3 id="srcfoundation.hs">src/Foundation.hs</h3>
<p><code>App</code> データ型にサブサイトを含め、さらに <code>import</code> を追加します。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">import</span> <span class="dt">HelloSub</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="kw">data</span> <span class="dt">App</span> <span class="fu">=</span> <span class="dt">App</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  {<span class="ot"> appSettings    ::</span> <span class="dt">AppSettings</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  ,<span class="ot"> appStatic      ::</span> <span class="dt">Static</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  ,<span class="ot"> appHttpManager ::</span> <span class="dt">Manager</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  ,<span class="ot"> appLogger      ::</span> <span class="dt">Logger</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">  ,<span class="ot"> getHelloSub    ::</span> <span class="dt">HelloSub</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">  }</a></code></pre></div>
<p><code>yesod-1.6.0</code> した影響でコンパイルエラーが出るため、<code>shouldLog</code> をコメントアウトします。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">    <span class="co">-- shouldLog app _source level =</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">    <span class="co">--     appShouldLogAll (appSettings app)</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">    <span class="co">--         || level == LevelWarn</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">    <span class="co">--         || level == LevelError</span></a></code></pre></div>
<h3 id="configroute">config/route</h3>
<p>サブサイトへのルートを追加します。</p>
<pre class="txt"><code>/subsite SubsiteR HelloSub getHelloSub</code></pre>
<h3 id="srcapplication.hs">src/Application.hs</h3>
<p>以下の2点を追記します。</p>
<ul>
<li><code>import HelloSub</code> を追加</li>
<li><code>makeFoundation</code> 関数に <code>let getHelloSub = HelloSub</code> を追記</li>
</ul>
<div class="sourceCode" id="cb12"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">import</span> <span class="dt">HelloSub</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="ot">makeFoundation ::</span> <span class="dt">AppSettings</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">App</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">makeFoundation appSettings <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  <span class="kw">let</span> getHelloSub <span class="fu">=</span> <span class="dt">HelloSub</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">  appHttpManager <span class="ot">&lt;-</span> newManager</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">  appLogger <span class="ot">&lt;-</span> newStdoutLoggerSet defaultBufSize <span class="fu">&gt;&gt;=</span> makeYesodLogger</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">  appStatic <span class="ot">&lt;-</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">    (<span class="kw">if</span> appMutableStatic appSettings <span class="kw">then</span> staticDevel <span class="kw">else</span> static)</a>
<a class="sourceLine" id="cb12-11" data-line-number="11">    (appStaticDir appSettings)</a>
<a class="sourceLine" id="cb12-12" data-line-number="12"></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">  return <span class="dt">App</span> {<span class="fu">..</span>}</a></code></pre></div>
<p><code>App {..}</code> は <code>GHC</code> の <code>RecordWildCards</code> 言語拡張です。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Example</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  { a <span class="fu">=</span> a</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  , b <span class="fu">=</span> b</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  , c <span class="fu">=</span> c</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  }</a></code></pre></div>
<p>僕はあまり使いませんが、雰囲気はこんな感じです。</p>
<h3 id="実行-1">実行</h3>
<div class="sourceCode" id="cb14"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb14-1" data-line-number="1">$ <span class="ex">stack</span> build</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">$ <span class="ex">stack</span> exec example-subsite</a></code></pre></div>
<p><a href="http://localhost:3000/subsite" class="uri">http://localhost:3000/subsite</a> にアクセスすると次のような画面が現れます。</p>
<figure>
<img src="/images/2018/03-19/img03.png" alt="実行結果" /><figcaption>実行結果</figcaption>
</figure>
<h2 id="まとめ">まとめ</h2>
<p><code>Yesod</code> を使っていてもサブサイトについて知らないという人は多いと思いますが、<code>Yesod</code> のアプリケーションが増えてきた時に使える、とても便利な仕組みだと思います。</p>
<p>サブサイトについて、もっと詳しく知りたい人は <a href="https://www.stackage.org/lts-11.1/package/yesod-static-1.6.0">yesod-static</a> パッケージの実装を見てみると良いでしょう。</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>extra-deps に github の短縮形が指定できるようになります</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-13-stack-extra-deps-shorthand.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-13-stack-extra-deps-shorthand.html</id>
    <published>2018-03-13T00:00:00Z</published>
    <updated>2018-03-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>今日マージされた <a href="https://github.com/commercialhaskell/stack/pull/3890">Allow ‘github’ shorthand for extra-deps (fixes #3873) #3890</a> がとても便利だと思いますのでご紹介します。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1">$ <span class="ex">stack</span> --version</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ex">Version</span> 1.7.0, Git revision 4a140342f9b28005bf2fdd5335bdcd32c9370265 (5702 commits) <span class="ex">x86_64</span> hpack-0.21.2</a></code></pre></div>
<!--more-->
<p><code>stack.yaml</code> に記述する <code>extra-deps</code> は主に2つの理由で記述することが多いです。</p>
<ul>
<li><code>lts</code> に含まれていないパッケージのバージョンを指定するため</li>
<li>そもそも <code>Hackage</code> に上がっていないパッケージを使うため</li>
</ul>
<p>今回は <code>extra-deps</code> の指定方法に <code>github</code> 専用の短縮形が導入されました。</p>
<p>こんな感じで指定可能です。(コミットの短縮形はいつから使えていたのかわかりませんが、使えます)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="fu">extra-deps:</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">-</span> <span class="fu">github:</span><span class="at"> haskell/text</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="fu">commit:</span><span class="at"> 9fac5d</span></a></code></pre></div>
<p>1.6.5 ではまだ利用できない機能となっております。</p>
<h2 id="試し方">試し方</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1">$ <span class="ex">stack</span> upgrade --git</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="co"># コンパイルするので時間かかります</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">$ <span class="ex">stack</span> --version</a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ex">Version</span> 1.7.0, Git revision 4a140342f9b28005bf2fdd5335bdcd32c9370265 (5702 commits) <span class="ex">x86_64</span> hpack-0.21.2</a></code></pre></div>
<p>遊んでから、元の <code>stack</code> のバージョンに戻す時は以下のようにするだけです。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1">$ <span class="ex">stack</span> upgrade --binary-version 1.6.5</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ex">...</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">$ <span class="ex">stack</span> --version</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="ex">Version</span> 1.6.5, Git revision 24ab0d6ff07f28276e082c3ce74dfdeb1a2ca9e9 (5514 commits) <span class="ex">x86_64</span> hpack-0.20.0</a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="co"># バイナリが落ちてくるのですぐ終わります</span></a></code></pre></div>
<h2 id="まとめ">まとめ</h2>
<ul>
<li><code>stack 1.7.0</code> ぐらいから利用できるようになるはず</li>
<li><code>github</code> が新たに追加され <code>user/repo</code> の短縮形で記述できるようになった</li>
<li><code>commit</code> もいつからか短縮形で記述できるようになっていた</li>
<li><code>subdirs</code> を指定すれば <code>Yesod</code> のような mega-repo でも指定できる</li>
</ul>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>wizard モノイド</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-07-The-wizard-monoid.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-07-The-wizard-monoid.html</id>
    <published>2018-03-07T00:00:00Z</published>
    <updated>2018-03-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="wizard-モノイド-翻訳">wizard モノイド (翻訳)</h2>
<p>Original post: <a href="http://www.haskellforall.com/2018/02/the-wizard-monoid.html">The wizard monoid</a></p>
<p>最近の GHC 8.0 は、<code>IO</code> 用の <code>Monoid</code> インスタンスを提供しています。このブログ記事では、組み合わせ可能な “wizard” を作りつつ、なぜこのインスタンスが便利なのかを示す例をお見せします。</p>
<!--more-->
<h3 id="wizard">Wizard</h3>
<p>ここで使う “wizard” とは、ユーザーに複数の入力を促し、全ての入力が完了したら、いくつかのアクションを実行するようなプログラムです。</p>
<p>簡単な wizard の例です:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    <span class="co">-- First, we request all inputs:</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    putStrLn <span class="st">&quot;What is your name?&quot;</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    name <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    putStrLn <span class="st">&quot;What is your age?&quot;</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    age <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb1-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">    <span class="co">-- Then, we perform all actions:</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">    putStrLn (<span class="st">&quot;Your name is: &quot;</span> <span class="fu">++</span> name)</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">    putStrLn (<span class="st">&quot;Your age is: &quot;</span> <span class="fu">++</span> age)</a></code></pre></div>
<p>… 実行例:</p>
<pre class="plain"><code>What is your name?
Gabriel&lt;Enter&gt;
What is your age?
31&lt;Enter&gt;
Your name is: Gabriel
Your age is: 31</code></pre>
<p>… それで、以下はもう少し複雑な wizard の例です:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">System.Directory</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    <span class="co">-- First, we request all inputs:</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    files <span class="ot">&lt;-</span> System.Directory.listDirectory <span class="st">&quot;.&quot;</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    <span class="kw">let</span> askFile file <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">            putStrLn (<span class="st">&quot;Would you like to delete &quot;</span> <span class="fu">++</span> file <span class="fu">++</span> <span class="st">&quot;?&quot;</span>)</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">            response <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">            <span class="kw">case</span> response <span class="kw">of</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">                <span class="st">&quot;y&quot;</span> <span class="ot">-&gt;</span> return [file]</a>
<a class="sourceLine" id="cb3-12" data-line-number="12">                _   <span class="ot">-&gt;</span> return []</a>
<a class="sourceLine" id="cb3-13" data-line-number="13"></a>
<a class="sourceLine" id="cb3-14" data-line-number="14">    listOfListOfFilesToRemove <span class="ot">&lt;-</span> mapM askFile files</a>
<a class="sourceLine" id="cb3-15" data-line-number="15">    <span class="kw">let</span> listOfFilesToRemove <span class="fu">=</span> concat listOfListOfFilesToRemove</a>
<a class="sourceLine" id="cb3-16" data-line-number="16"></a>
<a class="sourceLine" id="cb3-17" data-line-number="17">    <span class="co">-- Then, we perform all actions:</span></a>
<a class="sourceLine" id="cb3-18" data-line-number="18">    <span class="kw">let</span> removeFile file <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-19" data-line-number="19">            putStrLn (<span class="st">&quot;Removing &quot;</span> <span class="fu">++</span> file)</a>
<a class="sourceLine" id="cb3-20" data-line-number="20">            System.Directory.removeFile file</a>
<a class="sourceLine" id="cb3-21" data-line-number="21">    mapM_ removeFile listOfFilesToRemove</a></code></pre></div>
<p>… 実行例:</p>
<pre class="plain"><code>Would you like to delete file1.txt?
y&lt;Enter&gt;
Would you like to delete file2.txt?
n&lt;Enter&gt;
Would you like to delete file3.txt?
y&lt;Enter&gt;
Removing file1.txt
Removing file3.txt</code></pre>
<p>以上に挙げた例では、ユーザーが要求された入力を全て入力し終えるまで、変更ができないアクションを実行するのは避けたいという要求があります。</p>
<h3 id="モジュール性">モジュール性</h3>
<p>最初の例を見直してみましょう:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    <span class="co">-- First, we request all inputs:</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    putStrLn <span class="st">&quot;What is your name?&quot;</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    name <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    putStrLn <span class="st">&quot;What is your age?&quot;</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">    age <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb5-9" data-line-number="9"></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    <span class="co">-- Then, we perform all actions:</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    putStrLn (<span class="st">&quot;Your name is: &quot;</span> <span class="fu">++</span> name)</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">    putStrLn (<span class="st">&quot;Your age is: &quot;</span> <span class="fu">++</span> age)</a></code></pre></div>
<p>この例は、実質的には2つの独立した wizard を組み合わせています:</p>
<ul>
<li>最初の wizard はユーザーの名前を要求し、表示している</li>
<li>2つ目の wizard はユーザーの年齢を要求し、表示している</li>
</ul>
<p>しかし、アクションを実行する前に全ての入力が必要だったので、2つの wizard のロジックをそれぞれ混ぜる必要がありました。</p>
<p>これら2つの wizard を別々に定義し、より大きな wizard に合体させる方法があったらどうでしょう? <code>IO</code> の <code>Monoid</code> インスタンスの長所を活かせば可能です。こんな感じ:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Monoid</span> ((&lt;&gt;))</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="ot">name ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">name <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    putStrLn <span class="st">&quot;What is your name?&quot;</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    x <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    return (putStrLn (<span class="st">&quot;Your name is: &quot;</span> <span class="fu">++</span> x))</a>
<a class="sourceLine" id="cb6-8" data-line-number="8"></a>
<a class="sourceLine" id="cb6-9" data-line-number="9"><span class="ot">age ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">age <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">    putStrLn <span class="st">&quot;What is your age?&quot;</span></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">    x <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb6-13" data-line-number="13">    return (putStrLn (<span class="st">&quot;Your age is: &quot;</span> <span class="fu">++</span> x))</a>
<a class="sourceLine" id="cb6-14" data-line-number="14"></a>
<a class="sourceLine" id="cb6-15" data-line-number="15"><span class="ot">runWizard ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb6-16" data-line-number="16">runWizard request <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-17" data-line-number="17">    respond <span class="ot">&lt;-</span> request</a>
<a class="sourceLine" id="cb6-18" data-line-number="18">    respond</a>
<a class="sourceLine" id="cb6-19" data-line-number="19"></a>
<a class="sourceLine" id="cb6-20" data-line-number="20"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb6-21" data-line-number="21">main <span class="fu">=</span> runWizard (name <span class="fu">&lt;&gt;</span> age)</a></code></pre></div>
<p>このプログラムはさっきの例と完全に同じ動きをします。が、ユーザーの名前を扱うロジックは、ユーザーの年齢を扱うロジックと完全に分離されています。</p>
<p>この方法でうまくいくのは、それぞれの wizard を2つの部分に分けたからです:</p>
<ul>
<li>リクエストの部分 (ユーザーに入力を求める部分など)</li>
<li>レスポンスの部分 (その入力に応じたアクションを実行する部分など)</li>
</ul>
<p>… そしてそれぞれの wizard に <code>IO (IO ())</code> という型を与えることによって、型レベルでこれを実現しています:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">name ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="ot">age ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a></code></pre></div>
<p>外側の <code>IO</code> アクションは“リクエスト”です。リクエストが終了したとき、外側の <code>IO</code> アクションは内側の <code>IO</code> アクション、つまり“レスポンス”を返します。例えば:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">--      ↓ リクエスト</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ot">name ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="co">--          ↑ レスポンス</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">name <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    putStrLn <span class="st">&quot;What is your name?&quot;</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">    x <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    <span class="co">-- ↑ ここから上の部分全てが、外側の `IO` アクションの一部 (例えばリクエスト)</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    <span class="co">--      ↓ この return される値は、内側の `IO` アクション (例えばレスポンス)</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">    return (putStrLn (<span class="st">&quot;Your name is: &quot;</span> <span class="fu">++</span> x))</a></code></pre></div>
<p>wizard は <code>(&lt;&gt;)</code> 演算子を使って組み合わせることができます。<code>IO</code> アクションに限って言うなら、以下のような動作をします:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">ioLeft <span class="fu">&lt;&gt;</span> ioRight</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="fu">=</span> <span class="kw">do</span> resultLeft  <span class="ot">&lt;-</span> ioLeft</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">     resultRight <span class="ot">&lt;-</span> ioRight</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">     return (resultLeft <span class="fu">&lt;&gt;</span> resultRight)</a></code></pre></div>
<p>言い換えるなら、<code>IO</code> アクションを2つ組み合わせるということは、それぞれの <code>IO</code> アクションを実行して結果を組み合わせるということなのです。これは、2つの <code>IO</code> アクションをネストさせると、アクションを実行して結果を組み合わせるという処理を2回実行する、ということも示しています:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">requestLeft <span class="fu">&lt;&gt;</span> requestRight</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="fu">=</span> <span class="kw">do</span> respondLeft  <span class="ot">&lt;-</span> requestLeft</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">     respondRight <span class="ot">&lt;-</span> requestRight</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">     return (respondLeft <span class="fu">&lt;&gt;</span> respondRight)</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="fu">=</span> <span class="kw">do</span> respondLeft  <span class="ot">&lt;-</span> requestLeft</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">     respondRight <span class="ot">&lt;-</span> requestRight</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">     return (<span class="kw">do</span></a>
<a class="sourceLine" id="cb10-10" data-line-number="10">         unitLeft  <span class="ot">&lt;-</span> respondLeft</a>
<a class="sourceLine" id="cb10-11" data-line-number="11">         unitRight <span class="ot">&lt;-</span> respondRight</a>
<a class="sourceLine" id="cb10-12" data-line-number="12">         return (unitLeft <span class="fu">&lt;&gt;</span> unitRight) )</a>
<a class="sourceLine" id="cb10-13" data-line-number="13"></a>
<a class="sourceLine" id="cb10-14" data-line-number="14"><span class="co">-- Both `unitLeft` and `unitRight` are `()` and `() &lt;&gt; () = ()`, so we can</span></a>
<a class="sourceLine" id="cb10-15" data-line-number="15"><span class="co">-- simplify this further to:</span></a>
<a class="sourceLine" id="cb10-16" data-line-number="16"></a>
<a class="sourceLine" id="cb10-17" data-line-number="17"><span class="co">-- `unitLeft` も `unitRight` も `()` で、`() &lt;&gt; () = ()` なので、</span></a>
<a class="sourceLine" id="cb10-18" data-line-number="18"><span class="co">-- 以下のように簡約化することができます:</span></a>
<a class="sourceLine" id="cb10-19" data-line-number="19"><span class="fu">=</span> <span class="kw">do</span> respondLeft  <span class="ot">&lt;-</span> requestLeft</a>
<a class="sourceLine" id="cb10-20" data-line-number="20">     respondRight <span class="ot">&lt;-</span> requestRight</a>
<a class="sourceLine" id="cb10-21" data-line-number="21">     return (<span class="kw">do</span></a>
<a class="sourceLine" id="cb10-22" data-line-number="22">         respondLeft</a>
<a class="sourceLine" id="cb10-23" data-line-number="23">         respondRight )</a></code></pre></div>
<p>つまり、2つの wizard を組み合わせると、リクエストを組み合わせてレスポンスも組み合わせたことになるのです。</p>
<p>この方法は2つ以上の wizard でもうまくいきます。例えば:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">request0 <span class="fu">&lt;&gt;</span> request1 <span class="fu">&lt;&gt;</span> request2 <span class="fu">&lt;&gt;</span> request3</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="fu">=</span> <span class="kw">do</span> respond0 <span class="ot">&lt;-</span> request0</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">     respond1 <span class="ot">&lt;-</span> request1</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">     respond2 <span class="ot">&lt;-</span> request2</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">     respond3 <span class="ot">&lt;-</span> request3</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">     return (<span class="kw">do</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">         respond0</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">         respond1</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">         respond2</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">         respond3 )</a></code></pre></div>
<p>これをアクションの形で表現するために、さっきの例をもう一度見てみましょう:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Monoid</span> ((&lt;&gt;))</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="ot">name ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">name <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">    putStrLn <span class="st">&quot;What is your name?&quot;</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">    x <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">    return (putStrLn (<span class="st">&quot;Your name is: &quot;</span> <span class="fu">++</span> x))</a>
<a class="sourceLine" id="cb12-8" data-line-number="8"></a>
<a class="sourceLine" id="cb12-9" data-line-number="9"><span class="ot">age ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">age <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-11" data-line-number="11">    putStrLn <span class="st">&quot;What is your age?&quot;</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">    x <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb12-13" data-line-number="13">    return (putStrLn (<span class="st">&quot;Your age is: &quot;</span> <span class="fu">++</span> x))</a>
<a class="sourceLine" id="cb12-14" data-line-number="14"></a>
<a class="sourceLine" id="cb12-15" data-line-number="15"><span class="ot">runWizard ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb12-16" data-line-number="16">runWizard request <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-17" data-line-number="17">    respond <span class="ot">&lt;-</span> request</a>
<a class="sourceLine" id="cb12-18" data-line-number="18">    respond</a>
<a class="sourceLine" id="cb12-19" data-line-number="19"></a>
<a class="sourceLine" id="cb12-20" data-line-number="20"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb12-21" data-line-number="21">main <span class="fu">=</span> runWizard (name <span class="fu">&lt;&gt;</span> age)</a></code></pre></div>
<p>…<code>name</code> と <code>age</code> はかなり似ているので、共通の関数を使うような実装にすることができますね:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Monoid</span> ((&lt;&gt;))</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="ot">prompt ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">prompt attribute <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    putStrLn (<span class="st">&quot;What is your &quot;</span> <span class="fu">++</span> attribute <span class="fu">++</span> <span class="st">&quot;?&quot;</span>)</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    x <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    return (putStrLn (<span class="st">&quot;Your &quot;</span> <span class="fu">++</span> attribute <span class="fu">++</span> <span class="st">&quot; is: &quot;</span> <span class="fu">++</span> x))</a>
<a class="sourceLine" id="cb13-8" data-line-number="8"></a>
<a class="sourceLine" id="cb13-9" data-line-number="9"><span class="ot">runWizard ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb13-10" data-line-number="10">runWizard request <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-11" data-line-number="11">    respond <span class="ot">&lt;-</span> request</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">    respond</a>
<a class="sourceLine" id="cb13-13" data-line-number="13"></a>
<a class="sourceLine" id="cb13-14" data-line-number="14"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb13-15" data-line-number="15">main <span class="fu">=</span> runWizard (prompt <span class="st">&quot;name&quot;</span> <span class="fu">&lt;&gt;</span> prompt <span class="st">&quot;age&quot;</span>)</a></code></pre></div>
<p>2つの wizard のロジックが混ざっていたとき、この共通化のロジックを使うことはできませんでした。しかしロジック毎に別々の wizard に分割すると、プログラムを小さくするための共通構造を突くことができます。</p>
<p>このプログラムの圧縮によって、簡単に新しい wizard を追加することができます:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Monoid</span> ((&lt;&gt;))</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="ot">prompt ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">prompt attribute <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    putStrLn (<span class="st">&quot;What is your &quot;</span> <span class="fu">++</span> attribute <span class="fu">++</span> <span class="st">&quot;?&quot;</span>)</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    x <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    return (putStrLn (<span class="st">&quot;Your &quot;</span> <span class="fu">++</span> attribute <span class="fu">++</span> <span class="st">&quot; is: &quot;</span> <span class="fu">++</span> x))</a>
<a class="sourceLine" id="cb14-8" data-line-number="8"></a>
<a class="sourceLine" id="cb14-9" data-line-number="9"><span class="ot">runWizard ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">runWizard request <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-11" data-line-number="11">    respond <span class="ot">&lt;-</span> request</a>
<a class="sourceLine" id="cb14-12" data-line-number="12">    respond</a>
<a class="sourceLine" id="cb14-13" data-line-number="13"></a>
<a class="sourceLine" id="cb14-14" data-line-number="14"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb14-15" data-line-number="15">main <span class="fu">=</span> runWizard (prompt <span class="st">&quot;name&quot;</span> <span class="fu">&lt;&gt;</span> prompt <span class="st">&quot;age&quot;</span> <span class="fu">&lt;&gt;</span> prompt <span class="st">&quot;favorite color&quot;</span>)</a></code></pre></div>
<p>… そして、モノイド関連の標準ライブラリ関数を活用しましょう。例えば <code>foldMap</code> を使えば wizard を大量に作ることができます。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Monoid</span> ((&lt;&gt;))</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="ot">prompt ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">prompt attribute <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    putStrLn (<span class="st">&quot;What is your &quot;</span> <span class="fu">++</span> attribute <span class="fu">++</span> <span class="st">&quot;?&quot;</span>)</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">    x <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb15-7" data-line-number="7">    return (putStrLn (<span class="st">&quot;Your &quot;</span> <span class="fu">++</span> attribute <span class="fu">++</span> <span class="st">&quot; is: &quot;</span> <span class="fu">++</span> x))</a>
<a class="sourceLine" id="cb15-8" data-line-number="8"></a>
<a class="sourceLine" id="cb15-9" data-line-number="9"><span class="ot">runWizard ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb15-10" data-line-number="10">runWizard request <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb15-11" data-line-number="11">    respond <span class="ot">&lt;-</span> request</a>
<a class="sourceLine" id="cb15-12" data-line-number="12">    respond</a>
<a class="sourceLine" id="cb15-13" data-line-number="13"></a>
<a class="sourceLine" id="cb15-14" data-line-number="14"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb15-15" data-line-number="15">main <span class="fu">=</span> runWizard (foldMap prompt [ <span class="st">&quot;name&quot;</span>, <span class="st">&quot;age&quot;</span>, <span class="st">&quot;favorite color&quot;</span>, <span class="st">&quot;sign&quot;</span> ])</a></code></pre></div>
<p>より重要なのは、プログラムが何をしているのか一目瞭然になりました。読みやすさは書きやすさに比べ、大きな美徳です。</p>
<h3 id="最後の例">最後の例</h3>
<p>ファイル削除の例も同じ観点から見直してみましょう:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">System.Directory</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    <span class="co">-- 最初に全ての入力をリクエストする:</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    files <span class="ot">&lt;-</span> System.Directory.listDirectory <span class="st">&quot;.&quot;</span></a>
<a class="sourceLine" id="cb16-7" data-line-number="7">    <span class="kw">let</span> askFile file <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-8" data-line-number="8">            putStrLn (<span class="st">&quot;Would you like to delete &quot;</span> <span class="fu">++</span> file <span class="fu">++</span> <span class="st">&quot;?&quot;</span>)</a>
<a class="sourceLine" id="cb16-9" data-line-number="9">            response <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb16-10" data-line-number="10">            <span class="kw">case</span> response <span class="kw">of</span></a>
<a class="sourceLine" id="cb16-11" data-line-number="11">                <span class="st">&quot;y&quot;</span> <span class="ot">-&gt;</span> return [file]</a>
<a class="sourceLine" id="cb16-12" data-line-number="12">                _   <span class="ot">-&gt;</span> return []</a>
<a class="sourceLine" id="cb16-13" data-line-number="13"></a>
<a class="sourceLine" id="cb16-14" data-line-number="14">    listOfListOfFilesToRemove <span class="ot">&lt;-</span> mapM askFile files</a>
<a class="sourceLine" id="cb16-15" data-line-number="15">    <span class="kw">let</span> listOfFilesToRemove <span class="fu">=</span> concat listOfListOfFilesToRemove</a>
<a class="sourceLine" id="cb16-16" data-line-number="16"></a>
<a class="sourceLine" id="cb16-17" data-line-number="17">    <span class="co">-- 次に全てのアクションを実行する</span></a>
<a class="sourceLine" id="cb16-18" data-line-number="18">    <span class="kw">let</span> removeFile file <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-19" data-line-number="19">            putStrLn (<span class="st">&quot;Removing &quot;</span> <span class="fu">++</span> file)</a>
<a class="sourceLine" id="cb16-20" data-line-number="20">            System.Directory.removeFile file</a>
<a class="sourceLine" id="cb16-21" data-line-number="21">    mapM_ removeFile listOfFilesToRemove</a></code></pre></div>
<p>さっきと同じパターンで、シンプルにすることができます:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">System.Directory</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5">    files <span class="ot">&lt;-</span> System.Directory.listDirectory <span class="st">&quot;.&quot;</span></a>
<a class="sourceLine" id="cb17-6" data-line-number="6">    runWizard (foldMap prompt files)</a>
<a class="sourceLine" id="cb17-7" data-line-number="7"></a>
<a class="sourceLine" id="cb17-8" data-line-number="8"><span class="ot">prompt ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb17-9" data-line-number="9">prompt file <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-10" data-line-number="10">    putStrLn (<span class="st">&quot;Would you like to delete &quot;</span> <span class="fu">++</span> file <span class="fu">++</span> <span class="st">&quot;?&quot;</span>)</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">    response <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb17-12" data-line-number="12">    <span class="kw">case</span> response <span class="kw">of</span></a>
<a class="sourceLine" id="cb17-13" data-line-number="13">        <span class="st">&quot;y&quot;</span> <span class="ot">-&gt;</span> return (<span class="kw">do</span></a>
<a class="sourceLine" id="cb17-14" data-line-number="14">            putStrLn (<span class="st">&quot;Removing &quot;</span> <span class="fu">++</span> file)</a>
<a class="sourceLine" id="cb17-15" data-line-number="15">            System.Directory.removeFile file )</a>
<a class="sourceLine" id="cb17-16" data-line-number="16">        _   <span class="ot">-&gt;</span> return (return ())</a>
<a class="sourceLine" id="cb17-17" data-line-number="17"></a>
<a class="sourceLine" id="cb17-18" data-line-number="18"><span class="ot">runWizard ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb17-19" data-line-number="19">runWizard request <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-20" data-line-number="20">    respond <span class="ot">&lt;-</span> request</a>
<a class="sourceLine" id="cb17-21" data-line-number="21">    respond</a></code></pre></div>
<p>やるべきなのは、1つのファイルに対して処理を行う wizard を定義すること、そして <code>foldMap</code> を使って wizard を大量に生成することだけです。<code>IO</code> の <code>Monoid</code> インスタンスは、全てのリクエストを束ねて表示し、後で選択したファイルを削除してくれます。</p>
<h3 id="結論">結論</h3>
<p>ユーザーが望む wizard の全てにこのパターンが適用できるわけではありません。例えば、wizard が互いに依存しているような状況では、このパターンはすぐに使い物にならなくなります。しかし、このパターンは <code>Monoid</code> の <code>IO</code> インスタンスを他の <code>Monoid</code> のインスタンスと (もしくは自分自身と!) 連結させ、新しい動作を生成するような一例にはなっています。</p>]]></summary>
</entry>
<entry>
    <title>Liquid Haskell のインストールと学習方法</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-03-liquidhaskell-intro.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-03-liquidhaskell-intro.html</id>
    <published>2018-03-03T00:00:00Z</published>
    <updated>2018-03-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p><code>Liquid Haskell</code> を半年ほど勉強した結果、色々と出来ることが増えて楽しくなってきました。</p>
<p>現状、日本語で詳しく説明しているブログ記事や <code>Qiita</code> 記事はほとんどありません。</p>
<p>とても面白いツールだと思いますので、色々と紹介していけたらと思います。</p>
<p>今回は <code>Liquid Haskell</code> の導入方法について簡単に説明したいと思います。</p>
<!--more-->
<h2 id="liquid-haskell-とは">Liquid Haskell とは？</h2>
<p><code>Liquid Haskell</code> は <code>GHC</code> の型よりも、さらに厳密な <code>篩型 (Refinement Type)</code> の型検査器です。</p>
<p>既存のコードを変更 (さらには実行すら) することなく利用できるため、既存のプロジェクトの一部にだけ導入することも可能です。</p>
<p>また、つい最近も <code>GADT</code> をサポートしたりと、開発はとても活発に行われています。</p>
<p>正しいソフトウェアを楽しく作るために、<code>Liquid Haskell</code> を学習してみるのはどうでしょうか！</p>
<p>ちなみに <code>Liquid</code> という単語は <code>液体</code> と言いたくなりますが、それとはあまり関係なく、実際は <code>Logically Qualified Data</code> の略です。(ロゴは <code>水滴</code> + <code>&gt;&gt;=</code> なので、全く無関係では無いかもですが)</p>
<h2 id="インストール">インストール</h2>
<p><code>Liquid Haskell</code> は以下の2つのリポジトリで開発が進められています。</p>
<ul>
<li><a href="https://github.com/ucsd-progsys/liquidhaskell">ucsd-progsys/liquidhaskell</a></li>
<li><a href="https://github.com/ucsd-progsys/liquid-fixpoint">ucsd-progsys/liquid-fixpoint</a></li>
</ul>
<p><code>liquidhaskell</code> がフロントエンド (コマンドライン処理やパーサーなどの処理等) を行い <code>liquid-fixpoint</code> が <code>SMT</code> ソルバに投げるための処理を色々とやっている印象です。(詳しくないので間違ってたらすみません)</p>
<p>なので、僕らが関係するのは基本的に <code>liquidhaskell</code> リポジトリの方です。(<code>liquid-fixpoint</code> はサブモジュールになっています)</p>
<p>また、実際にチェックを行うのは <code>SMT</code> ソルバなので、そちらも同様にインストールが必要です。</p>
<h3 id="smt-ソルバのインストール">SMT ソルバのインストール</h3>
<p><code>SMT</code> ソルバも色々と種類があるようで、公式では以下の3種類が紹介されています。</p>
<ul>
<li>Z3</li>
<li>CVC4</li>
<li>MathSat</li>
</ul>
<p>どれでもちゃんと動くので好きなソルバを使えば良いのですが、どれを選んだら良いかわからない人は <code>Z3</code> にしましょう。</p>
<p>理由としてはインストール方法が簡単で、性能も良いそうです。</p>
<h4 id="ubuntu">Ubuntu</h4>
<pre class="shell"><code>$ sudo apt install z3

$ z3 --version
Z3 version 4.4.1</code></pre>
<h4 id="mac-brew">Mac (brew)</h4>
<pre class="shell"><code>$ brew install z3

$ z3 --version
Z3 version 4.6.0 - 64 bit</code></pre>
<h3 id="liquid-haskell-のインストール">Liquid Haskell のインストール</h3>
<p>現状、一番安定しているのは <code>github</code> の <a href="https://github.com/ucsd-progsys/liquidhaskell"><strong>develop</strong></a> ブランチを <code>stack</code> でビルドしてインストールする方法だと思います。</p>
<p>また、その他のインストール方法等は <a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/INSTALL.md">INSTALL.md</a> をご参照下さい。</p>
<pre class="shell"><code>$ git clone --recursive git@github.com:ucsd-progsys/liquidhaskell.git
$ cd liquidhaskell
$ stack install

$ liquid
LiquidHaskell Version 0.8.2.4, Git revision d641244775cd842776cecf2c5d3e9afa01549e76 (dirty)
Copyright 2013-18 Regents of the University of California. All Rights Reserved.</code></pre>
<p>stack プロジェクトで利用する場合は、以下のように <code>stack exec</code> コマンドで呼び出します。</p>
<pre class="shell"><code>$ stack exec -- liquid
LiquidHaskell Version 0.8.2.4, Git revision d641244775cd842776cecf2c5d3e9afa01549e76 (dirty)
Copyright 2013-18 Regents of the University of California. All Rights Reserved.</code></pre>
<h2 id="サンプルプログラム">サンプルプログラム</h2>
<p><code>myDiv</code> 関数の例を使って <code>LiquidHaskell</code> に慣れましょう！</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">-- MyDiv.hs</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">module</span> <span class="dt">MyDiv</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="ot">myDiv ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">myDiv <span class="fu">=</span> div</a></code></pre></div>
<p><code>myDiv</code> の実装は単に <code>div</code> をラップしただけです。</p>
<p>この関数はだいたい上手く動きますが、もし第二引数に <strong>0</strong> が与えられたらどうでしょうか？そう、実行時エラーになります・・・。試してみましょう。</p>
<pre class="shell"><code>$ stack repl -- MyDiv.hs
*MyDiv&gt; myDiv 10 2
5
*MyDiv&gt; myDiv 10 0
*** Exception: divide by zero</code></pre>
<p>全然安全ではありませんね。</p>
<p>では、どうしたら本当に安全な <code>myDiv</code> を作れるのでしょうか？</p>
<p>その答えは<code>篩(ふるい)型</code>にあります。</p>
<p><code>Liquid Haskell</code> では <code>篩型</code> を <code>{-@ ... @-}</code> のコメント形式で記述します。<code>Liquid Haskell</code> を利用するメリットの1つは、篩型の自動推論です。(推論できない場合も多々ありますが、結構色々と推論してくれます)</p>
<p>先程の <code>myDiv</code> には篩型を書いていませんが、こういう場合に <code>Liquid Haskell</code> は <code>Haskell</code> の型をそのまま篩型として利用します。</p>
<p><code>myDiv</code> に対して明示的に篩型を書いてみましょう！</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="co">{-@ myDiv :: Int -&gt; Int -&gt; Int @-}</span> <span class="co">-- これが篩型</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">myDiv ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">myDiv <span class="fu">=</span> div</a></code></pre></div>
<p>この <code>myDiv</code> 関数を <code>LquidHaskell</code> でチェックしてみましょう。</p>
<pre class="shell"><code>$ liquid MyDiv.hs
**** RESULT: UNSAFE ************************************************************

 MyDiv.hs:4:11-13: Error: Liquid Type Mismatch

 4 | myDiv = div
             ^^^

   Inferred type
     VV : Int

   not a subtype of Required type
     VV : {VV : Int | VV /= 0}

   In Context</code></pre>
<p>なぜか <code>UNSAFE</code> が表示されましたね。これは <code>Liquid Haskell</code> で既に <code>div</code> の篩型が定義されているからです。(<a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/include/GHC/Real.spec#L19">div</a> 以外にも色々ありますが、充実しているとは言い難いと思います)</p>
<p>だいたいこんな感じで、第二引数に <strong>0を含まないInt型</strong> という事前条件がついているのです。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="co">{-@ div :: Int -&gt; {v:Int | v /= 0} -&gt; Int @-}</span></a></code></pre></div>
<p>そのため、先程のエラーメッセージで以下のように指摘されてしまったのです。</p>
<pre class="shell"><code>not a subtype of Required type
     VV : {VV : Int | VV /= 0}</code></pre>
<p>つまり、僕らの定義した篩型は <code>0</code> を含む <code>Int</code> 型なので、このままだと <code>div</code> に <code>0</code> が与えられてしまう可能性があるよ！ということを教えてくれています。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="co">{-@ myDiv :: Int -&gt; Int -&gt; Int @-}</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="ot">myDiv ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">myDiv <span class="fu">=</span> div</a></code></pre></div>
<p><code>myDiv</code> にも同じ篩型をつけてみましょう。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="co">{-@ myDiv :: Int -&gt; {v:Int | v /= 0} -&gt; Int @-}</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="ot">myDiv ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">myDiv <span class="fu">=</span> div</a></code></pre></div>
<p>これで <code>SAFE</code> になります。</p>
<pre class="shell"><code>$ liquid MyDiv.hs
**** RESULT: SAFE **************************************************************</code></pre>
<p><code>0</code> を含まない <code>Int</code> 型というのは、よく使いそうなので篩型のエイリアスとして定義してみます。</p>
<p>篩型のエイリアスは <code>type</code> キーワードを使います。<code>Haskell</code> と同じですね。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="co">{-@ type NonZero = {v:Int | v /= 0} @-}</span></a></code></pre></div>
<p>そして <code>myDiv</code> の篩型も <code>NonZero</code> で置き換えます。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="co">{-@ type NonZero = {v:Int | v /= 0} @-}</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="co">{-@ myDiv :: Int -&gt; NonZero -&gt; Int @-}</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="ot">myDiv ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">myDiv <span class="fu">=</span> div</a></code></pre></div>
<p>意味は全く同じですが、先程よりもわかりやすくなりました。</p>
<pre class="shell"><code>$ liquid MyDiv.hs
**** RESULT: SAFE **************************************************************</code></pre>
<p>最後に <code>myDiv</code> を呼び出す関数を定義してみましょう。</p>
<p><code>good</code> は問題の無い使い方です。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">good ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">good <span class="fu">=</span> myDiv <span class="dv">10</span> <span class="dv">2</span></a></code></pre></div>
<p>しかし、以下のような関数 <code>bad</code> が定義された場合、<code>Liquid Haskell</code> は <code>UNSAFE</code> を返します。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">bad ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">bad <span class="fu">=</span> myDiv <span class="dv">10</span> <span class="dv">0</span></a></code></pre></div>
<pre class="shell"><code>$ liquid MyDiv.hs
**** RESULT: UNSAFE ************************************************************

 MyDiv.hs:13:7-16: Error: Liquid Type Mismatch

 13 | bad = myDiv 10 0
            ^^^^^^^^^^

   Inferred type
     VV : {v : Int | v == (0 : int)
                     &amp;&amp; v == ?a}

   not a subtype of Required type
     VV : {VV : Int | VV /= 0}

   In Context
     ?a : {?a : Int | ?a == (0 : int)}</code></pre>
<h2 id="問題">問題</h2>
<p>以下のプログラムは標準入力から入力された数 <code>n</code>, <code>m</code> で <code>safeDiv n m</code> を計算します。</p>
<p><code>safeDiv</code> の <code>check</code> を正しく実装して <code>Liquid Haskell</code> の結果を <code>SAFE</code> にしてみましょう。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="co">-- Main.hs</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="co">{-@ type NonZero = {v:Int | v /= 0} @-}</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5"></a>
<a class="sourceLine" id="cb20-6" data-line-number="6"><span class="co">{-@ myDiv :: Int -&gt; NonZero -&gt; Int @-}</span></a>
<a class="sourceLine" id="cb20-7" data-line-number="7"><span class="ot">myDiv ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb20-8" data-line-number="8">myDiv <span class="fu">=</span> div</a>
<a class="sourceLine" id="cb20-9" data-line-number="9"></a>
<a class="sourceLine" id="cb20-10" data-line-number="10"><span class="co">{-@ lazy main @-}</span></a>
<a class="sourceLine" id="cb20-11" data-line-number="11"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb20-12" data-line-number="12">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb20-13" data-line-number="13">  n <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb20-14" data-line-number="14">  m <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb20-15" data-line-number="15">  <span class="kw">case</span> safeDiv (read n) (read m) <span class="kw">of</span></a>
<a class="sourceLine" id="cb20-16" data-line-number="16">    <span class="dt">Just</span> res <span class="ot">-&gt;</span> print res</a>
<a class="sourceLine" id="cb20-17" data-line-number="17">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb20-18" data-line-number="18">      putStrLn <span class="st">&quot;第二引数に0が入力されています&quot;</span></a>
<a class="sourceLine" id="cb20-19" data-line-number="19">      putStrLn <span class="st">&quot;もう一度入力してください&quot;</span></a>
<a class="sourceLine" id="cb20-20" data-line-number="20">      main</a>
<a class="sourceLine" id="cb20-21" data-line-number="21"></a>
<a class="sourceLine" id="cb20-22" data-line-number="22"><span class="co">{-@ safeDiv :: Int -&gt; Int -&gt; Maybe Int @-}</span></a>
<a class="sourceLine" id="cb20-23" data-line-number="23"><span class="ot">safeDiv ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb20-24" data-line-number="24">safeDiv n m</a>
<a class="sourceLine" id="cb20-25" data-line-number="25">  <span class="fu">|</span> check     <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> div n m</a>
<a class="sourceLine" id="cb20-26" data-line-number="26">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb20-27" data-line-number="27">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-28" data-line-number="28">   check <span class="fu">=</span> <span class="dt">True</span></a></code></pre></div>
<p>Hint: <code>div</code> に <code>0</code> を通さないよう <code>check</code> でバリデーションすれば良いです。</p>
<h3 id="エラーメッセージ">エラーメッセージ</h3>
<p>現状では、<code>Liquid Haskell</code> は以下のエラーメッセージを返します。</p>
<pre class="shell"><code>$ liquid Main.hs
**** RESULT: UNSAFE ************************************************************

 Main.hs:24:24-30: Error: Liquid Type Mismatch

 24 |   | check     = Just $ div n m
                             ^^^^^^^

   Inferred type
     VV : {v : Int | v == m}

   not a subtype of Required type
     VV : {VV : Int | VV /= 0}

   In Context
     m : Int</code></pre>
<h3 id="実行例">実行例</h3>
<p><code>Liquid Haskell</code> が <code>UNSAFE</code> の場合は実行時エラーが発生します。</p>
<pre class="shell"><code>$ stack repl -- Main.hs
*Main&gt; main
10
2
5

*Main&gt; main
10
0
*** Exception: divide by zero</code></pre>
<p><code>Liquid Haskell</code> を <code>SAFE</code> にすると、再入力を促すようになります。</p>
<pre class="shell"><code>*Main&gt; main
10
0
第二引数に0が入力されています
もう一度入力してください
10
2
5</code></pre>
<h2 id="興味を持った方へ">興味を持った方へ</h2>
<p><code>Liquid Haskell</code> に興味を持った方は以下の文献を読んで <code>Liquid Haskell</code> に詳しくなりましょう！(個人的にまとめているやつを貼り付けただけなので雑ですみません・・・)</p>
<p>たぶん、おすすめは以下のチュートリアルです。(僕はまだ読んでないですが、かなり最近できたものなので情報が新しく良いのではないかと思います)</p>
<ul>
<li><a href="https://liquid.kosmikus.org/">Liquid Haskell Tutorial</a></li>
</ul>
<h3 id="日本語の情報">日本語の情報</h3>
<ul>
<li><a href="http://ccvanishing.hateblo.jp/entry/2016/12/24/193038">LiquidHaskell コトハジメ</a></li>
<li><a href="https://dodgsonlabs.booth.pm/items/490689">入門 LiquidHaskell −篩型による静的コード解析−</a></li>
<li><a href="http://demand-side-science.jp/blog/2014/flops2014%E5%A0%B1%E5%91%8A/">FLOPS2014報告</a></li>
</ul>
<h3 id="ブログ">ブログ</h3>
<ul>
<li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/">liquidhaskell-blog</a></li>
<li><a href="http://www.haskellforall.com/2015/12/compile-time-memory-safety-using-liquid.html">Compile-time memory safety using Liquid Haskell</a></li>
<li><a href="http://conscientiousprogrammer.com/blog/2015/12/23/24-days-of-hackage-2015-day-23-liquid-haskell-refinement-types-for-the-real-world/">Liquid Haskell: refinement types for the real world</a></li>
</ul>
<h3 id="チュートリアル">チュートリアル</h3>
<ul>
<li><a href="https://liquid.kosmikus.org/">Liquid Haskell Tutorial</a></li>
<li><a href="https://github.com/ucsd-progsys/liquidhaskell-tutorial">liquidhaskell-tutorial</a>
<ul>
<li>long tutorial</li>
<li><a href="http://ucsd-progsys.github.io/liquidhaskell-tutorial/book.pdf">book</a></li>
<li><a href="https://github.com/ucsd-progsys/liquidhaskell-tutorial/blob/master/pdf/programming-with-refinement-types.pdf">programming-with-refinement-types.pdf</a></li>
</ul></li>
<li><a href="https://github.com/ucsd-progsys/lh-workshop">lh-workshop</a>
<ul>
<li>short tutorial</li>
</ul></li>
<li><a href="http://goto.ucsd.edu/~nvazou/presentations/shonan17/01-index.html">Liquid Haskell: Verification of Haskell Code</a></li>
</ul>
<h3 id="スライド">スライド</h3>
<ol type="1">
<li><a href="http://goto.ucsd.edu/~rjhala/flops14/lhs/00_Index.lhs.slides.html#/">Liquid Types For Haskell</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/flops14/lhs/01_SimpleRefinements.lhs.slides.html#/">Simple Refinement Types</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/flops14/lhs/02_Measures.lhs.slides.html#/">Measuring Data Types</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/flops14/lhs/03_HigherOrderFunctions.lhs.slides.html#/">Higher-Order Specifications</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/flops14/lhs/04_AbstractRefinements.lhs.slides.html#/">Abstract Refinements</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/flops14/lhs/09_Laziness.lhs.slides.html#/">Lazy Evaluation?</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/flops14/lhs/10_Termination.lhs.slides.html#/">Refinements &amp; Termination</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/flops14/lhs/11_Evaluation.lhs.slides.html#/">Evaluation</a></li>
</ol>
<ul>
<li><a href="https://web.eecs.umich.edu/~weimerw/students/anish-ms-pres.pdf">Finding and Fixing Bugs in Liquid Haskell</a></li>
<li><a href="https://github.com/Gabriel439/slides/blob/master/liquidhaskell/slides.md">Scrap your Bounds Checks with Liquid Haskell</a></li>
<li><a href="https://nikivazou.github.io/static/popl18/reflection.pdf">Refinement Reflection: Complete Verification with SMT</a></li>
<li><a href="https://popl18.sigplan.org/event/plmw-popl-2018-liquidhaskell-overview">Liquid Haskell: Refinement Types for Haskell</a></li>
</ul>
<h3 id="論文">論文</h3>
<ul>
<li><a href="http://goto.ucsd.edu/~pmr/papers/rondon-liquid-types.pdf">Pat Rondon’s Ph.D Dissertation</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/liquid/liquid_types_techrep.pdf">Tech Report</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/papers/refinement_types_for_haskell.pdf">Refinement Types For Haskell, ICFP 2014</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/papers/real_world_liquid.pdf">LiquidHaskell in the Real World, Haskell 2014</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/papers/abstract_refinement_types.pdf">Abstract Refinement Types, ESOP 2013</a></li>
<li><a href="https://arxiv.org/pdf/1701.03320.pdf">An Introduction to Liquid Haskell</a></li>
<li><a href="http://goto.ucsd.edu/~nvazou/thesis/main.pdf">Liquid Haskell: Haskell as a Theorem Prover</a></li>
<li><a href="https://nikivazou.github.io/static/Haskell17/a-tale.pdf">A Tale of Two Provers Verifying Monoidal String Matching in Liquid Haskell and Coq</a></li>
</ul>
<h3 id="youtube">Youtube</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=LEsEME7JwEE">Liquid Types for Haskell</a></li>
<li><a href="https://www.youtube.com/watch?v=vYh27zz9530">Ranjit Jhala - Liquid Haskell</a></li>
<li><a href="https://www.youtube.com/watch?v=vQrutfPAERQ">LambdaConf 2015 - LiquidHaskell Refinement Types for Haskell Ranjit Jhala</a></li>
<li><a href="https://www.youtube.com/watch?v=vqvNQixKr6w">Haskell 2014: LiquidHaskell: Refinement Types for the Real World, Eric L. Seidel</a></li>
<li><a href="https://www.youtube.com/watch?v=nd3buP97Ryw">07 Bounded Refinement Types</a></li>
</ul>
<h2 id="まとめ">まとめ</h2>
<ul>
<li>篩型は <code>{-@ ... @-}</code> で記述する</li>
<li>篩型の型エイリアスは <code>{-@ type @-}</code> で記述する</li>
</ul>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Liquid Haskell</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-01-liquidhaskell.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-01-liquidhaskell.html</id>
    <published>2018-03-01T00:00:00Z</published>
    <updated>2018-03-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>Liquid Haskell で少しハマったのでメモとして残しておきます。</p>
<p>本来なら先に仕様を書いて実装を書くべきだと思いますが、今回の例は既存のコードにリファインメント型をつけるような場合を想定しています。</p>
<pre class="shell"><code>$ liquid
LiquidHaskell Version 0.8.2.4, Git revision d641244775cd842776cecf2c5d3e9afa01549e76 (dirty)
Copyright 2013-18 Regents of the University of California. All Rights Reserved.</code></pre>
<p>Liquid Haskell を気になってる人向けの記事です。</p>
<!--more-->
<h2 id="やりたいこと">やりたいこと</h2>
<p>データの挿入と更新操作を次のような型で表現します。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Operation</span> <span class="fu">=</span> <span class="dt">Insert</span> <span class="fu">|</span> <span class="dt">Update</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="kw">deriving</span> <span class="dt">Eq</span></a></code></pre></div>
<p>上記のデータ型を使って、次のような関数を定義します。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">adjustBound ::</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">adjustBound op lower upper n <span class="fu">|</span> isInsert op <span class="fu">=</span> upper <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">                             <span class="fu">|</span> otherwise   <span class="fu">=</span> lower <span class="ot">`max`</span> (n <span class="ot">`min`</span> upper)</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">isInsert ::</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">isInsert <span class="dt">Insert</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">isInsert _      <span class="fu">=</span> <span class="dt">False</span></a></code></pre></div>
<p><code>adjustBound</code> 関数は以下のように動作します。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">&gt;</span> adjustBound <span class="dt">Insert</span> <span class="dv">0</span> <span class="dv">10</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="dv">11</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="fu">&gt;</span> adjustBound <span class="dt">Insert</span> <span class="dv">0</span> <span class="dv">10</span> <span class="dv">100</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="dv">11</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="fu">&gt;</span> adjustBound <span class="dt">Insert</span> <span class="dv">0</span> <span class="dv">10</span> (<span class="fu">-</span><span class="dv">100</span>)</a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="dv">11</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"></a>
<a class="sourceLine" id="cb4-8" data-line-number="8"><span class="fu">&gt;</span> adjustBound <span class="dt">Update</span> <span class="dv">0</span> <span class="dv">10</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="dv">5</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10"><span class="fu">&gt;</span> adjustBound <span class="dt">Update</span> <span class="dv">0</span> <span class="dv">10</span> <span class="dv">100</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11"><span class="dv">10</span></a>
<a class="sourceLine" id="cb4-12" data-line-number="12"><span class="fu">&gt;</span> adjustBound <span class="dt">Update</span> <span class="dv">0</span> <span class="dv">10</span> (<span class="fu">-</span><span class="dv">100</span>)</a>
<a class="sourceLine" id="cb4-13" data-line-number="13"><span class="dv">0</span></a></code></pre></div>
<p><code>adjustBound</code> のような関数でバグが無いことを確認するためには何をしたら良いでしょうか？</p>
<p>型は非常に強力ですが、値について何も教えてくれません。</p>
<h2 id="バグの少ない世界を目指して">バグの少ない世界を目指して</h2>
<p>僕が Haskell を使う理由は、第一に <code>楽しい</code> からです。そのため、「勉強しても就職する時に役に立たないでしょ？」などと言われても全く気になりません。(そもそも、就職するために勉強するわけじゃないですよね)</p>
<p>また Haskell を使えば、正しいソフトウェアを普通に作ることができます。また、<code>hspec</code> などで単体テストを書いたり、<code>QuichCheck</code> などでランダムテストを書くことで、過去に起こった問題を再発させないようにする努力や、バグを少なくするための取り組みが行われています。</p>
<p>しかしながら、個人的にはどれもまだ不安です。もしかしたら、チェックしてない部分にバグがあるんじゃないの・・・？</p>
<p>そんな心配性の方は <code>Liquid Haskell (LH)</code> を使いましょう！</p>
<h2 id="型をより厳しく">型をより厳しく</h2>
<p>最初に定義した <code>Operation</code> 型と <code>adjustBound</code> を再掲します。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">-- LH.hs</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">module</span> <span class="dt">LH</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="kw">data</span> <span class="dt">Operation</span> <span class="fu">=</span> <span class="dt">Insert</span> <span class="fu">|</span> <span class="dt">Update</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  <span class="kw">deriving</span> <span class="dt">Eq</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="ot">adjustBound ::</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">adjustBound op lower upper n <span class="fu">|</span> isInsert op <span class="fu">=</span> upper <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">                             <span class="fu">|</span> otherwise   <span class="fu">=</span> lower <span class="ot">`max`</span> (n <span class="ot">`min`</span> upper)</a>
<a class="sourceLine" id="cb5-10" data-line-number="10"></a>
<a class="sourceLine" id="cb5-11" data-line-number="11"><span class="ot">isInsert ::</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">isInsert <span class="dt">Insert</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb5-13" data-line-number="13">isInsert _      <span class="fu">=</span> <span class="dt">False</span></a></code></pre></div>
<p>とりあえず、現在のコードを <code>LH</code> にかけてみます。</p>
<pre class="shell"><code>$ liquid LH.hs
LiquidHaskell Version 0.8.2.4, Git revision d641244775cd842776cecf2c5d3e9afa01549e76 (dirty)
Copyright 2013-18 Regents of the University of California. All Rights Reserved.


**** DONE:  A-Normalization ****************************************************


**** DONE:  Extracted Core using GHC *******************************************


**** DONE:  Transformed Core ***************************************************

Working 100% [=================================================================]

**** DONE:  annotate ***********************************************************


**** RESULT: SAFE **************************************************************</code></pre>
<p><code>RESULT: SAFE</code> が表示されれば問題ありません！</p>
<h3 id="入力を自然数に限定させよう">入力を自然数に限定させよう</h3>
<p>例えば <code>lower</code> と <code>upper</code> が自然数 (0含む) しか許容しないという仕様が与えられた時、どうしますか？</p>
<p>よくある対応としては、コメントにその旨を書いたり、テストを作ったりという作業になるでしょう。</p>
<p><code>Liquid Haskell</code> では上記の仕様を <code>事前条件</code> として記述することができます。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="co">{-@ adjustBound :: _ -&gt; Nat -&gt; Nat -&gt; _ -&gt; _ @-}</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">adjustBound ::</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">adjustBound op lower upper n <span class="fu">|</span> isInsert op <span class="fu">=</span> upper <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">                             <span class="fu">|</span> otherwise   <span class="fu">=</span> lower <span class="ot">`max`</span> (n <span class="ot">`min`</span> upper)</a></code></pre></div>
<p><code>Nat</code> は <a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/include/Prelude.spec">Prelude</a> で以下のように定義されています。つまり、0以上の <code>Int</code> のみを含むリファインメント型です。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">{-@ type Nat = {v: Int | v &gt;= 0 } @-}</span></a></code></pre></div>
<p>これだけです。<code>LH</code> で結果を確かめてみましょう。</p>
<pre class="shell"><code>$ liquid LH.hs
...

**** RESULT: SAFE **************************************************************</code></pre>
<p><code>SAFE</code> ですね！</p>
<p>これでもう <code>adjustBound</code> の <code>lower</code> と <code>upper</code> は <code>0</code> 以上の自然数でしか呼び出されていないことが示されました。</p>
<h3 id="もう少し具体例">もう少し具体例</h3>
<p>では、別のプログラマが <code>adjustBound</code> を利用した関数を作ったとしましょう。この関数自体に意味はないですが、<code>LH</code> を理解するためにはとても良い例だと思います。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">f ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">f <span class="fu">=</span> adjustBound <span class="dt">Insert</span> (<span class="fu">-</span><span class="dv">100</span>) (<span class="fu">-</span><span class="dv">50</span>) (<span class="fu">-</span><span class="dv">70</span>)</a></code></pre></div>
<p>この関数 <code>f</code> は、型が正しいため当然コンパイルできます。</p>
<pre class="shell"><code>$ stack repl -- LH.hs
&gt; f
-49</code></pre>
<p>けれども、僕らの仕様では <code>adjustBound</code> の <code>lower</code> と <code>upper</code> には自然数しか適用してはいけないはずです。</p>
<p>次に <code>LH</code> を実行してみましょう。</p>
<pre class="shell"><code>$ liquid LH.hs
**** RESULT: UNSAFE ************************************************************


 LH.hs:18:25-28: Error: Liquid Type Mismatch

 18 | f = adjustBound Insert (-100) (-50) (-70)
                              ^^^^


   Inferred type
    VV : {v : Int | v == (-?a)
                    &amp;&amp; v == ?b}

  not a subtype of Required type
    VV : {VV : Int | VV &gt;= 0}

  In Context
    ?b : {?b : Int | ?b == (-?a)}

    ?a : {?a : Int | ?a == (100 : int)}


 LH.hs:18:32-34: Error: Liquid Type Mismatch

 18 | f = adjustBound Insert (-100) (-50) (-70)
                                     ^^^


   Inferred type
    VV : {v : Int | v == (-?b)
                    &amp;&amp; v == ?a}

  not a subtype of Required type
    VV : {VV : Int | VV &gt;= 0}

  In Context
    ?b : {?b : Int | ?b == (50 : int)}

    ?a : {?a : Int | ?a == (-?b)}</code></pre>
<p><code>UNSAFE</code> になりましたね。こういうことです。</p>
<p>つまり、<strong>自分たちが使っている範囲</strong>で <code>Liquid Haskell</code> のリファインメント型について、正しく整合性が取れているのかということを判定しています。</p>
<h3 id="戻り値の型も厳しくしよう">戻り値の型も厳しくしよう！</h3>
<p>先程、事前条件についてリファインメント型を書きました。</p>
<p>次は事後条件についてリファインメントを書きましょう！</p>
<p>同様に戻り値の型も自然数という仕様にします。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="co">{-@ adjustBound :: _ -&gt; Nat -&gt; Nat -&gt; _ -&gt; Nat @-}</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="ot">adjustBound ::</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">adjustBound op lower upper n <span class="fu">|</span> isInsert op <span class="fu">=</span> upper <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">                             <span class="fu">|</span> otherwise   <span class="fu">=</span> lower <span class="ot">`max`</span> (n <span class="ot">`min`</span> upper)</a></code></pre></div>
<pre class="shell"><code>$ liquid LH.hs
**** RESULT: SAFE **************************************************************</code></pre>
<p>リファインメント型 (Refinement type) は <code>篩 (ふるい) 型</code> と訳されている本 (<a href="https://taimen.jp/f/389">入門LiquidHaskell−篩型による静的コード解析−</a>) もありますが、それは <code>Haskell</code> の型の値が条件によって <code>ふるい</code> 落とされて、新しい型 (リファインメント型) になっているというイメージから来ているのだと思います。(読んだこと無いので間違ってたらすみません・・・。)</p>
<p>追記: チェシャ猫さんから <code>篩型</code> について教えてもらいました！</p>
<blockquote class="twitter-tweet" data-lang="ja">
<p lang="ja" dir="ltr">
&gt; リファインメント型 (Refinement type) は 篩 (ふるい) 型 と訳されている本もありますが<br><br>頒布したときに最も多かった質問は「これ何て読むんですか？」だった。ちなみに「篩型」はこの本で勝手に作った造語ではなく、論文タイトルなどにも使われています。<a href="https://t.co/Du6mK1hqdD">https://t.co/Du6mK1hqdD</a>
</p>
— チェシャ猫 (<span class="citation" data-cites="y_taka_23">@y_taka_23</span>) <a href="https://twitter.com/y_taka_23/status/969499842895495168?ref_src=twsrc%5Etfw">2018年3月2日</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<blockquote class="twitter-tweet" data-lang="ja">
<p lang="ja" dir="ltr">
五十嵐先生と末永先生が発案した訳語のようです。 <a href="https://t.co/rcZuFuptl6">https://t.co/rcZuFuptl6</a>
</p>
— チェシャ猫 (<span class="citation" data-cites="y_taka_23">@y_taka_23</span>) <a href="https://twitter.com/y_taka_23/status/969515905737621506?ref_src=twsrc%5Etfw">2018年3月2日</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<h2 id="もっと仕様を">もっと仕様を</h2>
<p><code>adjustBound</code> 関数はこれで十分なのでしょうか？人によっては十分だね。と答えるかもしれません。</p>
<p>しかし、今回は次のような仕様を与えることにします。</p>
<ol type="1">
<li><code>upper</code> は <code>lower</code> 以上の自然数</li>
<li><code>Insert</code> の操作の場合の戻り値は <code>lower</code> 〜 <code>upper + 1</code> の間の自然数</li>
<li><code>Update</code> の操作の場合の戻り値は <code>lower</code> 〜 <code>lower `max` (n `min` upper)</code> の間の自然数</li>
</ol>
<p>ここからが面白いところです。</p>
<p>まずは前準備として <code>x 〜 y</code> までの間の自然数を表すリファインメント型と述語を定義します。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="co">{-@ type Btwn Lo Hi = {v:Int | Lo &lt;= v &amp;&amp; v &lt;= Hi} @-}</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="co">{-@ predicate BtwnP Lo Hi = Lo &lt;= v &amp;&amp; v &lt;= Hi @-}</span></a></code></pre></div>
<p>では、<code>仕様1</code>を反映させてみましょう。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="co">{-@ adjustBound :: _ -&gt; l:Nat -&gt; {u:Nat | l &lt;= u} -&gt; _ -&gt; Nat @-}</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="ot">adjustBound ::</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">adjustBound op lower upper n <span class="fu">|</span> isInsert op <span class="fu">=</span> upper <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">                             <span class="fu">|</span> otherwise   <span class="fu">=</span> lower <span class="ot">`max`</span> (n <span class="ot">`min`</span> upper)</a></code></pre></div>
<pre class="shell"><code>$ liquid LH.hs
**** RESULT: SAFE **************************************************************</code></pre>
<p>では次に、<code>仕様2</code> と <code>仕様3</code> です。</p>
<p>リファインメント型は以下のようになります。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="co">{-@ adjustBound ::</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="co">      op:Operation -&gt;</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3"><span class="co">      l:Nat -&gt;</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4"><span class="co">      {u:Nat | l &lt;= u} -&gt;</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5"><span class="co">      _ -&gt;</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6"><span class="co">      {v:Nat | if (isInsert op) then (BtwnP l (u+1)) else BtwnP l u }</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7"><span class="co">@-}</span></a>
<a class="sourceLine" id="cb18-8" data-line-number="8"><span class="ot">adjustBound ::</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb18-9" data-line-number="9">adjustBound op lower upper n <span class="fu">|</span> isInsert op <span class="fu">=</span> upper <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb18-10" data-line-number="10">                             <span class="fu">|</span> otherwise   <span class="fu">=</span> lower <span class="ot">`max`</span> (n <span class="ot">`min`</span> upper)</a>
<a class="sourceLine" id="cb18-11" data-line-number="11"></a>
<a class="sourceLine" id="cb18-12" data-line-number="12"><span class="co">{-@ measure isInsert @-}</span></a>
<a class="sourceLine" id="cb18-13" data-line-number="13"><span class="ot">isInsert ::</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb18-14" data-line-number="14">isInsert <span class="dt">Insert</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb18-15" data-line-number="15">isInsert _      <span class="fu">=</span> <span class="dt">False</span></a></code></pre></div>
<pre class="shell"><code>$ liquid LH.hs
**** RESULT: SAFE **************************************************************</code></pre>
<h2 id="はまったポイント">はまったポイント</h2>
<p><code>if (isInsert op) then (BtwnP l (u+1)) else BtwnP l u</code> の部分でかなりはまりました。</p>
<p>例えば <code>if</code> の括弧を外した場合は次のようなエラーになります。</p>
<p><code>if isInsert op then (BtwnP l (u+1)) else BtwnP l u</code></p>
<pre class="shell"><code>**** RESULT: ERROR *************************************************************


 LH.hs:10:73: Error: Cannot parse specification:

 10 | {-@ adjustBound :: op:Operation -&gt; l:Nat -&gt; {u:Nat | l &lt;= u}  -&gt; _ -&gt; {v:Nat | if isInsert op then (BtwnP l (u+1)) else BtwnP l u } @-}
                                                                              ^

     unexpected &quot;:&quot;
     expecting operator, white space or &quot;}&quot;</code></pre>
<p>また、同様に <code>then</code> の括弧を外してもエラーになります。</p>
<p><code>if (isInsert op) then BtwnP l (u+1) else BtwnP l u</code></p>
<pre class="shell"><code>**** RESULT: ERROR *************************************************************


 LH.hs:10:73: Error: Cannot parse specification:

 10 | {-@ adjustBound :: op:Operation -&gt; l:Nat -&gt; {u:Nat | l &lt;= u}  -&gt; _ -&gt; {v:Nat | if (isInsert op) then BtwnP l (u+1) else BtwnP l u } @-}
                                                                              ^

     unexpected &quot;:&quot;
     expecting operator, white space or &quot;}&quot;</code></pre>
<p><code>else</code> については括弧があっても無くても <code>SAFE</code> です。</p>
<p>この挙動が本当にわからなくてつらかったです・・・。</p>
<p>ちなみに、以下のような場合も同様にはまるので、ご注意ください。</p>
<pre><code>-- UNSAFE
{-@ adjustBound :: _ -&gt; l:Nat -&gt; {u:Nat | l &lt;= u}  -&gt; _ -&gt; Btwn l (u+1) @-}
{-@ adjustBound :: _ -&gt; l:Nat -&gt; {u:Nat | l &lt;= u}  -&gt; _ -&gt; Btwn l {u+1} @-}

-- SAFE
{-@ adjustBound :: _ -&gt; l:Nat -&gt; {u:Nat | l &lt;= u}  -&gt; _ -&gt; Btwn {l} {u+1} @-}</code></pre>
<h2 id="まとめ">まとめ</h2>
<ul>
<li><code>if</code> を使う場合は多めに括弧を付けておいた方が良さそう。</li>
<li><code>{}</code> で囲むと上手くいく場合もある</li>
<li><code>LiquidHaskell</code> はすごい</li>
</ul>
<p>この良くわからない挙動について一緒に考えてくれた友人の tkg さんありがとうございました。</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>debug パッケージのアナウンス (翻訳)</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/02-26-Announcing-the-debug-package.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/02-26-Announcing-the-debug-package.html</id>
    <published>2018-02-26T00:00:00Z</published>
    <updated>2018-02-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="debug-パッケージのアナウンス-翻訳">debug パッケージのアナウンス (翻訳)</h2>
<p>Original post: <a href="http://neilmitchell.blogspot.jp/2017/12/announcing-debug-package.html">Announcing the ‘debug’ package</a></p>
<p>Haskell は素晴らしい言語ですが、Haskell のデバッグは間違いなく弱い部分です。この問題をどうにかするために、<a href="https://hackage.haskell.org/package/debug">debug ライブラリ</a> をリリースしました。このライブラリは全てのことを解決するのではなく、一般的なデバッグのタスクに対してシンプルで簡単に使えるような設計を目指しました。デバッグをするにあたって、みなさんが興味を持ってくれるような関数を例に取って見てみましょう。</p>
<!--more-->
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">module</span> <span class="dt">QuickSort</span>(quicksort) <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Data.List</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">quicksort ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">quicksort [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">quicksort (x<span class="fu">:</span>xs) <span class="fu">=</span> quicksort lt <span class="fu">++</span> [x] <span class="fu">++</span> quicksort gt</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    <span class="kw">where</span> (lt, gt) <span class="fu">=</span> partition (<span class="fu">&lt;=</span> x) xs</a></code></pre></div>
<p><code>TemplateHaskell</code> と <code>ViewPatterns</code> を有効にしてから、<code>Debug</code> をインポートし、コードをインデントして <code>debug</code> の引数に渡してやりましょう。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">{-# LANGUAGE TemplateHaskell, ViewPatterns #-}</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">module</span> <span class="dt">QuickSort</span>(quicksort) <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Data.List</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Debug</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">debug [d|</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">   quicksort :: Ord a =&gt; [a] -&gt; [a]</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">   quicksort [] = []</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">   quicksort (x:xs) = quicksort lt ++ [x] ++ quicksort gt</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">       where (lt, gt) = partition (&lt;= x) xs</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">   |]</a></code></pre></div>
<p>以下のコマンドでデバッガを走らせることができます。</p>
<pre class="shell"><code>$ ghci QuickSort.hs
GHCi, version 8.2.1: http://www.haskell.org/ghc/  :? for help
[1 of 1] Compiling QuickSort        ( QuickSort.hs, interpreted )
Ok, 1 module loaded.
*QuickSort&gt; quicksort &quot;haskell&quot;
&quot;aehklls&quot;
*QuickSort&gt; debugView</code></pre>
<p><code>debugView</code> を呼ぶと Webブラウザが起動して、記録されたデバッグの結果を見ることができます。こんな感じです。</p>
<figure>
<img src="https://cdn.rawgit.com/ndmitchell/debug/f6e8dbc9/debug.png" alt="debugView の実行結果" /><figcaption>debugView の実行結果</figcaption>
</figure>
<p>ここから、計算の経過をクリックしつつ探すことができます。</p>
<p>私は <code>debug</code> を使った感想や、これを改善できるようなアイディアを求めています。そのため、フィードバックや<a href="https://github.com/ndmitchell/debug/issues">バグトラッカー</a>経由のお手伝いなどをお待ちしています。</p>
<p>また別の Haskell のデバッガに興味があるのなら、<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#the-ghci-debugger">GHCi デバッガ</a>や <a href="https://hackage.haskell.org/package/Hoed">Hood/Hoed</a> などを試してみるべきでしょう。</p>]]></summary>
</entry>

</feed>
