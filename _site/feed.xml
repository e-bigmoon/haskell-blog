<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>BIG MOON</title>
    <link href="https://haskell.e-bigmoon.com/feed.xml" rel="self" />
    <link href="https://haskell.e-bigmoon.com" />
    <id>https://haskell.e-bigmoon.com/feed.xml</id>
    <author>
        <name>BIG MOON</name>
        <email>it@e-bigmoon.com</email>
    </author>
    <updated>2018-03-19T00:00:00Z</updated>
    <entry>
    <title>Yesod v1.6 のサブサイト</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-19-yesod-subsite.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-19-yesod-subsite.html</id>
    <published>2018-03-19T00:00:00Z</published>
    <updated>2018-03-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>今回は <code>Yesod</code> を使っているマニア向け情報です。</p>
<p><code>Yesod</code> にはサブサイトという機能があり、Yesod Book の <a href="https://www.yesodweb.com/book/creating-a-subsite">Creating a Subsite</a> で一通りの使い方が説明されています。</p>
<p>簡単に言えば、異なる <code>Yesod</code> アプリケーションで共通のコンポーネント (認証システム等) を利用するために使えるようです。</p>
<p><code>scaffolded site</code> を使っている人は <a href="https://www.stackage.org/lts-11.1/package/yesod-static-1.6.0">yesod-static</a> パッケージで提供されている <code>Static</code> 型をサブサイトとして利用していることでしょう。</p>
<p><code>Yesod</code> のバージョンが <code>1.6</code> に上がった影響により <code>Yesod Book</code> の内容がそのままでは動かなくなっていたため、コードを修正して実際に動かしてみたいと思います。</p>
<!--more-->
<h2 id="修正ポイント">修正ポイント</h2>
<ul>
<li><code>HandlerT site IO a</code> のような形式は何も考えずに <code>HandlerFor site a</code> に書き換える</li>
<li>サブサイトのハンドラ関数の型は <code>SubHandlerFor sub master a</code> という形式に書き換える</li>
<li><code>HandlerFor</code> から <code>SubHandlerFor</code> へ持ち上げる時は <code>liftHandler</code> を使う</li>
<li>サブサイトの <code>YesodDispatch</code> 型クラスのインスタンスは <code>HandlerT</code> ではなく <code>instance Yesod master =&gt; YesodSubDispatch HelloSub master where</code> のように <code>Yesod</code> 型クラスのインスタンスを直接指定できるようになった</li>
</ul>
<h2 id="修正後のソースコード">修正後のソースコード</h2>
<p>ここでは公式サイトのコードと同様のディレクトリ構造及び、ファイル名とします。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1">$ <span class="ex">tree</span> .</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ex">.</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">├── <span class="ex">HelloSub</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">│   └── <span class="ex">Data.hs</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">├── <span class="ex">HelloSub.hs</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">└── <span class="ex">Main.hs</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="ex">1</span> directory, 3 files</a></code></pre></div>
<p>ファイルを分割しているのは <code>TH</code> の <code>GHC stage restriction</code> を回避するためです。</p>
<h3 id="hellosubdata.hs">HelloSub/Data.hs</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">{-# LANGUAGE QuasiQuotes     #-}</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ot">{-# LANGUAGE TypeFamilies    #-}</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">module</span> <span class="dt">HelloSub.Data</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Yesod</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="kw">data</span> <span class="dt">HelloSub</span> <span class="fu">=</span> <span class="dt">HelloSub</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">mkYesodSubData <span class="st">&quot;HelloSub&quot;</span> [parseRoutes|</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">/ SubHomeR GET</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">|]</a></code></pre></div>
<p>サブサイトのファウンデーション型 <code>HelloSub</code> とルートを定義しています。</p>
<p>通常であれば <code>mkYesod</code> を利用しますが <code>mkYesodSubData</code> を利用している点がサブサイトの特徴です。</p>
<h3 id="hellosub.hs">HelloSub.hs</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">{-# LANGUAGE FlexibleInstances     #-}</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="ot">{-# LANGUAGE OverloadedStrings     #-}</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ot">{-# LANGUAGE QuasiQuotes           #-}</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">{-# LANGUAGE TemplateHaskell       #-}</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="kw">module</span> <span class="dt">HelloSub</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  ( <span class="kw">module</span> <span class="dt">HelloSub.Data</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">  , <span class="kw">module</span> <span class="dt">HelloSub</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">  ) <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10"></a>
<a class="sourceLine" id="cb3-11" data-line-number="11"><span class="kw">import</span>           <span class="dt">HelloSub.Data</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12"><span class="kw">import</span>           <span class="dt">Yesod</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13"><span class="kw">import</span>           <span class="dt">Yesod.Core.Types</span></a>
<a class="sourceLine" id="cb3-14" data-line-number="14"></a>
<a class="sourceLine" id="cb3-15" data-line-number="15"><span class="ot">getSubHomeR ::</span> <span class="dt">Yesod</span> master <span class="ot">=&gt;</span> <span class="dt">SubHandlerFor</span> <span class="dt">HelloSub</span> master <span class="dt">Html</span></a>
<a class="sourceLine" id="cb3-16" data-line-number="16">getSubHomeR <span class="fu">=</span> liftHandler <span class="fu">$</span> defaultLayout [whamlet|Welcome to the subsite!|]</a>
<a class="sourceLine" id="cb3-17" data-line-number="17"></a>
<a class="sourceLine" id="cb3-18" data-line-number="18"><span class="kw">instance</span> <span class="dt">Yesod</span> master <span class="ot">=&gt;</span> <span class="dt">YesodSubDispatch</span> <span class="dt">HelloSub</span> master <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-19" data-line-number="19">  yesodSubDispatch <span class="fu">=</span> <span class="fu">$</span>(mkYesodSubDispatch resourcesHelloSub)</a></code></pre></div>
<p>サブサイトのハンドラと <code>dispatch</code> の定義です。</p>
<p><code>resourcesHelloSub</code> は <code>HelloSub/Data.hs</code> で定義した <code>mkYesodSubData</code> でコンパイル時に自動生成されます。</p>
<h3 id="main.hs">Main.hs</h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="co">-- stack --resolver lts-11.0 script --package yesod-core --package yesod</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="ot">{-# LANGUAGE QuasiQuotes       #-}</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="ot">{-# LANGUAGE TemplateHaskell   #-}</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="ot">{-# LANGUAGE TypeFamilies      #-}</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">HelloSub</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="kw">import</span>           <span class="dt">Yesod</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10"></a>
<a class="sourceLine" id="cb4-11" data-line-number="11"><span class="kw">data</span> <span class="dt">Master</span> <span class="fu">=</span> <span class="dt">Master</span></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">  {<span class="ot"> getHelloSub ::</span> <span class="dt">HelloSub</span></a>
<a class="sourceLine" id="cb4-13" data-line-number="13">  }</a>
<a class="sourceLine" id="cb4-14" data-line-number="14"></a>
<a class="sourceLine" id="cb4-15" data-line-number="15">mkYesod <span class="st">&quot;Master&quot;</span> [parseRoutes|</a>
<a class="sourceLine" id="cb4-16" data-line-number="16">/ HomeR GET</a>
<a class="sourceLine" id="cb4-17" data-line-number="17">/subsite SubsiteR HelloSub getHelloSub</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">|]</a>
<a class="sourceLine" id="cb4-19" data-line-number="19"></a>
<a class="sourceLine" id="cb4-20" data-line-number="20"><span class="kw">instance</span> <span class="dt">Yesod</span> <span class="dt">Master</span></a>
<a class="sourceLine" id="cb4-21" data-line-number="21"></a>
<a class="sourceLine" id="cb4-22" data-line-number="22"><span class="ot">getHomeR ::</span> <span class="dt">HandlerFor</span> <span class="dt">Master</span> <span class="dt">Html</span></a>
<a class="sourceLine" id="cb4-23" data-line-number="23">getHomeR <span class="fu">=</span> defaultLayout</a>
<a class="sourceLine" id="cb4-24" data-line-number="24">  [whamlet|</a>
<a class="sourceLine" id="cb4-25" data-line-number="25">    <span class="kw">&lt;h1&gt;</span>Welcome to the homepage</a>
<a class="sourceLine" id="cb4-26" data-line-number="26">    <span class="kw">&lt;p&gt;</span></a>
<a class="sourceLine" id="cb4-27" data-line-number="27">      Feel free to visit the #</a>
<a class="sourceLine" id="cb4-28" data-line-number="28">      <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="kw">@{</span><span class="dt">SubsiteR</span> <span class="dt">SubHomeR</span><span class="kw">}&gt;</span>subsite</a>
<a class="sourceLine" id="cb4-29" data-line-number="29">      \ as well.</a>
<a class="sourceLine" id="cb4-30" data-line-number="30">  |]</a>
<a class="sourceLine" id="cb4-31" data-line-number="31"></a>
<a class="sourceLine" id="cb4-32" data-line-number="32">main <span class="fu">=</span> warp <span class="dv">3000</span> <span class="fu">$</span> <span class="dt">Master</span> <span class="dt">HelloSub</span></a></code></pre></div>
<p>重要なポイントは以下の3点です。</p>
<ul>
<li><code>Master</code> ファウンデーション型にサブサイトの型を含ませる (さらにアクセサ <code>getHelloSub</code> を定義)</li>
<li><code>/subsite SubsiteR HelloSub getHelloSub</code> という形式でサブサイトへのルートを定義</li>
<li>サブサイトへの参照は <code>@{SubsiteR SubHomeR}</code> という形式の型安全URLとなる</li>
</ul>
<h2 id="実行">実行</h2>
<p><code>stack interpreter</code> 形式で実行します。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" data-line-number="1">$ <span class="fu">chmod</span> u+x Main.hs</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">$ <span class="ex">./Main.hs</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="ex">19/Mar</span>/2018:<span class="ex">00</span>:37:27 +0900 [Info#yesod-core] Application launched @(yesod-core-1.6.2-JztYji0NiLuH8rcbB3eMBP:Yesod.Core.Dispatch ./Yesod/Core/Dispatch.hs:167:11)</a></code></pre></div>
<p>この状態で <a href="http://localhost:3000/" class="uri">http://localhost:3000/</a> にアクセスしてみましょう。以下のようなページが表示されるはずです。</p>
<figure>
<img src="/images/2018/03-19/img01.png" alt="トップページ" /><figcaption>トップページ</figcaption>
</figure>
<p>サブサイトにアクセスするとこんな感じです。</p>
<figure>
<img src="/images/2018/03-19/img02.png" alt="サブサイト" /><figcaption>サブサイト</figcaption>
</figure>
<h2 id="scaffolded-site">Scaffolded Site</h2>
<p>ここではさらに一歩踏み込んで <code>Scaffolded Site</code> を利用する際、どのファイルに何を書いたら良いのか簡単に解説しておこうと思います。</p>
<p><code>Scaffolded Site</code> は一番素朴な <code>yesod-simple</code> を利用することとします。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" data-line-number="1">$ <span class="ex">stack</span> new example-subsite yesod-simple</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">$ <span class="bu">cd</span> example-subsite</a></code></pre></div>
<p>サブサイトの内容は上記で定義した内容を再利用します。</p>
<h3 id="stack.yaml">stack.yaml</h3>
<div class="sourceCode" id="cb7"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="fu">resolver:</span><span class="at"> lts-11.0</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="fu">packages:</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="kw">-</span> .</a></code></pre></div>
<p>現状落ちてくるものは <code>yesod-1.6.0</code> ではないので、書き換えます。</p>
<h3 id="package.yaml">package.yaml</h3>
<div class="sourceCode" id="cb8"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="fu">dependencies:</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">-</span> base</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="kw">-</span> classy-prelude-yesod</a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="kw">-</span> yesod</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="kw">-</span> yesod-core</a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="kw">-</span> yesod-static</a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="kw">-</span> yesod-form</a>
<a class="sourceLine" id="cb8-8" data-line-number="8"><span class="kw">-</span> classy-prelude</a>
<a class="sourceLine" id="cb8-9" data-line-number="9"><span class="kw">-</span> classy-prelude-conduit</a>
<a class="sourceLine" id="cb8-10" data-line-number="10"><span class="kw">-</span> bytestring</a>
<a class="sourceLine" id="cb8-11" data-line-number="11"><span class="kw">-</span> text</a>
<a class="sourceLine" id="cb8-12" data-line-number="12"><span class="kw">-</span> template-haskell</a>
<a class="sourceLine" id="cb8-13" data-line-number="13"><span class="kw">-</span> shakespeare</a>
<a class="sourceLine" id="cb8-14" data-line-number="14"><span class="kw">-</span> hjsmin</a>
<a class="sourceLine" id="cb8-15" data-line-number="15"><span class="kw">-</span> monad-control</a>
<a class="sourceLine" id="cb8-16" data-line-number="16"><span class="kw">-</span> wai-extra</a>
<a class="sourceLine" id="cb8-17" data-line-number="17"><span class="kw">-</span> yaml</a>
<a class="sourceLine" id="cb8-18" data-line-number="18"><span class="kw">-</span> http-conduit</a>
<a class="sourceLine" id="cb8-19" data-line-number="19"><span class="kw">-</span> directory</a>
<a class="sourceLine" id="cb8-20" data-line-number="20"><span class="kw">-</span> warp</a>
<a class="sourceLine" id="cb8-21" data-line-number="21"><span class="kw">-</span> data-default</a>
<a class="sourceLine" id="cb8-22" data-line-number="22"><span class="kw">-</span> aeson</a>
<a class="sourceLine" id="cb8-23" data-line-number="23"><span class="kw">-</span> conduit</a>
<a class="sourceLine" id="cb8-24" data-line-number="24"><span class="kw">-</span> monad-logger</a>
<a class="sourceLine" id="cb8-25" data-line-number="25"><span class="kw">-</span> fast-logger</a>
<a class="sourceLine" id="cb8-26" data-line-number="26"><span class="kw">-</span> wai-logger</a>
<a class="sourceLine" id="cb8-27" data-line-number="27"><span class="kw">-</span> file-embed</a>
<a class="sourceLine" id="cb8-28" data-line-number="28"><span class="kw">-</span> safe</a>
<a class="sourceLine" id="cb8-29" data-line-number="29"><span class="kw">-</span> unordered-containers</a>
<a class="sourceLine" id="cb8-30" data-line-number="30"><span class="kw">-</span> containers</a>
<a class="sourceLine" id="cb8-31" data-line-number="31"><span class="kw">-</span> vector</a>
<a class="sourceLine" id="cb8-32" data-line-number="32"><span class="kw">-</span> time</a>
<a class="sourceLine" id="cb8-33" data-line-number="33"><span class="kw">-</span> case-insensitive</a>
<a class="sourceLine" id="cb8-34" data-line-number="34"><span class="kw">-</span> wai</a>
<a class="sourceLine" id="cb8-35" data-line-number="35"><span class="kw">-</span> foreign-store</a></code></pre></div>
<p>バージョンを全部消しただけです。</p>
<h3 id="srcfoundation.hs">src/Foundation.hs</h3>
<p><code>App</code> データ型にサブサイトを含め、さらに <code>import</code> を追加します。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">import</span> <span class="dt">HelloSub</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="kw">data</span> <span class="dt">App</span> <span class="fu">=</span> <span class="dt">App</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  {<span class="ot"> appSettings    ::</span> <span class="dt">AppSettings</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">  ,<span class="ot"> appStatic      ::</span> <span class="dt">Static</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  ,<span class="ot"> appHttpManager ::</span> <span class="dt">Manager</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  ,<span class="ot"> appLogger      ::</span> <span class="dt">Logger</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">  ,<span class="ot"> getHelloSub    ::</span> <span class="dt">HelloSub</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">  }</a></code></pre></div>
<p><code>yesod-1.6.0</code> した影響でコンパイルエラーが出るため、<code>shouldLog</code> をコメントアウトします。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">    <span class="co">-- shouldLog app _source level =</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">    <span class="co">--     appShouldLogAll (appSettings app)</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">    <span class="co">--         || level == LevelWarn</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">    <span class="co">--         || level == LevelError</span></a></code></pre></div>
<h3 id="configroute">config/route</h3>
<p>サブサイトへのルートを追加します。</p>
<pre class="txt"><code>/subsite SubsiteR HelloSub getHelloSub</code></pre>
<h3 id="srcapplication.hs">src/Application.hs</h3>
<p>以下の2点を追記します。</p>
<ul>
<li><code>import HelloSub</code> を追加</li>
<li><code>makeFoundation</code> 関数に <code>let getHelloSub = HelloSub</code> を追記</li>
</ul>
<div class="sourceCode" id="cb12"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">import</span> <span class="dt">HelloSub</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="ot">makeFoundation ::</span> <span class="dt">AppSettings</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">App</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">makeFoundation appSettings <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  <span class="kw">let</span> getHelloSub <span class="fu">=</span> <span class="dt">HelloSub</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">  appHttpManager <span class="ot">&lt;-</span> newManager</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">  appLogger <span class="ot">&lt;-</span> newStdoutLoggerSet defaultBufSize <span class="fu">&gt;&gt;=</span> makeYesodLogger</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">  appStatic <span class="ot">&lt;-</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">    (<span class="kw">if</span> appMutableStatic appSettings <span class="kw">then</span> staticDevel <span class="kw">else</span> static)</a>
<a class="sourceLine" id="cb12-11" data-line-number="11">    (appStaticDir appSettings)</a>
<a class="sourceLine" id="cb12-12" data-line-number="12"></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">  return <span class="dt">App</span> {<span class="fu">..</span>}</a></code></pre></div>
<p><code>App {..}</code> は <code>GHC</code> の <code>RecordWildCards</code> 言語拡張です。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Example</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  { a <span class="fu">=</span> a</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  , b <span class="fu">=</span> b</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  , c <span class="fu">=</span> c</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  }</a></code></pre></div>
<p>僕はあまり使いませんが、雰囲気はこんな感じです。</p>
<h3 id="実行-1">実行</h3>
<div class="sourceCode" id="cb14"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb14-1" data-line-number="1">$ <span class="ex">stack</span> build</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">$ <span class="ex">stack</span> exec example-subsite</a></code></pre></div>
<p><a href="http://localhost:3000/subsite" class="uri">http://localhost:3000/subsite</a> にアクセスすると次のような画面が現れます。</p>
<figure>
<img src="/images/2018/03-19/img03.png" alt="実行結果" /><figcaption>実行結果</figcaption>
</figure>
<h2 id="まとめ">まとめ</h2>
<p><code>Yesod</code> を使っていてもサブサイトについて知らないという人は多いと思いますが、<code>Yesod</code> のアプリケーションが増えてきた時に使える、とても便利な仕組みだと思います。</p>
<p>サブサイトについて、もっと詳しく知りたい人は <a href="https://www.stackage.org/lts-11.1/package/yesod-static-1.6.0">yesod-static</a> パッケージの実装を見てみると良いでしょう。</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>extra-deps に github の短縮形が指定できるようになります</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-13-stack-extra-deps-shorthand.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-13-stack-extra-deps-shorthand.html</id>
    <published>2018-03-13T00:00:00Z</published>
    <updated>2018-03-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>今日マージされた <a href="https://github.com/commercialhaskell/stack/pull/3890">Allow ‘github’ shorthand for extra-deps (fixes #3873) #3890</a> がとても便利だと思いますのでご紹介します。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1">$ <span class="ex">stack</span> --version</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ex">Version</span> 1.7.0, Git revision 4a140342f9b28005bf2fdd5335bdcd32c9370265 (5702 commits) <span class="ex">x86_64</span> hpack-0.21.2</a></code></pre></div>
<!--more-->
<p><code>stack.yaml</code> に記述する <code>extra-deps</code> は主に2つの理由で記述することが多いです。</p>
<ul>
<li><code>lts</code> に含まれていないパッケージのバージョンを指定するため</li>
<li>そもそも <code>Hackage</code> に上がっていないパッケージを使うため</li>
</ul>
<p>今回は <code>extra-deps</code> の指定方法に <code>github</code> 専用の短縮形が導入されました。</p>
<p>こんな感じで指定可能です。(コミットの短縮形はいつから使えていたのかわかりませんが、使えます)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="fu">extra-deps:</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">-</span> <span class="fu">github:</span><span class="at"> haskell/text</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="fu">commit:</span><span class="at"> 9fac5d</span></a></code></pre></div>
<p>1.6.5 ではまだ利用できない機能となっております。</p>
<h2 id="試し方">試し方</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1">$ <span class="ex">stack</span> upgrade --git</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="co"># コンパイルするので時間かかります</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">$ <span class="ex">stack</span> --version</a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ex">Version</span> 1.7.0, Git revision 4a140342f9b28005bf2fdd5335bdcd32c9370265 (5702 commits) <span class="ex">x86_64</span> hpack-0.21.2</a></code></pre></div>
<p>遊んでから、元の <code>stack</code> のバージョンに戻す時は以下のようにするだけです。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1">$ <span class="ex">stack</span> upgrade --binary-version 1.6.5</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ex">...</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">$ <span class="ex">stack</span> --version</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="ex">Version</span> 1.6.5, Git revision 24ab0d6ff07f28276e082c3ce74dfdeb1a2ca9e9 (5514 commits) <span class="ex">x86_64</span> hpack-0.20.0</a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="co"># バイナリが落ちてくるのですぐ終わります</span></a></code></pre></div>
<h2 id="まとめ">まとめ</h2>
<ul>
<li><code>stack 1.7.0</code> ぐらいから利用できるようになるはず</li>
<li><code>github</code> が新たに追加され <code>user/repo</code> の短縮形で記述できるようになった</li>
<li><code>commit</code> もいつからか短縮形で記述できるようになっていた</li>
<li><code>subdirs</code> を指定すれば <code>Yesod</code> のような mega-repo でも指定できる</li>
</ul>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>wizard モノイド</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-07-The-wizard-monoid.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-07-The-wizard-monoid.html</id>
    <published>2018-03-07T00:00:00Z</published>
    <updated>2018-03-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="wizard-モノイド-翻訳">wizard モノイド (翻訳)</h2>
<p>Original post: <a href="http://www.haskellforall.com/2018/02/the-wizard-monoid.html">The wizard monoid</a></p>
<p>最近の GHC 8.0 は、<code>IO</code> 用の <code>Monoid</code> インスタンスを提供しています。このブログ記事では、組み合わせ可能な “wizard” を作りつつ、なぜこのインスタンスが便利なのかを示す例をお見せします。</p>
<!--more-->
<h3 id="wizard">Wizard</h3>
<p>ここで使う “wizard” とは、ユーザーに複数の入力を促し、全ての入力が完了したら、いくつかのアクションを実行するようなプログラムです。</p>
<p>簡単な wizard の例です:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">    <span class="co">-- First, we request all inputs:</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    putStrLn <span class="st">&quot;What is your name?&quot;</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    name <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    putStrLn <span class="st">&quot;What is your age?&quot;</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    age <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb1-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">    <span class="co">-- Then, we perform all actions:</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">    putStrLn (<span class="st">&quot;Your name is: &quot;</span> <span class="fu">++</span> name)</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">    putStrLn (<span class="st">&quot;Your age is: &quot;</span> <span class="fu">++</span> age)</a></code></pre></div>
<p>… 実行例:</p>
<pre class="plain"><code>What is your name?
Gabriel&lt;Enter&gt;
What is your age?
31&lt;Enter&gt;
Your name is: Gabriel
Your age is: 31</code></pre>
<p>… それで、以下はもう少し複雑な wizard の例です:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">System.Directory</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    <span class="co">-- First, we request all inputs:</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    files <span class="ot">&lt;-</span> System.Directory.listDirectory <span class="st">&quot;.&quot;</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    <span class="kw">let</span> askFile file <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">            putStrLn (<span class="st">&quot;Would you like to delete &quot;</span> <span class="fu">++</span> file <span class="fu">++</span> <span class="st">&quot;?&quot;</span>)</a>
<a class="sourceLine" id="cb3-9" data-line-number="9">            response <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">            <span class="kw">case</span> response <span class="kw">of</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">                <span class="st">&quot;y&quot;</span> <span class="ot">-&gt;</span> return [file]</a>
<a class="sourceLine" id="cb3-12" data-line-number="12">                _   <span class="ot">-&gt;</span> return []</a>
<a class="sourceLine" id="cb3-13" data-line-number="13"></a>
<a class="sourceLine" id="cb3-14" data-line-number="14">    listOfListOfFilesToRemove <span class="ot">&lt;-</span> mapM askFile files</a>
<a class="sourceLine" id="cb3-15" data-line-number="15">    <span class="kw">let</span> listOfFilesToRemove <span class="fu">=</span> concat listOfListOfFilesToRemove</a>
<a class="sourceLine" id="cb3-16" data-line-number="16"></a>
<a class="sourceLine" id="cb3-17" data-line-number="17">    <span class="co">-- Then, we perform all actions:</span></a>
<a class="sourceLine" id="cb3-18" data-line-number="18">    <span class="kw">let</span> removeFile file <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-19" data-line-number="19">            putStrLn (<span class="st">&quot;Removing &quot;</span> <span class="fu">++</span> file)</a>
<a class="sourceLine" id="cb3-20" data-line-number="20">            System.Directory.removeFile file</a>
<a class="sourceLine" id="cb3-21" data-line-number="21">    mapM_ removeFile listOfFilesToRemove</a></code></pre></div>
<p>… 実行例:</p>
<pre class="plain"><code>Would you like to delete file1.txt?
y&lt;Enter&gt;
Would you like to delete file2.txt?
n&lt;Enter&gt;
Would you like to delete file3.txt?
y&lt;Enter&gt;
Removing file1.txt
Removing file3.txt</code></pre>
<p>以上に挙げた例では、ユーザーが要求された入力を全て入力し終えるまで、変更ができないアクションを実行するのは避けたいという要求があります。</p>
<h3 id="モジュール性">モジュール性</h3>
<p>最初の例を見直してみましょう:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    <span class="co">-- First, we request all inputs:</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    putStrLn <span class="st">&quot;What is your name?&quot;</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    name <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">    putStrLn <span class="st">&quot;What is your age?&quot;</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">    age <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb5-9" data-line-number="9"></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    <span class="co">-- Then, we perform all actions:</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    putStrLn (<span class="st">&quot;Your name is: &quot;</span> <span class="fu">++</span> name)</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">    putStrLn (<span class="st">&quot;Your age is: &quot;</span> <span class="fu">++</span> age)</a></code></pre></div>
<p>この例は、実質的には2つの独立した wizard を組み合わせています:</p>
<ul>
<li>最初の wizard はユーザーの名前を要求し、表示している</li>
<li>2つ目の wizard はユーザーの年齢を要求し、表示している</li>
</ul>
<p>しかし、アクションを実行する前に全ての入力が必要だったので、2つの wizard のロジックをそれぞれ混ぜる必要がありました。</p>
<p>これら2つの wizard を別々に定義し、より大きな wizard に合体させる方法があったらどうでしょう? <code>IO</code> の <code>Monoid</code> インスタンスの長所を活かせば可能です。こんな感じ:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Monoid</span> ((&lt;&gt;))</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="ot">name ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">name <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    putStrLn <span class="st">&quot;What is your name?&quot;</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    x <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    return (putStrLn (<span class="st">&quot;Your name is: &quot;</span> <span class="fu">++</span> x))</a>
<a class="sourceLine" id="cb6-8" data-line-number="8"></a>
<a class="sourceLine" id="cb6-9" data-line-number="9"><span class="ot">age ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb6-10" data-line-number="10">age <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">    putStrLn <span class="st">&quot;What is your age?&quot;</span></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">    x <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb6-13" data-line-number="13">    return (putStrLn (<span class="st">&quot;Your age is: &quot;</span> <span class="fu">++</span> x))</a>
<a class="sourceLine" id="cb6-14" data-line-number="14"></a>
<a class="sourceLine" id="cb6-15" data-line-number="15"><span class="ot">runWizard ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb6-16" data-line-number="16">runWizard request <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-17" data-line-number="17">    respond <span class="ot">&lt;-</span> request</a>
<a class="sourceLine" id="cb6-18" data-line-number="18">    respond</a>
<a class="sourceLine" id="cb6-19" data-line-number="19"></a>
<a class="sourceLine" id="cb6-20" data-line-number="20"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb6-21" data-line-number="21">main <span class="fu">=</span> runWizard (name <span class="fu">&lt;&gt;</span> age)</a></code></pre></div>
<p>このプログラムはさっきの例と完全に同じ動きをします。が、ユーザーの名前を扱うロジックは、ユーザーの年齢を扱うロジックと完全に分離されています。</p>
<p>この方法でうまくいくのは、それぞれの wizard を2つの部分に分けたからです:</p>
<ul>
<li>リクエストの部分 (ユーザーに入力を求める部分など)</li>
<li>レスポンスの部分 (その入力に応じたアクションを実行する部分など)</li>
</ul>
<p>… そしてそれぞれの wizard に <code>IO (IO ())</code> という型を与えることによって、型レベルでこれを実現しています:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">name ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="ot">age ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a></code></pre></div>
<p>外側の <code>IO</code> アクションは“リクエスト”です。リクエストが終了したとき、外側の <code>IO</code> アクションは内側の <code>IO</code> アクション、つまり“レスポンス”を返します。例えば:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">--      ↓ リクエスト</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ot">name ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="co">--          ↑ レスポンス</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">name <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    putStrLn <span class="st">&quot;What is your name?&quot;</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">    x <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    <span class="co">-- ↑ ここから上の部分全てが、外側の `IO` アクションの一部 (例えばリクエスト)</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    <span class="co">--      ↓ この return される値は、内側の `IO` アクション (例えばレスポンス)</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">    return (putStrLn (<span class="st">&quot;Your name is: &quot;</span> <span class="fu">++</span> x))</a></code></pre></div>
<p>wizard は <code>(&lt;&gt;)</code> 演算子を使って組み合わせることができます。<code>IO</code> アクションに限って言うなら、以下のような動作をします:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">ioLeft <span class="fu">&lt;&gt;</span> ioRight</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="fu">=</span> <span class="kw">do</span> resultLeft  <span class="ot">&lt;-</span> ioLeft</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">     resultRight <span class="ot">&lt;-</span> ioRight</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">     return (resultLeft <span class="fu">&lt;&gt;</span> resultRight)</a></code></pre></div>
<p>言い換えるなら、<code>IO</code> アクションを2つ組み合わせるということは、それぞれの <code>IO</code> アクションを実行して結果を組み合わせるということなのです。これは、2つの <code>IO</code> アクションをネストさせると、アクションを実行して結果を組み合わせるという処理を2回実行する、ということも示しています:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">requestLeft <span class="fu">&lt;&gt;</span> requestRight</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="fu">=</span> <span class="kw">do</span> respondLeft  <span class="ot">&lt;-</span> requestLeft</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">     respondRight <span class="ot">&lt;-</span> requestRight</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">     return (respondLeft <span class="fu">&lt;&gt;</span> respondRight)</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="fu">=</span> <span class="kw">do</span> respondLeft  <span class="ot">&lt;-</span> requestLeft</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">     respondRight <span class="ot">&lt;-</span> requestRight</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">     return (<span class="kw">do</span></a>
<a class="sourceLine" id="cb10-10" data-line-number="10">         unitLeft  <span class="ot">&lt;-</span> respondLeft</a>
<a class="sourceLine" id="cb10-11" data-line-number="11">         unitRight <span class="ot">&lt;-</span> respondRight</a>
<a class="sourceLine" id="cb10-12" data-line-number="12">         return (unitLeft <span class="fu">&lt;&gt;</span> unitRight) )</a>
<a class="sourceLine" id="cb10-13" data-line-number="13"></a>
<a class="sourceLine" id="cb10-14" data-line-number="14"><span class="co">-- Both `unitLeft` and `unitRight` are `()` and `() &lt;&gt; () = ()`, so we can</span></a>
<a class="sourceLine" id="cb10-15" data-line-number="15"><span class="co">-- simplify this further to:</span></a>
<a class="sourceLine" id="cb10-16" data-line-number="16"></a>
<a class="sourceLine" id="cb10-17" data-line-number="17"><span class="co">-- `unitLeft` も `unitRight` も `()` で、`() &lt;&gt; () = ()` なので、</span></a>
<a class="sourceLine" id="cb10-18" data-line-number="18"><span class="co">-- 以下のように簡約化することができます:</span></a>
<a class="sourceLine" id="cb10-19" data-line-number="19"><span class="fu">=</span> <span class="kw">do</span> respondLeft  <span class="ot">&lt;-</span> requestLeft</a>
<a class="sourceLine" id="cb10-20" data-line-number="20">     respondRight <span class="ot">&lt;-</span> requestRight</a>
<a class="sourceLine" id="cb10-21" data-line-number="21">     return (<span class="kw">do</span></a>
<a class="sourceLine" id="cb10-22" data-line-number="22">         respondLeft</a>
<a class="sourceLine" id="cb10-23" data-line-number="23">         respondRight )</a></code></pre></div>
<p>つまり、2つの wizard を組み合わせると、リクエストを組み合わせてレスポンスも組み合わせたことになるのです。</p>
<p>この方法は2つ以上の wizard でもうまくいきます。例えば:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">request0 <span class="fu">&lt;&gt;</span> request1 <span class="fu">&lt;&gt;</span> request2 <span class="fu">&lt;&gt;</span> request3</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="fu">=</span> <span class="kw">do</span> respond0 <span class="ot">&lt;-</span> request0</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">     respond1 <span class="ot">&lt;-</span> request1</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">     respond2 <span class="ot">&lt;-</span> request2</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">     respond3 <span class="ot">&lt;-</span> request3</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">     return (<span class="kw">do</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">         respond0</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">         respond1</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">         respond2</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">         respond3 )</a></code></pre></div>
<p>これをアクションの形で表現するために、さっきの例をもう一度見てみましょう:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Monoid</span> ((&lt;&gt;))</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="ot">name ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">name <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">    putStrLn <span class="st">&quot;What is your name?&quot;</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">    x <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">    return (putStrLn (<span class="st">&quot;Your name is: &quot;</span> <span class="fu">++</span> x))</a>
<a class="sourceLine" id="cb12-8" data-line-number="8"></a>
<a class="sourceLine" id="cb12-9" data-line-number="9"><span class="ot">age ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb12-10" data-line-number="10">age <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-11" data-line-number="11">    putStrLn <span class="st">&quot;What is your age?&quot;</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">    x <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb12-13" data-line-number="13">    return (putStrLn (<span class="st">&quot;Your age is: &quot;</span> <span class="fu">++</span> x))</a>
<a class="sourceLine" id="cb12-14" data-line-number="14"></a>
<a class="sourceLine" id="cb12-15" data-line-number="15"><span class="ot">runWizard ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb12-16" data-line-number="16">runWizard request <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-17" data-line-number="17">    respond <span class="ot">&lt;-</span> request</a>
<a class="sourceLine" id="cb12-18" data-line-number="18">    respond</a>
<a class="sourceLine" id="cb12-19" data-line-number="19"></a>
<a class="sourceLine" id="cb12-20" data-line-number="20"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb12-21" data-line-number="21">main <span class="fu">=</span> runWizard (name <span class="fu">&lt;&gt;</span> age)</a></code></pre></div>
<p>…<code>name</code> と <code>age</code> はかなり似ているので、共通の関数を使うような実装にすることができますね:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Monoid</span> ((&lt;&gt;))</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="ot">prompt ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">prompt attribute <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    putStrLn (<span class="st">&quot;What is your &quot;</span> <span class="fu">++</span> attribute <span class="fu">++</span> <span class="st">&quot;?&quot;</span>)</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    x <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    return (putStrLn (<span class="st">&quot;Your &quot;</span> <span class="fu">++</span> attribute <span class="fu">++</span> <span class="st">&quot; is: &quot;</span> <span class="fu">++</span> x))</a>
<a class="sourceLine" id="cb13-8" data-line-number="8"></a>
<a class="sourceLine" id="cb13-9" data-line-number="9"><span class="ot">runWizard ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb13-10" data-line-number="10">runWizard request <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-11" data-line-number="11">    respond <span class="ot">&lt;-</span> request</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">    respond</a>
<a class="sourceLine" id="cb13-13" data-line-number="13"></a>
<a class="sourceLine" id="cb13-14" data-line-number="14"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb13-15" data-line-number="15">main <span class="fu">=</span> runWizard (prompt <span class="st">&quot;name&quot;</span> <span class="fu">&lt;&gt;</span> prompt <span class="st">&quot;age&quot;</span>)</a></code></pre></div>
<p>2つの wizard のロジックが混ざっていたとき、この共通化のロジックを使うことはできませんでした。しかしロジック毎に別々の wizard に分割すると、プログラムを小さくするための共通構造を突くことができます。</p>
<p>このプログラムの圧縮によって、簡単に新しい wizard を追加することができます:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Monoid</span> ((&lt;&gt;))</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="ot">prompt ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">prompt attribute <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    putStrLn (<span class="st">&quot;What is your &quot;</span> <span class="fu">++</span> attribute <span class="fu">++</span> <span class="st">&quot;?&quot;</span>)</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    x <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    return (putStrLn (<span class="st">&quot;Your &quot;</span> <span class="fu">++</span> attribute <span class="fu">++</span> <span class="st">&quot; is: &quot;</span> <span class="fu">++</span> x))</a>
<a class="sourceLine" id="cb14-8" data-line-number="8"></a>
<a class="sourceLine" id="cb14-9" data-line-number="9"><span class="ot">runWizard ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">runWizard request <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-11" data-line-number="11">    respond <span class="ot">&lt;-</span> request</a>
<a class="sourceLine" id="cb14-12" data-line-number="12">    respond</a>
<a class="sourceLine" id="cb14-13" data-line-number="13"></a>
<a class="sourceLine" id="cb14-14" data-line-number="14"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb14-15" data-line-number="15">main <span class="fu">=</span> runWizard (prompt <span class="st">&quot;name&quot;</span> <span class="fu">&lt;&gt;</span> prompt <span class="st">&quot;age&quot;</span> <span class="fu">&lt;&gt;</span> prompt <span class="st">&quot;favorite color&quot;</span>)</a></code></pre></div>
<p>… そして、モノイド関連の標準ライブラリ関数を活用しましょう。例えば <code>foldMap</code> を使えば wizard を大量に作ることができます。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Monoid</span> ((&lt;&gt;))</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="ot">prompt ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">prompt attribute <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    putStrLn (<span class="st">&quot;What is your &quot;</span> <span class="fu">++</span> attribute <span class="fu">++</span> <span class="st">&quot;?&quot;</span>)</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">    x <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb15-7" data-line-number="7">    return (putStrLn (<span class="st">&quot;Your &quot;</span> <span class="fu">++</span> attribute <span class="fu">++</span> <span class="st">&quot; is: &quot;</span> <span class="fu">++</span> x))</a>
<a class="sourceLine" id="cb15-8" data-line-number="8"></a>
<a class="sourceLine" id="cb15-9" data-line-number="9"><span class="ot">runWizard ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb15-10" data-line-number="10">runWizard request <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb15-11" data-line-number="11">    respond <span class="ot">&lt;-</span> request</a>
<a class="sourceLine" id="cb15-12" data-line-number="12">    respond</a>
<a class="sourceLine" id="cb15-13" data-line-number="13"></a>
<a class="sourceLine" id="cb15-14" data-line-number="14"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb15-15" data-line-number="15">main <span class="fu">=</span> runWizard (foldMap prompt [ <span class="st">&quot;name&quot;</span>, <span class="st">&quot;age&quot;</span>, <span class="st">&quot;favorite color&quot;</span>, <span class="st">&quot;sign&quot;</span> ])</a></code></pre></div>
<p>より重要なのは、プログラムが何をしているのか一目瞭然になりました。読みやすさは書きやすさに比べ、大きな美徳です。</p>
<h3 id="最後の例">最後の例</h3>
<p>ファイル削除の例も同じ観点から見直してみましょう:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">System.Directory</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    <span class="co">-- 最初に全ての入力をリクエストする:</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">    files <span class="ot">&lt;-</span> System.Directory.listDirectory <span class="st">&quot;.&quot;</span></a>
<a class="sourceLine" id="cb16-7" data-line-number="7">    <span class="kw">let</span> askFile file <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-8" data-line-number="8">            putStrLn (<span class="st">&quot;Would you like to delete &quot;</span> <span class="fu">++</span> file <span class="fu">++</span> <span class="st">&quot;?&quot;</span>)</a>
<a class="sourceLine" id="cb16-9" data-line-number="9">            response <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb16-10" data-line-number="10">            <span class="kw">case</span> response <span class="kw">of</span></a>
<a class="sourceLine" id="cb16-11" data-line-number="11">                <span class="st">&quot;y&quot;</span> <span class="ot">-&gt;</span> return [file]</a>
<a class="sourceLine" id="cb16-12" data-line-number="12">                _   <span class="ot">-&gt;</span> return []</a>
<a class="sourceLine" id="cb16-13" data-line-number="13"></a>
<a class="sourceLine" id="cb16-14" data-line-number="14">    listOfListOfFilesToRemove <span class="ot">&lt;-</span> mapM askFile files</a>
<a class="sourceLine" id="cb16-15" data-line-number="15">    <span class="kw">let</span> listOfFilesToRemove <span class="fu">=</span> concat listOfListOfFilesToRemove</a>
<a class="sourceLine" id="cb16-16" data-line-number="16"></a>
<a class="sourceLine" id="cb16-17" data-line-number="17">    <span class="co">-- 次に全てのアクションを実行する</span></a>
<a class="sourceLine" id="cb16-18" data-line-number="18">    <span class="kw">let</span> removeFile file <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-19" data-line-number="19">            putStrLn (<span class="st">&quot;Removing &quot;</span> <span class="fu">++</span> file)</a>
<a class="sourceLine" id="cb16-20" data-line-number="20">            System.Directory.removeFile file</a>
<a class="sourceLine" id="cb16-21" data-line-number="21">    mapM_ removeFile listOfFilesToRemove</a></code></pre></div>
<p>さっきと同じパターンで、シンプルにすることができます:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">System.Directory</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2"></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5">    files <span class="ot">&lt;-</span> System.Directory.listDirectory <span class="st">&quot;.&quot;</span></a>
<a class="sourceLine" id="cb17-6" data-line-number="6">    runWizard (foldMap prompt files)</a>
<a class="sourceLine" id="cb17-7" data-line-number="7"></a>
<a class="sourceLine" id="cb17-8" data-line-number="8"><span class="ot">prompt ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IO</span> ())</a>
<a class="sourceLine" id="cb17-9" data-line-number="9">prompt file <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-10" data-line-number="10">    putStrLn (<span class="st">&quot;Would you like to delete &quot;</span> <span class="fu">++</span> file <span class="fu">++</span> <span class="st">&quot;?&quot;</span>)</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">    response <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb17-12" data-line-number="12">    <span class="kw">case</span> response <span class="kw">of</span></a>
<a class="sourceLine" id="cb17-13" data-line-number="13">        <span class="st">&quot;y&quot;</span> <span class="ot">-&gt;</span> return (<span class="kw">do</span></a>
<a class="sourceLine" id="cb17-14" data-line-number="14">            putStrLn (<span class="st">&quot;Removing &quot;</span> <span class="fu">++</span> file)</a>
<a class="sourceLine" id="cb17-15" data-line-number="15">            System.Directory.removeFile file )</a>
<a class="sourceLine" id="cb17-16" data-line-number="16">        _   <span class="ot">-&gt;</span> return (return ())</a>
<a class="sourceLine" id="cb17-17" data-line-number="17"></a>
<a class="sourceLine" id="cb17-18" data-line-number="18"><span class="ot">runWizard ::</span> <span class="dt">IO</span> (<span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</a>
<a class="sourceLine" id="cb17-19" data-line-number="19">runWizard request <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-20" data-line-number="20">    respond <span class="ot">&lt;-</span> request</a>
<a class="sourceLine" id="cb17-21" data-line-number="21">    respond</a></code></pre></div>
<p>やるべきなのは、1つのファイルに対して処理を行う wizard を定義すること、そして <code>foldMap</code> を使って wizard を大量に生成することだけです。<code>IO</code> の <code>Monoid</code> インスタンスは、全てのリクエストを束ねて表示し、後で選択したファイルを削除してくれます。</p>
<h3 id="結論">結論</h3>
<p>ユーザーが望む wizard の全てにこのパターンが適用できるわけではありません。例えば、wizard が互いに依存しているような状況では、このパターンはすぐに使い物にならなくなります。しかし、このパターンは <code>Monoid</code> の <code>IO</code> インスタンスを他の <code>Monoid</code> のインスタンスと (もしくは自分自身と!) 連結させ、新しい動作を生成するような一例にはなっています。</p>]]></summary>
</entry>
<entry>
    <title>Liquid Haskell のインストールと学習方法</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-03-liquidhaskell-intro.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-03-liquidhaskell-intro.html</id>
    <published>2018-03-03T00:00:00Z</published>
    <updated>2018-03-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p><code>Liquid Haskell</code> を半年ほど勉強した結果、色々と出来ることが増えて楽しくなってきました。</p>
<p>現状、日本語で詳しく説明しているブログ記事や <code>Qiita</code> 記事はほとんどありません。</p>
<p>とても面白いツールだと思いますので、色々と紹介していけたらと思います。</p>
<p>今回は <code>Liquid Haskell</code> の導入方法について簡単に説明したいと思います。</p>
<!--more-->
<h2 id="liquid-haskell-とは">Liquid Haskell とは？</h2>
<p><code>Liquid Haskell</code> は <code>GHC</code> の型よりも、さらに厳密な <code>篩型 (Refinement Type)</code> の型検査器です。</p>
<p>既存のコードを変更 (さらには実行すら) することなく利用できるため、既存のプロジェクトの一部にだけ導入することも可能です。</p>
<p>また、つい最近も <code>GADT</code> をサポートしたりと、開発はとても活発に行われています。</p>
<p>正しいソフトウェアを楽しく作るために、<code>Liquid Haskell</code> を学習してみるのはどうでしょうか！</p>
<p>ちなみに <code>Liquid</code> という単語は <code>液体</code> と言いたくなりますが、それとはあまり関係なく、実際は <code>Logically Qualified Data</code> の略です。(ロゴは <code>水滴</code> + <code>&gt;&gt;=</code> なので、全く無関係では無いかもですが)</p>
<h2 id="インストール">インストール</h2>
<p><code>Liquid Haskell</code> は以下の2つのリポジトリで開発が進められています。</p>
<ul>
<li><a href="https://github.com/ucsd-progsys/liquidhaskell">ucsd-progsys/liquidhaskell</a></li>
<li><a href="https://github.com/ucsd-progsys/liquid-fixpoint">ucsd-progsys/liquid-fixpoint</a></li>
</ul>
<p><code>liquidhaskell</code> がフロントエンド (コマンドライン処理やパーサーなどの処理等) を行い <code>liquid-fixpoint</code> が <code>SMT</code> ソルバに投げるための処理を色々とやっている印象です。(詳しくないので間違ってたらすみません)</p>
<p>なので、僕らが関係するのは基本的に <code>liquidhaskell</code> リポジトリの方です。(<code>liquid-fixpoint</code> はサブモジュールになっています)</p>
<p>また、実際にチェックを行うのは <code>SMT</code> ソルバなので、そちらも同様にインストールが必要です。</p>
<h3 id="smt-ソルバのインストール">SMT ソルバのインストール</h3>
<p><code>SMT</code> ソルバも色々と種類があるようで、公式では以下の3種類が紹介されています。</p>
<ul>
<li>Z3</li>
<li>CVC4</li>
<li>MathSat</li>
</ul>
<p>どれでもちゃんと動くので好きなソルバを使えば良いのですが、どれを選んだら良いかわからない人は <code>Z3</code> にしましょう。</p>
<p>理由としてはインストール方法が簡単で、性能も良いそうです。</p>
<h4 id="ubuntu">Ubuntu</h4>
<pre class="shell"><code>$ sudo apt install z3

$ z3 --version
Z3 version 4.4.1</code></pre>
<h4 id="mac-brew">Mac (brew)</h4>
<pre class="shell"><code>$ brew install z3

$ z3 --version
Z3 version 4.6.0 - 64 bit</code></pre>
<h3 id="liquid-haskell-のインストール">Liquid Haskell のインストール</h3>
<p>現状、一番安定しているのは <code>github</code> の <a href="https://github.com/ucsd-progsys/liquidhaskell"><strong>develop</strong></a> ブランチを <code>stack</code> でビルドしてインストールする方法だと思います。</p>
<p>また、その他のインストール方法等は <a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/INSTALL.md">INSTALL.md</a> をご参照下さい。</p>
<pre class="shell"><code>$ git clone --recursive git@github.com:ucsd-progsys/liquidhaskell.git
$ cd liquidhaskell
$ stack install

$ liquid
LiquidHaskell Version 0.8.2.4, Git revision d641244775cd842776cecf2c5d3e9afa01549e76 (dirty)
Copyright 2013-18 Regents of the University of California. All Rights Reserved.</code></pre>
<p>stack プロジェクトで利用する場合は、以下のように <code>stack exec</code> コマンドで呼び出します。</p>
<pre class="shell"><code>$ stack exec -- liquid
LiquidHaskell Version 0.8.2.4, Git revision d641244775cd842776cecf2c5d3e9afa01549e76 (dirty)
Copyright 2013-18 Regents of the University of California. All Rights Reserved.</code></pre>
<h2 id="サンプルプログラム">サンプルプログラム</h2>
<p><code>myDiv</code> 関数の例を使って <code>LiquidHaskell</code> に慣れましょう！</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">-- MyDiv.hs</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">module</span> <span class="dt">MyDiv</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="ot">myDiv ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">myDiv <span class="fu">=</span> div</a></code></pre></div>
<p><code>myDiv</code> の実装は単に <code>div</code> をラップしただけです。</p>
<p>この関数はだいたい上手く動きますが、もし第二引数に <strong>0</strong> が与えられたらどうでしょうか？そう、実行時エラーになります・・・。試してみましょう。</p>
<pre class="shell"><code>$ stack repl -- MyDiv.hs
*MyDiv&gt; myDiv 10 2
5
*MyDiv&gt; myDiv 10 0
*** Exception: divide by zero</code></pre>
<p>全然安全ではありませんね。</p>
<p>では、どうしたら本当に安全な <code>myDiv</code> を作れるのでしょうか？</p>
<p>その答えは<code>篩(ふるい)型</code>にあります。</p>
<p><code>Liquid Haskell</code> では <code>篩型</code> を <code>{-@ ... @-}</code> のコメント形式で記述します。<code>Liquid Haskell</code> を利用するメリットの1つは、篩型の自動推論です。(推論できない場合も多々ありますが、結構色々と推論してくれます)</p>
<p>先程の <code>myDiv</code> には篩型を書いていませんが、こういう場合に <code>Liquid Haskell</code> は <code>Haskell</code> の型をそのまま篩型として利用します。</p>
<p><code>myDiv</code> に対して明示的に篩型を書いてみましょう！</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="co">{-@ myDiv :: Int -&gt; Int -&gt; Int @-}</span> <span class="co">-- これが篩型</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">myDiv ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">myDiv <span class="fu">=</span> div</a></code></pre></div>
<p>この <code>myDiv</code> 関数を <code>LquidHaskell</code> でチェックしてみましょう。</p>
<pre class="shell"><code>$ liquid MyDiv.hs
**** RESULT: UNSAFE ************************************************************

 MyDiv.hs:4:11-13: Error: Liquid Type Mismatch

 4 | myDiv = div
             ^^^

   Inferred type
     VV : Int

   not a subtype of Required type
     VV : {VV : Int | VV /= 0}

   In Context</code></pre>
<p>なぜか <code>UNSAFE</code> が表示されましたね。これは <code>Liquid Haskell</code> で既に <code>div</code> の篩型が定義されているからです。(<a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/include/GHC/Real.spec#L19">div</a> 以外にも色々ありますが、充実しているとは言い難いと思います)</p>
<p>だいたいこんな感じで、第二引数に <strong>0を含まないInt型</strong> という事前条件がついているのです。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="co">{-@ div :: Int -&gt; {v:Int | v /= 0} -&gt; Int @-}</span></a></code></pre></div>
<p>そのため、先程のエラーメッセージで以下のように指摘されてしまったのです。</p>
<pre class="shell"><code>not a subtype of Required type
     VV : {VV : Int | VV /= 0}</code></pre>
<p>つまり、僕らの定義した篩型は <code>0</code> を含む <code>Int</code> 型なので、このままだと <code>div</code> に <code>0</code> が与えられてしまう可能性があるよ！ということを教えてくれています。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="co">{-@ myDiv :: Int -&gt; Int -&gt; Int @-}</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="ot">myDiv ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">myDiv <span class="fu">=</span> div</a></code></pre></div>
<p><code>myDiv</code> にも同じ篩型をつけてみましょう。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="co">{-@ myDiv :: Int -&gt; {v:Int | v /= 0} -&gt; Int @-}</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="ot">myDiv ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">myDiv <span class="fu">=</span> div</a></code></pre></div>
<p>これで <code>SAFE</code> になります。</p>
<pre class="shell"><code>$ liquid MyDiv.hs
**** RESULT: SAFE **************************************************************</code></pre>
<p><code>0</code> を含まない <code>Int</code> 型というのは、よく使いそうなので篩型のエイリアスとして定義してみます。</p>
<p>篩型のエイリアスは <code>type</code> キーワードを使います。<code>Haskell</code> と同じですね。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="co">{-@ type NonZero = {v:Int | v /= 0} @-}</span></a></code></pre></div>
<p>そして <code>myDiv</code> の篩型も <code>NonZero</code> で置き換えます。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="co">{-@ type NonZero = {v:Int | v /= 0} @-}</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="co">{-@ myDiv :: Int -&gt; NonZero -&gt; Int @-}</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="ot">myDiv ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">myDiv <span class="fu">=</span> div</a></code></pre></div>
<p>意味は全く同じですが、先程よりもわかりやすくなりました。</p>
<pre class="shell"><code>$ liquid MyDiv.hs
**** RESULT: SAFE **************************************************************</code></pre>
<p>最後に <code>myDiv</code> を呼び出す関数を定義してみましょう。</p>
<p><code>good</code> は問題の無い使い方です。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">good ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">good <span class="fu">=</span> myDiv <span class="dv">10</span> <span class="dv">2</span></a></code></pre></div>
<p>しかし、以下のような関数 <code>bad</code> が定義された場合、<code>Liquid Haskell</code> は <code>UNSAFE</code> を返します。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">bad ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">bad <span class="fu">=</span> myDiv <span class="dv">10</span> <span class="dv">0</span></a></code></pre></div>
<pre class="shell"><code>$ liquid MyDiv.hs
**** RESULT: UNSAFE ************************************************************

 MyDiv.hs:13:7-16: Error: Liquid Type Mismatch

 13 | bad = myDiv 10 0
            ^^^^^^^^^^

   Inferred type
     VV : {v : Int | v == (0 : int)
                     &amp;&amp; v == ?a}

   not a subtype of Required type
     VV : {VV : Int | VV /= 0}

   In Context
     ?a : {?a : Int | ?a == (0 : int)}</code></pre>
<h2 id="問題">問題</h2>
<p>以下のプログラムは標準入力から入力された数 <code>n</code>, <code>m</code> で <code>safeDiv n m</code> を計算します。</p>
<p><code>safeDiv</code> の <code>check</code> を正しく実装して <code>Liquid Haskell</code> の結果を <code>SAFE</code> にしてみましょう。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="co">-- Main.hs</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="co">{-@ type NonZero = {v:Int | v /= 0} @-}</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5"></a>
<a class="sourceLine" id="cb20-6" data-line-number="6"><span class="co">{-@ myDiv :: Int -&gt; NonZero -&gt; Int @-}</span></a>
<a class="sourceLine" id="cb20-7" data-line-number="7"><span class="ot">myDiv ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb20-8" data-line-number="8">myDiv <span class="fu">=</span> div</a>
<a class="sourceLine" id="cb20-9" data-line-number="9"></a>
<a class="sourceLine" id="cb20-10" data-line-number="10"><span class="co">{-@ lazy main @-}</span></a>
<a class="sourceLine" id="cb20-11" data-line-number="11"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb20-12" data-line-number="12">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb20-13" data-line-number="13">  n <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb20-14" data-line-number="14">  m <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb20-15" data-line-number="15">  <span class="kw">case</span> safeDiv (read n) (read m) <span class="kw">of</span></a>
<a class="sourceLine" id="cb20-16" data-line-number="16">    <span class="dt">Just</span> res <span class="ot">-&gt;</span> print res</a>
<a class="sourceLine" id="cb20-17" data-line-number="17">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb20-18" data-line-number="18">      putStrLn <span class="st">&quot;第二引数に0が入力されています&quot;</span></a>
<a class="sourceLine" id="cb20-19" data-line-number="19">      putStrLn <span class="st">&quot;もう一度入力してください&quot;</span></a>
<a class="sourceLine" id="cb20-20" data-line-number="20">      main</a>
<a class="sourceLine" id="cb20-21" data-line-number="21"></a>
<a class="sourceLine" id="cb20-22" data-line-number="22"><span class="co">{-@ safeDiv :: Int -&gt; Int -&gt; Maybe Int @-}</span></a>
<a class="sourceLine" id="cb20-23" data-line-number="23"><span class="ot">safeDiv ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb20-24" data-line-number="24">safeDiv n m</a>
<a class="sourceLine" id="cb20-25" data-line-number="25">  <span class="fu">|</span> check     <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> div n m</a>
<a class="sourceLine" id="cb20-26" data-line-number="26">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb20-27" data-line-number="27">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-28" data-line-number="28">   check <span class="fu">=</span> <span class="dt">True</span></a></code></pre></div>
<p>Hint: <code>div</code> に <code>0</code> を通さないよう <code>check</code> でバリデーションすれば良いです。</p>
<h3 id="エラーメッセージ">エラーメッセージ</h3>
<p>現状では、<code>Liquid Haskell</code> は以下のエラーメッセージを返します。</p>
<pre class="shell"><code>$ liquid Main.hs
**** RESULT: UNSAFE ************************************************************

 Main.hs:24:24-30: Error: Liquid Type Mismatch

 24 |   | check     = Just $ div n m
                             ^^^^^^^

   Inferred type
     VV : {v : Int | v == m}

   not a subtype of Required type
     VV : {VV : Int | VV /= 0}

   In Context
     m : Int</code></pre>
<h3 id="実行例">実行例</h3>
<p><code>Liquid Haskell</code> が <code>UNSAFE</code> の場合は実行時エラーが発生します。</p>
<pre class="shell"><code>$ stack repl -- Main.hs
*Main&gt; main
10
2
5

*Main&gt; main
10
0
*** Exception: divide by zero</code></pre>
<p><code>Liquid Haskell</code> を <code>SAFE</code> にすると、再入力を促すようになります。</p>
<pre class="shell"><code>*Main&gt; main
10
0
第二引数に0が入力されています
もう一度入力してください
10
2
5</code></pre>
<h2 id="興味を持った方へ">興味を持った方へ</h2>
<p><code>Liquid Haskell</code> に興味を持った方は以下の文献を読んで <code>Liquid Haskell</code> に詳しくなりましょう！(個人的にまとめているやつを貼り付けただけなので雑ですみません・・・)</p>
<p>たぶん、おすすめは以下のチュートリアルです。(僕はまだ読んでないですが、かなり最近できたものなので情報が新しく良いのではないかと思います)</p>
<ul>
<li><a href="https://liquid.kosmikus.org/">Liquid Haskell Tutorial</a></li>
</ul>
<h3 id="日本語の情報">日本語の情報</h3>
<ul>
<li><a href="http://ccvanishing.hateblo.jp/entry/2016/12/24/193038">LiquidHaskell コトハジメ</a></li>
<li><a href="https://dodgsonlabs.booth.pm/items/490689">入門 LiquidHaskell −篩型による静的コード解析−</a></li>
<li><a href="http://demand-side-science.jp/blog/2014/flops2014%E5%A0%B1%E5%91%8A/">FLOPS2014報告</a></li>
</ul>
<h3 id="ブログ">ブログ</h3>
<ul>
<li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/">liquidhaskell-blog</a></li>
<li><a href="http://www.haskellforall.com/2015/12/compile-time-memory-safety-using-liquid.html">Compile-time memory safety using Liquid Haskell</a></li>
<li><a href="http://conscientiousprogrammer.com/blog/2015/12/23/24-days-of-hackage-2015-day-23-liquid-haskell-refinement-types-for-the-real-world/">Liquid Haskell: refinement types for the real world</a></li>
</ul>
<h3 id="チュートリアル">チュートリアル</h3>
<ul>
<li><a href="https://liquid.kosmikus.org/">Liquid Haskell Tutorial</a></li>
<li><a href="https://github.com/ucsd-progsys/liquidhaskell-tutorial">liquidhaskell-tutorial</a>
<ul>
<li>long tutorial</li>
<li><a href="http://ucsd-progsys.github.io/liquidhaskell-tutorial/book.pdf">book</a></li>
<li><a href="https://github.com/ucsd-progsys/liquidhaskell-tutorial/blob/master/pdf/programming-with-refinement-types.pdf">programming-with-refinement-types.pdf</a></li>
</ul></li>
<li><a href="https://github.com/ucsd-progsys/lh-workshop">lh-workshop</a>
<ul>
<li>short tutorial</li>
</ul></li>
<li><a href="http://goto.ucsd.edu/~nvazou/presentations/shonan17/01-index.html">Liquid Haskell: Verification of Haskell Code</a></li>
</ul>
<h3 id="スライド">スライド</h3>
<ol type="1">
<li><a href="http://goto.ucsd.edu/~rjhala/flops14/lhs/00_Index.lhs.slides.html#/">Liquid Types For Haskell</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/flops14/lhs/01_SimpleRefinements.lhs.slides.html#/">Simple Refinement Types</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/flops14/lhs/02_Measures.lhs.slides.html#/">Measuring Data Types</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/flops14/lhs/03_HigherOrderFunctions.lhs.slides.html#/">Higher-Order Specifications</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/flops14/lhs/04_AbstractRefinements.lhs.slides.html#/">Abstract Refinements</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/flops14/lhs/09_Laziness.lhs.slides.html#/">Lazy Evaluation?</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/flops14/lhs/10_Termination.lhs.slides.html#/">Refinements &amp; Termination</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/flops14/lhs/11_Evaluation.lhs.slides.html#/">Evaluation</a></li>
</ol>
<ul>
<li><a href="https://web.eecs.umich.edu/~weimerw/students/anish-ms-pres.pdf">Finding and Fixing Bugs in Liquid Haskell</a></li>
<li><a href="https://github.com/Gabriel439/slides/blob/master/liquidhaskell/slides.md">Scrap your Bounds Checks with Liquid Haskell</a></li>
<li><a href="https://nikivazou.github.io/static/popl18/reflection.pdf">Refinement Reflection: Complete Verification with SMT</a></li>
<li><a href="https://popl18.sigplan.org/event/plmw-popl-2018-liquidhaskell-overview">Liquid Haskell: Refinement Types for Haskell</a></li>
</ul>
<h3 id="論文">論文</h3>
<ul>
<li><a href="http://goto.ucsd.edu/~pmr/papers/rondon-liquid-types.pdf">Pat Rondon’s Ph.D Dissertation</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/liquid/liquid_types_techrep.pdf">Tech Report</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/papers/refinement_types_for_haskell.pdf">Refinement Types For Haskell, ICFP 2014</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/papers/real_world_liquid.pdf">LiquidHaskell in the Real World, Haskell 2014</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/papers/abstract_refinement_types.pdf">Abstract Refinement Types, ESOP 2013</a></li>
<li><a href="https://arxiv.org/pdf/1701.03320.pdf">An Introduction to Liquid Haskell</a></li>
<li><a href="http://goto.ucsd.edu/~nvazou/thesis/main.pdf">Liquid Haskell: Haskell as a Theorem Prover</a></li>
<li><a href="https://nikivazou.github.io/static/Haskell17/a-tale.pdf">A Tale of Two Provers Verifying Monoidal String Matching in Liquid Haskell and Coq</a></li>
</ul>
<h3 id="youtube">Youtube</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=LEsEME7JwEE">Liquid Types for Haskell</a></li>
<li><a href="https://www.youtube.com/watch?v=vYh27zz9530">Ranjit Jhala - Liquid Haskell</a></li>
<li><a href="https://www.youtube.com/watch?v=vQrutfPAERQ">LambdaConf 2015 - LiquidHaskell Refinement Types for Haskell Ranjit Jhala</a></li>
<li><a href="https://www.youtube.com/watch?v=vqvNQixKr6w">Haskell 2014: LiquidHaskell: Refinement Types for the Real World, Eric L. Seidel</a></li>
<li><a href="https://www.youtube.com/watch?v=nd3buP97Ryw">07 Bounded Refinement Types</a></li>
</ul>
<h2 id="まとめ">まとめ</h2>
<ul>
<li>篩型は <code>{-@ ... @-}</code> で記述する</li>
<li>篩型の型エイリアスは <code>{-@ type @-}</code> で記述する</li>
</ul>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Liquid Haskell</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-01-liquidhaskell.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-01-liquidhaskell.html</id>
    <published>2018-03-01T00:00:00Z</published>
    <updated>2018-03-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>Liquid Haskell で少しハマったのでメモとして残しておきます。</p>
<p>本来なら先に仕様を書いて実装を書くべきだと思いますが、今回の例は既存のコードにリファインメント型をつけるような場合を想定しています。</p>
<pre class="shell"><code>$ liquid
LiquidHaskell Version 0.8.2.4, Git revision d641244775cd842776cecf2c5d3e9afa01549e76 (dirty)
Copyright 2013-18 Regents of the University of California. All Rights Reserved.</code></pre>
<p>Liquid Haskell を気になってる人向けの記事です。</p>
<!--more-->
<h2 id="やりたいこと">やりたいこと</h2>
<p>データの挿入と更新操作を次のような型で表現します。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Operation</span> <span class="fu">=</span> <span class="dt">Insert</span> <span class="fu">|</span> <span class="dt">Update</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="kw">deriving</span> <span class="dt">Eq</span></a></code></pre></div>
<p>上記のデータ型を使って、次のような関数を定義します。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">adjustBound ::</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">adjustBound op lower upper n <span class="fu">|</span> isInsert op <span class="fu">=</span> upper <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">                             <span class="fu">|</span> otherwise   <span class="fu">=</span> lower <span class="ot">`max`</span> (n <span class="ot">`min`</span> upper)</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">isInsert ::</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">isInsert <span class="dt">Insert</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">isInsert _      <span class="fu">=</span> <span class="dt">False</span></a></code></pre></div>
<p><code>adjustBound</code> 関数は以下のように動作します。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">&gt;</span> adjustBound <span class="dt">Insert</span> <span class="dv">0</span> <span class="dv">10</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="dv">11</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="fu">&gt;</span> adjustBound <span class="dt">Insert</span> <span class="dv">0</span> <span class="dv">10</span> <span class="dv">100</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="dv">11</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="fu">&gt;</span> adjustBound <span class="dt">Insert</span> <span class="dv">0</span> <span class="dv">10</span> (<span class="fu">-</span><span class="dv">100</span>)</a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="dv">11</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"></a>
<a class="sourceLine" id="cb4-8" data-line-number="8"><span class="fu">&gt;</span> adjustBound <span class="dt">Update</span> <span class="dv">0</span> <span class="dv">10</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="dv">5</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10"><span class="fu">&gt;</span> adjustBound <span class="dt">Update</span> <span class="dv">0</span> <span class="dv">10</span> <span class="dv">100</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11"><span class="dv">10</span></a>
<a class="sourceLine" id="cb4-12" data-line-number="12"><span class="fu">&gt;</span> adjustBound <span class="dt">Update</span> <span class="dv">0</span> <span class="dv">10</span> (<span class="fu">-</span><span class="dv">100</span>)</a>
<a class="sourceLine" id="cb4-13" data-line-number="13"><span class="dv">0</span></a></code></pre></div>
<p><code>adjustBound</code> のような関数でバグが無いことを確認するためには何をしたら良いでしょうか？</p>
<p>型は非常に強力ですが、値について何も教えてくれません。</p>
<h2 id="バグの少ない世界を目指して">バグの少ない世界を目指して</h2>
<p>僕が Haskell を使う理由は、第一に <code>楽しい</code> からです。そのため、「勉強しても就職する時に役に立たないでしょ？」などと言われても全く気になりません。(そもそも、就職するために勉強するわけじゃないですよね)</p>
<p>また Haskell を使えば、正しいソフトウェアを普通に作ることができます。また、<code>hspec</code> などで単体テストを書いたり、<code>QuichCheck</code> などでランダムテストを書くことで、過去に起こった問題を再発させないようにする努力や、バグを少なくするための取り組みが行われています。</p>
<p>しかしながら、個人的にはどれもまだ不安です。もしかしたら、チェックしてない部分にバグがあるんじゃないの・・・？</p>
<p>そんな心配性の方は <code>Liquid Haskell (LH)</code> を使いましょう！</p>
<h2 id="型をより厳しく">型をより厳しく</h2>
<p>最初に定義した <code>Operation</code> 型と <code>adjustBound</code> を再掲します。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">-- LH.hs</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">module</span> <span class="dt">LH</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="kw">data</span> <span class="dt">Operation</span> <span class="fu">=</span> <span class="dt">Insert</span> <span class="fu">|</span> <span class="dt">Update</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  <span class="kw">deriving</span> <span class="dt">Eq</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="ot">adjustBound ::</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">adjustBound op lower upper n <span class="fu">|</span> isInsert op <span class="fu">=</span> upper <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">                             <span class="fu">|</span> otherwise   <span class="fu">=</span> lower <span class="ot">`max`</span> (n <span class="ot">`min`</span> upper)</a>
<a class="sourceLine" id="cb5-10" data-line-number="10"></a>
<a class="sourceLine" id="cb5-11" data-line-number="11"><span class="ot">isInsert ::</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">isInsert <span class="dt">Insert</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb5-13" data-line-number="13">isInsert _      <span class="fu">=</span> <span class="dt">False</span></a></code></pre></div>
<p>とりあえず、現在のコードを <code>LH</code> にかけてみます。</p>
<pre class="shell"><code>$ liquid LH.hs
LiquidHaskell Version 0.8.2.4, Git revision d641244775cd842776cecf2c5d3e9afa01549e76 (dirty)
Copyright 2013-18 Regents of the University of California. All Rights Reserved.


**** DONE:  A-Normalization ****************************************************


**** DONE:  Extracted Core using GHC *******************************************


**** DONE:  Transformed Core ***************************************************

Working 100% [=================================================================]

**** DONE:  annotate ***********************************************************


**** RESULT: SAFE **************************************************************</code></pre>
<p><code>RESULT: SAFE</code> が表示されれば問題ありません！</p>
<h3 id="入力を自然数に限定させよう">入力を自然数に限定させよう</h3>
<p>例えば <code>lower</code> と <code>upper</code> が自然数 (0含む) しか許容しないという仕様が与えられた時、どうしますか？</p>
<p>よくある対応としては、コメントにその旨を書いたり、テストを作ったりという作業になるでしょう。</p>
<p><code>Liquid Haskell</code> では上記の仕様を <code>事前条件</code> として記述することができます。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="co">{-@ adjustBound :: _ -&gt; Nat -&gt; Nat -&gt; _ -&gt; _ @-}</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">adjustBound ::</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">adjustBound op lower upper n <span class="fu">|</span> isInsert op <span class="fu">=</span> upper <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">                             <span class="fu">|</span> otherwise   <span class="fu">=</span> lower <span class="ot">`max`</span> (n <span class="ot">`min`</span> upper)</a></code></pre></div>
<p><code>Nat</code> は <a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/include/Prelude.spec">Prelude</a> で以下のように定義されています。つまり、0以上の <code>Int</code> のみを含むリファインメント型です。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">{-@ type Nat = {v: Int | v &gt;= 0 } @-}</span></a></code></pre></div>
<p>これだけです。<code>LH</code> で結果を確かめてみましょう。</p>
<pre class="shell"><code>$ liquid LH.hs
...

**** RESULT: SAFE **************************************************************</code></pre>
<p><code>SAFE</code> ですね！</p>
<p>これでもう <code>adjustBound</code> の <code>lower</code> と <code>upper</code> は <code>0</code> 以上の自然数でしか呼び出されていないことが示されました。</p>
<h3 id="もう少し具体例">もう少し具体例</h3>
<p>では、別のプログラマが <code>adjustBound</code> を利用した関数を作ったとしましょう。この関数自体に意味はないですが、<code>LH</code> を理解するためにはとても良い例だと思います。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">f ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">f <span class="fu">=</span> adjustBound <span class="dt">Insert</span> (<span class="fu">-</span><span class="dv">100</span>) (<span class="fu">-</span><span class="dv">50</span>) (<span class="fu">-</span><span class="dv">70</span>)</a></code></pre></div>
<p>この関数 <code>f</code> は、型が正しいため当然コンパイルできます。</p>
<pre class="shell"><code>$ stack repl -- LH.hs
&gt; f
-49</code></pre>
<p>けれども、僕らの仕様では <code>adjustBound</code> の <code>lower</code> と <code>upper</code> には自然数しか適用してはいけないはずです。</p>
<p>次に <code>LH</code> を実行してみましょう。</p>
<pre class="shell"><code>$ liquid LH.hs
**** RESULT: UNSAFE ************************************************************


 LH.hs:18:25-28: Error: Liquid Type Mismatch

 18 | f = adjustBound Insert (-100) (-50) (-70)
                              ^^^^


   Inferred type
    VV : {v : Int | v == (-?a)
                    &amp;&amp; v == ?b}

  not a subtype of Required type
    VV : {VV : Int | VV &gt;= 0}

  In Context
    ?b : {?b : Int | ?b == (-?a)}

    ?a : {?a : Int | ?a == (100 : int)}


 LH.hs:18:32-34: Error: Liquid Type Mismatch

 18 | f = adjustBound Insert (-100) (-50) (-70)
                                     ^^^


   Inferred type
    VV : {v : Int | v == (-?b)
                    &amp;&amp; v == ?a}

  not a subtype of Required type
    VV : {VV : Int | VV &gt;= 0}

  In Context
    ?b : {?b : Int | ?b == (50 : int)}

    ?a : {?a : Int | ?a == (-?b)}</code></pre>
<p><code>UNSAFE</code> になりましたね。こういうことです。</p>
<p>つまり、<strong>自分たちが使っている範囲</strong>で <code>Liquid Haskell</code> のリファインメント型について、正しく整合性が取れているのかということを判定しています。</p>
<h3 id="戻り値の型も厳しくしよう">戻り値の型も厳しくしよう！</h3>
<p>先程、事前条件についてリファインメント型を書きました。</p>
<p>次は事後条件についてリファインメントを書きましょう！</p>
<p>同様に戻り値の型も自然数という仕様にします。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="co">{-@ adjustBound :: _ -&gt; Nat -&gt; Nat -&gt; _ -&gt; Nat @-}</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="ot">adjustBound ::</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">adjustBound op lower upper n <span class="fu">|</span> isInsert op <span class="fu">=</span> upper <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">                             <span class="fu">|</span> otherwise   <span class="fu">=</span> lower <span class="ot">`max`</span> (n <span class="ot">`min`</span> upper)</a></code></pre></div>
<pre class="shell"><code>$ liquid LH.hs
**** RESULT: SAFE **************************************************************</code></pre>
<p>リファインメント型 (Refinement type) は <code>篩 (ふるい) 型</code> と訳されている本 (<a href="https://taimen.jp/f/389">入門LiquidHaskell−篩型による静的コード解析−</a>) もありますが、それは <code>Haskell</code> の型の値が条件によって <code>ふるい</code> 落とされて、新しい型 (リファインメント型) になっているというイメージから来ているのだと思います。(読んだこと無いので間違ってたらすみません・・・。)</p>
<p>追記: チェシャ猫さんから <code>篩型</code> について教えてもらいました！</p>
<blockquote class="twitter-tweet" data-lang="ja">
<p lang="ja" dir="ltr">
&gt; リファインメント型 (Refinement type) は 篩 (ふるい) 型 と訳されている本もありますが<br><br>頒布したときに最も多かった質問は「これ何て読むんですか？」だった。ちなみに「篩型」はこの本で勝手に作った造語ではなく、論文タイトルなどにも使われています。<a href="https://t.co/Du6mK1hqdD">https://t.co/Du6mK1hqdD</a>
</p>
— チェシャ猫 (<span class="citation" data-cites="y_taka_23">@y_taka_23</span>) <a href="https://twitter.com/y_taka_23/status/969499842895495168?ref_src=twsrc%5Etfw">2018年3月2日</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<blockquote class="twitter-tweet" data-lang="ja">
<p lang="ja" dir="ltr">
五十嵐先生と末永先生が発案した訳語のようです。 <a href="https://t.co/rcZuFuptl6">https://t.co/rcZuFuptl6</a>
</p>
— チェシャ猫 (<span class="citation" data-cites="y_taka_23">@y_taka_23</span>) <a href="https://twitter.com/y_taka_23/status/969515905737621506?ref_src=twsrc%5Etfw">2018年3月2日</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<h2 id="もっと仕様を">もっと仕様を</h2>
<p><code>adjustBound</code> 関数はこれで十分なのでしょうか？人によっては十分だね。と答えるかもしれません。</p>
<p>しかし、今回は次のような仕様を与えることにします。</p>
<ol type="1">
<li><code>upper</code> は <code>lower</code> 以上の自然数</li>
<li><code>Insert</code> の操作の場合の戻り値は <code>lower</code> 〜 <code>upper + 1</code> の間の自然数</li>
<li><code>Update</code> の操作の場合の戻り値は <code>lower</code> 〜 <code>lower `max` (n `min` upper)</code> の間の自然数</li>
</ol>
<p>ここからが面白いところです。</p>
<p>まずは前準備として <code>x 〜 y</code> までの間の自然数を表すリファインメント型と述語を定義します。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="co">{-@ type Btwn Lo Hi = {v:Int | Lo &lt;= v &amp;&amp; v &lt;= Hi} @-}</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="co">{-@ predicate BtwnP Lo Hi = Lo &lt;= v &amp;&amp; v &lt;= Hi @-}</span></a></code></pre></div>
<p>では、<code>仕様1</code>を反映させてみましょう。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="co">{-@ adjustBound :: _ -&gt; l:Nat -&gt; {u:Nat | l &lt;= u} -&gt; _ -&gt; Nat @-}</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="ot">adjustBound ::</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">adjustBound op lower upper n <span class="fu">|</span> isInsert op <span class="fu">=</span> upper <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">                             <span class="fu">|</span> otherwise   <span class="fu">=</span> lower <span class="ot">`max`</span> (n <span class="ot">`min`</span> upper)</a></code></pre></div>
<pre class="shell"><code>$ liquid LH.hs
**** RESULT: SAFE **************************************************************</code></pre>
<p>では次に、<code>仕様2</code> と <code>仕様3</code> です。</p>
<p>リファインメント型は以下のようになります。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="co">{-@ adjustBound ::</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="co">      op:Operation -&gt;</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3"><span class="co">      l:Nat -&gt;</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4"><span class="co">      {u:Nat | l &lt;= u} -&gt;</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5"><span class="co">      _ -&gt;</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6"><span class="co">      {v:Nat | if (isInsert op) then (BtwnP l (u+1)) else BtwnP l u }</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7"><span class="co">@-}</span></a>
<a class="sourceLine" id="cb18-8" data-line-number="8"><span class="ot">adjustBound ::</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb18-9" data-line-number="9">adjustBound op lower upper n <span class="fu">|</span> isInsert op <span class="fu">=</span> upper <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb18-10" data-line-number="10">                             <span class="fu">|</span> otherwise   <span class="fu">=</span> lower <span class="ot">`max`</span> (n <span class="ot">`min`</span> upper)</a>
<a class="sourceLine" id="cb18-11" data-line-number="11"></a>
<a class="sourceLine" id="cb18-12" data-line-number="12"><span class="co">{-@ measure isInsert @-}</span></a>
<a class="sourceLine" id="cb18-13" data-line-number="13"><span class="ot">isInsert ::</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb18-14" data-line-number="14">isInsert <span class="dt">Insert</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb18-15" data-line-number="15">isInsert _      <span class="fu">=</span> <span class="dt">False</span></a></code></pre></div>
<pre class="shell"><code>$ liquid LH.hs
**** RESULT: SAFE **************************************************************</code></pre>
<h2 id="はまったポイント">はまったポイント</h2>
<p><code>if (isInsert op) then (BtwnP l (u+1)) else BtwnP l u</code> の部分でかなりはまりました。</p>
<p>例えば <code>if</code> の括弧を外した場合は次のようなエラーになります。</p>
<p><code>if isInsert op then (BtwnP l (u+1)) else BtwnP l u</code></p>
<pre class="shell"><code>**** RESULT: ERROR *************************************************************


 LH.hs:10:73: Error: Cannot parse specification:

 10 | {-@ adjustBound :: op:Operation -&gt; l:Nat -&gt; {u:Nat | l &lt;= u}  -&gt; _ -&gt; {v:Nat | if isInsert op then (BtwnP l (u+1)) else BtwnP l u } @-}
                                                                              ^

     unexpected &quot;:&quot;
     expecting operator, white space or &quot;}&quot;</code></pre>
<p>また、同様に <code>then</code> の括弧を外してもエラーになります。</p>
<p><code>if (isInsert op) then BtwnP l (u+1) else BtwnP l u</code></p>
<pre class="shell"><code>**** RESULT: ERROR *************************************************************


 LH.hs:10:73: Error: Cannot parse specification:

 10 | {-@ adjustBound :: op:Operation -&gt; l:Nat -&gt; {u:Nat | l &lt;= u}  -&gt; _ -&gt; {v:Nat | if (isInsert op) then BtwnP l (u+1) else BtwnP l u } @-}
                                                                              ^

     unexpected &quot;:&quot;
     expecting operator, white space or &quot;}&quot;</code></pre>
<p><code>else</code> については括弧があっても無くても <code>SAFE</code> です。</p>
<p>この挙動が本当にわからなくてつらかったです・・・。</p>
<p>ちなみに、以下のような場合も同様にはまるので、ご注意ください。</p>
<pre><code>-- UNSAFE
{-@ adjustBound :: _ -&gt; l:Nat -&gt; {u:Nat | l &lt;= u}  -&gt; _ -&gt; Btwn l (u+1) @-}
{-@ adjustBound :: _ -&gt; l:Nat -&gt; {u:Nat | l &lt;= u}  -&gt; _ -&gt; Btwn l {u+1} @-}

-- SAFE
{-@ adjustBound :: _ -&gt; l:Nat -&gt; {u:Nat | l &lt;= u}  -&gt; _ -&gt; Btwn {l} {u+1} @-}</code></pre>
<h2 id="まとめ">まとめ</h2>
<ul>
<li><code>if</code> を使う場合は多めに括弧を付けておいた方が良さそう。</li>
<li><code>{}</code> で囲むと上手くいく場合もある</li>
<li><code>LiquidHaskell</code> はすごい</li>
</ul>
<p>この良くわからない挙動について一緒に考えてくれた友人の tkg さんありがとうございました。</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>debug パッケージのアナウンス (翻訳)</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/02-26-Announcing-the-debug-package.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/02-26-Announcing-the-debug-package.html</id>
    <published>2018-02-26T00:00:00Z</published>
    <updated>2018-02-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="debug-パッケージのアナウンス-翻訳">debug パッケージのアナウンス (翻訳)</h2>
<p>Original post: <a href="http://neilmitchell.blogspot.jp/2017/12/announcing-debug-package.html">Announcing the ‘debug’ package</a></p>
<p>Haskell は素晴らしい言語ですが、Haskell のデバッグは間違いなく弱い部分です。この問題をどうにかするために、<a href="https://hackage.haskell.org/package/debug">debug ライブラリ</a> をリリースしました。このライブラリは全てのことを解決するのではなく、一般的なデバッグのタスクに対してシンプルで簡単に使えるような設計を目指しました。デバッグをするにあたって、みなさんが興味を持ってくれるような関数を例に取って見てみましょう。</p>
<!--more-->
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">module</span> <span class="dt">QuickSort</span>(quicksort) <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Data.List</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">quicksort ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">quicksort [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">quicksort (x<span class="fu">:</span>xs) <span class="fu">=</span> quicksort lt <span class="fu">++</span> [x] <span class="fu">++</span> quicksort gt</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    <span class="kw">where</span> (lt, gt) <span class="fu">=</span> partition (<span class="fu">&lt;=</span> x) xs</a></code></pre></div>
<p><code>TemplateHaskell</code> と <code>ViewPatterns</code> を有効にしてから、<code>Debug</code> をインポートし、コードをインデントして <code>debug</code> の引数に渡してやりましょう。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">{-# LANGUAGE TemplateHaskell, ViewPatterns #-}</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">module</span> <span class="dt">QuickSort</span>(quicksort) <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Data.List</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Debug</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">debug [d|</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">   quicksort :: Ord a =&gt; [a] -&gt; [a]</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">   quicksort [] = []</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">   quicksort (x:xs) = quicksort lt ++ [x] ++ quicksort gt</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">       where (lt, gt) = partition (&lt;= x) xs</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">   |]</a></code></pre></div>
<p>以下のコマンドでデバッガを走らせることができます。</p>
<pre class="shell"><code>$ ghci QuickSort.hs
GHCi, version 8.2.1: http://www.haskell.org/ghc/  :? for help
[1 of 1] Compiling QuickSort        ( QuickSort.hs, interpreted )
Ok, 1 module loaded.
*QuickSort&gt; quicksort &quot;haskell&quot;
&quot;aehklls&quot;
*QuickSort&gt; debugView</code></pre>
<p><code>debugView</code> を呼ぶと Webブラウザが起動して、記録されたデバッグの結果を見ることができます。こんな感じです。</p>
<figure>
<img src="https://cdn.rawgit.com/ndmitchell/debug/f6e8dbc9/debug.png" alt="debugView の実行結果" /><figcaption>debugView の実行結果</figcaption>
</figure>
<p>ここから、計算の経過をクリックしつつ探すことができます。</p>
<p>私は <code>debug</code> を使った感想や、これを改善できるようなアイディアを求めています。そのため、フィードバックや<a href="https://github.com/ndmitchell/debug/issues">バグトラッカー</a>経由のお手伝いなどをお待ちしています。</p>
<p>また別の Haskell のデバッガに興味があるのなら、<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#the-ghci-debugger">GHCi デバッガ</a>や <a href="https://hackage.haskell.org/package/Hoed">Hood/Hoed</a> などを試してみるべきでしょう。</p>]]></summary>
</entry>
<entry>
    <title>SLURP (翻訳)</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/02-25-SLURP.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/02-25-SLURP.html</id>
    <published>2018-02-25T00:00:00Z</published>
    <updated>2018-02-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="slurp">SLURP</h2>
<p>Great original post: <a href="https://www.snoyman.com/blog/2018/01/slurp">SLURP</a></p>
<p>すでにコミュニティの多くの人々が SLURP の提案を見ていると思います。何人かの人たちに私の意見を聞かれたり、私が議論に参加しないことについて、まぁいろいろな意見をもらいました。この議題を私が避けてきた理由を今ここで書かせてください。作者はその提案をリリース前に教えてくれましたが、その時はサポートしないことを伝えました。私はまた、失礼にならないような形で SLURP へのコメントを控えていることも伝えました。残念ながら、その結果2つのことが起こりました。</p>
<ul>
<li>人によっては、とても良くない影響を与えてしまいました。</li>
<li>“fork” という用語の使い方の誤解、そして残念ながら作者はその間違いを訂正していません。</li>
</ul>
<p>つまりまとめると: 提案は私のものではなく、変更を頼んだわけでも、誰かの頭に銃を向けているわけでもありません。この説明は間違っています。他に出すことができるコメントはいくらでもありますが、正直価値はないでしょう。</p>
<p>間違ってはいないことは、私は日常的に多くの人や Haskell のコミュニティやエコシステムマネジメントチームと直面している問題についてコミュニケーションを取っています。仕事で幅広いユーザーと交流し、不満を聞けばそれを誰かに伝えます。私も不満を持つことがあって、それを誰かに聞いてもらいます。この不満の中には、全てが同じようなものを指しているものもあります。</p>
<p>私が公開できる情報というのは限られています。なぜなら、私に寄せられるかなり多くのコメントが、公にされることを嫌うようなプライベートなメールで書かれているからです。そして経験上、私のことを嘘つきだと誹謗中傷する人たちがいることも分かっています。この絶え間ない誹謗中傷を理由に発言を避けてきましたが、私はここに残しておくべきだと決断しました。わかったのは次の2つのことです。</p>
<ul>
<li>私のやること成すこと全てが悪だと信じている人は、私が何か根拠を持っていてもそれを見ようとはしません。</li>
<li>私が悪魔ではないという可能性を否定しない人は、もしかしたら私の声明をその通りに受け取ってくれるかもしれないということです。</li>
</ul>
<p>以前の私は、アーキテクチャとエコシステム開発についてオープンに議論していました。これはオープンソースコミュニティを作る唯一無二の方法だと私は信じています。Stack 対 cabal の時代の緊張が最も高まったときに、多くの人がオープンな議論に異論を唱えたため、私はより静かなコミュニケーションのチャネルに移ることにしました。これはとても残念なことだったと感じています。私はエコシステムの計画についてもっとオープンに、声高に議論をしたいと思っています。他の人たちが簡単に情報にたどり着けるようにしたいと思っています。私は閉じた扉の裏側で全てを議論することを強く反対します。オープンな議論が再開できるかどうかはいずれわかることでしょう。</p>
<!--more-->
<h2 id="fork-ってなに">“fork” ってなに?</h2>
<p>SLURP に関する議論の大部分が SLURP そのものとはなんの関係もないことは明らかですが、fork に関するコメントは関係があります。作者がドキュメントの中で fork という言葉を使うつもりだったのなら、まずは fork についてしっかりと説明することが望ましかったのではないでしょうか。これから Stackage と Stack の世界で使われている fork という言葉の意味について、私が知っていることをお話しようと思います。この話が本当に作者たちの意図を反映しているのかどうか、それは作者たちの発言を待って確認するしかありません。</p>
<p>ここでいう “fork” という用語は、「何かソフトウェアのプロジェクトを取ってきて、ソースコードを他の場所にホストして、別名で開発を続ける」といった文字通りの意味で使われているわけではありません (私の定義ですが)。この用語は、より一般的なものです。例えば、Stack はコードなんて何も共有していないのに、多くの人に cabal-install の fork だと言われています (もちろん、Cabal のようなベースとなるライブラリは共有していますが)。</p>
<p>誰もが固執していることについて、明確に言及しておきましょう。誰もが考えるような Hackage の直接の競争相手を作ろうとするやりとりには、全く関わっていません。私が知っている人で、こういうことをしたい人はいませんし、私もしたくありません。なぜなら、今日の Stackage と Stack は Hackage あってこそのものだからです。そして私の知人で、この構図を変えたい人は誰一人としていません。Hackage をコントロールしたいなどと考えている人はいないのです。</p>
<p>Hackage の “fork” というと、論理的にそういう結論に至るかもしれませんが、そうではないのです。</p>
<p>次に、この “fork” に関する具体的な頭痛のタネについてお話しましょう。</p>
<h2 id="hackage-のリビジョン">Hackage のリビジョン</h2>
<p>多くの人が Hackage のリビジョンについて嫌悪感を示しています。私も Hackage リビジョンは嫌いです。そして、他の誰よりも嫌悪感を抱く理由を持っています。私は数週間から数ヶ月ほどの自分の人生を使って、いくつかのツールにリビジョンをサポートさせたことがあります。この凄惨な歴史を辿ることもできますが、プログラマの戦記になるだけで価値はないでしょう。それよりも今に向き合うことにします。</p>
<p>私はついに Stack 1.6 で、リビジョンの指定 (pinning) を完全にサポートしました。Stackage は既に長い間リビジョンの指定をサポートし続けています。Stackage にはいくつかのパッケージのリビジョンを無視しているものとしてリストアップする機能があります。</p>
<p>もし仮に、今聞かれたら私はリビジョンが悪いアイディアで、無効にすべきだと答えるでしょう。そして、依存関係の解決に関する問題について、より良い解決方法があると依然として答えるでしょう (これらについては、過去に長々と議論したことがあります)。同時に、そのコストは下がっています。ユーザーが extra-deps に特定のリビジョンを付けていないこと、そして Hackage におけるリビジョンのルールが緩すぎることについては実際、いまだに心配です。これについて懸念を抱いていることは確かですが、私の中の最優先事項ではありません。</p>
<p>ところが他の人は違う考えを持っているようです。私は Hackage Truestee が強制的に cabalファイルを編集することについて腹を立てている多くの人を知っています。彼らに反対することはありませんが、この話題に情熱を持っているわけでもありません。コミュニティのリーダーとの会話の中で、私はこの区別を明確に強調しました (少なくともそうしようとはしました)。</p>
<p>リビジョンに関する最大の懸念は、それの持つ社会的な影響です。すなわち、誰か別のものが自分のビルドの安定性を担うということです。これまでに何度も言及してきましたが、社会的緊張の原因の最たるものに、ビルドがいきなり止まったので上流の開発者に文句を言う、というものがあります。これは大惨事への第一歩で、PVP (Package Versioning Policy) + 依存解決という手法が持つ原理的な欠陥でした。そのため、固定ビルドプランに焦点を当てたツールが必要となるのです。私はこれを何年も主張してきましたが、結局は上流を説得することができなかったので Stack を大々的に作りました。</p>
<p>以上のことから、リビジョンとはフォークのような何かなのでしょうか? 違います。</p>
<h2 id="キュレーション">キュレーション</h2>
<p>数週間前、私はこんなツイートをしました。</p>
<blockquote class="twitter-tweet" data-lang="en">
<p lang="en" dir="ltr">
I did that initially. When collaborating on GPS Haskell, I removed that functionality as a requirement of the Hackage, Cabal, and Haskell Platform teams. Then GPS died and we're stuck unable to work around upstream breakage like this.
</p>
— Michael Snoyman (<span class="citation" data-cites="snoyberg">@snoyberg</span>) <a href="https://twitter.com/snoyberg/status/949385673982730240?ref_src=twsrc%5Etfw">January 5, 2018</a>
</blockquote>
<p>Stackage のオリジナルデザインは、標準的な Linux ディストリビューションモデルに準拠していました。Hackage は私たちの上流でしたが、バージョンの境界が大きく壊れるのを防ぐために一連のパッチを整備し、あまりありませんでしたが時折 (たとえそうでも、正直覚えていませんが)、バグを修正するためにソースを編集したりしました。</p>
<p>2014年に Stackage を cabal と Haskell のプラットフォームに組み込む計画 (GPS Haskell のコードネームで開発していました。それが地面から飛び立つことは一度もありませんでしたが) について議論をしたとき、cabal, Hackage, そして Haskell Platform のメンテナに、ローカルの変更を Stackage が整備しないことを要求されました。なので私はその機能を削除したのですが、それは私たちが今までいた世界の話です。</p>
<p>この機能を復活させるかどうかは再検討中です。その理由を簡潔に説明しますと、これはフォークと捉えることができます。ソフトフォークと呼ぶ人もいるかもしれません。正直なところ、一連のパッチを整備するのは重労働なので Stackage に追加し直したい機能ではありません。しかし、多くのコミュニティがこの作業を必要としています。私がこのことを理解しているように、Nix も理解しています。もしもこれをフォークと言うのなら、私たちのエコシステムに広く浸透しているフォークなんでしょう。</p>
<p>このキュレーションで扱う理由としては、新しい依存バージョンへの更新が遅いパッケージを避けるため、というものがあります。Stackage のパッケージメンテナにとって、誰か他の人がその上限に満足しないからといって、自分のパッケージのバージョンを下げるのはかなりイライラするものがあるでしょう。キュレーションはこの辺の問題を何とかできるかもしれません。私はこれをおまけの特典のように考えていますが、必要なものではないです。</p>
<p>しかし、キュレーションには cabal-install 界隈では問題になっていないものの、Stackage や Stack 界隈で問題を引き起こしているパッケージをどうにかする、というもっと重要な理由があります。ここ数ヶ月の間に何回も問題が起こるまで、私は本当の問題だとは認識していませんでした。<a href="https://github.com/haskell-hvr/cassava/pull/155">例えばこんな例があります</a></p>
<p>私はこの記事で、作者の誰かに何かを要求するつもりはありません。でも私は結局、これらの類の問題に多くの自分の時間を費やして対処してきています。これが現実です。私の友達や同僚は、緊急のリリースポイントを切ったり、様々な持ち越し作業に巻き込まれています。Cabal のライブラリの仕様に明記されているべきだが文書化されていないような何かのために、多くの時間を割いて Stack を変更しなければならないような現状に私の人生を浪費したくはありません。</p>
<p>Hackage は cabal-install を壊さないために、既に大きな苦労をしています。多くの人が、 <code>^&gt;=</code> 演算子の導入がどのように Stack 1.5 を破壊したか聞いたことがあるのではないでしょうか。しかし、実はこの演算子の導入は cabal-install 1.24 も壊していたのです。この事実を知っている人がいないのは、<a href="https://github.com/haskell/cabal/issues/4624">Hackage がこれらのファイルを古いバージョンの cabal-install から隠すような措置を導入した</a>からです。このキュレーションのアイディアは Stack の破壊に対応する術を Stackage に対して提供するものです。Hackage も同じ方法で cabal-install へのダメージに対処するでしょう。</p>
<p>そして、私は同じ類の処置を、Hackage から Stack へしてもらえないかとお願いしました。このお願いは、優先的な処置を求める声に後押しされています。この記事の読者は、各々の判断で自分がどう感じるか考えてください。</p>
<p>まとめると: 私は Stackage に上流のパッケージのパッチを当てられるようにしようとしています。他の人はフォークという言葉を使うかもしれませんが、私はこれをフォークではなくキュレーションだと考えています。</p>
<h2 id="hackage-へのアップロードを避ける">Hackage へのアップロードを避ける</h2>
<p>まず、これは私の好みですが、私のパッケージは Hackage に上げ続けたいと考えています。conduit や yesod, その他鋭意 Hackage でメンテ中の 80 を超えるパッケージの更新をやめるつもりも、そうしたいという願望もありません。そうは言っても、全員が全員同じように感じているわけではありません。</p>
<p>現在 Stackage は Hackage の下流になっています。最初にパッケージが Hackage にアップロードされない限り、そのパッケージを Stackage に入れることはできません。しかし、この状況は終わりを告げようとしています。およそ、現状を変えようとしているグループは以下の 3 パターンに分けられるでしょう。</p>
<ol type="1">
<li>少なくとも一部の PVP 支持者は、PVP に従わないパッケージ作成者に対して、そのパッケージを Hackage にアップロードしないように要請 (要求) しています。これは私が幾度となく指摘してきたように、Hackage 公式のガイドラインと完全に矛盾しているにも関わらず、彼らはしつこく同じ趣旨の発言を続けています。</li>
<li>PVP に反対する人の中には、基本的に (1) の理由で、Hackage にアップロードしたくない、という人もいます。PVP の遵守という観点で、たくさんの張りつめた議論がありました。これを避けるための最も簡単な方法は Hackage にアップロードしない、というものでした。私はこういった事情があって Hackage や Stackage にコードをリリースしない人たちを知っています。しぶしぶこうしている人もいますが、その全員が同じ理由で Hackage を避けたがっています。</li>
<li>技術的に見て、中央リポジトリに手作業で tarball をアップロードするようなモデルは、時代遅れになってきていると感じる人もいます。そういった人たちは、タグやリリースブランチを使って自動化された、Git ベースのリリースに基づいたワークフローを考えています。これによる社会的な影響は何もなく、どちらかと言うと Hackage が現在サポートしていない、技術的に違うものを探してみたいという願望です。</li>
</ol>
<ol type="1">
<li>番目の状況は、私の大きな頭痛の種でした。私は Hackage Trustee のガイドラインと Hackage のルールを変更して、彼らの言動 (Hackage にアップロードしないように私的なメールで要求したり、個人や企業に対して PVP に従っていないことを公に批判したり) について明確に禁止するように要望を出していました。実際、私が思うに、この要望は究極的には SLURP に結びつくものです。私は変更しなければフォークするぞと脅したりしたでしょうか? あー、そう思いたいならそれでもいいでしょう。私は Hackage を使うのをやめようと言い続けてきました。完全にです。私はこのような Hackage の使い方が許可されるように、公式のポリシーに対して変更を求めました。</li>
</ol>
<p>現状を見たらわかりますが、Hackage のポリシーにそんな変更はされませんでした。私は (2) と (3) のグループに対して何を思うのか、言及していませんでしたね。しかし (3) の主張からもわかるように、Hackage とは別の代替パッケージリポジトリをホストしたりするのは全くもって意味がありません。なので、私はまたここで保証します。最も文字通りの Hackage の fork は、私も私が話しかけているあなたも誰も望んでいないものになるでしょう。</p>
<p>また他の選択肢は Stackage に Hackage に加え、Git リポジトリから直接パッケージをプルできるようにする、というものです。これは先に挙げた 問題 (1) に対するワークアラウンドとして議論されています。あることを主張して、一度離れてもう一度それを主張するようになる… なんてことはありません。私はむしろ、Hackage が全員からパッケージのアップロードを受け付けることを明確にすることを望んでいますし、それと比べれば Stackage を別のソースに対して解放するような要求は少なくなります (3 番目のグループは純粋に技術的な観点から実験したいと思っているようですが)。</p>
<p>私は銃で誰かの頭を狙っているでしょうか? それはあなたが決めることです。これが私が知る限りの本当の物語です。</p>
<p>まとめると、これは潜在的な fork に最も近いもので、Git リポジトリが Hackage の代替のソースとして許可されたらこうなります。</p>
<h2 id="まとめ">まとめ</h2>
<p>私は上記の問題を解決するための努力をするにあたって、複数の人と長く非公開な議論をしてきました。先ほども話したように、私はいつも公の場で行われる議論が好きです。SLURP の提案がどうなったかを鑑み、私はやはり公の議論はより良いという立場を取ろうと思います。“fork” という言葉を使って、とても多くの人を怖がらせてしまったことは申し訳なく思っています。本当に怖がっていた人に対して、私は鬼のようなことをしてしまっていたようです。説明に 2 日間待たせてしまい、申し訳ありませんでした。</p>]]></summary>
</entry>
<entry>
    <title>stack でどうしてもビルドできないとき</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/02-23-stack-build-failure.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/02-23-stack-build-failure.html</id>
    <published>2018-02-23T00:00:00Z</published>
    <updated>2018-02-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>僕は <code>stack</code>, <code>hlint</code>, <code>liquidhaskell</code> などのパッケージを毎日なんとなくビルドしてインストールしているのですが、ある時 <code>stack</code> のビルドで <code>GHC panic</code> が発生し、ビルドができなくなってしまいました。</p>
<p>数日放置していたのですが、直らず・・・。そればかりか別のPCでは問題なくビルドができているため <code>stack</code> の問題だな！と意気揚々と <a href="https://github.com/commercialhaskell/stack/issues/3876">issue</a> を作ったのですが、結局は自分の環境の問題でした・・・。</p>
<p>僕は英語が得意ではありませんが、こういった時に批判だけするのは良くないと思っているので、頑張って <code>issue</code> や <code>PR</code> を投げるようにしています。Google 翻訳とかもありますし、誰か助けてくれますよ、きっと。 (放置されたり却下されることもありますが、気にせずコツコツ続けると楽しいです)</p>
<!--more-->
<h2 id="stack-のビルドがどうしてもできない時">Stack のビルドがどうしてもできない時</h2>
<p>ちゃんと <code>stack clean --full</code> を行った上でビルドコマンドを叩いたら、以下のような <code>ghc panic</code> エラーになりました。</p>
<pre class="shell"><code>$ stack build
...

ghc: panic! (the &#39;impossible&#39; happened)
      (GHC version 8.2.2 for x86_64-apple-darwin):
    	Loading temp shared object failed: dlopen(/var/folders/ky/8g7fv32j4js337c85sy5gy0h0000gn/T/ghc43457_0/libghc_437.dylib, 5): Symbol not found: _hackagezmsecurityzm0zi5zi2zi2zm9BfzzLHvNB6mEIMD9YTAK2zz_HackageziSecurityziUtilziChecked_zdwthrowChecked_closure
      Referenced from: /var/folders/ky/8g7fv32j4js337c85sy5gy0h0000gn/T/ghc43457_0/libghc_437.dylib
      Expected in: flat namespace
     in /var/folders/ky/8g7fv32j4js337c85sy5gy0h0000gn/T/ghc43457_0/libghc_437.dylib

    Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug</code></pre>
<p><code>ghc panic</code> は、言語拡張とか最新の機能とかを触っていれば良く見るエラーですが、なぜこれが起きたのか全くわかりません・・・。</p>
<p><code>issue</code> のアドバイス通り <code>stack exec -- ghc-pkg unregister hackage-security</code> も試してみたのですがダメでした。</p>
<p>なので最終手段の <code>~/.stack</code> を削除することになったんですが、今までどのフォルダを削除したら良いのかイマイチわかっていませんでした。</p>
<p>しかし <code>stack</code> の中の人は違います！ <code>precompiled</code>, <code>snapshots</code> を削除しなよ！と優しく教えてくれたので、指示通りこんな感じで削除したところ、無事にビルドが通るようになりました！</p>
<pre class="shell"><code>$ stack path --stack-root
~/.stack

$ rm -rf $(stack path --stack-root)/precompiled
$ rm -rf $(stack path --stack-root)/snapshots</code></pre>
<p>もう知ってるよ・・・。という話かもしれませんが、どうしてもビルドできない人は試してみてはいかがでしょうか。</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>stack 1.6.5 がリリースされました。</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/02-21-stack165.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/02-21-stack165.html</id>
    <published>2018-02-21T00:00:00Z</published>
    <updated>2018-02-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>先日 Stack version 1.6.5 が<a href="https://github.com/commercialhaskell/stack/blob/master/ChangeLog.md#v165">リリース</a>されました。</p>
<p>バグフィックスのみです。</p>
<p>いくつか前回の <a href="https://haskell.e-bigmoon.com/posts/2017-12-24-stack163.html">1.6.3</a> に含まれていた内容が 1.6.5 に移動してますね。</p>
<!--more-->
<h2 id="更新方法">更新方法</h2>
<pre class="shell"><code>$ stack upgrade

$ stack --version
Version 1.6.5, Git revision 24ab0d6ff07f28276e082c3ce74dfdeb1a2ca9e9 (5514 commits) x86_64 hpack-0.20.0</code></pre>
<h2 id="バグフィックス">バグフィックス</h2>
<ul>
<li>Windows でプリコンパイルされたキャッシュファイルのパス名が長過ぎる場合にビルドが失敗する問題を修正しました (<a href="https://github.com/commercialhaskell/stack/issues/3649">#3649</a>)</li>
</ul>
<p>僕は Windows ユーザではないので、どのぐらいこのバグが深刻なのかわかりません。</p>
<p><code>stack</code> の内部的には <a href="https://github.com/commercialhaskell/stack/blob/v1.6.5/src/Stack/Build/Cache.hs#L372">pathTooLong</a> が新しく定義され、以前まではただの <code>length</code> で比較していたところを <code>utf16StringLength</code> の比較に修正したようです。</p>
<hr />
<ul>
<li>スクリプトインタプリタ形式で暗黙的に渡されるファイル引数を他の引数より先に処理するようにしました (<a href="https://github.com/commercialhaskell/stack/issues/3658">#3658</a>)。この修正により、スクリプト実行時に <code>-- +RTS ... -RTS</code> を渡せるようになりました。</li>
</ul>
<p>以下のような <code>RTS</code> オプションの指定が適切に処理できるようになりました。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">{- stack</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="co">  script</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="co">  --resolver lts-6.25</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="co">  --package turtle</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="co">  --</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="co">  +RTS -s -RTS</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="co">-}</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"></a>
<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="ot">main ::</span> <span class="dt">IO</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">main <span class="fu">=</span> putStrLn <span class="st">&quot;Hello, world!&quot;</span></a></code></pre></div>
<hr />
<ul>
<li>stack 設定ファイルで <code>year</code> パラメータが設定できるようになりました。それに伴い、ドキュメントもわかりやすくしました。 (<a href="https://github.com/commercialhaskell/stack/issues/2275">#2275</a>)。</li>
</ul>
<p>こんな感じで指定できるようです。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">templates:</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  <span class="fu">params:</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    <span class="fu">author-email:</span><span class="at"> 415fox@gmail.com</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    <span class="fu">author-name:</span><span class="at"> michael fox</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    <span class="fu">category:</span><span class="at"> Application</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    <span class="fu">copyright:</span><span class="at"> copytright michael fox 2016</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    <span class="fu">github-username:</span><span class="at"> gitfoxi</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">    <span class="fu">year:</span><span class="at"> 2016</span></a></code></pre></div>
<p>ドキュメントを見る限り <code>copyright</code> を省略した場合は <code>author-name</code> と <code>year</code> を使って <code>copyright</code> が生成されるようです。</p>
<p>また <code>year</code> を省略した場合は現在の年が設定されるとのことなので、設定しなくても良さそうですね。</p>
<hr />
<ul>
<li>ベンチーマークが別のベンチマークやビルドステップと並行して実行されてしまう問題を修正しました。これは別のプロセスのCPU利用がベンチマークに悪影響を及ぼすと思われるので理想的ではありません。また、デフォルトでベンチマークの出力が表示されないようになっていた件も同様に修正しました (<a href="https://github.com/commercialhaskell/stack/issues/3663">#3663</a>)</li>
</ul>
<p><a href="https://github.com/commercialhaskell/stack/pull/3666">Never run benchmarks concurrently, always output to console #3663 #3666</a>が修正のPRです。</p>
<p>良くわかりませんが <code>Actiontype</code> 型に <code>ConcurrencyDisallowed</code> というデータコンストラクタを追加し <code>bench</code> が呼ばれた際はこの値を <code>Action</code> 型の <code>actionConcurrency</code> フィールドに設定することで処理を切り替えるようにしているっぽいです。</p>
<hr />
<ul>
<li>パッケージのコンポーネントごとに別々のビルドキャッシュを持つことによって、未変更のファイルについて不要なリビルドを回避するようになりました (<a href="https://github.com/commercialhaskell/stack/issues/3732">#3732</a>)</li>
</ul>
<p><code>issue</code> にあがっている具体例だと <code>foo</code> と <code>bar</code> の2つのパッケージを作り、<code>bar</code> は <code>foo</code> に依存しているという関係です。</p>
<pre class="shell"><code>$ stack test --no-run-tests
$ stack test --no-run-tests bar</code></pre>
<p>この時、1回目でテストが終わってるので2回目で <code>bar</code> を指定した時に何も起こらないはずです。</p>
<p>しかし、実際にはこうなります。</p>
<pre class="shell"><code>$ stack test --no-run-tests bar
bar-0.1.0.0: unregistering (missing dependencies: foo)
foo-0.1.0.0: unregistering (local file changes: app/Main.hs test/Spec.hs)
foo-0.1.0.0: build (lib + exe)
foo-0.1.0.0: copy/register
bar-0.1.0.0: configure (lib + exe + test)</code></pre>
<p><a href="https://github.com/commercialhaskell/stack/pull/3750">Use a separate build cache for each component of a package #3750</a>で修正されています。</p>
<p>実装を見る感じ、コンポーネントというのは <code>lib</code>, <code>exe</code>, <code>test</code>, <code>bench</code> のことで、それぞれを接頭辞にしたビルドキャッシュを持つようになったみたい？です。</p>
<hr />
<ul>
<li>スナップショットからローカルパッケージにパッケージを反映させる処理の動作を修正しました。これはスナップショットのバージョン境界が衝突する時に発生する問題なので、古いパッケージの Hackage リビジョンによって引き起こされます。同様にカスタムスナップショットでも、問題の起きないパッケージの衝突するバージョンが定義できるようになりました。(<a href="https://github.com/fpco/stackage/issues/3185">Stackage issue #3185</a>)</li>
</ul>
<p><a href="https://github.com/commercialhaskell/stack/pull/3758/">Fix package promotion to snapshot #3758</a> で修正されました。コードの差分は以下の1行です。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot"># 変更前</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="dt">Just</span> version <span class="ot">-&gt;</span> version <span class="ot">`withinIntervals`</span> intervals</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="ot"># 変更後</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="dt">Just</span> _version <span class="ot">-&gt;</span> <span class="dt">True</span></a></code></pre></div>
<p>このようにローカルパッケージ反映時？にバージョンチェックを行わないようになりました。</p>
<p>以下のようにカスタムスナップショットに追加する場合はビルドできます。(<code>async-2.1.1.1</code> には <code>stm &gt;= 2.2 &amp;&amp; &lt; 2.5</code> の依存関係が設定されています。<a href="https://hackage.haskell.org/package/async-2.1.1.1/src/async.cabal">async.cabal</a>)</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="co"># stack.yaml</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="fu">resolver:</span><span class="at"> snapshot.yaml</span></a></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co"># snapshot.yaml</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="fu">resolver:</span><span class="at"> ghc-8.0.2</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="fu">name:</span><span class="at"> hackage-revisions-are-annoying</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="fu">packages:</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="kw">-</span> async-2.1.1.1</a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="kw">-</span> stm-2.1.2.2</a></code></pre></div>
<p>実行結果。</p>
<pre class="shell"><code>$ stack build --stack-yaml as-snapshot.yaml
WARNING: Ignoring out of range dependency (trusting snapshot over Hackage revisions): stm-2.1.2.2. async requires: &gt;=2.2 &amp;&amp; &lt;2.5

...

Process exited with code: ExitFailure 1
    Logs have been written to: /home/bm12/Desktop/testProj/test/.stack-work/logs/async-2.1.1.1.log

    Configuring async-2.1.1.1...
    Cabal-simple_mPHDZzAJ_1.24.2.0_ghc-8.0.2: Encountered missing dependencies:
    stm &gt;=2.2 &amp;&amp; &lt;2.5 &amp;&amp; ==2.1.2.2</code></pre>
<p>また、以下のように <code>extra-deps</code> に追加する場合はビルドが実行される前にバージョンエラーになります。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="co"># stack.yaml</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="fu">resolver:</span><span class="at"> ghc-8.0.2</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="fu">extra-deps:</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="kw">-</span> async-2.1.1.1</a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="kw">-</span> stm-2.1.2.2</a></code></pre></div>
<p>実行結果</p>
<pre class="shell"><code>$ stack build --stack-yaml as-extra-dep.yaml

Error: While constructing the build plan, the following exceptions were encountered:

In the dependencies for async-2.1.1.1:
    stm-2.1.2.2 from stack configuration does not match &gt;=2.2 &amp;&amp; &lt;2.5  (latest matching version is 2.4.5.0)
needed due to test-0.1.0.0 -&gt; async-2.1.1.1

Some different approaches to resolving this:

  * Set &#39;allow-newer: true&#39; to ignore all version constraints and build anyway.

  * Consider trying &#39;stack solver&#39;, which uses the cabal-install solver to attempt to find some working build configuration. This can be convenient when
    dealing with many complicated constraint errors, but results may be unpredictable.

  * Recommended action: try adding the following to your extra-deps in /home/bm12/Desktop/testProj/test/as-extra-dep.yaml:

- stm-2.4.5.0

Plan construction failed.</code></pre>
<hr />
<ul>
<li><code>stack ghci</code> で複数のパッケージで定義されている同名のモジュールを読み込めるようになりました (<a href="https://github.com/commercialhaskell/stack/pull/3776">#3776</a>)。</li>
</ul>
<p>あんまりわかってないですが、<code>issue</code> の内容は <code>stack</code> と <code>rio</code> の両方のパッケージで同名のモジュールがある場合でも、ちゃんと読み込めるようになったみたいです。</p>
<pre><code>Path.Extra (in stack, rio)
RIO (in stack, rio)
RIO.Logger (in stack, rio)
RIO.Prelude (in stack, rio)
RIO.Process (in stack, rio)</code></pre>
<p><a href="https://github.com/commercialhaskell/stack/pull/3779">With ghci, allow multiple packages to use the same module #3776 #3779</a> で修正されました。</p>
<p><code>ghciPkgModules</code> の型を <code>Set ModuleName</code> から <code>ModuleMap</code> に変更しています。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">type</span> <span class="dt">ModuleMap</span> <span class="fu">=</span> <span class="dt">Map</span> <span class="dt">ModuleName</span> (<span class="dt">Map</span> (<span class="dt">Path</span> <span class="dt">Abs</span> <span class="dt">File</span>) (<span class="dt">Set</span> (<span class="dt">PackageName</span>, <span class="dt">NamedComponent</span>)))</a></code></pre></div>
<p><code>モジュール名</code> → <code>ファイルの絶対パス</code> の順番で探して、その中を <code>Set (PackageName, NamedComponent)</code> で持つようになっています。今まではモジュール名の <code>Set</code> だったので確かに複数のパッケージでも上手く処理できそうな感じがします。</p>
<hr />
<ul>
<li><code>stack ghci</code> で <code>base</code> の依存関係を追加する必要が無くなりました。これはローカルターゲットが存在しない場合に自動的に追加されるためです。これにより、<code>base</code> を置き換えているコードも同様に読み込めるようになります (<a href="https://github.com/commercialhaskell/stack/issues/3589">#3589</a>)</li>
</ul>
<p>修正の<a href="https://github.com/commercialhaskell/stack/commit/196bdbae986ddf887f92999b26129085a8ed0be5">コミット</a>を見ると <code>&quot;-package&quot; : &quot;base&quot;</code> が明示的に追加されています。</p>
<hr />
<ul>
<li><code>--no-rerun-tests</code> が修正されました。今まではテストを実行した後に結果の記録を忘れていました。そのため、前回テストにパスしていたとしても、常に全てのテストが実行されていました (<a href="https://github.com/commercialhaskell/stack/pull/3770">#3770</a>)</li>
</ul>
<hr />
<ul>
<li><code>hackage-security</code> のパッチを当てたバージョンを含めるようにしました。このパッチには機械故障や <code>SIGKILL</code> に対して更新処理が正しく復帰できるように、非同期例外処理に関する問題とディレクトリロックからファイルロックへの変更の2つが含まれます (<a href="https://github.com/haskell/hackage-security/issues/187">hackage-security #187</a>, <a href="https://github.com/commercialhaskell/stack/issues/3073">#3073</a>)</li>
</ul>
<p>この問題よくわかってないのですが、<code>stack</code> のコミットは <code>extra-deps</code> にパッチの当たっている <code>hackage-security</code> を追加しただけです。(<a href="https://github.com/commercialhaskell/stack/commit/4bf68f02d901a6ffc7f4b81a22985d98435fbb14">コミット</a>)</p>
<p>実際のパッチは以下の2つです。</p>
<ul>
<li><a href="https://github.com/haskell/hackage-security/pull/202">Detect asynchronous exceptions via their types #187 #202</a></li>
<li><a href="https://github.com/haskell/hackage-security/pull/203">Use file instead of dir locking #187 #203</a></li>
</ul>
<h2 id="bug-fix-オリジナル">Bug fix (オリジナル)</h2>
<ul>
<li>1.6.1 introduced a change that made some precompiled cache files use longer paths, sometimes causing builds to fail on windows. This has been fixed. See <a href="https://github.com/commercialhaskell/stack/issues/3649">#3649</a></li>
<li>The script interpreter’s implicit file arguments are now passed before other arguments. See <a href="https://github.com/commercialhaskell/stack/issues/3658">#3658</a>. In particular, this makes it possible to pass <code>-- +RTS ... -RTS</code> to specify RTS arguments used when running the script.</li>
<li>Don’t ignore the template <code>year</code> parameter in config files, and clarify the surrounding documentation. See <a href="https://github.com/commercialhaskell/stack/issues/2275">#2275</a>.</li>
<li>Benchmarks used to be run concurrently with other benchmarks and build steps. This is non-ideal because CPU usage of other processes may interfere with benchmarks. It also prevented benchmark output from being displayed by default. This is now fixed. See <a href="https://github.com/commercialhaskell/stack/issues/3663">#3663</a>.</li>
<li>Some unnecessary rebuilds when no files were changed are now avoided, by having a separate build cache for each component of a package. See <a href="https://github.com/commercialhaskell/stack/issues/3732">#3732</a>.</li>
<li>Correct the behavior of promoting a package from snapshot to local package. This would get triggered when version bounds conflicted in a snapshot, which could be triggered via Hackage revisions for old packages. This also should allow custom snapshots to define conflicting versions of packages without issue. See <a href="https://github.com/fpco/stackage/issues/3185">Stackage issue #3185</a>.</li>
<li>When promoting packages from snapshot to local, we were occassionally discarding the actual package location content and instead defaulting to pulling the package from the index. We now correctly retain this information. Note that if you were affected by this bug, you will likely need to delete the binary build cache associated with the relevant custom snapshot. See <a href="https://github.com/commercialhaskell/stack/issues/3714">#3714</a>.</li>
<li><code>stack ghci</code> now allows loading multiple packages with the same module name, as long as they have the same filepath. See <a href="https://github.com/commercialhaskell/stack/pull/3776">#3776</a>.</li>
<li><code>stack ghci</code> no longer always adds a dependency on <code>base</code>. It is now only added when there are no local targets. This allows it to be to load code that uses replacements for <code>base</code>. See <a href="https://github.com/commercialhaskell/stack/issues/3589#issuecomment">#3589</a></li>
<li><code>--no-rerun-tests</code> has been fixed. Previously, after running a test we were forgetting to record the result, which meant that all tests always ran even if they had already passed before. See <a href="https://github.com/commercialhaskell/stack/pull/3770">#3770</a>.</li>
<li>Includes a patched version of <code>hackage-security</code> which fixes both some issues around asynchronous exception handling, and moves from directory locking to file locking, making the update mechanism resilient against SIGKILL and machine failure. See <a href="https://github.com/haskell/hackage-security/issues/187">hackage-security #187</a> and <a href="https://github.com/commercialhaskell/stack/issues/3073">#3073</a>.</li>
</ul>
<h2 id="まとめ">まとめ</h2>
<ul>
<li><code>stack ghci</code> 周りのバグフィックスもいくつかあったので <code>ghci</code> を多用する人にとっては嬉しいですね。</li>
<li>古い <code>LTS</code> を使っているプロジェクトでビルドができなくて困っている人は <code>1.6.5</code> にアップデートすると直るかもしれません。</li>
</ul>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Pattern Synonyms で DEPRECATED</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/02-12-pattern-synonyms.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/02-12-pattern-synonyms.html</id>
    <published>2018-02-12T00:00:00Z</published>
    <updated>2018-02-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p><code>persistent</code> ライブラリで <code>SomeField</code> を <code>CopyField</code> に置き換える際の<a href="https://github.com/yesodweb/persistent/pull/760">PR</a>で、パターンシノニム (Pattern Synonyms) の面白い使い方を見つけました。</p>
<p>もしかしたら良く知られた技なのかもしれませんが、ご紹介したいと思います。</p>
<p>パターンシノニムが何かについての説明は、今回全くしていませんのでわかる人向けです。</p>
<!--more-->
<h2 id="モチベーション">モチベーション</h2>
<p>パターンシノニムはパターンの再利用を可能にするための言語拡張です。詳しくは <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pattern-synonyms">User’s Guide 10.7. Pattern synonyms</a> をご確認ください。</p>
<p>使いみちは色々あると思いますが、今回はコンストラクタを <code>DEPRECATED</code> にするために利用する例をご紹介します。（実際のコードは<a href="https://github.com/parsonsmatt/persistent/blob/c882203c9cc09ba28b2012b58b4cd0fdc415e6ce/persistent-mysql/Database/Persist/MySQL.hs#L1080">このあたり</a>です)</p>
<p><code>Persistent</code> ライブラリの <code>3.0.0</code> から <code>SomeField</code> が廃止され <code>HandleUpdateCollision</code> 型が導入されました。</p>
<p><code>SomeField</code> 型は <code>Persistent</code> の中でも結構重要な型 (<code>SomeException</code> と同じような雰囲気の型) です。また <code>Yesod</code> のプロジェクトでは多数のユーザがいるため、このような変更に対しては、いきなり削除するのではなく <code>DEPRECATED</code> プラグマを利用して、新しい関数への移行を促しています。</p>
<p>今回の場合、<strong>関数</strong>ではなく<strong>データ型</strong>を変更する必要があるためパターンシノニムが利用されています。</p>
<h2 id="実際のコード">実際のコード</h2>
<p>コメント等を適宜削除しましたが、実際にはこんな感じで利用されています。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">HandleUpdateCollision</span> record <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="dt">CopyField</span><span class="ot"> ::</span> <span class="dt">EntityField</span> record typ <span class="ot">-&gt;</span> <span class="dt">HandleUpdateCollision</span> record</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="dt">CopyUnlessEq</span><span class="ot"> ::</span> <span class="dt">PersistField</span> typ <span class="ot">=&gt;</span> <span class="dt">EntityField</span> record typ <span class="ot">-&gt;</span> typ <span class="ot">-&gt;</span> <span class="dt">HandleUpdateCollision</span> record</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">type</span> <span class="dt">SomeField</span> <span class="fu">=</span> <span class="dt">HandleUpdateCollision</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="ot">#if MIN_VERSION_base(4,8,0)</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">pattern <span class="dt">SomeField</span><span class="ot"> ::</span> <span class="dt">EntityField</span> record typ <span class="ot">-&gt;</span> <span class="dt">SomeField</span> record</a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="ot">#endif</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">pattern <span class="dt">SomeField</span> x <span class="fu">=</span> <span class="dt">CopyField</span> x</a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="ot">{-# DEPRECATED SomeField &quot;The type SomeField is deprecated. Use the type HandleUpdateCollision instead, and use the function copyField instead of the data constructor.&quot; #-}</span></a></code></pre></div>
<p>重要な部分はここですね。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">pattern <span class="dt">SomeField</span> x <span class="fu">=</span> <span class="dt">CopyField</span> x</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ot">{-# DEPRECATED SomeField &quot;...&quot; #-}</span></a></code></pre></div>
<p><code>Haskell</code> には<strong>型シノニム</strong>があるのに<strong>データシノニム</strong>って無いんですね。。。って思った人はパターンシノニムを使えばこんな感じで実現可能です。</p>
<p>通常、パターンシノニムを利用するモチベーションはパターンマッチの再利用にあると思うのですが、単純にデータコンストラクタのエイリアスにしておいて <code>DEPRECATED</code> を促すやり方も結構使えるなーと思いました。</p>
<p>以上です。</p>]]></summary>
</entry>

</feed>
