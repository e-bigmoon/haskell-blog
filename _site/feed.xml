<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>BIG MOON</title>
    <link href="https://haskell.e-bigmoon.com/feed.xml" rel="self" />
    <link href="https://haskell.e-bigmoon.com" />
    <id>https://haskell.e-bigmoon.com/feed.xml</id>
    <author>
        <name>BIG MOON</name>
        <email>it@e-bigmoon.com</email>
    </author>
    <updated>2019-11-10T00:00:00Z</updated>
    <entry>
    <title>Megaparsec 8</title>
    <link href="https://haskell.e-bigmoon.com/posts/2019/11-10-megaparsec8.html" />
    <id>https://haskell.e-bigmoon.com/posts/2019/11-10-megaparsec8.html</id>
    <published>2019-11-10T00:00:00Z</published>
    <updated>2019-11-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Great original post: <a href="https://markkarpov.com/post/megaparsec-8.html">Megaparsec 8</a></p>
<p>一年が経ち、Megaparsecの新しいメジャーバージョンが再び登場する時がきました。 今回の変更は、これまでのメジャーリリースの中で最も破壊的ではない変更です。 実際、ほとんどのユーザはアップグレードのために何もする必要はないと思います。</p>
<!--more-->
<p>これには次の理由があります。</p>
<ul>
<li>それほど多くのissue が開かれておらず、バグも報告されていません。それはMegaparsecが最近、そしてほとんど満足のいく方法で「うまくいく」という事実と関係があると思います。</li>
<li>ライブラリは現在幅広く使用されています。この記事の執筆時点で、Megaparsecに直接依存する<a href="https://packdeps.haskellers.com/reverse/megaparsec">Hackageのパッケージは146個</a>あります。Megaparsecの上に構築することを選択した<a href="https://hackage.haskell.org/package/replace-megaparsec">新しい刺激的なライブラリ</a>も現れました。<a href="https://github.com/idris-lang/Idris-dev">Idris</a>や<a href="https://github.com/dhall-lang/dhall-haskell">Dhall</a>などのプロジェクトでは、Megaparsecを使用してパースの問題を解決しています。</li>
</ul>
<p>これらはライブラリが枯れ、成熟したことを示しているので、動作しているものを壊さないようにしましょう。 とはいえ、常に改善の余地があります。</p>
<h2 id="nixによる品質保証">Nixによる品質保証</h2>
<p>バージョン8の作業を開始する前に、Nixを使用して品質保証を強化することにしました。 現在のMegaparsecに依存するプロジェクトの数を把握し、Nixを使用して<a href="https://github.com/tweag/ormolu">Ormolu</a>のバグを発見したという成功体験から、依存パッケージによって引き起こされる破壊的変更、パフォーマンスの変更、およびバグのチェックにNixを用いることにしました。</p>
<p>結果をMegaparsecのリポジトリにある<a href="https://github.com/mrkkrp/megaparsec/blob/master/HACKING.md">HACKING.md</a>に文書化しました。 開発時のshellとは別に、Nix expressionは以下のターゲットグループを提供します。</p>
<ul>
<li><code>base</code> は <code>parser-combinators</code> や <code>hspec-megaparsec</code> などの密接に関連したパッケージとそのテストです。<code>nix-build -A base --no-out-link</code> を実行することにより、開発者はこれらすべてをビルドし、テストすることができます。</li>
<li><code>deps</code> は選択された依存関係のもとでビルドの破壊とテストスイートの失敗が起きないことを確認します。</li>
<li><code>benches</code> はベンチマークのコレクションです。これには、Megaparsecのマイクロベンチマークと、ライブラリが実際のタスクでどのように実行されるかを示すいくつかのパッケージが含まれます。</li>
</ul>
<p>これらコマンドのそれぞれで、特定のパッケージまたはベンチマークに「ズームイン」できます。 たとえば、<code>nix-build -A benches.parsers-bench</code> を実行して、<code>parsers-bench</code> のベンチマークを確認できます。 要するに、ほとんどのパッケージは新しい変更でも引き続き動作し、修正が容易ではないものでも動作します。 実際、システムを使い続けるためには不備のあるパッケージにパッチを適用する必要があり、そのための<a href="https://github.com/mrkkrp/megaparsec/tree/31b917b1297950c22925f9ee7f7a588834293103/nix/patches">アップグレード用のパッチ</a>も利用可能です。</p>
<p>ロジックやパフォーマンスの低下は見つかりませんでした。</p>
<h2 id="パースエラー位置の制御">パースエラー位置の制御</h2>
<p>新機能について話しましょう。 プリミティブ <code>failure</code> と <code>fancyFailure</code> は <code>parseError</code> に置き換わりました。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="ot">parseError ::</span> <span class="dt">MonadParsec</span> e s m <span class="ot">=&gt;</span> <span class="dt">ParseError</span> s e <span class="ot">-&gt;</span> m a</span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="co">-- 現在の &#39;failure&#39; と &#39;fancyFailure&#39; は普通の関数:</span></span>
<span id="cb1-4"><a href="#cb1-4"></a></span>
<span id="cb1-5"><a href="#cb1-5"></a>failure</span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="ot">  ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb1-7"><a href="#cb1-7"></a>  <span class="ot">=&gt;</span> <span class="dt">Maybe</span> (<span class="dt">ErrorItem</span> (<span class="dt">Token</span> s)) <span class="co">-- ^ 期待しないアイテム (あれば)</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>  <span class="ot">-&gt;</span> <span class="dt">Set</span> (<span class="dt">ErrorItem</span> (<span class="dt">Token</span> s)) <span class="co">-- ^ 期待するアイテム</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>  <span class="ot">-&gt;</span> m a</span>
<span id="cb1-10"><a href="#cb1-10"></a>failure us ps <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>  o <span class="ot">&lt;-</span> getOffset</span>
<span id="cb1-12"><a href="#cb1-12"></a>  parseError (<span class="dt">TrivialError</span> o us ps)</span>
<span id="cb1-13"><a href="#cb1-13"></a></span>
<span id="cb1-14"><a href="#cb1-14"></a>fancyFailure</span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="ot">  ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb1-16"><a href="#cb1-16"></a>  <span class="ot">=&gt;</span> <span class="dt">Set</span> (<span class="dt">ErrorFancy</span> e) <span class="co">-- ^ Fancy error components</span></span>
<span id="cb1-17"><a href="#cb1-17"></a>  <span class="ot">-&gt;</span> m a</span>
<span id="cb1-18"><a href="#cb1-18"></a>fancyFailure xs <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-19"><a href="#cb1-19"></a>  o <span class="ot">&lt;-</span> getOffset</span>
<span id="cb1-20"><a href="#cb1-20"></a>  parseError (<span class="dt">FancyError</span> o xs)</span></code></pre></div>
<p>これはプリミティブの数を減らすという話ではありません (減らすことも良いことですが)。 <code>parseError</code> の主な特徴は、パーサの状態から現在のオフセットを必要とすることなく、任意のオフセットでパースエラーを報告できることです。 これは、パースエラーにしたい位置を既に超えてしまっている場合でも、入力のその位置でパースエラーを作成したい場合に重要です。 これまでは、まず <code>getOffset</code> を介して正しいオフセットを取得し、次にパースエラーを報告する直前に <code>setOffset</code> でオフセットを設定することでしか達成できませんでした。 これは見苦しいだけでなく、エラーが発生しやすくなり、正しいオフセットの復元を忘れることがあります。 <code>mmark</code>の<a href="https://github.com/mmark-md/mmark/blob/8f5534d8068c2b7a139b893639ee5920bcaedd84/Text/MMark/Parser.hs#L787-L790">実例</a>を次に示します。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a>  o&#39; <span class="ot">&lt;-</span> getOffset</span>
<span id="cb2-2"><a href="#cb2-2"></a>  setOffset o</span>
<span id="cb2-3"><a href="#cb2-3"></a>  (void <span class="op">.</span> hidden <span class="op">.</span> string) <span class="st">&quot;[]&quot;</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>  <span class="co">-- ↑ これが失敗した場合、これをオフセット「o」で報告する必要があります</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>  setOffset (o&#39; <span class="op">+</span> <span class="dv">2</span>)</span></code></pre></div>
<p>ここでは完全な状況を説明しませんが、<code>"[]"</code>(<code>+ 2</code>の部分)のパース後にオフセットの増分を考慮するのを忘れたため、このコードにはしばらくバグがあったと言えば十分でしょう。 次のように書けば、同じことをよりうまく表現できます。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a>  region (setErrorOffset o) <span class="op">$</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>    (void <span class="op">.</span> hidden <span class="op">.</span> string) <span class="st">&quot;[]&quot;</span></span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="co">-- 備考</span></span>
<span id="cb3-5"><a href="#cb3-5"></a></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="ot">region ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb3-7"><a href="#cb3-7"></a>  <span class="ot">=&gt;</span> (<span class="dt">ParseError</span> s e <span class="ot">-&gt;</span> <span class="dt">ParseError</span> s e)</span>
<span id="cb3-8"><a href="#cb3-8"></a>     <span class="co">-- ^ &#39;ParseError&#39; の処理方法</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>  <span class="ot">-&gt;</span> m a</span>
<span id="cb3-10"><a href="#cb3-10"></a>     <span class="co">-- ^ 処理を適用する「region」</span></span>
<span id="cb3-11"><a href="#cb3-11"></a>  <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p><code>region</code>は<code>getOffset</code> / <code>setOffset</code> ハックと同じ目的で使用されます。 副作用として、エラーが起きた場合にはパースエラーを更新する関数によって現在のオフセットが変更されます。 <code>region</code> は <code>parseError</code> を使用して、古いハックを廃止できます。</p>
<pre class="haskel"><code>region f m = do
  r &lt;- observing m
  case r of
    Left err -&gt; parseError (f err)
    Right x -&gt; return x</code></pre>
<p>いいね.</p>
<h2 id="マルチエラーパーサのより良いストーリー">マルチエラーパーサのより良いストーリー</h2>
<p>プロジェクトの最初期から、マルチエラーパーサをサポートする方向にゆっくりと動いていました。 バージョン7では、<code>ParseError</code>の代わりに<code>ParseErrorBundle</code>を返すようになりました。 マルチエラーをサポートするための準備はすべてが整っていましたが、複数のパースエラーを報告するための方法がまだ提供されていませんでした。</p>
<p>マルチエラーパーサに求められる事前条件は、入力に問題のある部分をスキップして、正常であることがわかっている位置からパースを再開できることです。 この部分は、<code>withRecovery</code>プリミティブ（Megaparsec 4.4.0以降で使用可能）を使用して実現されます。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="co">-- | @&#39;withRecovery&#39; r p@ は、パーサー @p@ が失敗した場合でも解析を続行できます。</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="co">-- この場合、実際の &#39;ParseError&#39; を引数とする @r@ が呼び出されます。</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="co">-- よくある使い方として、特定のオブジェクトのパースの失敗を意味する値を返すことで、</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="co">-- その入力の一部を消費し次のオブジェクトの開始位置に移動します。</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="co">--</span></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="co">-- @r@ が失敗すると、元のエラーメッセージが &#39;withRecovery&#39; なしで報告されることに注意してください。</span></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="co">-- パーサ @r@ を回復してもエラーメッセージに影響することはありません。</span></span>
<span id="cb5-8"><a href="#cb5-8"></a></span>
<span id="cb5-9"><a href="#cb5-9"></a></span>
<span id="cb5-10"><a href="#cb5-10"></a>withRecovery</span>
<span id="cb5-11"><a href="#cb5-11"></a><span class="ot">  ::</span> (<span class="dt">ParseError</span> s e <span class="ot">-&gt;</span> m a) <span class="co">-- ^ 失敗の回復方法</span></span>
<span id="cb5-12"><a href="#cb5-12"></a>  <span class="ot">-&gt;</span> m a             <span class="co">-- ^ オリジナルのパーサ</span></span>
<span id="cb5-13"><a href="#cb5-13"></a>  <span class="ot">-&gt;</span> m a             <span class="co">-- ^ 失敗から回復できるパーサ</span></span></code></pre></div>
<p>Megaparsec 8 までのユーザーは、成功と失敗の可能性を含む直和型になるように型<code>a</code>を選択する必要がありました。 たとえば、<code>Either (ParseError s e) Result</code> です。 パースエラーを収集し、後で表示する前に手動で<code>ParseErrorBundle</code>に追加する必要がありました。 言うまでもなく、これらはすべて、ユーザーフレンドリーではない高度な使用例です。</p>
<p>Megaparsec 8 は、遅延パースエラーのサポートを追加します。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="co">-- | 後で報告するために &#39;ParseError&#39;を登録します。</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="co">-- このアクションはパースを終了せず、パースの最後に考慮される</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="co">-- 「遅延」&#39;ParseError&#39;のコレクションに特定の「ParseError」を</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="co">-- 追加する以外は効果がありません。 このコレクションが空の場合のみ、</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="co">-- パーサは成功します。 これは、複数のパースエラーを一度に報告する</span></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="co">-- 主な方法です。</span></span>
<span id="cb6-7"><a href="#cb6-7"></a></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="ot">registerParseError ::</span> <span class="dt">MonadParsec</span> e s m <span class="ot">=&gt;</span> <span class="dt">ParseError</span> s e <span class="ot">-&gt;</span> m ()</span>
<span id="cb6-9"><a href="#cb6-9"></a></span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="co">-- | &#39;failure&#39;に似ていますが、 遅延&#39;ParseError&#39;のためのものです。</span></span>
<span id="cb6-11"><a href="#cb6-11"></a></span>
<span id="cb6-12"><a href="#cb6-12"></a>registerFailure</span>
<span id="cb6-13"><a href="#cb6-13"></a><span class="ot">  ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb6-14"><a href="#cb6-14"></a>  <span class="ot">=&gt;</span> <span class="dt">Maybe</span> (<span class="dt">ErrorItem</span> (<span class="dt">Token</span> s)) <span class="co">-- ^ 期待しないアイテム (あれば)</span></span>
<span id="cb6-15"><a href="#cb6-15"></a>  <span class="ot">-&gt;</span> <span class="dt">Set</span> (<span class="dt">ErrorItem</span> (<span class="dt">Token</span> s)) <span class="co">-- ^ 期待するアイテム</span></span>
<span id="cb6-16"><a href="#cb6-16"></a>  <span class="ot">-&gt;</span> m ()</span>
<span id="cb6-17"><a href="#cb6-17"></a></span>
<span id="cb6-18"><a href="#cb6-18"></a><span class="co">-- | &#39;fancyFailure&#39;に似ていますが、 遅延&#39;ParseError&#39;のためのものです。</span></span>
<span id="cb6-19"><a href="#cb6-19"></a></span>
<span id="cb6-20"><a href="#cb6-20"></a>registerFancyFailure</span>
<span id="cb6-21"><a href="#cb6-21"></a><span class="ot">  ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb6-22"><a href="#cb6-22"></a>  <span class="ot">=&gt;</span> <span class="dt">Set</span> (<span class="dt">ErrorFancy</span> e) <span class="co">-- ^ Fancy error components</span></span>
<span id="cb6-23"><a href="#cb6-23"></a>  <span class="ot">-&gt;</span> m ()</span></code></pre></div>
<p>これらのエラーは <code>withRecovery</code> のエラー処理コールバックに登録でき、結果の型は <code>Maybe Result</code> になります。 これにより、遅延エラーが最終的な <code>ParseErrorBundle</code> に含まれるようになり、遅延エラーのコレクションが空でない場合に パーサが最終的に失敗するようになります。</p>
<p>以上のことから、マルチエラーパーサを書く習慣がユーザ間でより一般的になることを願っています。</p>
<h2 id="その他">その他</h2>
<ul>
<li>いつものように、変更の完全なリストについては、<a href="https://github.com/mrkkrp/megaparsec/blob/master/CHANGELOG.md">chagelog</a> を参照してください。</li>
<li><a href="https://markkarpov.com/megaparsec/megaparsec.html">公式チュートリアル</a>を含むすべてのテキストをバージョン8と互換性があるように更新しました。新しい機能の使用方法を説明するセクションを含めるように拡張しました。</li>
<li><code>hspec-megaparsec</code> などのサテライトパッケージが更新され、バージョン8で動作するようになりました。</li>
</ul>]]></summary>
</entry>
<entry>
    <title>cabal-fmt の紹介</title>
    <link href="https://haskell.e-bigmoon.com/posts/2019/10-07-cabal-fmt.html" />
    <id>https://haskell.e-bigmoon.com/posts/2019/10-07-cabal-fmt.html</id>
    <published>2019-10-07T00:00:00Z</published>
    <updated>2019-10-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p><a href="https://hackage.haskell.org/package/cabal-fmt">cabal-fmt</a> でできること。</p>
<ul>
<li><strong>cabal</strong> ファイルの整形</li>
<li>フォルダを指定して自動でモジュールを expand できる</li>
<li>以下のフィールドをアルファベット順で自動的に並べ替え&amp;重複を削除
<ul>
<li><strong>exposed-modules</strong></li>
<li><strong>other-modules</strong></li>
<li><strong>default-extensions</strong></li>
<li><strong>other-extensions</strong></li>
<li><strong>build-depends</strong></li>
</ul></li>
</ul>
<pre class="shell"><code>λ cabal-fmt --version
0.1.1.1

λ cabal -V
cabal-install version 3.0.0.0
compiled using version 3.0.0.0 of the Cabal library

# 使い方
λ cabal-fmt &lt;proj&gt;.cabal -i</code></pre>
<p>作者の記事: <a href="http://oleg.fi/gists/posts/2019-08-11-cabal-fmt.html">ANN: cabal-fmt</a></p>
<!--more-->
<h2 id="具体例">具体例</h2>
<h3 id="適用前">適用前</h3>
<pre class="cabal"><code>cabal-version: 2.4
name:test
version:0.1.0.0
tested-with:
  GHC ==8.8.1 || ==8.6.5 || ==8.4.4 || ==8.2.2 || ==8.0.2 || ==7.10.3
  GHCJS ==8.4

executable site
  main-is:          site.hs
  other-modules:
    Config
    Hakyll.Ext
  hs-source-dirs:   app
  ghc-options:
    -Wcompat -Wall
    -Wnoncanonical-monad-instances
    -Wincomplete-uni-patterns -Wincomplete-record-updates -Wredundant-constraints -Wtabs -threaded
  build-depends:
      base, lens
    , blaze-html, conduit-combinators
    , containers      , filepath
          , bytestring
    , extensible
    
    
    , yaml, time

  if !os(windows)
    build-depends: hakyll-sass

  default-language: Haskell2010</code></pre>
<h3 id="適用後">適用後</h3>
<pre class="cabal"><code>cabal-version: 2.4
name:          test
version:       0.1.0.0
tested-with:
    GHC ==7.10.3
     || ==8.0.2
     || ==8.2.2
     || ==8.4.4
     || ==8.6.5
     || ==8.8.1
  , GHCJS ==8.4

executable site
  main-is:          site.hs
  other-modules:
    Config
    Hakyll.Ext

  hs-source-dirs:   app
  ghc-options:
    -Wcompat -Wall -Wnoncanonical-monad-instances
    -Wincomplete-uni-patterns -Wincomplete-record-updates
    -Wredundant-constraints -Wtabs -threaded

  build-depends:
    , base
    , blaze-html
    , bytestring
    , conduit-combinators
    , containers
    , extensible
    , filepath
    , lens
    , time
    , yaml

  if !os(windows)
    build-depends: hakyll-sass

  default-language: Haskell2010
</code></pre>
<h2 id="インストール">インストール</h2>
<pre class="shell"><code>λ cabal v2-update
λ cabal v2-install cabal-fmt

λ cabal-fmt --help
λ cabal-fmt - .cabal file reformatter

Usage: cabal-fmt [-i|--inplace] [--Werror | --Wno-error | --indent N | --tabular
                 | --no-tabular] [FILE...] [--version]
  Reformat .cabal files

Available options:
  -i,--inplace             process files in-place
  --Werror                 Treat warnings as errors
  --indent N               Indentation
  --tabular                Tabular formatting
  FILE...                  input files
  -h,--help                Show this help text
  --version                Show version</code></pre>
<h2 id="使い方">使い方</h2>
<p>基本的には以下のコマンドで終わりです。(<code>&lt;proj&gt;</code> は各自のファイル名に置き換えてください)</p>
<pre class="shell"><code>λ cabal-fmt &lt;proj&gt;.cabal -i</code></pre>
<p><code>-i</code> オプション (<code>--inplace</code>) で既存ファイルを上書きするので、結果だけ見たい場合は外しましょう。</p>
<h3 id="モジュールの自動展開">モジュールの自動展開</h3>
<p>僕が <code>cabal-fmt</code> を使う理由の最大のポイントはモジュールの自動展開機能です。</p>
<pre class="cabal"><code>library
  -- cabal-fmt: expand src
  exposed-modules:</code></pre>
<p>記法としては、上記のようにしてモジュールを探索するディレクトリ (今回の場合は <strong>src</strong>) を指定します。</p>
<p>実際に使ってみましょう。ここでは例として <strong>test-dir</strong> を作りますが、実際には <strong>src</strong>, <strong>app</strong>, <strong>test</strong> などが展開の対象となることが多いと思います。</p>
<p>また、意図的に <strong>C.md</strong> としている点にも注意してください。</p>
<pre class="shell"><code>λ mkdir test-dir
λ touch test-dir/A.hs test-dir/B.hs test-dir/C.md
λ tree test-dir
test-dir
├── A.hs
├── B.hs
└── C.md</code></pre>
<p>適用する <strong>cabal</strong> ファイル (<strong>test.cabal</strong>) の中身は以下の通りです。</p>
<pre class="cabal"><code>name:    test
version: 0.1.0.0

library
  -- cabal-fmt: expand test-dir
  exposed-modules:</code></pre>
<p>この状態で <code>cabal-fmt test.cabal -i</code> を実行すると結果は以下のようになります。</p>
<pre class="cabal"><code>name:    test
version: 0.1.0.0

library
  -- cabal-fmt: expand test-dir
  exposed-modules:
    A
    B
    C
</code></pre>
<p><code>.hs</code> ファイルだけ列挙して欲しいところですが、指定したディレクトリ以下の全てを列挙します。そのため、公開したいモジュールと非公開のモジュールはディレクトリを分けて運用するなど、少しだけ工夫する必要があります。</p>
<p>一応、除外したいモジュールを <code>-Module</code> の形式で指定することもできます。</p>
<pre class="cabal"><code>name:    test
version: 0.1.0.0

library
  -- cabal-fmt: expand test-dir -C
  exposed-modules:</code></pre>
<p>適用後</p>
<pre class="cabal"><code>name:    test
version: 0.1.0.0

library
  -- cabal-fmt: expand test-dir -C
  exposed-modules:
    A
    B
</code></pre>
<p>この方法を使えば <strong>hspec-discover</strong> や <strong>tasty-discover</strong> のためのファイルなどを除外することができます。</p>
<h2 id="cabal-format-コマンド">cabal format コマンド</h2>
<p><code>cabal</code> についてあまり詳しく無いので良くわかりませんが、一応 <strong>cabal format</strong> というコマンドが存在します。(<a href="https://github.com/haskell/cabal/issues/2460"><code>cabal format</code> is not listed in –help message #2460</a>)</p>
<pre class="shell"><code>λ cabal format --help
Reformat the .cabal file using the standard style.

Usage: cabal format [FILE]

Flags for format:
 -h --help Show this help text</code></pre>
<p>実際にこのコマンドでも整形だけなら可能みたいです。ただし、<a href="https://github.com/haskell/cabal/issues/5734"><code>cabal format</code> inlines and removes <code>common</code> stanzas #5734</a> にもある通り <code>common</code> stanza が削除されたりします。</p>
<p>そのため、<strong>cabal format</strong> コマンドよりも <strong>cabal-fmt</strong> を利用した方が良いと思います。</p>
<h2 id="まとめ">まとめ</h2>
<p>便利なので最近良く使ってます。</p>
<h2 id="参考リソース">参考リソース</h2>
<ul>
<li><a href="http://oleg.fi/gists/posts/2019-08-11-cabal-fmt.html">ANN: cabal-fmt</a></li>
</ul>]]></summary>
</entry>
<entry>
    <title>NoStarIsType 言語拡張が必要になるとき</title>
    <link href="https://haskell.e-bigmoon.com/posts/2019/10-04-NoStarIsType.html" />
    <id>https://haskell.e-bigmoon.com/posts/2019/10-04-NoStarIsType.html</id>
    <published>2019-10-04T00:00:00Z</published>
    <updated>2019-10-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a>λ ghc <span class="op">-</span><span class="dt">V</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="dt">The</span> <span class="dt">Glorious</span> <span class="dt">Glasgow</span> <span class="dt">Haskell</span> <span class="dt">Compilation</span> <span class="dt">System</span>, version <span class="fl">8.8</span><span class="op">.</span><span class="dv">1</span></span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a>λ <span class="op">:</span>kind<span class="op">!</span> <span class="dv">10</span><span class="op">*</span><span class="dv">10</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">1</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>    • <span class="dt">Expected</span> kind ‘<span class="op">*</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> k0’, but ‘10’ has kind ‘<span class="dt">Nat</span>’</span>
<span id="cb1-7"><a href="#cb1-7"></a>    • <span class="dt">In</span> the <span class="kw">type</span> ‘<span class="dv">10</span> <span class="op">*</span> 10’</span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a>λ <span class="op">:</span>set <span class="op">-</span><span class="dt">XNoStarIsType</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>λ <span class="op">:</span>kind<span class="op">!</span> <span class="dv">10</span><span class="op">*</span><span class="dv">10</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="dv">10</span><span class="op">*</span><span class="dv">10</span><span class="ot"> ::</span> <span class="dt">Nat</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="ot">=</span> <span class="dv">100</span></span></code></pre></div>
<!--more-->
<h2 id="型レベル四則演算">型レベル四則演算</h2>
<p><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-TypeLits.html">GHC.TypeLits</a> に用意されている関数を使って型レベル自然数の四則演算を行ってみましょう。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a>λ <span class="op">:</span>set <span class="op">-</span><span class="dt">XDataKinds</span> <span class="op">-</span><span class="dt">XTypeOperators</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>λ <span class="kw">import</span> <span class="dt">GHC.TypeLits</span></span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a>λ <span class="op">:</span>kind<span class="op">!</span> <span class="dv">1</span><span class="op">+</span><span class="dv">1</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="dv">1</span><span class="op">+</span><span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Nat</span></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="ot">=</span> <span class="dv">2</span></span>
<span id="cb3-7"><a href="#cb3-7"></a></span>
<span id="cb3-8"><a href="#cb3-8"></a>λ <span class="op">:</span>kind<span class="op">!</span> <span class="dv">10</span><span class="op">-</span><span class="dv">1</span></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="dv">10</span><span class="op">-</span><span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Nat</span></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="ot">=</span> <span class="dv">9</span></span>
<span id="cb3-11"><a href="#cb3-11"></a></span>
<span id="cb3-12"><a href="#cb3-12"></a>λ <span class="op">:</span>kind<span class="op">!</span> <span class="dt">Div</span> <span class="dv">10</span> <span class="dv">2</span></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="dt">Div</span> <span class="dv">10</span> <span class="dv">2</span><span class="ot"> ::</span> <span class="dt">Nat</span></span>
<span id="cb3-14"><a href="#cb3-14"></a><span class="ot">=</span> <span class="dv">5</span></span>
<span id="cb3-15"><a href="#cb3-15"></a></span>
<span id="cb3-16"><a href="#cb3-16"></a>λ <span class="op">:</span>kind<span class="op">!</span> <span class="dv">10</span> <span class="op">*</span> <span class="dv">10</span></span>
<span id="cb3-17"><a href="#cb3-17"></a><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">1</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></span>
<span id="cb3-18"><a href="#cb3-18"></a>    • <span class="dt">Expected</span> kind ‘<span class="op">*</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> k0’, but ‘10’ has kind ‘<span class="dt">Nat</span>’</span>
<span id="cb3-19"><a href="#cb3-19"></a>    • <span class="dt">In</span> the <span class="kw">type</span> ‘<span class="dv">10</span> <span class="op">*</span> 10’</span></code></pre></div>
<p>掛け算だけエラーになりましたね・・・。それぞれの演算子のカインドを確認してみましょう。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a>λ <span class="op">:</span>k (<span class="op">+</span>)</span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="ot">(+) ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>λ <span class="op">:</span>k (<span class="op">-</span>)</span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="ot">(-) ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>λ <span class="op">:</span>k <span class="dt">Mod</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="dt">Mod</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>λ <span class="op">:</span>k (<span class="op">*</span>)</span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="ot">(*) ::</span> <span class="op">*</span></span></code></pre></div>
<p>1つだけ変ですね。これは <code>*</code> が <strong>Bool</strong> や <strong>Maybe</strong> などのよくある基本的な型 (lifted boxed types) のカインドの記号として割り当てられているためです。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a>λ <span class="op">:</span>k <span class="dt">Bool</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="dt">Bool</span><span class="ot"> ::</span> <span class="op">*</span></span>
<span id="cb5-3"><a href="#cb5-3"></a></span>
<span id="cb5-4"><a href="#cb5-4"></a>λ <span class="op">:</span>k <span class="dt">Maybe</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="dt">Maybe</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></span></code></pre></div>
<p>1つ前の <a href="https://gitlab.haskell.org/ghc/ghc/wikis/migration/8.6">GHC 8.6</a> から <strong>StarIsType</strong> 言語拡張がデフォルトで有効になり、<code>*</code> カインドは <code>Type</code> カインドのシノニムとして定義されるようになりました。なので明示的に <strong>StarIsType</strong> を無効にすると直ります。(この辺りの話題については既に <a href="https://www.reddit.com/r/haskell_jp/comments/8t8p4j/typeoperators_nostaristype%E3%81%AE%E5%BB%B6%E6%9C%9F%E3%81%AE%E6%8F%90%E6%A1%88/">“TypeOperators =&gt; NoStarIsType”の延期の提案</a> などにまとまっているため、気になる方はご参照ください)</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a>λ <span class="op">:</span>set <span class="op">-</span><span class="dt">XNoStarIsType</span></span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a>λ <span class="op">:</span>k <span class="dt">Bool</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="dt">Bool</span><span class="ot"> ::</span> <span class="dt">Type</span></span>
<span id="cb6-5"><a href="#cb6-5"></a></span>
<span id="cb6-6"><a href="#cb6-6"></a>λ <span class="op">:</span>k <span class="dt">Maybe</span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="dt">Maybe</span><span class="ot"> ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb6-8"><a href="#cb6-8"></a></span>
<span id="cb6-9"><a href="#cb6-9"></a>λ <span class="op">:</span>k (<span class="op">*</span>)</span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="ot">(*) ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></span></code></pre></div>
<p>ということでこれで無事に型レベルの掛け算ができるようになりました。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a>λ <span class="op">:</span>kind<span class="op">!</span> <span class="dv">10</span> <span class="op">*</span> <span class="dv">10</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="dv">10</span> <span class="op">*</span> <span class="dv">10</span><span class="ot"> ::</span> <span class="dt">Nat</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="ot">=</span> <span class="dv">100</span></span></code></pre></div>
<h2 id="まとめ">まとめ</h2>
<p><code>kind!</code> のエイリアスとして <code>k!</code> コマンド欲しい。</p>
<h2 id="追記">追記</h2>
<p><code>k!</code> コマンドのマージリクエストが作られました <a href="https://gitlab.haskell.org/ghc/ghc/merge_requests/1934">Allow completion for GHCi commands with option <code>!</code> (#17345)</a></p>
<p>ありがとうございます :)</p>
<p>GHC に組み込まれるまでは、<code>~/.ghci</code> や <code>&lt;proj&gt;/.ghci</code> に以下の内容を記述しておけば <code>:kind!</code> のエイリアスとして <code>:k!</code> が使えるようになります。</p>
<pre><code>:def! k! (\e -&gt; return (&quot;:kind! &quot; ++ e))</code></pre>
<p>実行結果</p>
<pre><code>&gt; :k! 1+1
1+1 :: Nat
= 2</code></pre>
<h2 id="参考リソース">参考リソース</h2>
<ul>
<li><a href="https://downloads.haskell.org/~ghc/8.8.1/docs/html/users_guide/glasgow_exts.html?highlight=nostaristype#extension-StarIsType">StarIsType - Glasgow Haskell Compiler User’s Guide</a></li>
<li><a href="https://gitlab.haskell.org/ghc/ghc/wikis/migration/8.6">GHC 8.6.x Migration Guide</a></li>
<li><a href="https://www.reddit.com/r/haskell_jp/comments/8t8p4j/typeoperators_nostaristype%E3%81%AE%E5%BB%B6%E6%9C%9F%E3%81%AE%E6%8F%90%E6%A1%88/">“TypeOperators =&gt; NoStarIsType”の延期の提案</a></li>
</ul>]]></summary>
</entry>
<entry>
    <title>AST を拡張しよう</title>
    <link href="https://haskell.e-bigmoon.com/posts/2019/09-09-extensible-ast.html" />
    <id>https://haskell.e-bigmoon.com/posts/2019/09-09-extensible-ast.html</id>
    <published>2019-09-09T00:00:00Z</published>
    <updated>2019-09-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>実験的な内容です。(<span class="citation" data-cites="fumievalさん">@fumievalさん</span>, <span class="citation" data-cites="matsubara0507さん">@matsubara0507さん</span>、アドバイスありがとうございました)</p>
<!--more-->
<h2 id="モチベーション">モチベーション</h2>
<p>まずは、以下のような型 <code>Expr</code> と関数 <code>pretty</code> が定義されているとします。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>  <span class="ot">=</span> <span class="dt">Constant</span> <span class="dt">Int</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>  <span class="op">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb1-5"><a href="#cb1-5"></a></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="ot">pretty ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>pretty (<span class="dt">Constant</span> i) <span class="ot">=</span> <span class="fu">show</span> i</span>
<span id="cb1-8"><a href="#cb1-8"></a>pretty (<span class="dt">Add</span> e1 e2) <span class="ot">=</span> pretty e1 <span class="op">&lt;&gt;</span> <span class="st">&quot; + &quot;</span> <span class="op">&lt;&gt;</span> pretty e2</span></code></pre></div>
<p>今回、この <code>Expr</code> をベースとして新しい型 <code>ExprM</code>, <code>ExprS</code> をそれぞれ定義したい場合、どのように書けば良いのでしょうか？</p>
<p>素朴に定義するとなると、以下のようになりそうです。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">data</span> <span class="dt">ExprM</span></span>
<span id="cb2-2"><a href="#cb2-2"></a>  <span class="ot">=</span> <span class="dt">Constant</span> <span class="dt">Int</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>  <span class="op">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>  <span class="op">|</span> <span class="dt">Mul</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb2-6"><a href="#cb2-6"></a></span>
<span id="cb2-7"><a href="#cb2-7"></a><span class="ot">pretty ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>pretty (<span class="dt">Constant</span> i) <span class="ot">=</span> <span class="fu">show</span> i</span>
<span id="cb2-9"><a href="#cb2-9"></a>pretty (<span class="dt">Add</span> e1 e2) <span class="ot">=</span> pretty e1 <span class="op">&lt;&gt;</span> <span class="st">&quot; + &quot;</span> <span class="op">&lt;&gt;</span> pretty e2</span>
<span id="cb2-10"><a href="#cb2-10"></a>pretty (<span class="dt">Mul</span> e1 e2) <span class="ot">=</span> pretty e1 <span class="op">&lt;&gt;</span> <span class="st">&quot; * &quot;</span> <span class="op">&lt;&gt;</span> pretty e2</span></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">data</span> <span class="dt">ExprS</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>  <span class="ot">=</span> <span class="dt">Constant</span> <span class="dt">Int</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>  <span class="op">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>  <span class="op">|</span> <span class="dt">Sub</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb3-6"><a href="#cb3-6"></a></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="ot">pretty ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>pretty (<span class="dt">Constant</span> i) <span class="ot">=</span> <span class="fu">show</span> i</span>
<span id="cb3-9"><a href="#cb3-9"></a>pretty (<span class="dt">Add</span> e1 e2) <span class="ot">=</span> pretty e1 <span class="op">&lt;&gt;</span> <span class="st">&quot; + &quot;</span> <span class="op">&lt;&gt;</span> pretty e2</span>
<span id="cb3-10"><a href="#cb3-10"></a>pretty (<span class="dt">Sub</span> e1 e2) <span class="ot">=</span> pretty e1 <span class="op">&lt;&gt;</span> <span class="st">&quot; - &quot;</span> <span class="op">&lt;&gt;</span> pretty e2</span></code></pre></div>
<p>しかし、同じようなコードが含まれていて冗長なので何とかしたいです・・・。</p>
<h2 id="方針">方針</h2>
<ul>
<li>各コンストラクタ <code>Constant</code>, <code>Add</code> 等を <code>extensible</code> のフィールドとして定義</li>
<li><code>Expr</code>, <code>ExprS</code>, <code>ExprM</code> は、それぞれのフィールドを集めて作った拡張可能和として定義</li>
<li>スマートコンストラクタは再利用できるようにしたい</li>
</ul>
<h2 id="実装">実装</h2>
<ol type="1">
<li>コンストラクタの定義</li>
<li>型の定義</li>
<li>スマートコンストラクタの定義</li>
<li>pretty 関数の定義</li>
<li>新しい型を定義</li>
</ol>
<h3 id="コンストラクタの定義">コンストラクタの定義</h3>
<p>まずはそれぞれのフィールドを定義しましょう。それぞれの型は <code>Assoc Symbol Type</code> のカインドを持ちます。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="co">-- Field/Constant.hs</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="ot">{-# LANGUAGE DataKinds     #-}</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb4-4"><a href="#cb4-4"></a></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="kw">import</span> <span class="dt">Data.Extensible</span></span>
<span id="cb4-6"><a href="#cb4-6"></a><span class="kw">type</span> <span class="dt">Constant</span> <span class="ot">=</span> <span class="st">&quot;constant&quot;</span> <span class="op">&gt;:</span> <span class="dt">Int</span></span></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="co">-- Field/Add.hs</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="ot">{-# LANGUAGE DataKinds     #-}</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb5-4"><a href="#cb5-4"></a></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="kw">import</span> <span class="dt">Data.Extensible</span></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="kw">type</span> <span class="dt">Add</span> expr <span class="ot">=</span> <span class="st">&quot;add&quot;</span> <span class="op">&gt;:</span> (expr, expr)</span></code></pre></div>
<p>これらのフィールドは以下のような型のコンストラクタを1つずつ切り出したような感じです。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>  <span class="ot">=</span> <span class="dt">Constant</span> <span class="dt">Int</span></span>
<span id="cb6-3"><a href="#cb6-3"></a>  <span class="op">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span></code></pre></div>
<h3 id="型の定義">型の定義</h3>
<p>フィールドの定義は完了したので、次にそれらのフィールドを集めて型にしましょう。</p>
<p>拡張性を得るために型クラスを定義します。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="co">-- Expr.hs</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="ot">{-# LANGUAGE DataKinds    #-}</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="kw">module</span> <span class="dt">Base</span> <span class="kw">where</span></span>
<span id="cb7-5"><a href="#cb7-5"></a></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="kw">import</span> <span class="dt">Data.Extensible</span></span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="kw">import</span> <span class="dt">Data.Kind</span></span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="kw">import</span> <span class="dt">GHC.TypeLits</span></span>
<span id="cb7-9"><a href="#cb7-9"></a></span>
<span id="cb7-10"><a href="#cb7-10"></a><span class="kw">class</span> <span class="dt">Expr</span> expr <span class="kw">where</span></span>
<span id="cb7-11"><a href="#cb7-11"></a>  <span class="kw">type</span> <span class="dt">FieldList</span><span class="ot"> expr ::</span> [<span class="dt">Assoc</span> <span class="dt">Symbol</span> <span class="dt">Type</span>]</span>
<span id="cb7-12"><a href="#cb7-12"></a><span class="ot">  liftExpr ::</span> <span class="dt">Variant</span> (<span class="dt">FieldList</span> expr) <span class="ot">-&gt;</span> expr</span></code></pre></div>
<p><code>FieldList expr</code> によって型に応じてフィールドが変化します。</p>
<p>実際に <code>Expr</code> 型を定義してみましょう。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="co">-- Expr/Base.hs</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="ot">{-# LANGUAGE DataKinds    #-}</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="kw">module</span> <span class="dt">Expr.Base</span> <span class="kw">where</span></span>
<span id="cb8-5"><a href="#cb8-5"></a></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="kw">import</span> <span class="dt">Expr</span></span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="kw">import</span> <span class="dt">Field.Add</span></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="kw">import</span> <span class="dt">Field.Constant</span></span>
<span id="cb8-9"><a href="#cb8-9"></a></span>
<span id="cb8-10"><a href="#cb8-10"></a><span class="kw">import</span> <span class="dt">Data.Extensible</span></span>
<span id="cb8-11"><a href="#cb8-11"></a></span>
<span id="cb8-12"><a href="#cb8-12"></a><span class="kw">newtype</span> <span class="dt">ExprB</span> <span class="ot">=</span> <span class="dt">ExprB</span></span>
<span id="cb8-13"><a href="#cb8-13"></a>  {<span class="ot"> unwrapExprB ::</span> <span class="dt">Variant</span> <span class="dt">ExprBFields</span></span>
<span id="cb8-14"><a href="#cb8-14"></a>  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb8-15"><a href="#cb8-15"></a></span>
<span id="cb8-16"><a href="#cb8-16"></a><span class="kw">type</span> <span class="dt">ExprBFields</span> <span class="ot">=</span> &#39;[ <span class="dt">Constant</span>, <span class="dt">Add</span> <span class="dt">ExprB</span> ]</span>
<span id="cb8-17"><a href="#cb8-17"></a></span>
<span id="cb8-18"><a href="#cb8-18"></a><span class="kw">instance</span> <span class="dt">Expr</span> <span class="dt">ExprB</span> <span class="kw">where</span></span>
<span id="cb8-19"><a href="#cb8-19"></a>  <span class="kw">type</span> <span class="dt">FieldList</span> <span class="dt">ExprB</span> <span class="ot">=</span> <span class="dt">ExprBFields</span></span>
<span id="cb8-20"><a href="#cb8-20"></a>  liftExpr <span class="ot">=</span> <span class="dt">ExprB</span></span></code></pre></div>
<ul>
<li><code>type ExprBFields</code> は型に含まれるフィールドを表します。</li>
<li>再帰的に定義するために <code>newtype ExprB</code> を宣言しています。</li>
<li><code>Variant ExprBFields</code> によって <code>Constant</code>, <code>Add ExprB</code> の直和型っぽい感じになります。</li>
</ul>
<p><code>liftExpr</code> は再利用可能なスマートコンストラクタを作るためにあります。次で説明します。</p>
<h3 id="スマートコンストラクタの定義">スマートコンストラクタの定義</h3>
<p>ここまでで型の定義は終わりました。次は値を作りましょう。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="co">-- Field/Add.hs</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="ot">{-# LANGUAGE DataKinds        #-}</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="ot">{-# LANGUAGE OverloadedLabels #-}</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="ot">{-# LANGUAGE TypeFamilies     #-}</span></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="ot">{-# LANGUAGE TypeOperators    #-}</span></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="kw">module</span> <span class="dt">Field.Add</span> <span class="kw">where</span></span>
<span id="cb9-7"><a href="#cb9-7"></a></span>
<span id="cb9-8"><a href="#cb9-8"></a><span class="kw">import</span> <span class="dt">Expr</span></span>
<span id="cb9-9"><a href="#cb9-9"></a></span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="kw">import</span> <span class="dt">Control.Lens</span> ((#))</span>
<span id="cb9-11"><a href="#cb9-11"></a><span class="kw">import</span> <span class="dt">Data.Extensible</span></span>
<span id="cb9-12"><a href="#cb9-12"></a></span>
<span id="cb9-13"><a href="#cb9-13"></a><span class="kw">type</span> <span class="dt">Add</span> expr <span class="ot">=</span> <span class="st">&quot;add&quot;</span> <span class="op">&gt;:</span> (expr, expr)</span>
<span id="cb9-14"><a href="#cb9-14"></a></span>
<span id="cb9-15"><a href="#cb9-15"></a>add e1 e2 <span class="ot">=</span> liftExpr (<span class="op">#</span>add <span class="op">#</span> (e1, e2))</span></code></pre></div>
<p><code>liftExpr</code> は文脈に応じて適切なタグに変化します。例えば <code>ExprB</code> 型であれば <code>ExprB</code> コンストラクタになります。</p>
<p>同様に <code>Constant</code> の値を作る関数も定義しましょう。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="ot">{-# LANGUAGE DataKinds        #-}</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="ot">{-# LANGUAGE OverloadedLabels #-}</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="ot">{-# LANGUAGE TypeFamilies     #-}</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="ot">{-# LANGUAGE TypeOperators    #-}</span></span>
<span id="cb10-5"><a href="#cb10-5"></a><span class="kw">module</span> <span class="dt">Field.Constant</span> <span class="kw">where</span></span>
<span id="cb10-6"><a href="#cb10-6"></a></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="kw">import</span> <span class="dt">Expr</span></span>
<span id="cb10-8"><a href="#cb10-8"></a></span>
<span id="cb10-9"><a href="#cb10-9"></a><span class="kw">import</span> <span class="dt">Control.Lens</span> ((#))</span>
<span id="cb10-10"><a href="#cb10-10"></a><span class="kw">import</span> <span class="dt">Data.Extensible</span></span>
<span id="cb10-11"><a href="#cb10-11"></a></span>
<span id="cb10-12"><a href="#cb10-12"></a><span class="kw">type</span> <span class="dt">Constant</span> <span class="ot">=</span> <span class="st">&quot;constant&quot;</span> <span class="op">&gt;:</span> <span class="dt">Int</span></span>
<span id="cb10-13"><a href="#cb10-13"></a></span>
<span id="cb10-14"><a href="#cb10-14"></a>c i <span class="ot">=</span> liftExpr (<span class="op">#</span>constant <span class="op">#</span> i)</span></code></pre></div>
<p>実際に使ってみるとこんな感じです。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="op">&gt;</span> add (c <span class="dv">10</span>) (c <span class="dv">20</span>)<span class="ot"> ::</span> <span class="dt">ExprB</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="dt">ExprB</span> {unwrapExprB <span class="ot">=</span> <span class="dt">EmbedAt</span> <span class="op">$</span>(mkMembership <span class="dv">1</span>) (add <span class="op">@=</span> (<span class="dt">ExprB</span> {unwrapExprB <span class="ot">=</span> <span class="dt">EmbedAt</span> <span class="op">$</span>(mkMembership <span class="dv">0</span>) (constant <span class="op">@=</span> <span class="dv">10</span>)},<span class="dt">ExprB</span> {unwrapExprB <span class="ot">=</span> <span class="dt">EmbedAt</span> <span class="op">$</span>(mkMembership <span class="dv">0</span>) (constant <span class="op">@=</span> <span class="dv">20</span>)}))}</span></code></pre></div>
<p>extensible の形式で表示されていますが、問題無く値が作れています。型注釈が無い場合はコンパイルエラーになってしまいますが、ここでは気にしないことにします。</p>
<h3 id="pretty-関数の定義">pretty 関数の定義</h3>
<p>値が作れるようになったら、次は <code>pretty</code> 関数を作ります。</p>
<p>ここが一番面白いポイントだと思っているのですが、<code>pretty</code> のような関数を各フィールドに対して動作する型クラスのメソッドとして定義します。</p>
<p>まずは、パターンマッチのための補助関数 <code>matchVariant</code> を定義します。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="co">-- Expr.hs</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="ot">{-# LANGUAGE ConstraintKinds     #-}</span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="ot">{-# LANGUAGE DataKinds           #-}</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="ot">{-# LANGUAGE PolyKinds           #-}</span></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="ot">{-# LANGUAGE RankNTypes          #-}</span></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb12-7"><a href="#cb12-7"></a><span class="ot">{-# LANGUAGE TypeApplications    #-}</span></span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="ot">{-# LANGUAGE TypeFamilies        #-}</span></span>
<span id="cb12-9"><a href="#cb12-9"></a><span class="op">...</span></span>
<span id="cb12-10"><a href="#cb12-10"></a></span>
<span id="cb12-11"><a href="#cb12-11"></a><span class="kw">import</span> <span class="dt">Data.Functor.Identity</span></span>
<span id="cb12-12"><a href="#cb12-12"></a></span>
<span id="cb12-13"><a href="#cb12-13"></a><span class="op">...</span></span>
<span id="cb12-14"><a href="#cb12-14"></a></span>
<span id="cb12-15"><a href="#cb12-15"></a><span class="ot">matchVariant ::</span> <span class="kw">forall</span> c xs r<span class="op">.</span> <span class="dt">Forall</span> c xs</span>
<span id="cb12-16"><a href="#cb12-16"></a>  <span class="ot">=&gt;</span> <span class="dt">Proxy</span> c <span class="ot">-&gt;</span> (<span class="kw">forall</span> x<span class="op">.</span> c x <span class="ot">=&gt;</span> <span class="dt">Membership</span> xs x <span class="ot">-&gt;</span> <span class="dt">TargetOf</span> x <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">Variant</span> xs <span class="ot">-&gt;</span> r</span>
<span id="cb12-17"><a href="#cb12-17"></a>matchVariant _ f <span class="ot">=</span> matchField <span class="op">$</span> htabulateFor (<span class="dt">Proxy</span> <span class="op">@</span>c) <span class="op">$</span> \m <span class="ot">-&gt;</span> <span class="dt">Field</span> <span class="op">$</span> <span class="dt">Match</span> <span class="op">$</span> f m <span class="op">.</span> runIdentity</span></code></pre></div>
<p>次に <code>pretty</code> 関数を定義するための型クラスを作ります。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="ot">{-# LANGUAGE PolyKinds        #-}</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="kw">module</span> <span class="dt">Operation.Pretty</span> <span class="kw">where</span></span>
<span id="cb13-5"><a href="#cb13-5"></a></span>
<span id="cb13-6"><a href="#cb13-6"></a><span class="kw">import</span> <span class="dt">Expr</span></span>
<span id="cb13-7"><a href="#cb13-7"></a></span>
<span id="cb13-8"><a href="#cb13-8"></a><span class="kw">import</span> <span class="dt">Data.Extensible</span></span>
<span id="cb13-9"><a href="#cb13-9"></a></span>
<span id="cb13-10"><a href="#cb13-10"></a><span class="ot">pretty&#39; ::</span> <span class="dt">Forall</span> <span class="dt">PrettyField</span> xs <span class="ot">=&gt;</span> <span class="dt">Variant</span> xs <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb13-11"><a href="#cb13-11"></a>pretty&#39; <span class="ot">=</span> matchVariant (<span class="dt">Proxy</span> <span class="op">@</span><span class="dt">PrettyField</span>) prettyField</span>
<span id="cb13-12"><a href="#cb13-12"></a></span>
<span id="cb13-13"><a href="#cb13-13"></a><span class="kw">class</span> <span class="dt">Expr</span> expr <span class="ot">=&gt;</span> <span class="dt">Pretty</span> expr <span class="kw">where</span></span>
<span id="cb13-14"><a href="#cb13-14"></a><span class="ot">  pretty ::</span> expr <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb13-15"><a href="#cb13-15"></a></span>
<span id="cb13-16"><a href="#cb13-16"></a><span class="kw">class</span> <span class="dt">PrettyField</span> kv <span class="kw">where</span></span>
<span id="cb13-17"><a href="#cb13-17"></a><span class="ot">  prettyField ::</span> proxy kv <span class="ot">-&gt;</span> <span class="dt">TargetOf</span> kv <span class="ot">-&gt;</span> <span class="dt">String</span></span></code></pre></div>
<p>実際にインスタンスを定義します。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a><span class="co">-- Field/Add.hs</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="op">...</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="op">...</span></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="kw">import</span> <span class="dt">Operation.Pretty</span></span>
<span id="cb14-6"><a href="#cb14-6"></a><span class="op">...</span></span>
<span id="cb14-7"><a href="#cb14-7"></a></span>
<span id="cb14-8"><a href="#cb14-8"></a><span class="kw">instance</span> <span class="dt">Pretty</span> expr <span class="ot">=&gt;</span> <span class="dt">PrettyField</span> (<span class="dt">Add</span> expr) <span class="kw">where</span></span>
<span id="cb14-9"><a href="#cb14-9"></a>  prettyField _ (l, r) <span class="ot">=</span> pretty l <span class="op">&lt;&gt;</span> <span class="st">&quot; + &quot;</span> <span class="op">&lt;&gt;</span> pretty r</span></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a><span class="co">-- Field/Constant.hs</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="op">...</span></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="op">...</span></span>
<span id="cb15-5"><a href="#cb15-5"></a><span class="kw">import</span> <span class="dt">Operation.Pretty</span></span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="op">...</span></span>
<span id="cb15-7"><a href="#cb15-7"></a></span>
<span id="cb15-8"><a href="#cb15-8"></a><span class="kw">instance</span> <span class="dt">PrettyField</span> <span class="dt">Constant</span> <span class="kw">where</span></span>
<span id="cb15-9"><a href="#cb15-9"></a>  prettyField _ <span class="ot">=</span> <span class="fu">show</span></span></code></pre></div>
<p><code>ExprB</code> に対する定義はボイラープレートのようなものです。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a><span class="co">-- Expr/Base.hs</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="op">...</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="kw">import</span> <span class="dt">Operation.Pretty</span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="op">...</span></span>
<span id="cb16-5"><a href="#cb16-5"></a></span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="kw">instance</span> <span class="dt">Pretty</span> <span class="dt">ExprB</span> <span class="kw">where</span></span>
<span id="cb16-7"><a href="#cb16-7"></a>  pretty <span class="ot">=</span> pretty&#39; <span class="op">.</span> unwrapExprB</span></code></pre></div>
<p>実際に使ってみます。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a><span class="op">&gt;</span> e1 <span class="ot">=</span> add (c <span class="dv">10</span>) (c <span class="dv">20</span>)<span class="ot"> ::</span> <span class="dt">ExprB</span></span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="op">&gt;</span> pretty e1</span>
<span id="cb17-3"><a href="#cb17-3"></a><span class="st">&quot;10 + 20&quot;</span></span></code></pre></div>
<p>期待通り、ちゃんと動いています。</p>
<h3 id="新しい型を定義">新しい型を定義</h3>
<p>最後に既存の型を拡張して <code>ExprM</code> を作ります。</p>
<p>まずは <code>Mul</code> フィールドの <code>pretty</code> とコンストラクタの定義を追加しましょう。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1"></a><span class="co">-- Field/Mul.hs</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="ot">{-# LANGUAGE DataKinds         #-}</span></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb18-4"><a href="#cb18-4"></a><span class="ot">{-# LANGUAGE OverloadedLabels  #-}</span></span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="ot">{-# LANGUAGE TypeFamilies      #-}</span></span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="ot">{-# LANGUAGE TypeOperators     #-}</span></span>
<span id="cb18-7"><a href="#cb18-7"></a><span class="kw">module</span> <span class="dt">Field.Mul</span> <span class="kw">where</span></span>
<span id="cb18-8"><a href="#cb18-8"></a></span>
<span id="cb18-9"><a href="#cb18-9"></a><span class="kw">import</span> <span class="dt">Expr</span></span>
<span id="cb18-10"><a href="#cb18-10"></a><span class="kw">import</span> <span class="dt">Operation.Pretty</span></span>
<span id="cb18-11"><a href="#cb18-11"></a></span>
<span id="cb18-12"><a href="#cb18-12"></a><span class="kw">import</span> <span class="dt">Control.Lens</span> ((#))</span>
<span id="cb18-13"><a href="#cb18-13"></a><span class="kw">import</span> <span class="dt">Data.Extensible</span></span>
<span id="cb18-14"><a href="#cb18-14"></a></span>
<span id="cb18-15"><a href="#cb18-15"></a><span class="kw">type</span> <span class="dt">Mul</span> expr <span class="ot">=</span> <span class="st">&quot;mul&quot;</span> <span class="op">&gt;:</span> (expr, expr)</span>
<span id="cb18-16"><a href="#cb18-16"></a></span>
<span id="cb18-17"><a href="#cb18-17"></a><span class="kw">instance</span> <span class="dt">Pretty</span> expr <span class="ot">=&gt;</span> <span class="dt">PrettyField</span> (<span class="dt">Mul</span> expr) <span class="kw">where</span></span>
<span id="cb18-18"><a href="#cb18-18"></a>  prettyField _ (l, r) <span class="ot">=</span> pretty l <span class="op">&lt;&gt;</span> <span class="st">&quot; * &quot;</span> <span class="op">&lt;&gt;</span> pretty r</span>
<span id="cb18-19"><a href="#cb18-19"></a></span>
<span id="cb18-20"><a href="#cb18-20"></a>mul e1 e2 <span class="ot">=</span> liftExpr (<span class="op">#</span>mul <span class="op">#</span> (e1, e2))</span></code></pre></div>
<p>次に <code>ExprM</code> 型を定義します。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1"></a><span class="co">-- Expr/Mul.hs</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="ot">{-# LANGUAGE DataKinds    #-}</span></span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="kw">module</span> <span class="dt">Expr.Mul</span> <span class="kw">where</span></span>
<span id="cb19-5"><a href="#cb19-5"></a></span>
<span id="cb19-6"><a href="#cb19-6"></a><span class="kw">import</span> <span class="dt">Expr</span></span>
<span id="cb19-7"><a href="#cb19-7"></a><span class="kw">import</span> <span class="dt">Expr.Base</span></span>
<span id="cb19-8"><a href="#cb19-8"></a><span class="kw">import</span> <span class="dt">Field.Add</span></span>
<span id="cb19-9"><a href="#cb19-9"></a><span class="kw">import</span> <span class="dt">Field.Mul</span></span>
<span id="cb19-10"><a href="#cb19-10"></a><span class="kw">import</span> <span class="dt">Field.Constant</span></span>
<span id="cb19-11"><a href="#cb19-11"></a><span class="kw">import</span> <span class="dt">Operation.Pretty</span></span>
<span id="cb19-12"><a href="#cb19-12"></a></span>
<span id="cb19-13"><a href="#cb19-13"></a><span class="kw">import</span> <span class="dt">Data.Extensible</span></span>
<span id="cb19-14"><a href="#cb19-14"></a></span>
<span id="cb19-15"><a href="#cb19-15"></a><span class="kw">newtype</span> <span class="dt">ExprM</span> <span class="ot">=</span> <span class="dt">ExprM</span></span>
<span id="cb19-16"><a href="#cb19-16"></a>  {<span class="ot"> unwrapExprM ::</span> <span class="dt">Variant</span> <span class="dt">ExprMFields</span></span>
<span id="cb19-17"><a href="#cb19-17"></a>  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb19-18"><a href="#cb19-18"></a></span>
<span id="cb19-19"><a href="#cb19-19"></a><span class="kw">type</span> <span class="dt">ExprMFields</span> <span class="ot">=</span> &#39;[ <span class="dt">Constant</span>, <span class="dt">Add</span> <span class="dt">ExprM</span>, <span class="dt">Mul</span> <span class="dt">ExprM</span> ]</span>
<span id="cb19-20"><a href="#cb19-20"></a></span>
<span id="cb19-21"><a href="#cb19-21"></a><span class="kw">instance</span> <span class="dt">Expr</span> <span class="dt">ExprM</span> <span class="kw">where</span></span>
<span id="cb19-22"><a href="#cb19-22"></a>  <span class="kw">type</span> <span class="dt">FieldList</span> <span class="dt">ExprM</span> <span class="ot">=</span> <span class="dt">ExprMFields</span></span>
<span id="cb19-23"><a href="#cb19-23"></a>  liftExpr <span class="ot">=</span> <span class="dt">ExprM</span></span>
<span id="cb19-24"><a href="#cb19-24"></a></span>
<span id="cb19-25"><a href="#cb19-25"></a><span class="kw">instance</span> <span class="dt">Pretty</span> <span class="dt">ExprM</span> <span class="kw">where</span></span>
<span id="cb19-26"><a href="#cb19-26"></a>  pretty <span class="ot">=</span> pretty&#39; <span class="op">.</span> unwrapExprM</span></code></pre></div>
<p>ほとんど同じですが、<code>type ExprMFields</code> の部分で <code>Mul ExprM</code> を追加しています。(<code>ExprB</code> のフィールドに単純に追加する方法も一応可能です。)</p>
<p>実際に使ってみると、ちゃんと異なる型と認識してコンパイルエラーになってくれます。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1"></a><span class="op">&gt;</span> e1 <span class="ot">=</span> add (c <span class="dv">10</span>) (c <span class="dv">20</span>)<span class="ot"> ::</span> <span class="dt">ExprB</span></span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="op">&gt;</span> e2 <span class="ot">=</span> add (c <span class="dv">40</span>) (c <span class="dv">50</span>)<span class="ot"> ::</span> <span class="dt">ExprM</span></span>
<span id="cb20-3"><a href="#cb20-3"></a></span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="op">&gt;</span> add e1 e2</span>
<span id="cb20-5"><a href="#cb20-5"></a><span class="co">-- 型が異なるためコンパイルエラー</span></span>
<span id="cb20-6"><a href="#cb20-6"></a></span>
<span id="cb20-7"><a href="#cb20-7"></a><span class="op">&gt;</span> pretty e1</span>
<span id="cb20-8"><a href="#cb20-8"></a><span class="st">&quot;10 + 20&quot;</span></span>
<span id="cb20-9"><a href="#cb20-9"></a><span class="op">&gt;</span> pretty e2</span>
<span id="cb20-10"><a href="#cb20-10"></a><span class="st">&quot;40 + 50&quot;</span></span>
<span id="cb20-11"><a href="#cb20-11"></a></span>
<span id="cb20-12"><a href="#cb20-12"></a><span class="op">&gt;</span> e3 <span class="ot">=</span> mul (c <span class="dv">60</span>) (c <span class="dv">70</span>)<span class="ot"> ::</span> <span class="dt">ExprB</span></span>
<span id="cb20-13"><a href="#cb20-13"></a><span class="co">-- ExprB 型には Mul フィールドが存在していないため、コンパイルエラー</span></span>
<span id="cb20-14"><a href="#cb20-14"></a></span>
<span id="cb20-15"><a href="#cb20-15"></a><span class="op">&gt;</span> e3 <span class="ot">=</span> mul (c <span class="dv">60</span>) (c <span class="dv">70</span>)<span class="ot"> ::</span> <span class="dt">ExprM</span></span>
<span id="cb20-16"><a href="#cb20-16"></a><span class="op">&gt;</span> pretty e3</span>
<span id="cb20-17"><a href="#cb20-17"></a><span class="st">&quot;60 * 70&quot;</span></span></code></pre></div>
<h2 id="おまけ">おまけ</h2>
<h3 id="既存のフィールドを拡張する">既存のフィールドを拡張する</h3>
<p><code>UndecidableInstances</code> 拡張を使っても良ければ、以下のように <code>ExprBFields ++ '[ Mul ExprM ]</code> と書くこともできます。</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1"></a><span class="ot">{-# LANGUAGE DataKinds    #-}</span></span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb21-4"><a href="#cb21-4"></a><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></span>
<span id="cb21-5"><a href="#cb21-5"></a><span class="kw">module</span> <span class="dt">Expr.Mul</span> <span class="kw">where</span></span>
<span id="cb21-6"><a href="#cb21-6"></a></span>
<span id="cb21-7"><a href="#cb21-7"></a><span class="kw">import</span> <span class="dt">Expr</span></span>
<span id="cb21-8"><a href="#cb21-8"></a><span class="kw">import</span> <span class="dt">Expr.Base</span></span>
<span id="cb21-9"><a href="#cb21-9"></a><span class="kw">import</span> <span class="dt">Field.Mul</span></span>
<span id="cb21-10"><a href="#cb21-10"></a><span class="kw">import</span> <span class="dt">Operation.Pretty</span></span>
<span id="cb21-11"><a href="#cb21-11"></a></span>
<span id="cb21-12"><a href="#cb21-12"></a><span class="kw">import</span> <span class="dt">Data.Extensible</span></span>
<span id="cb21-13"><a href="#cb21-13"></a></span>
<span id="cb21-14"><a href="#cb21-14"></a><span class="kw">newtype</span> <span class="dt">ExprM</span> <span class="ot">=</span> <span class="dt">ExprM</span></span>
<span id="cb21-15"><a href="#cb21-15"></a>  {<span class="ot"> unwrapExprM ::</span> <span class="dt">Variant</span> <span class="dt">ExprMFields</span></span>
<span id="cb21-16"><a href="#cb21-16"></a>  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb21-17"><a href="#cb21-17"></a></span>
<span id="cb21-18"><a href="#cb21-18"></a><span class="kw">type</span> <span class="dt">ExprMFields</span> <span class="ot">=</span> <span class="dt">ExprBFields</span> <span class="op">++</span> &#39;[ <span class="dt">Mul</span> <span class="dt">ExprM</span> ]</span>
<span id="cb21-19"><a href="#cb21-19"></a><span class="co">-- type ExprMFields = &#39;[ Constant, Add ExprM, Mul ExprM ]</span></span>
<span id="cb21-20"><a href="#cb21-20"></a></span>
<span id="cb21-21"><a href="#cb21-21"></a><span class="kw">instance</span> <span class="dt">Expr</span> <span class="dt">ExprM</span> <span class="kw">where</span></span>
<span id="cb21-22"><a href="#cb21-22"></a>  <span class="kw">type</span> <span class="dt">FieldList</span> <span class="dt">ExprM</span> <span class="ot">=</span> <span class="dt">ExprMFields</span></span>
<span id="cb21-23"><a href="#cb21-23"></a>  liftExpr <span class="ot">=</span> <span class="dt">ExprM</span></span>
<span id="cb21-24"><a href="#cb21-24"></a></span>
<span id="cb21-25"><a href="#cb21-25"></a><span class="kw">instance</span> <span class="dt">Pretty</span> <span class="dt">ExprM</span> <span class="kw">where</span></span>
<span id="cb21-26"><a href="#cb21-26"></a>  pretty <span class="ot">=</span> pretty&#39; <span class="op">.</span> unwrapExprM</span></code></pre></div>
<h3 id="操作を追加しよう">操作を追加しよう</h3>
<p><code>eval</code> を追加してみましょう。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1"></a><span class="co">-- Operation/Eval.hs</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></span>
<span id="cb22-3"><a href="#cb22-3"></a><span class="ot">{-# LANGUAGE PolyKinds        #-}</span></span>
<span id="cb22-4"><a href="#cb22-4"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb22-5"><a href="#cb22-5"></a><span class="kw">module</span> <span class="dt">Operation.Eval</span> <span class="kw">where</span></span>
<span id="cb22-6"><a href="#cb22-6"></a></span>
<span id="cb22-7"><a href="#cb22-7"></a><span class="kw">import</span> <span class="dt">Expr</span></span>
<span id="cb22-8"><a href="#cb22-8"></a></span>
<span id="cb22-9"><a href="#cb22-9"></a><span class="kw">import</span> <span class="dt">Data.Extensible</span></span>
<span id="cb22-10"><a href="#cb22-10"></a></span>
<span id="cb22-11"><a href="#cb22-11"></a><span class="ot">eval&#39; ::</span> <span class="dt">Forall</span> <span class="dt">EvalField</span> xs <span class="ot">=&gt;</span> <span class="dt">Variant</span> xs <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb22-12"><a href="#cb22-12"></a>eval&#39; <span class="ot">=</span> matchVariant (<span class="dt">Proxy</span> <span class="op">@</span><span class="dt">EvalField</span>) evalField</span>
<span id="cb22-13"><a href="#cb22-13"></a></span>
<span id="cb22-14"><a href="#cb22-14"></a><span class="kw">class</span> <span class="dt">Eval</span> expr <span class="kw">where</span></span>
<span id="cb22-15"><a href="#cb22-15"></a><span class="ot">  eval ::</span> expr <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb22-16"><a href="#cb22-16"></a></span>
<span id="cb22-17"><a href="#cb22-17"></a><span class="kw">class</span> <span class="dt">EvalField</span> kv <span class="kw">where</span></span>
<span id="cb22-18"><a href="#cb22-18"></a><span class="ot">  evalField ::</span> proxy kv <span class="ot">-&gt;</span> <span class="dt">TargetOf</span> kv <span class="ot">-&gt;</span> <span class="dt">Int</span></span></code></pre></div>
<p>さらに、インスタンス定義もこのファイルに定義します。</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1"></a><span class="co">-- Operation/Eval.hs</span></span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="op">...</span></span>
<span id="cb23-3"><a href="#cb23-3"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb23-4"><a href="#cb23-4"></a><span class="op">...</span></span>
<span id="cb23-5"><a href="#cb23-5"></a></span>
<span id="cb23-6"><a href="#cb23-6"></a><span class="kw">import</span> <span class="dt">Expr.Base</span></span>
<span id="cb23-7"><a href="#cb23-7"></a><span class="kw">import</span> <span class="dt">Expr.Mul</span></span>
<span id="cb23-8"><a href="#cb23-8"></a><span class="kw">import</span> <span class="dt">Field.Add</span></span>
<span id="cb23-9"><a href="#cb23-9"></a><span class="kw">import</span> <span class="dt">Field.Constant</span></span>
<span id="cb23-10"><a href="#cb23-10"></a><span class="kw">import</span> <span class="dt">Field.Mul</span></span>
<span id="cb23-11"><a href="#cb23-11"></a></span>
<span id="cb23-12"><a href="#cb23-12"></a><span class="op">...</span></span>
<span id="cb23-13"><a href="#cb23-13"></a></span>
<span id="cb23-14"><a href="#cb23-14"></a><span class="kw">instance</span> <span class="dt">Eval</span> <span class="dt">ExprB</span> <span class="kw">where</span></span>
<span id="cb23-15"><a href="#cb23-15"></a>  eval <span class="ot">=</span> eval&#39; <span class="op">.</span> unwrapExprB</span>
<span id="cb23-16"><a href="#cb23-16"></a></span>
<span id="cb23-17"><a href="#cb23-17"></a><span class="kw">instance</span> <span class="dt">Eval</span> <span class="dt">ExprM</span> <span class="kw">where</span></span>
<span id="cb23-18"><a href="#cb23-18"></a>  eval <span class="ot">=</span> eval&#39; <span class="op">.</span> unwrapExprM</span>
<span id="cb23-19"><a href="#cb23-19"></a></span>
<span id="cb23-20"><a href="#cb23-20"></a><span class="op">...</span></span>
<span id="cb23-21"><a href="#cb23-21"></a></span>
<span id="cb23-22"><a href="#cb23-22"></a><span class="kw">instance</span> <span class="dt">EvalField</span> <span class="dt">Constant</span> <span class="kw">where</span></span>
<span id="cb23-23"><a href="#cb23-23"></a>  evalField _ <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb23-24"><a href="#cb23-24"></a></span>
<span id="cb23-25"><a href="#cb23-25"></a><span class="kw">instance</span> <span class="dt">Eval</span> expr <span class="ot">=&gt;</span> <span class="dt">EvalField</span> (<span class="dt">Add</span> expr) <span class="kw">where</span></span>
<span id="cb23-26"><a href="#cb23-26"></a>  evalField _ (l, r) <span class="ot">=</span> eval l <span class="op">+</span> eval r</span>
<span id="cb23-27"><a href="#cb23-27"></a></span>
<span id="cb23-28"><a href="#cb23-28"></a><span class="kw">instance</span> <span class="dt">Eval</span> expr <span class="ot">=&gt;</span> <span class="dt">EvalField</span> (<span class="dt">Mul</span> expr) <span class="kw">where</span></span>
<span id="cb23-29"><a href="#cb23-29"></a>  evalField _ (l, r) <span class="ot">=</span> eval l <span class="op">*</span> eval r</span></code></pre></div>
<p>これで使えるようになりました。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1"></a><span class="op">&gt;</span> e1 <span class="ot">=</span> add (c <span class="dv">10</span>) (c <span class="dv">20</span>)<span class="ot"> ::</span> <span class="dt">ExprB</span></span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="op">&gt;</span> e2 <span class="ot">=</span> mul (c <span class="dv">40</span>) (c <span class="dv">50</span>)<span class="ot"> ::</span> <span class="dt">ExprM</span></span>
<span id="cb24-3"><a href="#cb24-3"></a></span>
<span id="cb24-4"><a href="#cb24-4"></a><span class="op">&gt;</span> eval e1</span>
<span id="cb24-5"><a href="#cb24-5"></a><span class="dv">30</span></span>
<span id="cb24-6"><a href="#cb24-6"></a><span class="op">&gt;</span> eval e2</span>
<span id="cb24-7"><a href="#cb24-7"></a><span class="dv">2000</span></span></code></pre></div>
<h2 id="まとめ">まとめ</h2>
<p>何かに使えないかなー。</p>]]></summary>
</entry>
<entry>
    <title>let, where, let...in の使い分け</title>
    <link href="https://haskell.e-bigmoon.com/posts/2019/08-24-let-where-letin.html" />
    <id>https://haskell.e-bigmoon.com/posts/2019/08-24-let-where-letin.html</id>
    <published>2019-08-24T00:00:00Z</published>
    <updated>2019-08-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>アルバイトの学生に良く質問される内容の1つに「<code>let</code>, <code>where</code>, <code>let...in</code> はどういう風に使い分ければ良いですか？」というものがあります。ちょっと前に <strong>twitter</strong> でも同じような話題を見かけたので、少しまとめてみました。</p>
<p>また、様々な Haskell 書籍で同様の内容について触れられていますが、明確な指針は無く個人の好みという感じがします。</p>
<!--more-->
<h2 id="let-を使うタイミング-do-の中">let を使うタイミング (do の中)</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="co">-- let version</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="ot">f ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>f <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>  x <span class="ot">&lt;-</span> <span class="fu">return</span> <span class="dv">1</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>  <span class="kw">let</span> y <span class="ot">=</span> x <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb1-6"><a href="#cb1-6"></a>      z <span class="ot">=</span> <span class="dv">2</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>  <span class="fu">return</span> (y<span class="op">+</span>z)</span></code></pre></div>
<ul>
<li>上記のコードのように <code>do</code> の中で束縛された変数 <code>x</code> を使って新しい変数 <code>y</code> を宣言する時に良く使います</li>
<li>他の変数に依存していない <code>z</code> はどの書き方でも書けますが、通常は <code>let</code> で続けて書くことが多いと思います</li>
<li><code>let</code> は <code>do</code> (またはリスト内包表記) 以外では使えません</li>
<li>内部的には <code>do { let decls; stmts } = let decls in do { stmts }</code> という変換が行われます。(リスト内包表記は <code>[ e | let decls, Q ] = let decls in [ e | Q ]</code> という変換です。)</li>
</ul>
<h3 id="where-で書いた場合">where で書いた場合</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">-- where version</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="ot">f ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>f <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>  x <span class="ot">&lt;-</span> <span class="fu">return</span> <span class="dv">1</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>  <span class="fu">return</span> ((x<span class="op">+</span><span class="dv">1</span>)<span class="op">+</span>z)</span>
<span id="cb2-6"><a href="#cb2-6"></a>  <span class="kw">where</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>    z <span class="ot">=</span> <span class="dv">2</span></span></code></pre></div>
<ul>
<li><code>where</code> を使って <code>x</code> を宣言することはできません。(<code>do</code> を脱糖した形を見ると、できない感じが伝わりやすいかもしれません)</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">-- do を使わない形</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>f <span class="ot">=</span> <span class="fu">return</span> <span class="dv">1</span> <span class="op">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> <span class="fu">return</span> ((x<span class="op">+</span><span class="dv">1</span>)<span class="op">+</span>z))</span>
<span id="cb3-3"><a href="#cb3-3"></a>  <span class="kw">where</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>    z <span class="ot">=</span> <span class="dv">2</span></span></code></pre></div>
<ul>
<li>何百行も続く巨大な <code>do</code> だと <code>where</code> で宣言されている変数までの距離が遠いため、可読性が落ちます。<code>z</code> を <code>where</code> で書くか <code>let</code> で書くかはケースバイケースかもしれません</li>
</ul>
<h3 id="letin-で書いた場合">let…in で書いた場合</h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="co">-- let...in version</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="ot">f ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>f <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>  x <span class="ot">&lt;-</span> <span class="fu">return</span> <span class="dv">1</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>  <span class="kw">let</span> y <span class="ot">=</span> x <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>      z <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>    <span class="kw">in</span> <span class="fu">return</span> (y<span class="op">+</span>z)</span></code></pre></div>
<ul>
<li><code>let...in</code> を使うとインデントに気配りする必要があるので面倒です
<ul>
<li>例えば <code>let</code> と <code>in</code> の先頭を合わせるとコンパイルエラーになります</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="co">-- let...in version (compile error)</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="ot">f ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>f <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>  x <span class="ot">&lt;-</span> <span class="fu">return</span> <span class="dv">1</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>  <span class="kw">let</span> y <span class="ot">=</span> x <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>      z <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>  <span class="kw">in</span> <span class="fu">return</span> (y<span class="op">+</span>z)</span></code></pre></div>
<h2 id="where-を使うタイミング-ガード">where を使うタイミング (ガード)</h2>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">calcBmi ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>calcBmi cm kg</span>
<span id="cb6-3"><a href="#cb6-3"></a>  <span class="op">|</span> bmi <span class="op">&lt;=</span> <span class="fl">18.5</span> <span class="ot">=</span> <span class="st">&quot;痩せてるね&quot;</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>  <span class="op">|</span> bmi <span class="op">&lt;=</span> <span class="fl">25.0</span> <span class="ot">=</span> <span class="st">&quot;普通だね&quot;</span></span>
<span id="cb6-5"><a href="#cb6-5"></a>  <span class="op">|</span> bmi <span class="op">&lt;=</span> <span class="fl">30.0</span> <span class="ot">=</span> <span class="st">&quot;ぽっちゃりだね&quot;</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="st">&quot;太っているね&quot;</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>  <span class="kw">where</span></span>
<span id="cb6-8"><a href="#cb6-8"></a>    bmi <span class="ot">=</span> kg <span class="op">/</span> (m<span class="op">^</span><span class="dv">2</span>)</span>
<span id="cb6-9"><a href="#cb6-9"></a>    m <span class="ot">=</span> cm <span class="op">/</span> <span class="dv">100</span></span>
<span id="cb6-10"><a href="#cb6-10"></a></span>
<span id="cb6-11"><a href="#cb6-11"></a><span class="co">-- *Main&gt; putStrLn $ calcBmi 170 60</span></span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="co">-- 普通だね</span></span></code></pre></div>
<ul>
<li>このように、ガードで共通する変数を宣言する場合に <code>where</code> を使うと見通しが良くなります。</li>
<li><code>do</code> の中ではないため、当然 <code>let</code> は使えません</li>
</ul>
<h3 id="letin-で書いた場合-1">let…in で書いた場合</h3>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="ot">{-# LANGUAGE MultiWayIf #-}</span></span>
<span id="cb7-2"><a href="#cb7-2"></a></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="ot">calcBmi ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>calcBmi cm kg <span class="ot">=</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>  <span class="kw">let</span> m   <span class="ot">=</span> cm <span class="op">/</span> <span class="dv">100</span></span>
<span id="cb7-6"><a href="#cb7-6"></a>      bmi <span class="ot">=</span> kg <span class="op">/</span> (m<span class="op">^</span><span class="dv">2</span>)</span>
<span id="cb7-7"><a href="#cb7-7"></a>  <span class="kw">in</span> <span class="kw">if</span> <span class="op">|</span> bmi <span class="op">&lt;=</span> <span class="fl">18.5</span> <span class="ot">-&gt;</span> <span class="st">&quot;痩せてるね&quot;</span></span>
<span id="cb7-8"><a href="#cb7-8"></a>        <span class="op">|</span> bmi <span class="op">&lt;=</span> <span class="fl">25.0</span> <span class="ot">-&gt;</span> <span class="st">&quot;普通だね&quot;</span></span>
<span id="cb7-9"><a href="#cb7-9"></a>        <span class="op">|</span> bmi <span class="op">&lt;=</span> <span class="fl">30.0</span> <span class="ot">-&gt;</span> <span class="st">&quot;ぽっちゃりだね&quot;</span></span>
<span id="cb7-10"><a href="#cb7-10"></a>        <span class="op">|</span> <span class="fu">otherwise</span>   <span class="ot">-&gt;</span> <span class="st">&quot;太っているね&quot;</span></span></code></pre></div>
<ul>
<li>もし <code>let...in</code> を使って同じように書く場合は、上記のように <code>MultiWayIf</code> を使うことになるでしょう。</li>
</ul>
<h2 id="letin-を使うタイミング">let…in を使うタイミング</h2>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="co">-- Programming in Haskell 2nd Edition より引用</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="kw">type</span> <span class="dt">State</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="kw">newtype</span> <span class="dt">ST</span> a <span class="ot">=</span> <span class="dt">S</span> (<span class="dt">State</span> <span class="ot">-&gt;</span> (a, <span class="dt">State</span>))</span>
<span id="cb8-4"><a href="#cb8-4"></a></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="ot">app ::</span> <span class="dt">ST</span> a <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> (a, <span class="dt">State</span>)</span>
<span id="cb8-6"><a href="#cb8-6"></a>app (<span class="dt">S</span> st) x <span class="ot">=</span> st x</span>
<span id="cb8-7"><a href="#cb8-7"></a></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">ST</span> <span class="kw">where</span></span>
<span id="cb8-9"><a href="#cb8-9"></a>  <span class="co">-- fmap :: (a -&gt; b) -&gt; ST a -&gt; ST b</span></span>
<span id="cb8-10"><a href="#cb8-10"></a>  <span class="fu">fmap</span> g st <span class="ot">=</span> <span class="dt">S</span> (\s <span class="ot">-&gt;</span> <span class="kw">let</span> (x,s&#39;) <span class="ot">=</span> app st s <span class="kw">in</span> (g x, s&#39;))</span></code></pre></div>
<ul>
<li>こんな感じの関数を書くときにはとても便利です</li>
<li>ただ、このようなケースというのはあまり遭遇しないので、個人的には使わないようにしています。無くてもほぼ困らないです
<ul>
<li>理由1: レイアウトルールを気にしなければならない点がとても面倒なので</li>
<li>理由2: ポイントフリースタイルで書くのが好きなので</li>
</ul></li>
</ul>
<h3 id="where-で書いた場合-1">where で書いた場合</h3>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="co">-- Programming in Haskell 2nd Edition より引用</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="kw">type</span> <span class="dt">State</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="kw">newtype</span> <span class="dt">ST</span> a <span class="ot">=</span> <span class="dt">S</span> (<span class="dt">State</span> <span class="ot">-&gt;</span> (a, <span class="dt">State</span>))</span>
<span id="cb9-4"><a href="#cb9-4"></a></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="ot">app ::</span> <span class="dt">ST</span> a <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> (a, <span class="dt">State</span>)</span>
<span id="cb9-6"><a href="#cb9-6"></a>app (<span class="dt">S</span> st) x <span class="ot">=</span> st x</span>
<span id="cb9-7"><a href="#cb9-7"></a></span>
<span id="cb9-8"><a href="#cb9-8"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">ST</span> <span class="kw">where</span></span>
<span id="cb9-9"><a href="#cb9-9"></a>  <span class="co">-- fmap :: (a -&gt; b) -&gt; ST a -&gt; ST b</span></span>
<span id="cb9-10"><a href="#cb9-10"></a>  <span class="fu">fmap</span> g <span class="ot">=</span> <span class="dt">S</span> <span class="op">.</span> f g</span>
<span id="cb9-11"><a href="#cb9-11"></a></span>
<span id="cb9-12"><a href="#cb9-12"></a><span class="ot">f ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">ST</span> a <span class="ot">-&gt;</span> <span class="dt">State</span> <span class="ot">-&gt;</span> (b, <span class="dt">State</span>)</span>
<span id="cb9-13"><a href="#cb9-13"></a>f g st s <span class="ot">=</span> (g x, s&#39;)</span>
<span id="cb9-14"><a href="#cb9-14"></a>  <span class="kw">where</span></span>
<span id="cb9-15"><a href="#cb9-15"></a>    (x,s&#39;) <span class="ot">=</span> app st s</span>
<span id="cb9-16"><a href="#cb9-16"></a></span>
<span id="cb9-17"><a href="#cb9-17"></a><span class="co">-- もしくは</span></span>
<span id="cb9-18"><a href="#cb9-18"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">ST</span> <span class="kw">where</span></span>
<span id="cb9-19"><a href="#cb9-19"></a>  <span class="co">-- fmap :: (a -&gt; b) -&gt; ST a -&gt; ST b</span></span>
<span id="cb9-20"><a href="#cb9-20"></a>  <span class="fu">fmap</span> g st <span class="ot">=</span> <span class="dt">S</span> f</span>
<span id="cb9-21"><a href="#cb9-21"></a>    <span class="kw">where</span></span>
<span id="cb9-22"><a href="#cb9-22"></a>      f s <span class="ot">=</span> (g x, s&#39;)</span>
<span id="cb9-23"><a href="#cb9-23"></a>        <span class="kw">where</span></span>
<span id="cb9-24"><a href="#cb9-24"></a>          (x,s&#39;) <span class="ot">=</span> app st s</span></code></pre></div>
<ul>
<li><code>let...in</code> で書いたときよりも可読性が落ちてしまったように思います</li>
</ul>
<h2 id="where-と-letin-の違い">where と let…in の違い</h2>
<p><code>let...in</code> と <code>where</code> の明確な違いは <code>let...in</code> が式なのに対して <code>where</code> が節だという点です。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="co">-- OK</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>f <span class="ot">=</span> <span class="kw">if</span> <span class="kw">let</span> x <span class="ot">=</span> <span class="dt">True</span> <span class="kw">in</span> x <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></span>
<span id="cb10-3"><a href="#cb10-3"></a></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="co">-- NG</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>g <span class="ot">=</span> <span class="kw">if</span> (x <span class="kw">where</span> x <span class="ot">=</span> <span class="dt">True</span>) <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></span></code></pre></div>
<p>構文上のどこに式が出現できるかという規則については <code>Language Report</code> に詳しく記載されています。</p>
<h2 id="まとめ">まとめ</h2>
<p>このように、<code>let</code>, <code>where</code>, <code>let...in</code> はどちらでも書けることが多いので、適材適所で自分の感性を信じて使いこなすと良いのではないかと思います。</p>
<p>そういえばラムダノートさんから<a href="https://www.lambdanote.com/collections/haskell">プログラミングHaskellの第2版</a>が発売されましたね。書籍の内容が個人的にとても好きなので、弊社のアルバイトの人には推薦図書として英語版を読んでもらっていました。</p>
<p>これからは日本語で読めるようになったので、これを機に Haskell に入門してみるのも良いかもしれません。</p>
<h2 id="参考リソース">参考リソース</h2>
<ul>
<li><a href="https://www.haskell.org/onlinereport/haskell2010/">Haskell 2010 Language Report</a></li>
<li>すごいHaskellたのしく学ぼう！</li>
<li>Programming in Haskell 2nd Edition</li>
</ul>
<h2 id="宣伝">宣伝</h2>
<p><a href="https://techbookfest.org/event/tbf07">技術書典7</a>に初参加します。</p>
<p><img src="/images/2019/08-19/circle.png" alt ="サークルカット" width="400px"></p>
<p>進捗・詳細については <a href="/ad/techbookfest7.html">技術書典7特設ページ</a> をご確認ください。</p>]]></summary>
</entry>
<entry>
    <title>extensible-0.6.1 マイグレーションガイド</title>
    <link href="https://haskell.e-bigmoon.com/posts/2019/08-19-extensible-migration.html" />
    <id>https://haskell.e-bigmoon.com/posts/2019/08-19-extensible-migration.html</id>
    <published>2019-08-19T00:00:00Z</published>
    <updated>2019-08-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p><a href="https://hackage.haskell.org/package/extensible">extensible</a> のバージョンを最新の <strong>0.6.1</strong> に更新した際にいくつかコードの修正が必要になったので、メモ程度に残しておきます。</p>
<p>今回の記事では一部の変更点にしか触れないため、完全な変更点については <a href="https://github.com/fumieval/extensible/blob/master/CHANGELOG.md">CHANGELOG</a> を参照してください。</p>
<!--more-->
<h3 id="section">0.5</h3>
<ul>
<li><a href="https://hackage.haskell.org/package/extensible-0.4.10.1/docs/Data-Extensible-Wrapper.html#t:Const-39-">Const’</a> が削除されました。</li>
</ul>
<p>今後は <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Control-Applicative.html#t:Const">Control.Applicative.Const</a> を利用しましょう。</p>
<h3 id="section-1">0.5.1</h3>
<ul>
<li><a href="https://hackage.haskell.org/package/membership">membership</a> パッケージが依存関係に追加されました。(<code>Data.Extensible.HList</code> と <code>Data.Extensible.Internal</code> が membership パッケージに移動した形です)</li>
</ul>
<hr />
<ul>
<li><code>AssocKey</code>, <code>AssocValue</code>, <code>ValueIs</code>, <code>KeyValue</code> が廃止予定になりました。</li>
</ul>
<p>今後はそれぞれ以下の型を利用しましょう。</p>
<table>
<thead>
<tr class="header">
<th>0.5.1 より前</th>
<th>0.5.1 以降</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://hackage.haskell.org/package/extensible-0.5.1/docs/Data-Extensible-Field.html#t:AssocKey">AssocKey</a></td>
<td><a href="https://hackage.haskell.org/package/extensible-0.5.1/docs/Data-Extensible-Field.html#t:KeyOf">KeyOf</a></td>
</tr>
<tr class="even">
<td><a href="https://hackage.haskell.org/package/extensible-0.5.1/docs/Data-Extensible-Field.html#t:AssocValue">AssocValue</a></td>
<td><a href="https://hackage.haskell.org/package/extensible-0.5.1/docs/Data-Extensible-Field.html#t:TargetOf">TargetOf</a></td>
</tr>
<tr class="odd">
<td><a href="https://hackage.haskell.org/package/extensible-0.5.1/docs/Data-Extensible-Field.html#t:ValueIs">ValueIs</a></td>
<td><a href="https://hackage.haskell.org/package/extensible-0.5.1/docs/Data-Extensible-Field.html#t:TargetIs">TargetIs</a></td>
</tr>
<tr class="even">
<td><a href="https://hackage.haskell.org/package/extensible-0.5.1/docs/Data-Extensible-Field.html#t:KeyValue">KeyValue</a></td>
<td><a href="https://hackage.haskell.org/package/extensible-0.5.1/docs/Data-Extensible-Field.html#t:KeyTargetAre">KeyTargetAre</a></td>
</tr>
</tbody>
</table>
<hr />
<ul>
<li><code>proxyAssocKey</code>, <code>stringAssocKey</code>, <code>proxyAssocValue</code> も同様に廃止予定になりました。</li>
</ul>
<p>今後はそれぞれ以下の関数を利用しましょう。</p>
<table>
<thead>
<tr class="header">
<th>0.5.1 より前</th>
<th>0.5.1 以降</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://hackage.haskell.org/package/extensible-0.5.1/docs/Data-Extensible-Field.html#v:proxyAssocKey">proxyAssocKey</a></td>
<td><a href="https://hackage.haskell.org/package/extensible-0.5.1/docs/Data-Extensible-Field.html#v:proxyKeyOf">proxyKeyOf</a></td>
</tr>
<tr class="even">
<td><a href="https://hackage.haskell.org/package/extensible-0.5.1/docs/Data-Extensible-Field.html#v:stringAssocKey">stringAssocKey</a></td>
<td><a href="https://hackage.haskell.org/package/extensible-0.5.1/docs/Data-Extensible-Field.html#v:stringKeyOf">stringKeyOf</a></td>
</tr>
<tr class="odd">
<td><a href="https://hackage.haskell.org/package/extensible-0.5.1/docs/Data-Extensible-Field.html#v:proxyAssocValue">proxyAssocValue</a></td>
<td><a href="https://hackage.haskell.org/package/extensible-0.5.1/docs/Data-Extensible-Field.html#v:proxyTargetOf">proxyTargetOf</a></td>
</tr>
</tbody>
</table>
<hr />
<ul>
<li><a href="https://hackage.haskell.org/package/extensible-0.5.1/docs/Data-Extensible-Class.html#t:Associate">Associate</a> が廃止予定になりました。</li>
</ul>
<p>今後は <a href="https://hackage.haskell.org/package/extensible-0.5.1/docs/Data-Extensible-Class.html#t:Lookup">Lookup</a> を利用しましょう。</p>
<p>引数の順番が変わる点に注意してください。そのままではコンパイルエラーになります。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">type</span> <span class="dt">Associate</span> k v xs <span class="ot">=</span> <span class="dt">Lookup</span> xs k v</span></code></pre></div>
<h3 id="section-2">0.6</h3>
<ul>
<li><code>(:*)</code> と <code>(:|)</code> がそれぞれ廃止予定になりました。</li>
</ul>
<p>今後はそれぞれ以下の関数を利用しましょう。その際、引数の順番が逆になっているので注意してください。</p>
<table>
<thead>
<tr class="header">
<th>0.6 より前</th>
<th>0.6 以降</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://hackage.haskell.org/package/extensible-0.6/docs/Data-Extensible-Struct.html#t::-42-">(:*)</a></td>
<td><a href="https://hackage.haskell.org/package/extensible-0.6/docs/Data-Extensible-Struct.html#t::-38-">(:&amp;)</a></td>
</tr>
<tr class="even">
<td><a href="https://hackage.haskell.org/package/extensible-0.6/docs/Data-Extensible-Sum.html#t::-124-">(:|)</a></td>
<td><a href="https://hackage.haskell.org/package/extensible-0.6/docs/Data-Extensible-Sum.html#t::-47-">(:/)</a></td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">type</span> (<span class="op">:*</span>) h xs <span class="ot">=</span> xs <span class="op">:&amp;</span> h</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="kw">type</span> (<span class="op">:|</span>) h xs <span class="ot">=</span> xs <span class="op">:/</span> h</span></code></pre></div>
<hr />
<ul>
<li><a href="https://hackage.haskell.org/package/extensible-0.6/docs/Data-Extensible-Tangle.html#t:TangleT">TangleT</a> の引数の順番が入れ替わりました。</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">-- 0.6 より前の定義</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="kw">newtype</span> <span class="dt">TangleT</span> h xs m a</span>
<span id="cb3-3"><a href="#cb3-3"></a></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="co">-- 0.6 以降の定義</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="kw">newtype</span> <span class="dt">TangleT</span> xs h m a</span></code></pre></div>
<h3 id="section-3">0.6.1</h3>
<ul>
<li><code>0.5.1</code> で廃止予定となっていた <code>deriveIsRecord</code> が削除されました。</li>
</ul>
<p>今後は <code>Generics</code> のインスタンスであれば導出可能です。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="co">-- 0.6.1 より前</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>deriveIsRecord &#39;<span class="dt">&#39;Foo</span></span>
<span id="cb4-3"><a href="#cb4-3"></a></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="co">-- 0.6.1 以降の定義 (Foo が Generics のインスタンスであればOK)</span></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="kw">instance</span> <span class="dt">IsRecord</span> <span class="dt">Foo</span></span></code></pre></div>
<h2 id="終わりに">終わりに</h2>
<p><code>extensible-0.6.1</code> に一気に更新しましたが、特にハマることも無くスムーズに更新が完了しました。</p>
<p>いくつか新しい関数などが追加されているので、その辺りも要チェックですね。</p>
<h2 id="宣伝">宣伝</h2>
<p><a href="https://techbookfest.org/event/tbf07">技術書典7</a>に初参加します。</p>
<p><img src="/images/2019/08-19/circle.png" alt ="サークルカット" width="400px"></p>
<p>サークルカットは<a href="https://ja.wikipedia.org/wiki/%E3%82%A2%E3%83%AB%E3%83%95%E3%82%A9%E3%83%B3%E3%82%B9%E3%83%BB%E3%83%9F%E3%83%A5%E3%82%B7%E3%83%A3">アルフォンス・ミュシャ</a>っぽい感じを意識しています。ミュシャ風のポスターは至る所で目にしますが、ミュシャの最高傑作は「スラヴ叙事詩」なので興味のある人は是非調べてみてください。</p>
<hr />
<p>現時点で Haskell 本を「2冊」販売予定です。(値段や配布数については未定です)</p>
<h3 id="すごいhaskell自分で作ろう-write-your-haskell-for-great-good">(1) すごいHaskell自分で作ろう！ Write Your Haskell for Great Good!</h3>
<p><img src="/images/2019/08-19/main.jpg" alt ="表紙" width="400px"></p>
<p>【著者】 <span class="citation" data-cites="gotoki_no_joe">@gotoki_no_joe</span></p>
<p>【概要】 Haskell でプログラミングするのは楽しい。ところで「Haskell<em>を</em>プログラミングする」のも楽しいのでは？じゃあやってみよう。というわけで、Haskell からヒラヒラを全て削り落して削りすぎたような関数型言語を作ります。</p>
<p>構文を設計し、意味を定義し、それらに従ってインタプリタを <strong>Haskell</strong> と <strong>TypeScript</strong> で実装します。</p>
<p>Haskell といいつつ普通でわかりやすい<strong>正格評価な処理系</strong>から始めて、その後で<strong>遅延評価をする処理系</strong>に取り組みます。必要になった部分だけを計算する遅延評価の仕組みが、組み込み演算やパターンマッチと協調する様子を自作して理解します。</p>
<p>おまけに TypeScript によるパーサコンビネータの作り方が付いています。</p>
<p>ごめんなさい！Haskell らしさの重要な柱である型システムについて執筆が間に合いませんでした。インデント構文、JavaScript を出力するコンパイラとともに、後編での執筆を予定しています。</p>
<p>【目次 (仮)】</p>
<p>クリックすると <code>pdf</code> が開きます。</p>
<p><a href="/images/2019/08-19/toc1.pdf"> <img src="/images/2019/08-19/toc1.png" alt ="目次1" width="400px"> </a> <a href="/images/2019/08-19/toc2.pdf"> <img src="/images/2019/08-19/toc2.png" alt ="目次2" width="400px"> </a></p>
<h3 id="ghc-api-入門-仮">(2) GHC API 入門 (仮)</h3>
<p>【著者】 <span class="citation" data-cites="waddlaw">@waddlaw</span></p>
<p>【概要】 GHC API を使って具体的に動く何かを作る予定ですが、全然筆が進んでいないので内容未定・・・。(上記の書籍と比べると宣伝できるものが何も・・・)</p>
<p>頑張ります！</p>
<h3 id="おすすめポイント">おすすめポイント</h3>
<p>Haskell の処理系を作ってみたいなーって思っている人は「すごいHaskell自分で作ろう！ Write Your Haskell for Great Good!」がおすすめです！！！</p>
<p><code>TypeScript</code> と <code>Haskell</code> という異なるパラダイムの言語による実装が一冊に収まっているので、とてもお得ですね。</p>
<p>応援よろしくお願いします〜。</p>]]></summary>
</entry>
<entry>
    <title>Megaparsec tutorial from IH book</title>
    <link href="https://haskell.e-bigmoon.com/posts/2019/07-14-megaparsec-tutorial.html" />
    <id>https://haskell.e-bigmoon.com/posts/2019/07-14-megaparsec-tutorial.html</id>
    <published>2019-07-14T00:00:00Z</published>
    <updated>2019-07-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Great original post: <a href="https://markkarpov.com/megaparsec/megaparsec.html">Megaparsec tutorial from IH book</a></p>
<p>この Megaparsec のチュートリアルは、元々は <a href="https://intermediatehaskell.com/">Intermediate Haskell</a> という本の１つの章のために書かれました。 ここ一年で本が進展していないため、 他の著者は私がスタンドアロンのチュートリアルとしてテキストを公表し、 人々が少なくとも私たちの仕事のこの部分から恩恵を受けることができるようにする ことに同意しました。</p>
<!--more-->
<ul>
<li><a href="#ParsecT"><code>ParsecT</code> と <code>Parsec</code> モナド</a></li>
<li><a href="#Character">文字 とバイナリストリーム</a></li>
<li><a href="#MonaAp">モナディック構文とアプリカティブ構文</a></li>
<li><a href="#Eof"><code>Eof</code> による入力の強制消費</a></li>
<li><a href="#Alt">選択肢を使った動作</a></li>
<li><a href="#Try"><code>try</code> によるバックトラックの制御</a></li>
<li><a href="#Debug">パーサのデバッグ</a></li>
<li><a href="#Label">ラベル付けと隠蔽</a></li>
<li><a href="#Run">パーサの実行</a></li>
<li><a href="#MonadParsec"><code>MonadParsec</code> 型クラス</a></li>
<li><a href="#Lexing">字句解析</a>
<ul>
<li><a href="#White">空白</a></li>
<li><a href="#Char">文字と文字列リテラル</a></li>
<li><a href="#Numbers">数字</a></li>
</ul></li>
<li><a href="#lookAhead"><code>notFollowedBy</code> と <code>lookAhead</code></a></li>
<li><a href="#Expr">式のパース</a></li>
<li><a href="#Indentation">Indentation-sensitiveなパース</a>
<ul>
<li><a href="#nonIndented"><code>nonIndented</code> と <code>indentBlock</code></a></li>
<li><a href="#SimpleIndented">単純なインデントされたリスト</a></li>
<li><a href="#NestedIndented">ネストされたインデントのあるリスト</a></li>
<li><a href="#LineFolds">折り返しの追加</a></li>
</ul></li>
<li><a href="#Efficient">効率のよいパーサを書く</a></li>
<li><a href="#Error">パースエラー</a>
<ul>
<li><a href="#ErrDef">パースエラーの定義</a></li>
<li><a href="#SigErr">パースエラーを通知する方法</a></li>
<li><a href="#DispErr">パースエラーの表示</a></li>
<li><a href="#CatchErr">パーサ実行時にパースエラーをキャッチする</a></li>
</ul></li>
<li><a href="#Testing">Megaparsecパーサのテスト</a></li>
<li><a href="#CustomInput">カスタム入力ストリームの操作</a></li>
</ul>
<p>「例：あなた自身のパーサコンビネータを書く」の章で開発されたトイパーサコンビネータは、実際の使用には適していないので、 同じ問題を解決するHaskellエコシステムのライブラリを見ていきましょう。 そして、それらがなすさまざまなトレードオフに注意してください。</p>
<ul>
<li><p><a href="https://hackage.haskell.org/package/parsec">parsec</a> は長い間 Haskellの「デフォルト」のパーサライブラリでした。このライブラリは、エラーメッセージの品質に焦点を当てていると言われています。ただし、テストカバレッジは良くなく、現在メンテナンスモードになっています。</p></li>
<li><p><a href="https://hackage.haskell.org/package/attoparsec">attoparsec</a> は、パフォーマンスを重視した堅牢で高速なパーサライブラリです。このリストの中で、インクリメンタルパージングを完全にサポートしているのはこれだけです。欠点はエラーメッセージの質が悪いこと、モナド変換子として使用できないこと、および入力ストリームとして使用できる型の組み合わせが限られていることです。</p></li>
<li><p><a href="https://hackage.haskell.org/package/trifecta">trifecta</a> は優れたエラーメッセージを特徴としていますが、あまり文書化されておらず、理解するのが難しいです。 <code>String</code> と <code>ByteString</code> はそのままではパースできますが、<code>Text</code> はパースできません。</p></li>
<li><p><a href="https://hackage.haskell.org/package/megaparsec">megaparsec</a> は、ここ数年で積極的に開発されてきた <code>parsec</code> のフォークです。現在のバージョンは、速度、エラーメッセージの品質、そして柔軟性の間で素晴らしいバランスを取っています。 <code>parsec</code> の非公式の後継者として、<code>parsec</code> ライブラリを使用したことがあるか、チュートリアルを読んだことがあるユーザにとっては慣習的でなじみのあるものです。</p></li>
</ul>
<p>これらすべてのライブラリを網羅しようとするのは実用的ではないため、 <code>megaparsec</code> に焦点を当てます。より正確には、この本が出版される時までにはほとんどどこでも古いバージョンに取って代わるであろうバージョン7をカバーするつもりです。</p>
<p><a name="ParsecT"></a></p>
<h2 id="parsect-と-parsec-モナド">ParsecT と Parsec モナド</h2>
<p><code>ParsecT</code>は、主要なパーサモナド変換子であり、<code>megaparsec</code> の中心的なデータ型です。 <code>ParsecT e s m a</code> は、次のようにパラメータ化されています。</p>
<ul>
<li><p><code>e</code> はエラーメッセージのカスタムコンポーネントの型です。もし私たちが何もカスタムを望まないのであれば（そして今のところ私たちはしません）、 <code>Data.Void</code> モジュールの <code>Void</code> を使うだけです。</p></li>
<li><p><code>s</code> は入力ストリームの型です。 <code>megaparsec</code> は、<code>String</code>、正格または遅延 <code>Text</code> 、 正格または遅延 <code>ByteStrings</code> をそのまま使用して動作します。カスタム入力ストリームを扱うことも可能です。</p></li>
<li><p><code>m</code> は <code>ParsecT</code> モナド変換子の内部モナドです。</p></li>
<li><p><code>a</code> はパース結果であるモナディック値です。</p></li>
</ul>
<p>ほとんどの場合、<code>m</code> は <code>Identity</code> に他ならないので、<code>Parsec</code> 型シノニムは非常に便利です。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">type</span> <span class="dt">Parsec</span> e s a <span class="ot">=</span> <span class="dt">ParsecT</span> e s <span class="dt">Identity</span> a</span></code></pre></div>
<p><code>Parsec</code> は、単なる <code>ParsecT</code>の変換子を使わないバージョンです。</p>
<p><code>megaparsec</code> のモナド変換子と MTL のモナド変換子およびクラスの間の類似点を示すこともできます。 確かに、<code>MonadState</code> や <code>MonadReader</code> などの型クラスと目的が似ている <code>MonadParsec</code> 型クラスがあります。 後で <code>MonadParsec</code> に戻り、詳細について説明します。</p>
<p>カスタムした型シノニムを定義することは <code>megaparsec</code> を使ってパーサを書くことを始める最も良い方法です。 これは次の2つの理由から良い考えです。</p>
<ul>
<li><p>あなたのパーサモナドとして <code>Parser</code> があれば、<code>Parser Int</code> のようなトップレベルのシグネチャを追加することがより簡単になります。シグネチャがないと、<code>e</code> のようなものが曖昧になることがよくあります。これはライブラリの多相APIの反面です。</p></li>
<li><p>すべての型変数を具体的な方に固定して操作すると、GHCの最適化が大幅に向上します。パーサが多相性を保っている場合、GHCは最適化の観点からそれほど多くのことはできません。<code>megaparsec</code> APIは多相ですが、エンドユーザーは具体的にパーサモナドの型を固定することが予想されます。そのため、インライン展開と、ほとんどの関数の定義がインターフェイスファイルと呼ばれるファイルに出力されているという事実により、GHCは非常に効率的な非多相的なコードを生成できます。</p></li>
</ul>
<p>次のように型シノニム（通常は <code>Parser</code> と呼ばれる）を定義しましょう。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a>ype <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Void</span> <span class="dt">Text</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="co">--                   ^    ^</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="co">--                   |    ┗━━━━┓</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="co">-- カスタムエラーコンポーネント  入力ストリームの型</span></span></code></pre></div>
<p>カスタムパースエラーを扱い始めるまでは、この章で <code>Parser</code>が表示されているときは、この型を想定してください。</p>
<p><a name="Character"></a></p>
<h2 id="文字とバイナリストリーム">文字とバイナリストリーム</h2>
<p><code>megaparsec</code> は、5種類の入力ストリーム（<code>String</code>、正格または遅延 <code>Text</code> 、 正格または遅延 <code>ByteStrings</code>）をそのまま使用できると言われています。 これが可能なのは、ライブラリでこれらの型が <code>Stream</code> 型クラスのインスタンスになっているからです。 <code>Stream</code> 型クラスはそれぞれのデータ型が <code>megaparsec</code> のパーサへの入力として使用するために必要な関数を抽象化したものです。</p>
<p>シンプルにしたバージョンの <code>Stream</code> は、次のようになります。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">class</span> <span class="dt">Stream</span> s <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>  <span class="kw">type</span> <span class="dt">Token</span><span class="ot">  s ::</span> <span class="op">*</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>  <span class="kw">type</span> <span class="dt">Tokens</span><span class="ot"> s ::</span> <span class="op">*</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="ot">  take1_ ::</span> s <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Token</span> s, s) <span class="co">-- aka uncons</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="ot">  tokensToChunk ::</span> <span class="dt">Proxy</span> s <span class="ot">-&gt;</span> [<span class="dt">Token</span> s] <span class="ot">-&gt;</span> <span class="dt">Tokens</span> s</span></code></pre></div>
<p>実際の <code>Stream</code> の定義にはもっと多くのメソッドがありますが、それらを知ることはライブラリを使うために必要ではありません。</p>
<p>型クラスには2つの型関数が関連付けられています。</p>
<ul>
<li><p>ストリーム <code>s</code> における <code>Token s</code> は単一トークンの型です。一般的な例は <code>Char</code> と <code>Word8</code> ですが、カスタムストリームのために何か他のものになるかもしれません。</p></li>
<li><p>ストリーム <code>s</code> における <code>Tokens s</code> はストリームの「チャンク」の型です。チャンクの概念はパフォーマンス上の理由から導入されただけです。確かに、トークンのリスト <code>[Token s]</code> と同型であるストリームの一部のより効率的な表現が可能です。例えば、 <code>Text</code> 型の入力ストリームは <code>Tokens s ~ Text</code> であり、<code>Text</code> のチャンクは <code>Text</code> です。型の等価性 <code>Tokens s ~ s</code> はしばしば成り立ちますが、 <code>Tokens s</code> と <code>s</code> はカスタムストリームでは異なる可能性があるため、<code>megaparsec</code> ではこれらの型を分離します。</p></li>
</ul>
<p>デフォルトの入力ストリームの型を以下の表に示します。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;"><code>s</code></th>
<th style="text-align: left;"><code>Token s</code></th>
<th style="text-align: left;"><code>Tokens s</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>String</code></td>
<td style="text-align: left;"><code>Char</code></td>
<td style="text-align: left;"><code>String</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">正格 <code>Text</code></td>
<td style="text-align: left;"><code>Char</code></td>
<td style="text-align: left;">正格 <code>Text</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">遅延 <code>Text</code></td>
<td style="text-align: left;"><code>Char</code></td>
<td style="text-align: left;">遅延 <code>Text</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">正格 <code>ByteString</code></td>
<td style="text-align: left;"><code>Word8</code></td>
<td style="text-align: left;">正格 <code>ByteString</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">遅延 <code>ByteString</code></td>
<td style="text-align: left;"><code>Word8</code></td>
<td style="text-align: left;">遅延 <code>ByteString</code></td>
</tr>
</tbody>
</table>
<p><code>Token</code> および <code>Tokens</code> 型関数は <code>megaparsec</code> API の型にて 多く出現するため、慣れることが重要です。</p>
<p>お気づきかもしれませんが、デフォルト入力ストリームを<code>Token</code>型でグループ化すると、2つのグループになります。</p>
<ul>
<li><p><code>Token s ~ Char</code> となる文字ストリーム : <code>String</code> および 正格・遅延 <code>Text</code>。</p></li>
<li><p><code>Token s ~ Word8</code> となるバイナリストリーム : 正格・遅延 <code>ByteString</code>。</p></li>
</ul>
<p><code>megaparsec</code> では、それぞれの型の入力ストリームに対して同じパーサをコーディングする必要はないことがわかりました。 (<code>attoparsec</code> ライブラリではする必要があります) しかし、それぞれの <code>Token s</code> ごとに異なるコードが必要です。</p>
<ul>
<li><p>文字ストリームの共通のコンビネータを得るには、<code>Text.Megaparsec.Char</code> モジュールをインポートしてください。</p></li>
<li><p>バイナリストリームで同じようにするには、<code>Text.Megaparsec.Byte</code>をインポートします。</p></li>
</ul>
<p>これらのモジュールには、次のような2つの類似したヘルパーパーサのセットが含まれています。</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>Name</strong></th>
<th style="text-align: left;"><code>Text.Megaparsec.Char</code></th>
<th style="text-align: left;"><code>Text.Megaparsec.Byte</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>newline</code></td>
<td style="text-align: left;"><code>(MonadParsec e s m, Token s ~ Char) =&gt; m (Token s)</code></td>
<td style="text-align: left;"><code>(MonadParsec e s m, Token s ~ Word8) =&gt; m (Token s)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>eol</code></td>
<td style="text-align: left;"><code>(MonadParsec e s m, Token s ~ Char) =&gt; m (Tokens s)</code></td>
<td style="text-align: left;"><code>(MonadParsec e s m, Token s ~ Word8) =&gt; m (Tokens s)</code></td>
</tr>
</tbody>
</table>
<p>このモジュールを構築するプリミティブをいくつか紹介しましょう。そうすれば、これから使用するツールを理解できます。</p>
<p>最初のプリミティブは<code>token</code>と呼ばれ、<code>Token s</code>をパースすることができます。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="ot">token ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb4-2"><a href="#cb4-2"></a>  <span class="ot">=&gt;</span> (<span class="dt">Token</span> s <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a)</span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="co">-- ^ Matching function for the token to parse</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>  <span class="ot">-&gt;</span> <span class="dt">Set</span> (<span class="dt">ErrorItem</span> (<span class="dt">Token</span> s))</span>
<span id="cb4-5"><a href="#cb4-5"></a>     <span class="co">-- ^ Expected items (in case of an error)</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>  <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p><code>token</code> の最初の引数はパースしたいトークンのマッチング関数です。 関数が<code>Just</code>で何かを返す場合、その値はパース結果になります。 <code>Nothing</code> はパーサがトークンを受理しなかったことによりプリミティブが失敗したこと示します。</p>
<p>2番目の引数は、（<code>container</code>パッケージの）<code>Set</code> であり、失敗した場合にユーザーに表示されるすべての予想されるErrorItemを含みます。 パースエラーについて議論するときに、<code>ErrorItem</code> 型を詳しく調べます。</p>
<p>トークンがどのように機能するのかをよりよく理解するために、 <code>Text.Megaparsec</code> モジュールの定義を見てみましょう。 これにはあらゆる種類の入力ストリームで 機能するコンビネータが含まれています。 <code>satisfy</code>はかなり一般的なコンビネータです。 マッチさせたいトークンを与えると <code>True</code> を返す述語を与え、 パーサは結果を返します。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="ot">satisfy ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb5-2"><a href="#cb5-2"></a>  <span class="ot">=&gt;</span> (<span class="dt">Token</span> s <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="co">-- ^ Predicate to apply</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>  <span class="ot">-&gt;</span> m (<span class="dt">Token</span> s)</span>
<span id="cb5-4"><a href="#cb5-4"></a>satisfy f <span class="ot">=</span> token testToken Set.empty</span>
<span id="cb5-5"><a href="#cb5-5"></a>  <span class="kw">where</span></span>
<span id="cb5-6"><a href="#cb5-6"></a>    testToken x <span class="ot">=</span> <span class="kw">if</span> f x <span class="kw">then</span> <span class="dt">Just</span> x <span class="kw">else</span> <span class="dt">Nothing</span></span></code></pre></div>
<p><code>testToken</code> は <code>Bool</code> を返す関数 <code>f</code> を 期待するトークン <code>Maybe (Token s)</code> を返す関数に変えます。 <code>satisfy</code> では、 一致すると予想される正確なトークン列がわからないため、 2番目の引数として <code>Set.empty</code> を渡します。</p>
<p><code>satisfy</code> を理解するために、機能するか見てみましょう。 パーサで遊ぶためには、それを実行するヘルパー関数が必要です。 GHCiでテストするために <code>megaparsec</code> は <code>parseTest</code> を提供します。</p>
<p>まず、GHCiを起動していくつかのモジュールをインポートしましょう。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1"></a>λ<span class="op">&gt;</span> <span class="ex">import</span> Text.Megaparsec</span>
<span id="cb6-2"><a href="#cb6-2"></a>λ<span class="op">&gt;</span> <span class="ex">import</span> Text.Megaparsec.Char</span>
<span id="cb6-3"><a href="#cb6-3"></a>λ<span class="op">&gt;</span> <span class="ex">import</span> Data.Text (Text)</span>
<span id="cb6-4"><a href="#cb6-4"></a>λ<span class="op">&gt;</span> <span class="ex">import</span> Data.Void</span></code></pre></div>
<p>パーサの型のあいまいさを解決するために、 使用する <code>Parser</code> 型シノニムを追加します。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1"></a>λ<span class="op">&gt;</span> <span class="bu">type</span> Parser = Parsec Void Text</span></code></pre></div>
<p>また、文字列リテラルを <code>Text</code> の値として使用できるように、<code>OverloadedStrings</code> 言語拡張を有効にする必要があります。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1"></a>λ<span class="op">&gt;</span> :<span class="ex">set</span> -XOverloadedStrings</span>
<span id="cb8-2"><a href="#cb8-2"></a></span>
<span id="cb8-3"><a href="#cb8-3"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (satisfy (== <span class="st">&#39;a&#39;</span>) :: <span class="ex">Parser</span> Char) <span class="st">&quot;&quot;</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="ex">1</span>:1:</span>
<span id="cb8-5"><a href="#cb8-5"></a>  <span class="kw">|</span></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="ex">1</span> <span class="kw">|</span> <span class="op">&lt;</span><span class="ex">empty</span> line<span class="op">&gt;</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>  <span class="kw">|</span> ^</span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="ex">unexpected</span> end of input</span>
<span id="cb8-9"><a href="#cb8-9"></a></span>
<span id="cb8-10"><a href="#cb8-10"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (satisfy (== <span class="st">&#39;a&#39;</span>) :: <span class="ex">Parser</span> Char) <span class="st">&quot;a&quot;</span></span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="st">&#39;a&#39;</span></span>
<span id="cb8-12"><a href="#cb8-12"></a></span>
<span id="cb8-13"><a href="#cb8-13"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (satisfy (== <span class="st">&#39;a&#39;</span>) :: <span class="ex">Parser</span> Char) <span class="st">&quot;b&quot;</span></span>
<span id="cb8-14"><a href="#cb8-14"></a><span class="ex">1</span>:1:</span>
<span id="cb8-15"><a href="#cb8-15"></a>  <span class="kw">|</span></span>
<span id="cb8-16"><a href="#cb8-16"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">b</span></span>
<span id="cb8-17"><a href="#cb8-17"></a>  <span class="kw">|</span> ^</span>
<span id="cb8-18"><a href="#cb8-18"></a><span class="ex">unexpected</span> <span class="st">&#39;b&#39;</span></span>
<span id="cb8-19"><a href="#cb8-19"></a></span>
<span id="cb8-20"><a href="#cb8-20"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (satisfy (<span class="op">&gt;</span> <span class="st">&#39;c&#39;</span>) :: <span class="ex">Parser</span> Char) <span class="st">&quot;a&quot;</span></span>
<span id="cb8-21"><a href="#cb8-21"></a><span class="ex">1</span>:1:</span>
<span id="cb8-22"><a href="#cb8-22"></a>  <span class="kw">|</span></span>
<span id="cb8-23"><a href="#cb8-23"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">a</span></span>
<span id="cb8-24"><a href="#cb8-24"></a>  <span class="kw">|</span> ^</span>
<span id="cb8-25"><a href="#cb8-25"></a><span class="ex">unexpected</span> <span class="st">&#39;a&#39;</span></span>
<span id="cb8-26"><a href="#cb8-26"></a></span>
<span id="cb8-27"><a href="#cb8-27"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (satisfy (<span class="op">&gt;</span> <span class="st">&#39;c&#39;</span>) :: <span class="ex">Parser</span> Char) <span class="st">&quot;d&quot;</span></span>
<span id="cb8-28"><a href="#cb8-28"></a><span class="st">&#39;d&#39;</span></span></code></pre></div>
<p><code>satisfy</code> の多相性により、 <code>parseTest</code> は <code>MonadParsec e s m</code> で <code>e</code> と <code>s</code> に何を使うべきかわからないため、 アノテーション <code>:: Parser Char</code> は必要です (<code>m</code> はこれらのヘルパーにより <code>Identity</code> と仮定されます)。 型シグネチャを持つ既存のパーサを使う場合、 パーサの型を明示的に説明する必要はありません。</p>
<p>うまくいきそうです。 <code>satisfy</code> の問題は、 それが失敗したときに何が期待されるのかを述べないということです。 なぜなら、 <code>satisfy</code> の呼び出し元が提供する関数を分析することができないからです。 あまり一般的ではないですが、 代わりにもっと有用なエラーメッセージを生成することができる 他のコンビネータがあります。 例えば、<code>single</code> (<code>Text.Megaparsec.Byte</code> と <code>Text.Megaparsec.Char</code> では <code>char</code> と呼ばれる型制約のあるシノニムを使用する) は特定のトークン値にマッチします。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1"></a><span class="ex">single</span> :: MonadParsec e s m</span>
<span id="cb9-2"><a href="#cb9-2"></a>  =<span class="op">&gt;</span> <span class="ex">Token</span> s           -- ^ Token to match</span>
<span id="cb9-3"><a href="#cb9-3"></a>  <span class="ex">-</span><span class="op">&gt;</span> m (Token s)</span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="ex">single</span> t = token testToken expected</span>
<span id="cb9-5"><a href="#cb9-5"></a>  <span class="ex">where</span></span>
<span id="cb9-6"><a href="#cb9-6"></a>    <span class="ex">testToken</span> x = if x == t then Just x else Nothing</span>
<span id="cb9-7"><a href="#cb9-7"></a>    <span class="ex">expected</span>    = E.singleton (Tokens (t:<span class="kw">|</span>[]))</span></code></pre></div>
<p><code>Tokens</code> 値コンストラクタは、前に説明した型関数 <code>Tokens</code> と何の共通点もありません。 実際、 <code>Tokens</code> は <code>ErrorItem</code> のコンストラクタの1つであり、 一致すると予想される具体的なトークン列 を指定するために使用されます。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (char <span class="st">&#39;a&#39;</span> :: Parser Char) <span class="st">&quot;b&quot;</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="ex">1</span>:1:</span>
<span id="cb10-3"><a href="#cb10-3"></a>  <span class="kw">|</span></span>
<span id="cb10-4"><a href="#cb10-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">b</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>  <span class="kw">|</span> ^</span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="ex">unexpected</span> <span class="st">&#39;b&#39;</span></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="ex">expecting</span> <span class="st">&#39;a&#39;</span></span>
<span id="cb10-8"><a href="#cb10-8"></a></span>
<span id="cb10-9"><a href="#cb10-9"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (char <span class="st">&#39;a&#39;</span> :: Parser Char) <span class="st">&quot;a&quot;</span></span>
<span id="cb10-10"><a href="#cb10-10"></a><span class="st">&#39;a&#39;</span></span></code></pre></div>
<p>以下のようにの改行を定義できます。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1"></a><span class="ex">newline</span> :: (MonadParsec e s m, Token s ~ Char) =<span class="op">&gt;</span> <span class="ex">m</span> (Token s)</span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="ex">newline</span> = single <span class="st">&#39;\n&#39;</span></span></code></pre></div>
<p>2つ目のプリミティブは<code>tokens</code>と呼ばれ、 <code>Tokens</code> をパースすることを可能にします。 つまり、入力の固定されたチャンクに一致させるために使用できます。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1"></a><span class="ex">tokens</span> :: MonadParsec e s m</span>
<span id="cb12-2"><a href="#cb12-2"></a>  =<span class="op">&gt;</span> <span class="kw">(</span><span class="ex">Tokens</span> s -<span class="op">&gt;</span> Tokens s -<span class="op">&gt;</span> Bool<span class="kw">)</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>    <span class="ex">--</span> ^ チャンクの等価性をチェックする述語</span>
<span id="cb12-4"><a href="#cb12-4"></a>  <span class="ex">-</span><span class="op">&gt;</span> Tokens s</span>
<span id="cb12-5"><a href="#cb12-5"></a>    <span class="ex">--</span> ^ 入力にマッチさせたいチャンク</span>
<span id="cb12-6"><a href="#cb12-6"></a>  <span class="ex">-</span><span class="op">&gt;</span> m (Tokens s)</span></code></pre></div>
<p><code>tokens</code> に関して定義された2つのパーサがあります。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="co">-- from &quot;Text.Megaparsec&quot;:</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="ot">chunk ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb13-3"><a href="#cb13-3"></a>  <span class="ot">=&gt;</span> <span class="dt">Tokens</span> s</span>
<span id="cb13-4"><a href="#cb13-4"></a>  <span class="ot">-&gt;</span> m (<span class="dt">Tokens</span> s)</span>
<span id="cb13-5"><a href="#cb13-5"></a>chunk <span class="ot">=</span> tokens (<span class="op">==</span>)</span>
<span id="cb13-6"><a href="#cb13-6"></a></span>
<span id="cb13-7"><a href="#cb13-7"></a><span class="co">-- from &quot;Text.Megaparsec.Char&quot; and &quot;Text.Megaparsec.Byte&quot;:</span></span>
<span id="cb13-8"><a href="#cb13-8"></a><span class="ot">string&#39; ::</span> (<span class="dt">MonadParsec</span> e s m, <span class="dt">CI.FoldCase</span> (<span class="dt">Tokens</span> s))</span>
<span id="cb13-9"><a href="#cb13-9"></a>  <span class="ot">=&gt;</span> <span class="dt">Tokens</span> s</span>
<span id="cb13-10"><a href="#cb13-10"></a>  <span class="ot">-&gt;</span> m (<span class="dt">Tokens</span> s)</span>
<span id="cb13-11"><a href="#cb13-11"></a>string&#39; <span class="ot">=</span> tokens ((<span class="op">==</span>) <span class="ot">`on`</span> CI.mk)</span></code></pre></div>
<p>それらは入力の一定のチャンクにマッチします。 <code>chunk</code> (<code>Text.Megaparsec.Byte</code> と <code>Text.Megaparsec.Char</code> では <code>string</code> と呼ばれる型制約のあるシノニムを使用する) は大文字と小文字を区別しますが、 <code>string'</code> は大文字と小文字を区別しません。 大文字と小文字を区別しない場合のマッチには <code>case-insensitive</code> パッケージが使われているため、 <code>FoldCase</code> 制約があります。</p>
<p>新しいコンビネータも使ってみましょう。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a>λ<span class="op">&gt;</span> parseTest (string <span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> <span class="dt">Parser</span> <span class="dt">Text</span>) <span class="st">&quot;foo&quot;</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="st">&quot;foo&quot;</span></span>
<span id="cb14-3"><a href="#cb14-3"></a></span>
<span id="cb14-4"><a href="#cb14-4"></a>λ<span class="op">&gt;</span> parseTest (string <span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> <span class="dt">Parser</span> <span class="dt">Text</span>) <span class="st">&quot;bar&quot;</span></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="dv">1</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span></span>
<span id="cb14-6"><a href="#cb14-6"></a>  <span class="op">|</span></span>
<span id="cb14-7"><a href="#cb14-7"></a><span class="dv">1</span> <span class="op">|</span> bar</span>
<span id="cb14-8"><a href="#cb14-8"></a>  <span class="op">|</span> <span class="op">^</span></span>
<span id="cb14-9"><a href="#cb14-9"></a>unexpected <span class="st">&quot;bar&quot;</span></span>
<span id="cb14-10"><a href="#cb14-10"></a>expecting <span class="st">&quot;foo&quot;</span></span>
<span id="cb14-11"><a href="#cb14-11"></a></span>
<span id="cb14-12"><a href="#cb14-12"></a>λ<span class="op">&gt;</span> parseTest (string&#39; <span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> <span class="dt">Parser</span> <span class="dt">Text</span>) <span class="st">&quot;FOO&quot;</span></span>
<span id="cb14-13"><a href="#cb14-13"></a><span class="st">&quot;FOO&quot;</span></span>
<span id="cb14-14"><a href="#cb14-14"></a></span>
<span id="cb14-15"><a href="#cb14-15"></a>λ<span class="op">&gt;</span> parseTest (string&#39; <span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> <span class="dt">Parser</span> <span class="dt">Text</span>) <span class="st">&quot;FoO&quot;</span></span>
<span id="cb14-16"><a href="#cb14-16"></a><span class="st">&quot;FoO&quot;</span></span>
<span id="cb14-17"><a href="#cb14-17"></a></span>
<span id="cb14-18"><a href="#cb14-18"></a>λ<span class="op">&gt;</span> parseTest (string&#39; <span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> <span class="dt">Parser</span> <span class="dt">Text</span>) <span class="st">&quot;FoZ&quot;</span></span>
<span id="cb14-19"><a href="#cb14-19"></a><span class="dv">1</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span></span>
<span id="cb14-20"><a href="#cb14-20"></a>  <span class="op">|</span></span>
<span id="cb14-21"><a href="#cb14-21"></a><span class="dv">1</span> <span class="op">|</span> <span class="dt">FoZ</span></span>
<span id="cb14-22"><a href="#cb14-22"></a>  <span class="op">|</span> <span class="op">^</span></span>
<span id="cb14-23"><a href="#cb14-23"></a>unexpected <span class="st">&quot;FoZ&quot;</span></span>
<span id="cb14-24"><a href="#cb14-24"></a>expecting <span class="st">&quot;foo&quot;</span></span></code></pre></div>
<p>OK、単一のトークンと入力のチャンクをマッチできました。 次のステップは、より興味深いパーサを書くために 基本的なパーサを組み合わせる方法を学びます。</p>
<p><a name="MonaAp"></a></p>
<h2 id="モナディック構文とアプリカティブ構文">モナディック構文とアプリカティブ構文</h2>
<p>パーサを組み合わせる最も簡単な方法は、それらを逐次実行することです。 <code>ParsecT</code>と<code>Parsec</code>はモナドであり、 モナドでの束縛はパーサを連続で使用することとまったく同じです。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a><span class="ot">mySequence ::</span> <span class="dt">Parser</span> (<span class="dt">Char</span>, <span class="dt">Char</span>, <span class="dt">Char</span>)</span>
<span id="cb15-2"><a href="#cb15-2"></a>mySequence <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb15-3"><a href="#cb15-3"></a>  a <span class="ot">&lt;-</span> char <span class="ch">&#39;a&#39;</span></span>
<span id="cb15-4"><a href="#cb15-4"></a>  b <span class="ot">&lt;-</span> char <span class="ch">&#39;b&#39;</span></span>
<span id="cb15-5"><a href="#cb15-5"></a>  c <span class="ot">&lt;-</span> char <span class="ch">&#39;c&#39;</span></span>
<span id="cb15-6"><a href="#cb15-6"></a>  <span class="fu">return</span> (a, b, c)</span></code></pre></div>
<p>これを実行すると、すべてが期待通りに機能することを確認できます。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> mySequence <span class="st">&quot;abc&quot;</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="kw">(</span><span class="st">&#39;a&#39;</span>,<span class="st">&#39;b&#39;</span>,<span class="st">&#39;c&#39;</span><span class="kw">)</span></span>
<span id="cb16-3"><a href="#cb16-3"></a></span>
<span id="cb16-4"><a href="#cb16-4"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> mySequence <span class="st">&quot;bcd&quot;</span></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="ex">1</span>:1:</span>
<span id="cb16-6"><a href="#cb16-6"></a>  <span class="kw">|</span></span>
<span id="cb16-7"><a href="#cb16-7"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">bcd</span></span>
<span id="cb16-8"><a href="#cb16-8"></a>  <span class="kw">|</span> ^</span>
<span id="cb16-9"><a href="#cb16-9"></a><span class="ex">unexpected</span> <span class="st">&#39;b&#39;</span></span>
<span id="cb16-10"><a href="#cb16-10"></a><span class="ex">expecting</span> <span class="st">&#39;a&#39;</span></span>
<span id="cb16-11"><a href="#cb16-11"></a></span>
<span id="cb16-12"><a href="#cb16-12"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> mySequence <span class="st">&quot;adc&quot;</span></span>
<span id="cb16-13"><a href="#cb16-13"></a><span class="ex">1</span>:2:</span>
<span id="cb16-14"><a href="#cb16-14"></a>  <span class="kw">|</span></span>
<span id="cb16-15"><a href="#cb16-15"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">adc</span></span>
<span id="cb16-16"><a href="#cb16-16"></a>  <span class="kw">|</span>  ^</span>
<span id="cb16-17"><a href="#cb16-17"></a><span class="ex">unexpected</span> <span class="st">&#39;d&#39;</span></span>
<span id="cb16-18"><a href="#cb16-18"></a><span class="ex">expecting</span> <span class="st">&#39;b&#39;</span></span></code></pre></div>
<p>すべてのモナドがアプリカティブファンクターでもあることを覚えていれば、 逐次実行のための代替構文が可能であり、 アプリカティブ構文を使用できます。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a><span class="ot">mySequence ::</span> <span class="dt">Parser</span> (<span class="dt">Char</span>, <span class="dt">Char</span>, <span class="dt">Char</span>)</span>
<span id="cb17-2"><a href="#cb17-2"></a>mySequence <span class="ot">=</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>  (,,) <span class="op">&lt;$&gt;</span> char <span class="ch">&#39;a&#39;</span></span>
<span id="cb17-4"><a href="#cb17-4"></a>       <span class="op">&lt;*&gt;</span> char <span class="ch">&#39;b&#39;</span></span>
<span id="cb17-5"><a href="#cb17-5"></a>       <span class="op">&lt;*&gt;</span> char <span class="ch">&#39;c&#39;</span></span></code></pre></div>
<p>2番目のバージョンは最初のバージョンとまったく同じように機能します。 どちらのスタイルを使うかは、しばしば好みの問題です。 モナディックスタイルは間違いなく冗長で、ときにはより明確ですが、 一方アプリカティブスタイルはより簡潔です。 そうは言っても、モナドはアプリカティブファンクターよりも強力であるため、 モナディックスタイルはもちろんより強力です。</p>
<p><a name="Eof"></a></p>
<h2 id="eof-による入力の強制消費">eof による入力の強制消費</h2>
<p><code>Applicative</code> はとてもおもしろいことをするのに十分強力です。 単位元を持つ結合演算子を備えることで、 Haskell では <code>Alternative</code> 型クラスとして表現される アプリカティブファンクタのモノイドを得ます。 <code>parser-combinators</code> パッケージは <code>Applicative</code> と <code>Alternative</code> の概念に基づき構築された かなりの数の抽象的なコンビネータを提供します。 <code>Text.Megaparsec</code> モジュールはそれらを <code>Control.Applicative.Combinators</code> から再エクスポートします。</p>
<p>最も一般的なコンビネータの1つに、<code>many</code> と呼ばれるものがあります。 それは与えられたパーサを0回以上実行することができます。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (many (char <span class="st">&#39;a&#39;</span>) :: <span class="ex">Parser</span> [Char]) <span class="st">&quot;aaa&quot;</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="st">&quot;aaa&quot;</span></span>
<span id="cb18-3"><a href="#cb18-3"></a></span>
<span id="cb18-4"><a href="#cb18-4"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (many (char <span class="st">&#39;a&#39;</span>) :: <span class="ex">Parser</span> [Char]) <span class="st">&quot;aabbb&quot;</span></span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="st">&quot;aa&quot;</span></span></code></pre></div>
<p>2番目の結果は少し驚くかもしれません。 パーサは <code>a</code> が一致したとして消費しましたが、その後停止しました。 <code>many (char 'a')</code> の後に何をしたいのか何も言っていませんでした！</p>
<p>ほとんどの場合は、パーサに入力全体の消費を強制させ、 恥ずかしがり屋で黙ってやめるのではなく、 パースエラーを報告させたいです。 これは、入力の終わりに達することを 要求することによって行われます。 入力の終わりは概念にすぎませんが、 幸いにも <code>eof :: MonadParsec e m =&gt; m ()</code>と呼ばれるプリミティブがあり、 これは何も消費せず、入力の終わりでのみ成功します。 これをパーサに追加してもう一度試してみましょう。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (many (char <span class="st">&#39;a&#39;</span>) <span class="op">&lt;</span><span class="ex">*</span> eof :: Parser [Char]) <span class="st">&quot;aabbb&quot;</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="ex">1</span>:3:</span>
<span id="cb19-3"><a href="#cb19-3"></a>  <span class="kw">|</span></span>
<span id="cb19-4"><a href="#cb19-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">aabbb</span></span>
<span id="cb19-5"><a href="#cb19-5"></a>  <span class="kw">|</span>   ^</span>
<span id="cb19-6"><a href="#cb19-6"></a><span class="ex">unexpected</span> <span class="st">&#39;b&#39;</span></span>
<span id="cb19-7"><a href="#cb19-7"></a><span class="ex">expecting</span> <span class="st">&#39;a&#39;</span> or end of input</span></code></pre></div>
<p>パーサで<code>b</code>について何も言わなかったことにより、 それらは確かに予想外となりました。</p>
<p><a name="Alt"></a></p>
<h2 id="選択肢を使った動作">選択肢を使った動作</h2>
<p>これから、次の形式のURIのパースが可能である実用的なパーサを開発します。</p>
<pre><code>scheme:[//[user:password@]host[:port]][/]path[?query][#fragment]</code></pre>
<p>角括弧 <code>[]</code> の中はオプションであり、それらは有効なURIに現れても現れなくてもよいことを覚えておくべきです。 <code>[]</code> は、ある可能性を別の可能性の中で表現するためにネストすることさえできます。私たちはこのすべてを処理します<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>。</p>
<p><code>scheme</code> から始めましょう。 <code>data</code>、<code>file</code>、<code>ftp</code>、<code>http</code>、<code>https</code>、<code>irc</code>、<code>mailto</code> など、私たちが知っているスキームのみを受け入れます。</p>
<p>一定の文字列と一致させるために、<code>string</code> を使います。 選択を表現するために、<code>Alternative</code> 型クラスの <code>(&lt;|&gt;)</code> メソッドを使います。 次のように書くことができます。</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="ot">{-# LANGUAGE RecordWildCards   #-}</span></span>
<span id="cb21-3"><a href="#cb21-3"></a></span>
<span id="cb21-4"><a href="#cb21-4"></a><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></span>
<span id="cb21-5"><a href="#cb21-5"></a></span>
<span id="cb21-6"><a href="#cb21-6"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb21-7"><a href="#cb21-7"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb21-8"><a href="#cb21-8"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb21-9"><a href="#cb21-9"></a><span class="kw">import</span> <span class="dt">Data.Void</span></span>
<span id="cb21-10"><a href="#cb21-10"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span> <span class="kw">hiding</span> (<span class="dt">State</span>)</span>
<span id="cb21-11"><a href="#cb21-11"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec.Char</span></span>
<span id="cb21-12"><a href="#cb21-12"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb21-13"><a href="#cb21-13"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Megaparsec.Char.Lexer</span> <span class="kw">as</span> <span class="dt">L</span></span>
<span id="cb21-14"><a href="#cb21-14"></a></span>
<span id="cb21-15"><a href="#cb21-15"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Void</span> <span class="dt">Text</span></span>
<span id="cb21-16"><a href="#cb21-16"></a></span>
<span id="cb21-17"><a href="#cb21-17"></a><span class="ot">pScheme ::</span> <span class="dt">Parser</span> <span class="dt">Text</span></span>
<span id="cb21-18"><a href="#cb21-18"></a>pScheme <span class="ot">=</span> string <span class="st">&quot;data&quot;</span></span>
<span id="cb21-19"><a href="#cb21-19"></a>  <span class="op">&lt;|&gt;</span> string <span class="st">&quot;file&quot;</span></span>
<span id="cb21-20"><a href="#cb21-20"></a>  <span class="op">&lt;|&gt;</span> string <span class="st">&quot;ftp&quot;</span></span>
<span id="cb21-21"><a href="#cb21-21"></a>  <span class="op">&lt;|&gt;</span> string <span class="st">&quot;http&quot;</span></span>
<span id="cb21-22"><a href="#cb21-22"></a>  <span class="op">&lt;|&gt;</span> string <span class="st">&quot;https&quot;</span></span>
<span id="cb21-23"><a href="#cb21-23"></a>  <span class="op">&lt;|&gt;</span> string <span class="st">&quot;irc&quot;</span></span>
<span id="cb21-24"><a href="#cb21-24"></a>  <span class="op">&lt;|&gt;</span> string <span class="st">&quot;mailto&quot;</span></span></code></pre></div>
<p>試してみましょう。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb22-1"><a href="#cb22-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pScheme <span class="st">&quot;&quot;</span></span>
<span id="cb22-2"><a href="#cb22-2"></a><span class="ex">1</span>:1:</span>
<span id="cb22-3"><a href="#cb22-3"></a>  <span class="kw">|</span></span>
<span id="cb22-4"><a href="#cb22-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="op">&lt;</span><span class="ex">empty</span> line<span class="op">&gt;</span></span>
<span id="cb22-5"><a href="#cb22-5"></a>  <span class="kw">|</span> ^</span>
<span id="cb22-6"><a href="#cb22-6"></a><span class="ex">unexpected</span> end of input</span>
<span id="cb22-7"><a href="#cb22-7"></a><span class="ex">expecting</span> <span class="st">&quot;data&quot;</span>, <span class="st">&quot;file&quot;</span>, <span class="st">&quot;ftp&quot;</span>, <span class="st">&quot;http&quot;</span>, <span class="st">&quot;https&quot;</span>, <span class="st">&quot;irc&quot;</span>, or <span class="st">&quot;mailto&quot;</span></span>
<span id="cb22-8"><a href="#cb22-8"></a></span>
<span id="cb22-9"><a href="#cb22-9"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pScheme <span class="st">&quot;dat&quot;</span></span>
<span id="cb22-10"><a href="#cb22-10"></a><span class="ex">1</span>:1:</span>
<span id="cb22-11"><a href="#cb22-11"></a>  <span class="kw">|</span></span>
<span id="cb22-12"><a href="#cb22-12"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">dat</span></span>
<span id="cb22-13"><a href="#cb22-13"></a>  <span class="kw">|</span> ^</span>
<span id="cb22-14"><a href="#cb22-14"></a><span class="ex">unexpected</span> <span class="st">&quot;dat&quot;</span></span>
<span id="cb22-15"><a href="#cb22-15"></a><span class="ex">expecting</span> <span class="st">&quot;data&quot;</span>, <span class="st">&quot;file&quot;</span>, <span class="st">&quot;ftp&quot;</span>, <span class="st">&quot;http&quot;</span>, <span class="st">&quot;https&quot;</span>, <span class="st">&quot;irc&quot;</span>, or <span class="st">&quot;mailto&quot;</span></span>
<span id="cb22-16"><a href="#cb22-16"></a></span>
<span id="cb22-17"><a href="#cb22-17"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pScheme <span class="st">&quot;file&quot;</span></span>
<span id="cb22-18"><a href="#cb22-18"></a><span class="st">&quot;file&quot;</span></span>
<span id="cb22-19"><a href="#cb22-19"></a></span>
<span id="cb22-20"><a href="#cb22-20"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pScheme <span class="st">&quot;irc&quot;</span></span>
<span id="cb22-21"><a href="#cb22-21"></a><span class="st">&quot;irc&quot;</span></span></code></pre></div>
<p>見栄えは良いですが、<code>pScheme</code>の定義は少し反復的です。 <code>choice</code> コンビネータを使って <code>pScheme</code> を書く方法があります。</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1"></a><span class="ot">pScheme ::</span> <span class="dt">Parser</span> <span class="dt">Text</span></span>
<span id="cb23-2"><a href="#cb23-2"></a>pScheme <span class="ot">=</span> choice</span>
<span id="cb23-3"><a href="#cb23-3"></a>  [ string <span class="st">&quot;data&quot;</span></span>
<span id="cb23-4"><a href="#cb23-4"></a>  , string <span class="st">&quot;file&quot;</span></span>
<span id="cb23-5"><a href="#cb23-5"></a>  , string <span class="st">&quot;ftp&quot;</span></span>
<span id="cb23-6"><a href="#cb23-6"></a>  , string <span class="st">&quot;http&quot;</span></span>
<span id="cb23-7"><a href="#cb23-7"></a>  , string <span class="st">&quot;https&quot;</span></span>
<span id="cb23-8"><a href="#cb23-8"></a>  , string <span class="st">&quot;irc&quot;</span></span>
<span id="cb23-9"><a href="#cb23-9"></a>  , string <span class="st">&quot;mailto&quot;</span> ]</span></code></pre></div>
<p><code>choice</code> は要素間に <code>(&lt;|&gt;)</code> を入れてリストを畳み込む操作である <code>asum</code> の単なるシノニムであり、<code>pScheme</code> の2つの定義は実際には同じです。 <code>choice</code> を使用したほうがが少し良く見えるかもしれません。</p>
<p>スキームの後にはコロン<code>:</code>があるはずです。 何かした後で別の何かを要求するために、 モナドでの束縛またはdo記法を使います。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">data</span> <span class="dt">Uri</span> <span class="ot">=</span> <span class="dt">Uri</span></span>
<span id="cb24-2"><a href="#cb24-2"></a>  {<span class="ot"> uriScheme ::</span> <span class="dt">Text</span></span>
<span id="cb24-3"><a href="#cb24-3"></a>  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb24-4"><a href="#cb24-4"></a></span>
<span id="cb24-5"><a href="#cb24-5"></a><span class="ot">pUri ::</span> <span class="dt">Parser</span> <span class="dt">Uri</span></span>
<span id="cb24-6"><a href="#cb24-6"></a>pUri <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb24-7"><a href="#cb24-7"></a>  r <span class="ot">&lt;-</span> pScheme</span>
<span id="cb24-8"><a href="#cb24-8"></a>  _ <span class="ot">&lt;-</span> char <span class="ch">&#39;:&#39;</span></span>
<span id="cb24-9"><a href="#cb24-9"></a>  <span class="fu">return</span> (<span class="dt">Uri</span> r)</span></code></pre></div>
<p><code>pUri</code>を実行しようとすると、スキーム名の後に <code>:</code> が必要であることがわかります。</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb25-1"><a href="#cb25-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pUri <span class="st">&quot;irc&quot;</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="ex">1</span>:4:</span>
<span id="cb25-3"><a href="#cb25-3"></a>  <span class="kw">|</span></span>
<span id="cb25-4"><a href="#cb25-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">irc</span></span>
<span id="cb25-5"><a href="#cb25-5"></a>  <span class="kw">|</span>    ^</span>
<span id="cb25-6"><a href="#cb25-6"></a><span class="ex">unexpected</span> end of input</span>
<span id="cb25-7"><a href="#cb25-7"></a><span class="ex">expecting</span> <span class="st">&#39;:&#39;</span></span>
<span id="cb25-8"><a href="#cb25-8"></a></span>
<span id="cb25-9"><a href="#cb25-9"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pUri <span class="st">&quot;irc:&quot;</span></span>
<span id="cb25-10"><a href="#cb25-10"></a><span class="ex">Uri</span> {uriScheme = <span class="st">&quot;irc&quot;</span>}</span></code></pre></div>
<p>しかし、このスキームのパーサは完成していません。 良い Haskell のプログラマーは、 正しくないデータを単純に表現できないように型を定義しようとします。 すべての <code>Text</code> の値が有効なスキームであるとは限りません。 スキームを表すためにデータ型を定義し、 <code>pScheme</code> パーサにその型の値を返させます。</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1"></a><span class="kw">data</span> <span class="dt">Scheme</span></span>
<span id="cb26-2"><a href="#cb26-2"></a>  <span class="ot">=</span> <span class="dt">SchemeData</span></span>
<span id="cb26-3"><a href="#cb26-3"></a>  <span class="op">|</span> <span class="dt">SchemeFile</span></span>
<span id="cb26-4"><a href="#cb26-4"></a>  <span class="op">|</span> <span class="dt">SchemeFtp</span></span>
<span id="cb26-5"><a href="#cb26-5"></a>  <span class="op">|</span> <span class="dt">SchemeHttp</span></span>
<span id="cb26-6"><a href="#cb26-6"></a>  <span class="op">|</span> <span class="dt">SchemeHttps</span></span>
<span id="cb26-7"><a href="#cb26-7"></a>  <span class="op">|</span> <span class="dt">SchemeIrc</span></span>
<span id="cb26-8"><a href="#cb26-8"></a>  <span class="op">|</span> <span class="dt">SchemeMailto</span></span>
<span id="cb26-9"><a href="#cb26-9"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb26-10"><a href="#cb26-10"></a></span>
<span id="cb26-11"><a href="#cb26-11"></a><span class="ot">pScheme ::</span> <span class="dt">Parser</span> <span class="dt">Scheme</span></span>
<span id="cb26-12"><a href="#cb26-12"></a>pScheme <span class="ot">=</span> choice</span>
<span id="cb26-13"><a href="#cb26-13"></a>  [ <span class="dt">SchemeData</span>   <span class="op">&lt;$</span> string <span class="st">&quot;data&quot;</span></span>
<span id="cb26-14"><a href="#cb26-14"></a>  , <span class="dt">SchemeFile</span>   <span class="op">&lt;$</span> string <span class="st">&quot;file&quot;</span></span>
<span id="cb26-15"><a href="#cb26-15"></a>  , <span class="dt">SchemeFtp</span>    <span class="op">&lt;$</span> string <span class="st">&quot;ftp&quot;</span></span>
<span id="cb26-16"><a href="#cb26-16"></a>  , <span class="dt">SchemeHttp</span>   <span class="op">&lt;$</span> string <span class="st">&quot;http&quot;</span></span>
<span id="cb26-17"><a href="#cb26-17"></a>  , <span class="dt">SchemeHttps</span>  <span class="op">&lt;$</span> string <span class="st">&quot;https&quot;</span></span>
<span id="cb26-18"><a href="#cb26-18"></a>  , <span class="dt">SchemeIrc</span>    <span class="op">&lt;$</span> string <span class="st">&quot;irc&quot;</span></span>
<span id="cb26-19"><a href="#cb26-19"></a>  , <span class="dt">SchemeMailto</span> <span class="op">&lt;$</span> string <span class="st">&quot;mailto&quot;</span> ]</span>
<span id="cb26-20"><a href="#cb26-20"></a></span>
<span id="cb26-21"><a href="#cb26-21"></a><span class="kw">data</span> <span class="dt">Uri</span> <span class="ot">=</span> <span class="dt">Uri</span></span>
<span id="cb26-22"><a href="#cb26-22"></a>  {<span class="ot"> uriScheme ::</span> <span class="dt">Scheme</span></span>
<span id="cb26-23"><a href="#cb26-23"></a>  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p><code>(&lt;$)</code> 演算子は、左側にある値をただちに関数型コンテキストに入れて、 その時点で存在しているものはすべて置き換えます。 <code>a &lt;$ f</code> は <code>const a &lt;$&gt; f</code> と同じですが、 関数によってはより効率的な場合があります。</p>
<p>引き続きパーサを使ってみましょう。</p>
<pre><code>λ&gt; parseTest pUri &quot;https:&quot;
1:5:
  |
1 | https:
  |     ^
unexpected &#39;s&#39;
expecting &#39;:&#39;</code></pre>
<p>うーん、<code>https</code> は有効なスキームであるべきです。 何がいけないのかわかりますか？ パーサは選択肢を一つずつ試し、 <code>http</code> で一致し、 <code>https</code> を試すことはありません。 解決策は、<code>SchemeHttp &lt;$ string "https"</code> という行を <code>SchemeHttp &lt;$ string "http"</code> という行の前に置くことです。 選択肢は順序が重要であることを覚えておいてください！</p>
<p><code>pUri</code> は正しく動作するようになりました。</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb28-1"><a href="#cb28-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pUri <span class="st">&quot;http:&quot;</span></span>
<span id="cb28-2"><a href="#cb28-2"></a><span class="ex">Uri</span> {uriScheme = SchemeHttp}</span>
<span id="cb28-3"><a href="#cb28-3"></a></span>
<span id="cb28-4"><a href="#cb28-4"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pUri <span class="st">&quot;https:&quot;</span></span>
<span id="cb28-5"><a href="#cb28-5"></a><span class="ex">Uri</span> {uriScheme = SchemeHttps}</span>
<span id="cb28-6"><a href="#cb28-6"></a></span>
<span id="cb28-7"><a href="#cb28-7"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pUri <span class="st">&quot;mailto:&quot;</span></span>
<span id="cb28-8"><a href="#cb28-8"></a><span class="ex">Uri</span> {uriScheme = SchemeMailto}</span>
<span id="cb28-9"><a href="#cb28-9"></a></span>
<span id="cb28-10"><a href="#cb28-10"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> pUri <span class="st">&quot;foo:&quot;</span></span>
<span id="cb28-11"><a href="#cb28-11"></a><span class="ex">1</span>:1:</span>
<span id="cb28-12"><a href="#cb28-12"></a>  <span class="kw">|</span></span>
<span id="cb28-13"><a href="#cb28-13"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">foo</span>:</span>
<span id="cb28-14"><a href="#cb28-14"></a>  <span class="kw">|</span> ^</span>
<span id="cb28-15"><a href="#cb28-15"></a><span class="ex">unexpected</span> <span class="st">&quot;foo:&quot;</span></span>
<span id="cb28-16"><a href="#cb28-16"></a><span class="ex">expecting</span> <span class="st">&quot;data&quot;</span>, <span class="st">&quot;file&quot;</span>, <span class="st">&quot;ftp&quot;</span>, <span class="st">&quot;http&quot;</span>, <span class="st">&quot;https&quot;</span>, <span class="st">&quot;irc&quot;</span>, or <span class="st">&quot;mailto&quot;</span></span></code></pre></div>
<p><a name="Try"></a></p>
<h2 id="try-によるバックトラックの制御"><code>try</code> によるバックトラックの制御</h2>
<p>次に扱う部分は <code>[//[user:password@]host[:port]]</code> つまり認証情報です。 オプション部分のネストが含まれるので、 これを反映するように <code>Uri</code> 型 を更新しましょう。</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1"></a><span class="kw">data</span> <span class="dt">Uri</span> <span class="ot">=</span> <span class="dt">Uri</span></span>
<span id="cb29-2"><a href="#cb29-2"></a>  {<span class="ot"> uriScheme    ::</span> <span class="dt">Scheme</span></span>
<span id="cb29-3"><a href="#cb29-3"></a>  ,<span class="ot"> uriAuthority ::</span> <span class="dt">Maybe</span> <span class="dt">Authority</span></span>
<span id="cb29-4"><a href="#cb29-4"></a>  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb29-5"><a href="#cb29-5"></a></span>
<span id="cb29-6"><a href="#cb29-6"></a><span class="kw">data</span> <span class="dt">Authority</span> <span class="ot">=</span> <span class="dt">Authority</span></span>
<span id="cb29-7"><a href="#cb29-7"></a>  {<span class="ot"> authUser ::</span> <span class="dt">Maybe</span> (<span class="dt">Text</span>, <span class="dt">Text</span>) <span class="co">-- (user, password)</span></span>
<span id="cb29-8"><a href="#cb29-8"></a>  ,<span class="ot"> authHost ::</span> <span class="dt">Text</span></span>
<span id="cb29-9"><a href="#cb29-9"></a>  ,<span class="ot"> authPort ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb29-10"><a href="#cb29-10"></a>  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p>ここで、バックトラックと呼ばれる重要な概念について議論する必要があります。 バックトラックは、入力を「消費しない」処理により時間を遡る方法です。 これは主に分岐で重要です。ここに一例を示します。</p>
<pre class="haskel"><code>alternatives :: Parser (Char, Char)
alternatives = foo &lt;|&gt; bar
  where
    foo = (,) &lt;$&gt; char &#39;a&#39; &lt;*&gt; char &#39;b&#39;
    bar = (,) &lt;$&gt; char &#39;a&#39; &lt;*&gt; char &#39;c&#39;</code></pre>
<p>合理的に見えますが、これを試してみましょう。</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb31-1"><a href="#cb31-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> alternatives <span class="st">&quot;ab&quot;</span></span>
<span id="cb31-2"><a href="#cb31-2"></a><span class="kw">(</span><span class="st">&#39;a&#39;</span>,<span class="st">&#39;b&#39;</span><span class="kw">)</span></span>
<span id="cb31-3"><a href="#cb31-3"></a></span>
<span id="cb31-4"><a href="#cb31-4"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> alternatives <span class="st">&quot;ac&quot;</span></span>
<span id="cb31-5"><a href="#cb31-5"></a><span class="ex">1</span>:2:</span>
<span id="cb31-6"><a href="#cb31-6"></a>  <span class="kw">|</span></span>
<span id="cb31-7"><a href="#cb31-7"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">ac</span></span>
<span id="cb31-8"><a href="#cb31-8"></a>  <span class="kw">|</span>  ^</span>
<span id="cb31-9"><a href="#cb31-9"></a><span class="ex">unexpected</span> <span class="st">&#39;c&#39;</span></span>
<span id="cb31-10"><a href="#cb31-10"></a><span class="ex">expecting</span> <span class="st">&#39;b&#39;</span></span></code></pre></div>
<p>ここで起きたことは、 <code>foo</code> の <code>char 'a'</code> の部分(これが最初に試行されます)の成功と、 入力ストリームからの <code>a</code> の消費です。 <code>char 'b'</code> は <code>'c'</code>とのマッチに失敗したため、エラーになりました。 ここで重要なことは、 <code>foo</code> が何らかの入力を消費しているので <code>(&lt;|&gt;)</code> は <code>bar</code> を試していないということです！</p>
<p>これはパフォーマンス上の理由から行われており、 また、<code>foo</code> の残り物を <code>bar</code> に与えて実行するのは意味が無いです。 <code>bar</code> は <code>foo</code> と同じ場所の入力ストリームから実行したいです。 <code>megaparsec</code> は <code>attoparsec</code> や前の章のトイコンビネータとは異なり、 自動で戻りません。そのため、<code>try</code> と呼ばれるプリミティブを使用して、 明示的にバックトラックしたいという願望を表現する必要があります。 <code>try p</code> は、 <code>p</code> が入力の消費に失敗した場合、 入力が消費されていないかのように失敗します (実際、パーサの状態全体をバックトラックします)。 これにより <code>(&lt;|&gt;)</code> で右側の選択肢を試すことが可能になります。</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1"></a><span class="ot">alternatives ::</span> <span class="dt">Parser</span> (<span class="dt">Char</span>, <span class="dt">Char</span>)</span>
<span id="cb32-2"><a href="#cb32-2"></a>alternatives <span class="ot">=</span> try foo <span class="op">&lt;|&gt;</span> bar</span>
<span id="cb32-3"><a href="#cb32-3"></a>  <span class="kw">where</span></span>
<span id="cb32-4"><a href="#cb32-4"></a>    foo <span class="ot">=</span> (,) <span class="op">&lt;$&gt;</span> char <span class="ch">&#39;a&#39;</span> <span class="op">&lt;*&gt;</span> char <span class="ch">&#39;b&#39;</span></span>
<span id="cb32-5"><a href="#cb32-5"></a>    bar <span class="ot">=</span> (,) <span class="op">&lt;$&gt;</span> char <span class="ch">&#39;a&#39;</span> <span class="op">&lt;*&gt;</span> char <span class="ch">&#39;c&#39;</span></span></code></pre></div>
<div class="sourceCode" id="cb33"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb33-1"><a href="#cb33-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> alternatives <span class="st">&quot;ac&quot;</span></span>
<span id="cb33-2"><a href="#cb33-2"></a><span class="kw">(</span><span class="st">&#39;a&#39;</span>,<span class="st">&#39;c&#39;</span><span class="kw">)</span></span></code></pre></div>
<p>実際に入力を消費するすべてのプリミティブ （<code>try</code> などの既存のパーサの動作を変更するプリミティブもあります）は、 入力の消費という点で「アトミック」です。 これは、失敗した場合に自動的にバックトラックするため、 入力を消費して途中で失敗することはできないことを意味します。 これが、<code>pScheme</code> の選択肢のリストが機能する理由です。 つまり、<code>string</code> は <code>tokens</code> の上に定義され、<code>tokens</code> はプリミティブです。 文字列全体を <code>string</code> でマッチさせるか、 入力ストリームをまったく消費せずに失敗します。</p>
<p>URIのパースに戻ると、 <code>(&lt;|&gt;)</code> を使った <code>optional</code> という便利なコンビネータを作ることができます。</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1"></a><span class="ot">optional ::</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f (<span class="dt">Maybe</span> a)</span>
<span id="cb34-2"><a href="#cb34-2"></a>optional p <span class="ot">=</span> (<span class="dt">Just</span> <span class="op">&lt;$&gt;</span> p) <span class="op">&lt;|&gt;</span> <span class="fu">pure</span> <span class="dt">Nothing</span></span></code></pre></div>
<p><code>optional p</code> の <code>p</code> でマッチすれば、結果は <code>Just</code> になります。 そうでなければ <code>Nothing</code> が返されます。 ちょうど欲ほしかったものです！ <code>optional</code> を定義する必要はありません、 <code>Text.Megaparsec</code> はこのコンビネータを再エクスポートします。 これを <code>pUri</code> で使うことができます。</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1"></a><span class="ot">pUri ::</span> <span class="dt">Parser</span> <span class="dt">Uri</span></span>
<span id="cb35-2"><a href="#cb35-2"></a>pUri <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb35-3"><a href="#cb35-3"></a>  uriScheme <span class="ot">&lt;-</span> pScheme</span>
<span id="cb35-4"><a href="#cb35-4"></a>  void (char <span class="ch">&#39;:&#39;</span>)</span>
<span id="cb35-5"><a href="#cb35-5"></a>  uriAuthority <span class="ot">&lt;-</span> optional <span class="op">.</span> try <span class="op">$</span> <span class="kw">do</span>            <span class="co">-- (1)</span></span>
<span id="cb35-6"><a href="#cb35-6"></a>    void (string <span class="st">&quot;//&quot;</span>)</span>
<span id="cb35-7"><a href="#cb35-7"></a>    authUser <span class="ot">&lt;-</span> optional <span class="op">.</span> try <span class="op">$</span> <span class="kw">do</span>              <span class="co">-- (2)</span></span>
<span id="cb35-8"><a href="#cb35-8"></a>      user <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar       <span class="co">-- (3)</span></span>
<span id="cb35-9"><a href="#cb35-9"></a>      void (char <span class="ch">&#39;:&#39;</span>)</span>
<span id="cb35-10"><a href="#cb35-10"></a>      password <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar</span>
<span id="cb35-11"><a href="#cb35-11"></a>      void (char <span class="ch">&#39;@&#39;</span>)</span>
<span id="cb35-12"><a href="#cb35-12"></a>      <span class="fu">return</span> (user, password)</span>
<span id="cb35-13"><a href="#cb35-13"></a>    authHost <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some (alphaNumChar <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;.&#39;</span>)</span>
<span id="cb35-14"><a href="#cb35-14"></a>    authPort <span class="ot">&lt;-</span> optional (char <span class="ch">&#39;:&#39;</span> <span class="op">*&gt;</span> L.decimal) <span class="co">-- (4)</span></span>
<span id="cb35-15"><a href="#cb35-15"></a>    <span class="fu">return</span> <span class="dt">Authority</span> {<span class="op">..</span>}                        <span class="co">-- (5)</span></span>
<span id="cb35-16"><a href="#cb35-16"></a>  <span class="fu">return</span> <span class="dt">Uri</span> {<span class="op">..</span>}                                <span class="co">-- (6)</span></span></code></pre></div>
<p>ユーザー名とパスワードとして 任意の英数字の文字列を受け入れることができるようにし、 同様にホストの形式を単純化しました。</p>
<p>以下に重要な点を挙げます。</p>
<ul>
<li><ol type="1">
<li>と (2) では、 <code>optional</code> の引数を <code>try</code> でラップする必要があります。 これは複合パーサであり、プリミティブではないためです。</li>
</ol></li>
<li><ol start="3" type="1">
<li><code>some</code> は <code>many</code> に似ていますが、その引数のパーサが少なくとも一度はマッチすることを要求します(<code>some p =（:) &lt;$&gt; p &lt;*&gt; many p</code>)。</li>
</ol></li>
<li><ol start="4" type="1">
<li>必要でない限り <code>try</code> を使わないでください！ここでは <code>char ':'</code> が成功すると (<code>token</code> の上に構築されているので, <code>try</code> は必要はありません)、そのあとに必ずポートが続かなければならないことがわかっているので、<code>L.decimal</code> により 10進数を要求します。<code>:</code> にマッチした後は、後戻りできないので、戻る方法は必要ありません。</li>
</ol></li>
<li><ol start="5" type="1">
<li>と (6) では、<code>RecordWildCards</code> 言語拡張を使用して <code>Authority</code> と <code>Uri</code> の値を作り上げます。</li>
</ol></li>
</ul>
<p>GHCiで <code>pUri</code> を試し、それが機能することを確認してください。</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb36-1"><a href="#cb36-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pUri <span class="op">&lt;</span>* eof) <span class="st">&quot;https://mark:secret@example.com&quot;</span></span>
<span id="cb36-2"><a href="#cb36-2"></a><span class="ex">Uri</span></span>
<span id="cb36-3"><a href="#cb36-3"></a>  <span class="kw">{</span> <span class="ex">uriScheme</span> = SchemeHttps</span>
<span id="cb36-4"><a href="#cb36-4"></a>  , <span class="ex">uriAuthority</span> = Just (Authority</span>
<span id="cb36-5"><a href="#cb36-5"></a>    <span class="kw">{</span> <span class="ex">authUser</span> = Just (<span class="st">&quot;mark&quot;</span>,<span class="st">&quot;secret&quot;</span>)</span>
<span id="cb36-6"><a href="#cb36-6"></a>    , <span class="ex">authHost</span> = <span class="st">&quot;example.com&quot;</span></span>
<span id="cb36-7"><a href="#cb36-7"></a>    , <span class="ex">authPort</span> = Nothing <span class="kw">}</span> ) <span class="kw">}</span></span>
<span id="cb36-8"><a href="#cb36-8"></a></span>
<span id="cb36-9"><a href="#cb36-9"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pUri <span class="op">&lt;</span>* eof) <span class="st">&quot;https://mark:secret@example.com:123&quot;</span></span>
<span id="cb36-10"><a href="#cb36-10"></a><span class="ex">Uri</span></span>
<span id="cb36-11"><a href="#cb36-11"></a>  <span class="kw">{</span> <span class="ex">uriScheme</span> = SchemeHttps</span>
<span id="cb36-12"><a href="#cb36-12"></a>  , <span class="ex">uriAuthority</span> = Just (Authority</span>
<span id="cb36-13"><a href="#cb36-13"></a>    <span class="kw">{</span> <span class="ex">authUser</span> = Just (<span class="st">&quot;mark&quot;</span>,<span class="st">&quot;secret&quot;</span>)</span>
<span id="cb36-14"><a href="#cb36-14"></a>    , <span class="ex">authHost</span> = <span class="st">&quot;example.com&quot;</span></span>
<span id="cb36-15"><a href="#cb36-15"></a>    , <span class="ex">authPort</span> = Just 123 <span class="kw">}</span> ) <span class="kw">}</span></span>
<span id="cb36-16"><a href="#cb36-16"></a></span>
<span id="cb36-17"><a href="#cb36-17"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pUri <span class="op">&lt;</span>* eof) <span class="st">&quot;https://example.com:123&quot;</span></span>
<span id="cb36-18"><a href="#cb36-18"></a><span class="ex">Uri</span></span>
<span id="cb36-19"><a href="#cb36-19"></a>  <span class="kw">{</span> <span class="ex">uriScheme</span> = SchemeHttps</span>
<span id="cb36-20"><a href="#cb36-20"></a>  , <span class="ex">uriAuthority</span> = Just (Authority</span>
<span id="cb36-21"><a href="#cb36-21"></a>    <span class="kw">{</span> <span class="ex">authUser</span> = Nothing</span>
<span id="cb36-22"><a href="#cb36-22"></a>    , <span class="ex">authHost</span> = <span class="st">&quot;example.com&quot;</span></span>
<span id="cb36-23"><a href="#cb36-23"></a>    , <span class="ex">authPort</span> = Just 123 <span class="kw">}</span> ) <span class="kw">}</span></span>
<span id="cb36-24"><a href="#cb36-24"></a></span>
<span id="cb36-25"><a href="#cb36-25"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pUri <span class="op">&lt;</span>* eof) <span class="st">&quot;https://mark@example.com:123&quot;</span></span>
<span id="cb36-26"><a href="#cb36-26"></a><span class="ex">1</span>:13:</span>
<span id="cb36-27"><a href="#cb36-27"></a>  <span class="kw">|</span></span>
<span id="cb36-28"><a href="#cb36-28"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">https</span>://mark@example.com:123</span>
<span id="cb36-29"><a href="#cb36-29"></a>  <span class="kw">|</span>             ^</span>
<span id="cb36-30"><a href="#cb36-30"></a><span class="ex">unexpected</span> <span class="st">&#39;@&#39;</span></span>
<span id="cb36-31"><a href="#cb36-31"></a><span class="ex">expecting</span> <span class="st">&#39;.&#39;</span>, <span class="st">&#39;:&#39;</span>, alphanumeric character, or end of input</span></code></pre></div>
<p><a name="Debug"></a></p>
<h2 id="パーサのデバッグ">パーサのデバッグ</h2>
<p>面白いことが起こっていることに気付くかもしれません。</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1"></a>λ<span class="op">&gt;</span> parseTest (pUri <span class="op">&lt;*</span> eof) <span class="st">&quot;https://mark:@example.com&quot;</span></span>
<span id="cb37-2"><a href="#cb37-2"></a><span class="dv">1</span><span class="op">:</span><span class="dv">7</span><span class="op">:</span></span>
<span id="cb37-3"><a href="#cb37-3"></a>  <span class="op">|</span></span>
<span id="cb37-4"><a href="#cb37-4"></a><span class="dv">1</span> <span class="op">|</span> https<span class="op">://</span>mark<span class="op">:@</span>example<span class="op">.</span>com</span>
<span id="cb37-5"><a href="#cb37-5"></a>  <span class="op">|</span>       <span class="op">^</span></span>
<span id="cb37-6"><a href="#cb37-6"></a>unexpected <span class="ch">&#39;/&#39;</span></span>
<span id="cb37-7"><a href="#cb37-7"></a>expecting end <span class="kw">of</span> input</span></code></pre></div>
<p>パースエラーを改善できそうです。何をすればいいでしょうか？ 何が起きているのかを知る最も簡単な方法は、 組み込みのヘルパー <code>dbg</code> を使うことです。</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1"></a><span class="ot">dbg ::</span> (<span class="dt">Stream</span> s, <span class="dt">ShowToken</span> (<span class="dt">Token</span> s), <span class="dt">ShowErrorComponent</span> e, <span class="dt">Show</span> a)</span>
<span id="cb38-2"><a href="#cb38-2"></a>  <span class="ot">=&gt;</span> <span class="dt">String</span>            <span class="co">-- ^ デバッグ用のラベル</span></span>
<span id="cb38-3"><a href="#cb38-3"></a>  <span class="ot">-&gt;</span> <span class="dt">ParsecT</span> e s m a   <span class="co">-- ^ デバッグするパーサ</span></span>
<span id="cb38-4"><a href="#cb38-4"></a>  <span class="ot">-&gt;</span> <span class="dt">ParsecT</span> e s m a   <span class="co">-- ^ デバッグメッセージを出力するパーサ</span></span></code></pre></div>
<p>これを <code>pUri</code> で使ってみましょう。</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1"></a><span class="ot">pUri ::</span> <span class="dt">Parser</span> <span class="dt">Uri</span></span>
<span id="cb39-2"><a href="#cb39-2"></a>pUri <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb39-3"><a href="#cb39-3"></a>  uriScheme <span class="ot">&lt;-</span> dbg <span class="st">&quot;scheme&quot;</span> pScheme</span>
<span id="cb39-4"><a href="#cb39-4"></a>  void (char <span class="ch">&#39;:&#39;</span>)</span>
<span id="cb39-5"><a href="#cb39-5"></a>  uriAuthority <span class="ot">&lt;-</span> dbg <span class="st">&quot;auth&quot;</span> <span class="op">.</span> optional <span class="op">.</span> try <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb39-6"><a href="#cb39-6"></a>    void (string <span class="st">&quot;//&quot;</span>)</span>
<span id="cb39-7"><a href="#cb39-7"></a>    authUser <span class="ot">&lt;-</span> dbg <span class="st">&quot;user&quot;</span> <span class="op">.</span> optional <span class="op">.</span> try <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb39-8"><a href="#cb39-8"></a>      user <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar</span>
<span id="cb39-9"><a href="#cb39-9"></a>      void (char <span class="ch">&#39;:&#39;</span>)</span>
<span id="cb39-10"><a href="#cb39-10"></a>      password <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar</span>
<span id="cb39-11"><a href="#cb39-11"></a>      void (char <span class="ch">&#39;@&#39;</span>)</span>
<span id="cb39-12"><a href="#cb39-12"></a>      <span class="fu">return</span> (user, password)</span>
<span id="cb39-13"><a href="#cb39-13"></a>    authHost <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> dbg <span class="st">&quot;host&quot;</span> (some (alphaNumChar <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;.&#39;</span>))</span>
<span id="cb39-14"><a href="#cb39-14"></a>    authPort <span class="ot">&lt;-</span> dbg <span class="st">&quot;port&quot;</span> <span class="op">$</span> optional (char <span class="ch">&#39;:&#39;</span> <span class="op">*&gt;</span> L.decimal)</span>
<span id="cb39-15"><a href="#cb39-15"></a>    <span class="fu">return</span> <span class="dt">Authority</span> {<span class="op">..</span>}</span>
<span id="cb39-16"><a href="#cb39-16"></a>  <span class="fu">return</span> <span class="dt">Uri</span> {<span class="op">..</span>}</span></code></pre></div>
<p>それでは、その不幸な入力に対してもう一度 <code>pUri</code> を実行してみましょう。</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1"></a>λ<span class="op">&gt;</span> parseTest (pUri <span class="op">&lt;*</span> eof) <span class="st">&quot;https://mark:@example.com&quot;</span></span>
<span id="cb40-2"><a href="#cb40-2"></a>scheme<span class="op">&gt;</span> <span class="dt">IN</span><span class="op">:</span> <span class="st">&quot;https://mark:@example.com&quot;</span></span>
<span id="cb40-3"><a href="#cb40-3"></a>scheme<span class="op">&gt;</span> <span class="dt">MATCH</span> (<span class="dt">COK</span>)<span class="op">:</span> <span class="st">&quot;https&quot;</span></span>
<span id="cb40-4"><a href="#cb40-4"></a>scheme<span class="op">&gt;</span> <span class="dt">VALUE</span><span class="op">:</span> <span class="dt">SchemeHttps</span></span>
<span id="cb40-5"><a href="#cb40-5"></a></span>
<span id="cb40-6"><a href="#cb40-6"></a>user<span class="op">&gt;</span> <span class="dt">IN</span><span class="op">:</span> <span class="st">&quot;mark:@example.com&quot;</span></span>
<span id="cb40-7"><a href="#cb40-7"></a>user<span class="op">&gt;</span> <span class="dt">MATCH</span> (<span class="dt">EOK</span>)<span class="op">:</span> <span class="op">&lt;</span><span class="dt">EMPTY</span><span class="op">&gt;</span></span>
<span id="cb40-8"><a href="#cb40-8"></a>user<span class="op">&gt;</span> <span class="dt">VALUE</span><span class="op">:</span> <span class="dt">Nothing</span></span>
<span id="cb40-9"><a href="#cb40-9"></a></span>
<span id="cb40-10"><a href="#cb40-10"></a>host<span class="op">&gt;</span> <span class="dt">IN</span><span class="op">:</span> <span class="st">&quot;mark:@example.com&quot;</span></span>
<span id="cb40-11"><a href="#cb40-11"></a>host<span class="op">&gt;</span> <span class="dt">MATCH</span> (<span class="dt">COK</span>)<span class="op">:</span> <span class="st">&quot;mark&quot;</span></span>
<span id="cb40-12"><a href="#cb40-12"></a>host<span class="op">&gt;</span> <span class="dt">VALUE</span><span class="op">:</span> <span class="st">&quot;mark&quot;</span></span>
<span id="cb40-13"><a href="#cb40-13"></a></span>
<span id="cb40-14"><a href="#cb40-14"></a>port<span class="op">&gt;</span> <span class="dt">IN</span><span class="op">:</span> <span class="st">&quot;:@example.com&quot;</span></span>
<span id="cb40-15"><a href="#cb40-15"></a>port<span class="op">&gt;</span> <span class="dt">MATCH</span> (<span class="dt">CERR</span>)<span class="op">:</span> <span class="ch">&#39;:&#39;</span></span>
<span id="cb40-16"><a href="#cb40-16"></a>port<span class="op">&gt;</span> <span class="dt">ERROR</span><span class="op">:</span></span>
<span id="cb40-17"><a href="#cb40-17"></a>port<span class="op">&gt;</span> <span class="dv">1</span><span class="op">:</span><span class="dv">14</span><span class="op">:</span></span>
<span id="cb40-18"><a href="#cb40-18"></a>port<span class="op">&gt;</span> unexpected <span class="ch">&#39;@&#39;</span></span>
<span id="cb40-19"><a href="#cb40-19"></a>port<span class="op">&gt;</span> expecting integer</span>
<span id="cb40-20"><a href="#cb40-20"></a></span>
<span id="cb40-21"><a href="#cb40-21"></a>auth<span class="op">&gt;</span> <span class="dt">IN</span><span class="op">:</span> <span class="st">&quot;//mark:@example.com&quot;</span></span>
<span id="cb40-22"><a href="#cb40-22"></a>auth<span class="op">&gt;</span> <span class="dt">MATCH</span> (<span class="dt">EOK</span>)<span class="op">:</span> <span class="op">&lt;</span><span class="dt">EMPTY</span><span class="op">&gt;</span></span>
<span id="cb40-23"><a href="#cb40-23"></a>auth<span class="op">&gt;</span> <span class="dt">VALUE</span><span class="op">:</span> <span class="dt">Nothing</span></span>
<span id="cb40-24"><a href="#cb40-24"></a></span>
<span id="cb40-25"><a href="#cb40-25"></a><span class="dv">1</span><span class="op">:</span><span class="dv">7</span><span class="op">:</span></span>
<span id="cb40-26"><a href="#cb40-26"></a>  <span class="op">|</span></span>
<span id="cb40-27"><a href="#cb40-27"></a><span class="dv">1</span> <span class="op">|</span> https<span class="op">://</span>mark<span class="op">:@</span>example<span class="op">.</span>com</span>
<span id="cb40-28"><a href="#cb40-28"></a>  <span class="op">|</span>       <span class="op">^</span></span>
<span id="cb40-29"><a href="#cb40-29"></a>unexpected <span class="ch">&#39;/&#39;</span></span>
<span id="cb40-30"><a href="#cb40-30"></a>expecting end <span class="kw">of</span> input</span></code></pre></div>
<p><code>megaparsec</code> の内部で何が起こっているのか正確にわかります。</p>
<ul>
<li><p><code>scheme</code> のマッチに成功します。</p></li>
<li><p><code>user</code> は失敗します。<code>mark</code> の所にユーザー名がありますが、<code>:</code> の後にパスワードはありません（ここではパスワードを空にしないことを要求します）。失敗し、<code>try</code> のおかげでバックトラックします。</p></li>
<li><p><code>host</code> は <code>user</code> と同じ場所から開始し、入力をホスト名として解釈しようとします。これは成功し、ホスト名として <code>mark</code> を返すことがわかります。</p></li>
<li><p><code>host</code> の後にポート番号があるかもしれないので、<code>port</code> は機会を得ます。それは <code>:</code> を見ますが、その後に整数がないので <code>port</code> は失敗します。</p></li>
<li><p>そのため、<code>auth</code> パーサ全体が失敗します（<code>port</code> は <code>auth</code> の内側にあり、失敗しました）。</p></li>
<li><p><code>auth</code> パーサは、何もパースできなかったため、<code>Nothing</code>を返します。<code>eof</code> は入力の終わりに達したことを要求しますが、そうではないので、最終的なエラーメッセージが表示されます。</p></li>
</ul>
<p>何をすべきでしょうか？これは、<code>try</code> を使用してコードの大部分を囲むと、 パースエラーが悪化する可能性がある場合の例です。 パースしたい構文をもう一度見てみましょう。</p>
<pre><code>scheme:[//[user:password@]host[:port]][/]path[?query][#fragment]</code></pre>
<p>私たちは何を探していますか？ パースのある特定の分岐にコミットできるようにするための何か。 <code>:</code> を見たときにポート番号が続かなければならないポートのように。 注意深く見れば、二重スラッシュ<code>//</code>が、URIに認証情報の部分があることを示す記号であることがわかります。 <code>//</code> のマッチはアトミックパーサ（<code>string</code>）が使われていることにより、 マッチは自動的にバックトラックするので、 <code>//</code> にマッチした後は恐れずに、認証情報の部分を要求することができます。 最初の<code>try</code>を<code>pUri</code>から削除しましょう。</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1"></a><span class="ot">pUri ::</span> <span class="dt">Parser</span> <span class="dt">Uri</span></span>
<span id="cb42-2"><a href="#cb42-2"></a>pUri <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb42-3"><a href="#cb42-3"></a>  uriScheme <span class="ot">&lt;-</span> pScheme</span>
<span id="cb42-4"><a href="#cb42-4"></a>  void (char <span class="ch">&#39;:&#39;</span>)</span>
<span id="cb42-5"><a href="#cb42-5"></a>  uriAuthority <span class="ot">&lt;-</span> optional <span class="op">$</span> <span class="kw">do</span> <span class="co">-- この行から try を削除した</span></span>
<span id="cb42-6"><a href="#cb42-6"></a>    void (string <span class="st">&quot;//&quot;</span>)</span>
<span id="cb42-7"><a href="#cb42-7"></a>    authUser <span class="ot">&lt;-</span> optional <span class="op">.</span> try <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb42-8"><a href="#cb42-8"></a>      user <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar</span>
<span id="cb42-9"><a href="#cb42-9"></a>      void (char <span class="ch">&#39;:&#39;</span>)</span>
<span id="cb42-10"><a href="#cb42-10"></a>      password <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar</span>
<span id="cb42-11"><a href="#cb42-11"></a>      void (char <span class="ch">&#39;@&#39;</span>)</span>
<span id="cb42-12"><a href="#cb42-12"></a>      <span class="fu">return</span> (user, password)</span>
<span id="cb42-13"><a href="#cb42-13"></a>    authHost <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some (alphaNumChar <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;.&#39;</span>)</span>
<span id="cb42-14"><a href="#cb42-14"></a>    authPort <span class="ot">&lt;-</span> optional (char <span class="ch">&#39;:&#39;</span> <span class="op">*&gt;</span> L.decimal)</span>
<span id="cb42-15"><a href="#cb42-15"></a>    <span class="fu">return</span> <span class="dt">Authority</span> {<span class="op">..</span>}</span>
<span id="cb42-16"><a href="#cb42-16"></a>  <span class="fu">return</span> <span class="dt">Uri</span> {<span class="op">..</span>}</span></code></pre></div>
<p>これで、より良いパースエラーを得られるようになりました。</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb43-1"><a href="#cb43-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pUri <span class="op">&lt;</span>* eof) <span class="st">&quot;https://mark:@example.com&quot;</span></span>
<span id="cb43-2"><a href="#cb43-2"></a><span class="ex">1</span>:14:</span>
<span id="cb43-3"><a href="#cb43-3"></a>  <span class="kw">|</span></span>
<span id="cb43-4"><a href="#cb43-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">https</span>://mark:@example.com</span>
<span id="cb43-5"><a href="#cb43-5"></a>  <span class="kw">|</span>              ^</span>
<span id="cb43-6"><a href="#cb43-6"></a><span class="ex">unexpected</span> <span class="st">&#39;@&#39;</span></span>
<span id="cb43-7"><a href="#cb43-7"></a><span class="ex">expecting</span> integer</span></code></pre></div>
<p>まだ少し誤解を招くようですが、まあ、それは私が選んだトリッキーな例です。 たくさんの<code>optional</code>。</p>
<p><a name="Label"></a></p>
<h2 id="ラベル付けと隠蔽">ラベル付けと隠蔽</h2>
<p>時には期待されるアイテムのリストがかなり長くなるかもしれません。 認識されていないスキームを使用しようとしたときに得られるものを覚えていますか？</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb44-1"><a href="#cb44-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pUri <span class="op">&lt;</span>* eof) <span class="st">&quot;foo://example.com&quot;</span></span>
<span id="cb44-2"><a href="#cb44-2"></a><span class="ex">1</span>:1:</span>
<span id="cb44-3"><a href="#cb44-3"></a>  <span class="kw">|</span></span>
<span id="cb44-4"><a href="#cb44-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">foo</span>://example.com</span>
<span id="cb44-5"><a href="#cb44-5"></a>  <span class="kw">|</span> ^</span>
<span id="cb44-6"><a href="#cb44-6"></a><span class="ex">unexpected</span> <span class="st">&quot;foo://&quot;</span></span>
<span id="cb44-7"><a href="#cb44-7"></a><span class="ex">expecting</span> <span class="st">&quot;data&quot;</span>, <span class="st">&quot;file&quot;</span>, <span class="st">&quot;ftp&quot;</span>, <span class="st">&quot;http&quot;</span>, <span class="st">&quot;https&quot;</span>, <span class="st">&quot;irc&quot;</span>, or <span class="st">&quot;mailto&quot;</span></span></code></pre></div>
<p><code>megaparsec</code> は、一般的に<em>ラベル</em>と呼ばれるカスタムで、期待されるアイテムを上書きする方法を提供します。これは、<code>label</code> プリミティブ(<code>(&lt;?&gt;)</code> 演算子の形式のシノニムを持つ)を使用して行われます。</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1"></a><span class="ot">pUri ::</span> <span class="dt">Parser</span> <span class="dt">Uri</span></span>
<span id="cb45-2"><a href="#cb45-2"></a>pUri <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb45-3"><a href="#cb45-3"></a>  uriScheme <span class="ot">&lt;-</span> pScheme <span class="op">&lt;?&gt;</span> <span class="st">&quot;valid scheme&quot;</span></span>
<span id="cb45-4"><a href="#cb45-4"></a>  <span class="co">-- 残りの部分は同じ</span></span></code></pre></div>
<div class="sourceCode" id="cb46"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb46-1"><a href="#cb46-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pUri <span class="op">&lt;</span>* eof) <span class="st">&quot;foo://example.com&quot;</span></span>
<span id="cb46-2"><a href="#cb46-2"></a><span class="ex">1</span>:1:</span>
<span id="cb46-3"><a href="#cb46-3"></a>  <span class="kw">|</span></span>
<span id="cb46-4"><a href="#cb46-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">foo</span>://example.com</span>
<span id="cb46-5"><a href="#cb46-5"></a>  <span class="kw">|</span> ^</span>
<span id="cb46-6"><a href="#cb46-6"></a><span class="ex">unexpected</span> <span class="st">&quot;foo://&quot;</span></span>
<span id="cb46-7"><a href="#cb46-7"></a><span class="ex">expecting</span> valid scheme</span></code></pre></div>
<p>エラーメッセージを読みやすくするために、ラベルを追加します。</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1"></a><span class="ot">pUri ::</span> <span class="dt">Parser</span> <span class="dt">Uri</span></span>
<span id="cb47-2"><a href="#cb47-2"></a>pUri <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb47-3"><a href="#cb47-3"></a>  uriScheme <span class="ot">&lt;-</span> pScheme <span class="op">&lt;?&gt;</span> <span class="st">&quot;valid scheme&quot;</span></span>
<span id="cb47-4"><a href="#cb47-4"></a>  void (char <span class="ch">&#39;:&#39;</span>)</span>
<span id="cb47-5"><a href="#cb47-5"></a>  uriAuthority <span class="ot">&lt;-</span> optional <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb47-6"><a href="#cb47-6"></a>    void (string <span class="st">&quot;//&quot;</span>)</span>
<span id="cb47-7"><a href="#cb47-7"></a>    authUser <span class="ot">&lt;-</span> optional <span class="op">.</span> try <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb47-8"><a href="#cb47-8"></a>      user <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar <span class="op">&lt;?&gt;</span> <span class="st">&quot;username&quot;</span></span>
<span id="cb47-9"><a href="#cb47-9"></a>      void (char <span class="ch">&#39;:&#39;</span>)</span>
<span id="cb47-10"><a href="#cb47-10"></a>      password <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar <span class="op">&lt;?&gt;</span> <span class="st">&quot;password&quot;</span></span>
<span id="cb47-11"><a href="#cb47-11"></a>      void (char <span class="ch">&#39;@&#39;</span>)</span>
<span id="cb47-12"><a href="#cb47-12"></a>      <span class="fu">return</span> (user, password)</span>
<span id="cb47-13"><a href="#cb47-13"></a>    authHost <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some (alphaNumChar <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;.&#39;</span>) <span class="op">&lt;?&gt;</span> <span class="st">&quot;hostname&quot;</span></span>
<span id="cb47-14"><a href="#cb47-14"></a>    authPort <span class="ot">&lt;-</span> optional (char <span class="ch">&#39;:&#39;</span> <span class="op">*&gt;</span> label <span class="st">&quot;port number&quot;</span> L.decimal)</span>
<span id="cb47-15"><a href="#cb47-15"></a>    <span class="fu">return</span> <span class="dt">Authority</span> {<span class="op">..</span>}</span>
<span id="cb47-16"><a href="#cb47-16"></a>  <span class="fu">return</span> <span class="dt">Uri</span> {<span class="op">..</span>}</span></code></pre></div>
<p>例:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb48-1"><a href="#cb48-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pUri <span class="op">&lt;</span>* eof) <span class="st">&quot;https://mark:@example.com&quot;</span></span>
<span id="cb48-2"><a href="#cb48-2"></a><span class="ex">1</span>:14:</span>
<span id="cb48-3"><a href="#cb48-3"></a>  <span class="kw">|</span></span>
<span id="cb48-4"><a href="#cb48-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">https</span>://mark:@example.com</span>
<span id="cb48-5"><a href="#cb48-5"></a>  <span class="kw">|</span>              ^</span>
<span id="cb48-6"><a href="#cb48-6"></a><span class="ex">unexpected</span> <span class="st">&#39;@&#39;</span></span>
<span id="cb48-7"><a href="#cb48-7"></a><span class="ex">expecting</span> port number</span></code></pre></div>
<p>もう1つのプリミティブは <code>hidden</code> と呼ばれます。 <code>label</code> が名前の変更であることに対し、 hiddenは単にそれらを完全に削除します。 比較しましょう。</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb49-1"><a href="#cb49-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (many (char <span class="st">&#39;a&#39;</span>) <span class="op">&gt;&gt;</span> <span class="ex">many</span> (char <span class="st">&#39;b&#39;</span>) <span class="op">&gt;&gt;</span> <span class="ex">eof</span> :: Parser ()) <span class="st">&quot;d&quot;</span></span>
<span id="cb49-2"><a href="#cb49-2"></a><span class="ex">1</span>:1:</span>
<span id="cb49-3"><a href="#cb49-3"></a>  <span class="kw">|</span></span>
<span id="cb49-4"><a href="#cb49-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">d</span></span>
<span id="cb49-5"><a href="#cb49-5"></a>  <span class="kw">|</span> ^</span>
<span id="cb49-6"><a href="#cb49-6"></a><span class="ex">unexpected</span> <span class="st">&#39;d&#39;</span></span>
<span id="cb49-7"><a href="#cb49-7"></a><span class="ex">expecting</span> <span class="st">&#39;a&#39;</span>, <span class="st">&#39;b&#39;</span>, or end of input</span>
<span id="cb49-8"><a href="#cb49-8"></a></span>
<span id="cb49-9"><a href="#cb49-9"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (many (char <span class="st">&#39;a&#39;</span>) <span class="op">&gt;&gt;</span> <span class="ex">hidden</span> (many (char <span class="st">&#39;b&#39;</span>)) <span class="op">&gt;&gt;</span> <span class="ex">eof</span> :: Parser ()) <span class="st">&quot;d&quot;</span></span>
<span id="cb49-10"><a href="#cb49-10"></a><span class="ex">1</span>:1:</span>
<span id="cb49-11"><a href="#cb49-11"></a>  <span class="kw">|</span></span>
<span id="cb49-12"><a href="#cb49-12"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">d</span></span>
<span id="cb49-13"><a href="#cb49-13"></a>  <span class="kw">|</span> ^</span>
<span id="cb49-14"><a href="#cb49-14"></a><span class="ex">unexpected</span> <span class="st">&#39;d&#39;</span></span>
<span id="cb49-15"><a href="#cb49-15"></a><span class="ex">expecting</span> <span class="st">&#39;a&#39;</span> or end of input</span></code></pre></div>
<p>エラーメッセージのノイズを少なくすることが望ましい場合は、 <code>hidden</code> を使用してください。 例えば、プログラミング言語をパースするときは、通常、各トークンの後に空白文字がある可能性があるため、“expecting white space” というメッセージを削除することをお勧めします。</p>
<p>演習 : <code>pUri</code> パーサを完成させることは読者のための課題として残されています。完成に必要なすべてのツールは説明されました。</p>
<p><a name="Run"></a></p>
<h2 id="パーサの実行">パーサの実行</h2>
<p>パーサを構築する方法を詳細に調べました。 しかし、 <code>parseTest</code> を除いて、 それらを実行できる関数を調べていませんでした。</p>
<p>慣習的に、あなたがプログラムしたパーサを実行するための “デフォルト”の関数は <code>parse</code> でした。 しかし、<code>parse</code> は実際には <code>runParser</code> のシノニムです。</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1"></a>runParser</span>
<span id="cb50-2"><a href="#cb50-2"></a><span class="ot">  ::</span> <span class="dt">Parsec</span> e s a <span class="co">-- ^ 実行するパーサ</span></span>
<span id="cb50-3"><a href="#cb50-3"></a>  <span class="ot">-&gt;</span> <span class="dt">String</span>     <span class="co">-- ^ ソースファイルの名前</span></span>
<span id="cb50-4"><a href="#cb50-4"></a>  <span class="ot">-&gt;</span> s          <span class="co">-- ^ パーサへの入力</span></span>
<span id="cb50-5"><a href="#cb50-5"></a>  <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">ParseErrorBundle</span> s e) a</span></code></pre></div>
<p>2番目の引数は、生成されたパースエラーに含まれる単なるファイル名です。 実際の入力は関数の3番目の引数として渡されるため、 <code>megaparsec</code> はそのファイルから何も読みません。</p>
<p><code>runParser</code> を使用すると、<code>Parsec</code> モナドを実行できます。 これは、既にご存知のとおり、変換子を使わないバージョンの <code>ParsecT</code> です。</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1"></a><span class="kw">type</span> <span class="dt">Parsec</span> e s <span class="ot">=</span> <span class="dt">ParsecT</span> e s <span class="dt">Identity</span></span></code></pre></div>
<p><code>runParser</code> には、<code>runParser'</code>、<code>runParserT</code>、 および <code>runParserT'</code> の3つの姉妹がいます。 接尾辞 <code>T</code> の付いたバージョンは <code>PrasecT</code> モナド変換子を実行し、 「プライム」バージョンはパーサの状態を受け取り、返します。 すべての関数を表にまとめましょう。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">引数</th>
<th style="text-align: left;"><code>Parsec</code> の実行</th>
<th style="text-align: left;"><code>ParsecT</code> の実行</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">入力とファイル名</td>
<td style="text-align: left;"><code>runParser</code></td>
<td style="text-align: left;"><code>runParserT</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">カスタム初期状態</td>
<td style="text-align: left;"><code>runParser'</code></td>
<td style="text-align: left;"><code>runParserT'</code></td>
</tr>
</tbody>
</table>
<p>タブの幅を標準以外の値(デフォルトの値は8)に設定したい場合など、 カスタム初期状態が必要な場合があります。 <code>runParser'</code> はこのようになっています。</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1"></a>runParser&#39;</span>
<span id="cb52-2"><a href="#cb52-2"></a><span class="ot">  ::</span> <span class="dt">Parsec</span> e s a <span class="co">-- ^ 実行するパーサ</span></span>
<span id="cb52-3"><a href="#cb52-3"></a>  <span class="ot">-&gt;</span> <span class="dt">State</span> s    <span class="co">-- ^ 初期状態</span></span>
<span id="cb52-4"><a href="#cb52-4"></a>  <span class="ot">-&gt;</span> (<span class="dt">State</span> s, <span class="dt">Either</span> (<span class="dt">ParseErrorBundle</span> s e) a)</span></code></pre></div>
<p>手動で状態を変更することはライブラリの高度な使用法であり、 ここでは説明しません。</p>
<p><code>ParseErrorBundle</code> とは何かについて疑問に思う場合は、 <a href="#Error">この後の章のいずれか</a>で説明します。</p>
<p><a name="MonadParsec"></a></p>
<h2 id="monadparsec-型クラス"><code>MonadParsec</code> 型クラス</h2>
<p><code>megaparsec</code> のすべてのツールは、 <code>MonadParsec</code> 型クラスの任意のインスタンスと連携します。 型クラスは、プリミティブコンビネータ、 つまりすべての <code>megaparsec</code> のパーサの基本的な構成要素、 他のコンビネータでは表現できないコンビネータを抽象化します。</p>
<p>プリミティブコンビネータを型クラスに持つことで、 <code>megaarsec</code> の <code>ParsecT</code> の主要なモナド変換子を、 MTL系のよく知られている変換子にラップして、 モナドスタックのレイヤー間でさまざまな相互作用を実現することができます。 動機をよりよく理解するために、 モナドスタック内のレイヤーの順序が重要であることを思い出してください。 このように <code>ReaderT</code> と <code>State</code> を組み合わせると、</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1"></a><span class="kw">type</span> <span class="dt">MyStack</span> a <span class="ot">=</span> <span class="dt">ReaderT</span> <span class="dt">MyContext</span> (<span class="dt">State</span> <span class="dt">MyState</span>) a</span></code></pre></div>
<p>外側のレイヤー <code>ReaderT</code> はその下のレイヤー <code>m</code> の内部構造を検査できません。 <code>ReaderT</code> の <code>Monad</code> インスタンスはバインディングの戦略を記述しています。</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1"></a><span class="kw">newtype</span> <span class="dt">ReaderT</span> r m a <span class="ot">=</span> <span class="dt">ReaderT</span> {<span class="ot"> runReaderT ::</span> r <span class="ot">-&gt;</span> m a }</span>
<span id="cb54-2"><a href="#cb54-2"></a></span>
<span id="cb54-3"><a href="#cb54-3"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">ReaderT</span> r m) <span class="kw">where</span></span>
<span id="cb54-4"><a href="#cb54-4"></a>  m <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="dt">ReaderT</span> <span class="op">$</span> \r <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb54-5"><a href="#cb54-5"></a>    a <span class="ot">&lt;-</span> runReaderT m r</span>
<span id="cb54-6"><a href="#cb54-6"></a>    runReaderT (k a) r</span></code></pre></div>
<p>実際、<code>m</code> について私たちが知っている唯一のことは、 それが <code>Monad</code>のインスタンスであり、 したがって <code>m</code> の状態はモナディックバインドを介してのみ <code>k</code> に渡すことができるということです。 とにかくそれが <code>ReaderT</code> の <code>(&gt;&gt;=)</code> から私たちが通常欲しいものです。</p>
<p><code>Alternative</code> 型クラスの <code>(&lt;|&gt;)</code> メソッドは異なった働きをします。 それは状態を「分割」し、パーサの2つの分岐はもう接触しません。 そのため、最初の分岐が破棄されるとその状態への変更も破棄され、 2番目の分岐に影響を与えることはできないという意味で バックトラックした状態になります (最初の分岐が失敗したときの状態を「バックトラック」します。)。</p>
<p>説明のために、ReaderTのAlternativeの定義を見てみましょう。</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1"></a><span class="kw">instance</span> <span class="dt">Alternative</span> m <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">ReaderT</span> r m) <span class="kw">where</span></span>
<span id="cb55-2"><a href="#cb55-2"></a>  empty <span class="ot">=</span> liftReaderT empty</span>
<span id="cb55-3"><a href="#cb55-3"></a>  <span class="dt">ReaderT</span> m <span class="op">&lt;|&gt;</span> <span class="dt">ReaderT</span> n <span class="ot">=</span> <span class="dt">ReaderT</span> <span class="op">$</span> \r <span class="ot">-&gt;</span> m r <span class="op">&lt;|&gt;</span> n r</span></code></pre></div>
<p><code>ReaderT</code> は「ステートレス」なモナド変換子であり、 (何を持っていない) <code>ReaderT</code> 自体に関連するモナドの状態を組み合わせる必要なしに(ここで <code>m</code> の <code>Alternative</code> インスタンスが役に立ちます。) 実際の作業を内部のモナドに委任するのは簡単なので、 これはすべて非常に素晴らしいことです。</p>
<p>それでは、Stateを見てみましょう。 <code>State s a</code> は <code>StateT s Identity a</code> の単なるシノニムなので、 <code>StateT s m</code> 自体の <code>Alternative</code> インスタンスを見てください。</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1"></a><span class="kw">instance</span> (<span class="dt">Functor</span> m, <span class="dt">Alternative</span> m) <span class="ot">=&gt;</span> <span class="dt">Alternative</span> (<span class="dt">StateT</span> s m) <span class="kw">where</span></span>
<span id="cb56-2"><a href="#cb56-2"></a>  empty <span class="ot">=</span> <span class="dt">StateT</span> <span class="op">$</span> \_ <span class="ot">-&gt;</span> empty</span>
<span id="cb56-3"><a href="#cb56-3"></a>  <span class="dt">StateT</span> m <span class="op">&lt;|&gt;</span> <span class="dt">StateT</span> n <span class="ot">=</span> <span class="dt">StateT</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> m s <span class="op">&lt;|&gt;</span> n s</span></code></pre></div>
<p>ここでは、reader のコンテキスト <code>r</code> の共有を見たように、 状態 <code>s</code> の分割を見ることができます。 ただし、<code>m s</code> と <code>n s</code> の式はステートフルな結果を生成するため、 モナディック値と一緒に、新しい状態をタプルで返すという違いがあります。 ここでは、<code>m s</code> か <code>n s</code> のどちらかで進み、 自然にバックトラックを達成します。</p>
<p><code>ParsecT</code> はどうですか？ <code>State</code> を <code>ParsecT</code> の中に次のように置くことを考えてみましょう。</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1"></a><span class="kw">type</span> <span class="dt">MyStack</span> a <span class="ot">=</span> <span class="dt">ParsecT</span> <span class="dt">Void</span> <span class="dt">Text</span> (<span class="dt">State</span> <span class="dt">MyState</span>) a</span></code></pre></div>
<p><code>ParsecT</code> は <code>ReaderT</code> よりも複雑で、<code>(&lt;|&gt;)</code>の実装にはもっと多くのことが必要です。</p>
<ul>
<li>パーサ自体の状態管理</li>
<li>起こるべき（適切な）パースエラーのマージ。</li>
</ul>
<p><code>ParsecT</code> の <code>Alternative</code> のインスタンスへの<code>(&lt;|&gt;)</code>の実装は、 その基盤となる <code>State MyState</code> モナドの <code>Alternative</code>インスタンスに その作業を委任することができないので、<code>MyState</code>の分割は発生せず、 バックトラックはありません。</p>
<p>例を挙げて説明しましょう。</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb58-2"><a href="#cb58-2"></a></span>
<span id="cb58-3"><a href="#cb58-3"></a><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></span>
<span id="cb58-4"><a href="#cb58-4"></a></span>
<span id="cb58-5"><a href="#cb58-5"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb58-6"><a href="#cb58-6"></a><span class="kw">import</span> <span class="dt">Control.Monad.State.Strict</span></span>
<span id="cb58-7"><a href="#cb58-7"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb58-8"><a href="#cb58-8"></a><span class="kw">import</span> <span class="dt">Data.Void</span></span>
<span id="cb58-9"><a href="#cb58-9"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span> <span class="kw">hiding</span> (<span class="dt">State</span>)</span>
<span id="cb58-10"><a href="#cb58-10"></a></span>
<span id="cb58-11"><a href="#cb58-11"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">ParsecT</span> <span class="dt">Void</span> <span class="dt">Text</span> (<span class="dt">State</span> <span class="dt">String</span>)</span>
<span id="cb58-12"><a href="#cb58-12"></a></span>
<span id="cb58-13"><a href="#cb58-13"></a><span class="ot">parser0 ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb58-14"><a href="#cb58-14"></a>parser0 <span class="ot">=</span> a <span class="op">&lt;|&gt;</span> b</span>
<span id="cb58-15"><a href="#cb58-15"></a>  <span class="kw">where</span></span>
<span id="cb58-16"><a href="#cb58-16"></a>    a <span class="ot">=</span> <span class="st">&quot;foo&quot;</span> <span class="op">&lt;$</span> put <span class="st">&quot;branch A&quot;</span></span>
<span id="cb58-17"><a href="#cb58-17"></a>    b <span class="ot">=</span> get   <span class="op">&lt;*</span> put <span class="st">&quot;branch B&quot;</span></span>
<span id="cb58-18"><a href="#cb58-18"></a></span>
<span id="cb58-19"><a href="#cb58-19"></a><span class="ot">parser1 ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb58-20"><a href="#cb58-20"></a>parser1 <span class="ot">=</span> a <span class="op">&lt;|&gt;</span> b</span>
<span id="cb58-21"><a href="#cb58-21"></a>  <span class="kw">where</span></span>
<span id="cb58-22"><a href="#cb58-22"></a>    a <span class="ot">=</span> <span class="st">&quot;foo&quot;</span> <span class="op">&lt;$</span> put <span class="st">&quot;branch A&quot;</span> <span class="op">&lt;*</span> empty</span>
<span id="cb58-23"><a href="#cb58-23"></a>    b <span class="ot">=</span> get   <span class="op">&lt;*</span> put <span class="st">&quot;branch B&quot;</span></span>
<span id="cb58-24"><a href="#cb58-24"></a></span>
<span id="cb58-25"><a href="#cb58-25"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb58-26"><a href="#cb58-26"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb58-27"><a href="#cb58-27"></a>  <span class="kw">let</span> run p          <span class="ot">=</span> runState (runParserT p <span class="st">&quot;&quot;</span> <span class="st">&quot;&quot;</span>) <span class="st">&quot;initial&quot;</span></span>
<span id="cb58-28"><a href="#cb58-28"></a>      (<span class="dt">Right</span> a0, s0) <span class="ot">=</span> run parser0</span>
<span id="cb58-29"><a href="#cb58-29"></a>      (<span class="dt">Right</span> a1, s1) <span class="ot">=</span> run parser1</span>
<span id="cb58-30"><a href="#cb58-30"></a></span>
<span id="cb58-31"><a href="#cb58-31"></a>  <span class="fu">putStrLn</span>  <span class="st">&quot;Parser 0&quot;</span></span>
<span id="cb58-32"><a href="#cb58-32"></a>  <span class="fu">putStrLn</span> (<span class="st">&quot;Result:      &quot;</span> <span class="op">++</span> <span class="fu">show</span> a0)</span>
<span id="cb58-33"><a href="#cb58-33"></a>  <span class="fu">putStrLn</span> (<span class="st">&quot;Final state: &quot;</span> <span class="op">++</span> <span class="fu">show</span> s0)</span>
<span id="cb58-34"><a href="#cb58-34"></a></span>
<span id="cb58-35"><a href="#cb58-35"></a>  <span class="fu">putStrLn</span>  <span class="st">&quot;Parser 1&quot;</span></span>
<span id="cb58-36"><a href="#cb58-36"></a>  <span class="fu">putStrLn</span> (<span class="st">&quot;Result:      &quot;</span> <span class="op">++</span> <span class="fu">show</span> a1)</span>
<span id="cb58-37"><a href="#cb58-37"></a>  <span class="fu">putStrLn</span> (<span class="st">&quot;Final state: &quot;</span> <span class="op">++</span> <span class="fu">show</span> s1)</span></code></pre></div>
<p>これがプログラムを実行した結果です。</p>
<pre><code>Parser 0
Result:      &quot;foo&quot;
Final state: &quot;branch A&quot;
Parser 1
Result:      &quot;branch A&quot;
Final state: &quot;branch B&quot;</code></pre>
<p><code>parser0</code> を使うと、分岐 <code>b</code> が試行されていないことがわかります。 しかしparser1では、<code>empty</code> によって失敗し、 成功したのは分岐 <code>b</code> であるにもかかわらず、 最終結果（<code>get</code> によって返される値）が分岐 <code>a</code>から得られることは明らかです。 (パーサの文脈では <code>empty</code> は 「即座に失敗し、何が起こったのかについての情報がない」 という意味です。) バックトラックは発生しません。</p>
<p>パーサーでカスタム状態をバックトラックしたい場合はどうしますか？ <code>ParsecT</code> を <code>StateT</code> 内にラップすることを許可するならば、それを提供することができます。</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1"></a><span class="kw">type</span> <span class="dt">MyStack</span> a <span class="ot">=</span> <span class="dt">StateT</span> <span class="dt">MyState</span> (<span class="dt">ParsecT</span> <span class="dt">Void</span> <span class="dt">Text</span> <span class="dt">Identity</span>) a</span></code></pre></div>
<p><code>MyStack</code> で <code>(&lt;|&gt;)</code> を使用すると、 使用されるインスタンスは <code>StateT</code> のインスタンスになります。</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1"></a><span class="dt">StateT</span> m <span class="op">&lt;|&gt;</span> <span class="dt">StateT</span> n <span class="ot">=</span> <span class="dt">StateT</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> m s <span class="op">&lt;|&gt;</span> n s</span></code></pre></div>
<p>これは状態をバックトラックさせ、 それから残りの作業をその内部モナド<code>ParsecT</code> の <code>Alternative</code> インスタンスに委任します。 この動作はまさに私たちが望むものです。</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb62-2"><a href="#cb62-2"></a></span>
<span id="cb62-3"><a href="#cb62-3"></a><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></span>
<span id="cb62-4"><a href="#cb62-4"></a></span>
<span id="cb62-5"><a href="#cb62-5"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb62-6"><a href="#cb62-6"></a><span class="kw">import</span> <span class="dt">Control.Monad.Identity</span></span>
<span id="cb62-7"><a href="#cb62-7"></a><span class="kw">import</span> <span class="dt">Control.Monad.State.Strict</span></span>
<span id="cb62-8"><a href="#cb62-8"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb62-9"><a href="#cb62-9"></a><span class="kw">import</span> <span class="dt">Data.Void</span></span>
<span id="cb62-10"><a href="#cb62-10"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span> <span class="kw">hiding</span> (<span class="dt">State</span>)</span>
<span id="cb62-11"><a href="#cb62-11"></a></span>
<span id="cb62-12"><a href="#cb62-12"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">StateT</span> <span class="dt">String</span> (<span class="dt">ParsecT</span> <span class="dt">Void</span> <span class="dt">Text</span> <span class="dt">Identity</span>)</span>
<span id="cb62-13"><a href="#cb62-13"></a></span>
<span id="cb62-14"><a href="#cb62-14"></a><span class="ot">parser ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb62-15"><a href="#cb62-15"></a>parser <span class="ot">=</span> a <span class="op">&lt;|&gt;</span> b</span>
<span id="cb62-16"><a href="#cb62-16"></a>  <span class="kw">where</span></span>
<span id="cb62-17"><a href="#cb62-17"></a>    a <span class="ot">=</span> <span class="st">&quot;foo&quot;</span> <span class="op">&lt;$</span> put <span class="st">&quot;branch A&quot;</span> <span class="op">&lt;*</span> empty</span>
<span id="cb62-18"><a href="#cb62-18"></a>    b <span class="ot">=</span> get   <span class="op">&lt;*</span> put <span class="st">&quot;branch B&quot;</span></span>
<span id="cb62-19"><a href="#cb62-19"></a></span>
<span id="cb62-20"><a href="#cb62-20"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb62-21"><a href="#cb62-21"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb62-22"><a href="#cb62-22"></a>  <span class="kw">let</span> p            <span class="ot">=</span> runStateT parser <span class="st">&quot;initial&quot;</span></span>
<span id="cb62-23"><a href="#cb62-23"></a>      <span class="dt">Right</span> (a, s) <span class="ot">=</span> runParser p <span class="st">&quot;&quot;</span> <span class="st">&quot;&quot;</span></span>
<span id="cb62-24"><a href="#cb62-24"></a>  <span class="fu">putStrLn</span> (<span class="st">&quot;Result:      &quot;</span> <span class="op">++</span> <span class="fu">show</span> a)</span>
<span id="cb62-25"><a href="#cb62-25"></a>  <span class="fu">putStrLn</span> (<span class="st">&quot;Final state: &quot;</span> <span class="op">++</span> <span class="fu">show</span> s)</span></code></pre></div>
<p>プログラムは次のように出力します。</p>
<pre><code>Result:      &quot;initial&quot;
Final state: &quot;branch B&quot;</code></pre>
<p>このアプローチを実行可能にするために、 <code>StateT</code> はプリミティブパーサのセット全体をサポートするべきであり、 そうすることで <code>ParsecT</code> と同じようにそれを扱うことができます。 言い換えれば、 内部モナドが(MTLの)<code>MonadWriter</code>のインスタンスである場合は <code>MonadState</code> だけではなく、<code>MonadWriter</code>も <code>MonadParsec</code>のインスタンスである必要があります。</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1"></a><span class="kw">instance</span> <span class="dt">MonadWriter</span> w m <span class="ot">=&gt;</span> <span class="dt">MonadWriter</span> w (<span class="dt">StateT</span> s m) <span class="kw">where</span> …</span></code></pre></div>
<p>確かに、<code>MonadParsec</code> の内部インスタンスから <code>StateT</code> に プリミティブを持ち上げることができます。</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1"></a><span class="kw">instance</span> <span class="dt">MonadParsec</span> e s m <span class="ot">=&gt;</span> <span class="dt">MonadParsec</span> e s (<span class="dt">StateT</span> st m) <span class="kw">where</span> …</span></code></pre></div>
<p><code>megaparsec</code>は MTL のすべてのモナド変換子に対して <code>MonadParsec</code> のインスタンスを定義しているので、 ユーザーは変換子を <code>ParsecT</code> の内側に挿入したり、 それらの変換子で <code>ParsecT</code> をラップしたりして、 モナドスタックの層間で異なる種類の相互作用を実現できます。</p>
<p><a name="Lexing"></a></p>
<h2 id="字句解析">字句解析</h2>
<p>字句解析は、入力ストリームを整数、キーワード、シンボルなどのトークン のストリームに変換するプロセスです。 これらは、生の入力を直接パースするよりもパースが容易であるか、 またはパーサジェネレータで生成されたパーサへの入力として期待されます。 字句解析は、<code>alex</code>などの外部ツールを使用して別のパスで実行できますが、 <code>megaparsec</code>はパーサの一部として、シームレスに字句解析プログラムを書くことを簡単にする関数も提供します。</p>
<p>文字ストリーム用の <code>Text.Megaparsec.Char.Lexer</code> と バイトストリーム用の <code>Text.Megaparsec.Byte.Lexer</code> の 2つの字句解析モジュールがあります。 正格な <code>Text</code> を入力ストリームとして扱うので <code>Text.Megaparsec.Char.Lexer</code> を使いますが、 <code>ByteStrings</code> を使いたい場合はほとんどの関数は <code>Text.Megaparsec.Byte.Lexer</code> にも反映されます。</p>
<p><a name="White"></a></p>
<h2 id="空白">空白</h2>
<p>最初に取り上げる必要があるトピックは、空白の扱いです。 すべてのトークンの前またはすべてのトークンの後に、 一貫した方法で空白を消費することが役立ちます。 Megaparsec の字句解析モジュールは、 「トークンの前に空白を入れず、トークンの後にすべての空白を消費する」 という戦略に従います。</p>
<p>空白を消費するには、<em>スペースコンシューマ</em> と呼ばれる特別なパーサが必要です。 <code>Text.Megaparsec.Char.Lexer</code> モジュールは、 一般的なスペースコンシューマを構築するためのヘルパーを提供します。</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1"></a><span class="ot">space ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb66-2"><a href="#cb66-2"></a>  <span class="ot">=&gt;</span> m () <span class="co">-- ^ 空の入力を受け入れない空白文字のパーサ</span></span>
<span id="cb66-3"><a href="#cb66-3"></a>          <span class="co">-- (e.g. &#39;space1&#39;)</span></span>
<span id="cb66-4"><a href="#cb66-4"></a>  <span class="ot">-&gt;</span> m () <span class="co">-- ^ 行コメントのパーサ (e.g. &#39;skipLineComment&#39;)</span></span>
<span id="cb66-5"><a href="#cb66-5"></a>  <span class="ot">-&gt;</span> m () <span class="co">-- ^ ブロックコメントのパーサ (e.g. &#39;skipBlockComment&#39;)</span></span>
<span id="cb66-6"><a href="#cb66-6"></a>  <span class="ot">-&gt;</span> m ()</span></code></pre></div>
<p><code>space</code> 関数のドキュメンテーションはそれ自体で非常に包括的ですが、 例を挙げて補足しましょう。</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb67-2"><a href="#cb67-2"></a></span>
<span id="cb67-3"><a href="#cb67-3"></a><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></span>
<span id="cb67-4"><a href="#cb67-4"></a></span>
<span id="cb67-5"><a href="#cb67-5"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb67-6"><a href="#cb67-6"></a><span class="kw">import</span> <span class="dt">Data.Void</span></span>
<span id="cb67-7"><a href="#cb67-7"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span></span>
<span id="cb67-8"><a href="#cb67-8"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec.Char</span></span>
<span id="cb67-9"><a href="#cb67-9"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Megaparsec.Char.Lexer</span> <span class="kw">as</span> <span class="dt">L</span> <span class="co">-- (1)</span></span>
<span id="cb67-10"><a href="#cb67-10"></a></span>
<span id="cb67-11"><a href="#cb67-11"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Void</span> <span class="dt">Text</span></span>
<span id="cb67-12"><a href="#cb67-12"></a></span>
<span id="cb67-13"><a href="#cb67-13"></a><span class="ot">sc ::</span> <span class="dt">Parser</span> ()</span>
<span id="cb67-14"><a href="#cb67-14"></a>sc <span class="ot">=</span> L.space</span>
<span id="cb67-15"><a href="#cb67-15"></a>  space1                         <span class="co">-- (2)</span></span>
<span id="cb67-16"><a href="#cb67-16"></a>  (L.skipLineComment <span class="st">&quot;//&quot;</span>)       <span class="co">-- (3)</span></span>
<span id="cb67-17"><a href="#cb67-17"></a>  (L.skipBlockComment <span class="st">&quot;/*&quot;</span> <span class="st">&quot;*/&quot;</span>) <span class="co">-- (4)</span></span></code></pre></div>
<p>いくつかのメモ：</p>
<ul>
<li><p><code>Text.Megaparsec.Char.Lexer</code>は、修飾付きでインポートされることを意図されています。なぜなら、Text.Megaparsec.Charの<code>space</code>のように衝突する名前を含んでいるからです。</p></li>
<li><p><code>L.space</code> の最初の引数は空白を拾うために使用されることになっているパーサであるべきです。重要な点は、<code>L.space</code>が無限ループに入ってしまうので、空の入力を受け入れてはいけないということです。<code>space1</code>は、要件を完全に満たす <code>Text.Megaparsec.Char</code> のパーサです。</p></li>
<li><p><code>L.space</code> の2番目の引数は、行コメント、すなわち、与えられたトークンのシーケンスで始まり行の終わりで終わるコメントをスキップする方法を定義します。<code>skipLineComment</code> ヘルパーを使用すると、行コメント用の補助パーサを簡単に作成できます。</p></li>
<li><p><code>L.space</code> の3番目の引数は、ブロックコメント、つまりトークンの開始シーケンスと終了シーケンスの間のすべてのものをを受け取る方法を定義します。<code>skipBlockComment</code> ヘルパーは、ネストされていないブロックコメントを扱うことができます。ネストされたブロックコメントをサポートする場合は、代わりに <code>skipBlockCommentNested</code> を使用してください。</p></li>
</ul>
<p>操作的には、<code>L.space</code> は3つすべてのパーサを適用できなくなるまで、順番に試行します。つまり、空白がすべて消費されたことになります。 これを知っていれば、文法にブロックコメントや行コメントが含まれていない場合は、<code>L.space</code>の2番目または3番目の引数として<code>empty</code>を渡すことができます。 <code>(&lt;|&gt;)</code> の単位元である <code>empty</code> は、<code>L.space</code> が次の空白要素のためにパーサを試みるようにします。まさに望んでいたことです。</p>
<p>スペースコンシューマ <code>sc</code> を持っているなら、 さまざまな空白関連のヘルパーを定義できます。</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb68-1"><a href="#cb68-1"></a><span class="ot">lexeme ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb68-2"><a href="#cb68-2"></a>lexeme <span class="ot">=</span> L.lexeme sc <span class="co">-- (1)</span></span>
<span id="cb68-3"><a href="#cb68-3"></a></span>
<span id="cb68-4"><a href="#cb68-4"></a><span class="ot">symbol ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Text</span></span>
<span id="cb68-5"><a href="#cb68-5"></a>symbol <span class="ot">=</span> L.symbol sc <span class="co">-- (2)</span></span></code></pre></div>
<ul>
<li><p><code>lexeme</code> は、供給されたスペースコンシューマを使用してすべての末尾の空白を取る、語彙素のラッパーです。</p></li>
<li><p><code>symbol</code> は内部で <code>string</code> を使って与えられたテキストにマッチさせ、そして同様にすべての末尾の空白を拾うパーサです。</p></li>
</ul>
<p>私たちはすぐにそれがすべて一緒に動作する方法を見ますが、 最初に <code>Text.Megaparsec.Char.Lexer</code> からさらに2,3のヘルパーを 導入する必要があります。</p>
<p><a name="Chara"></a></p>
<h2 id="文字と文字列リテラル">文字と文字列リテラル</h2>
<p>エスケープ規則はさまざまなので、 文字リテラルおよび文字列リテラルのパースは難しい場合があります。 簡単にするために、<code>megaparsec</code> は <code>charLiteral</code> パーサを提供します。</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb69-1"><a href="#cb69-1"></a><span class="ot">charLiteral ::</span> (<span class="dt">MonadParsec</span> e s m, <span class="dt">Token</span> s <span class="op">~</span> <span class="dt">Char</span>) <span class="ot">=&gt;</span> m <span class="dt">Char</span></span></code></pre></div>
<p><code>charLiteral</code> の仕事は、Haskellレポートに記述されている文字リテラルの構文に従ってエスケープされる可能性がある単一の文字をパースすることです。 ただし、次の2つの理由から、リテラルを囲む引用符はパースされません。</p>
<ul>
<li><p>ユーザーは文字リテラルの引用方法を制御できる</p></li>
<li><p>そのため、charLiteralを使用して文字列リテラルもパースできる</p></li>
</ul>
<p><code>charLiteral</code>の上に構築されたパーサの例をいくつか示します。</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb70-1"><a href="#cb70-1"></a><span class="ot">charLiteral ::</span> <span class="dt">Parser</span> <span class="dt">Char</span></span>
<span id="cb70-2"><a href="#cb70-2"></a>charLiteral <span class="ot">=</span> between (char <span class="ch">&#39;\&#39;&#39;</span>) (char <span class="ch">&#39;\&#39;&#39;</span>) L.charLiteral</span>
<span id="cb70-3"><a href="#cb70-3"></a></span>
<span id="cb70-4"><a href="#cb70-4"></a><span class="ot">stringLiteral ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb70-5"><a href="#cb70-5"></a>stringLiteral <span class="ot">=</span> char <span class="ch">&#39;\&quot;&#39;</span> <span class="op">*&gt;</span> manyTill L.charLiteral (char <span class="ch">&#39;\&quot;&#39;</span>)</span></code></pre></div>
<ul>
<li><p><code>L.charLiteral</code> を文字リテラルのパーサに変えるには、囲む引用符を追加するだけです。ここではHaskellの構文に従い、シングルクオートを使います。<code>between</code>コンビネータは、単純に<code>between open close p = open *&gt; p &lt;* close</code>ように定義されます。</p></li>
<li><p><code>stringLiteral</code>はダブルクオートで囲まれた文字列リテラル内の個々の文字をパースするために <code>L.charLiteral</code> を使用します。</p></li>
</ul>
<p>2番目の関数も、<code>manyTill</code> コンビネータを使用しているため興味深いです。</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb71-1"><a href="#cb71-1"></a><span class="ot">manyTill ::</span> <span class="dt">Alternative</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> m end <span class="ot">-&gt;</span> m [a]</span>
<span id="cb71-2"><a href="#cb71-2"></a>manyTill p end <span class="ot">=</span> go</span>
<span id="cb71-3"><a href="#cb71-3"></a>  <span class="kw">where</span></span>
<span id="cb71-4"><a href="#cb71-4"></a>    go <span class="ot">=</span> ([] <span class="op">&lt;$</span> end) <span class="op">&lt;|&gt;</span> ((<span class="op">:</span>) <span class="op">&lt;$&gt;</span> p <span class="op">&lt;*&gt;</span> go)</span></code></pre></div>
<p><code>manyTill</code> は繰り返しごとにパーサ <code>end</code> を適用しようとし、 失敗するとパーサ <code>p</code> を実行して <code>p</code> の結果をリストに蓄積します。</p>
<p>少なくとも1つのアイテムが存在することを要求する <code>someTill</code> もあります。</p>
<p><a name="Numbers"></a></p>
<h2 id="数字">数字</h2>
<p>最後に、非常に一般的なニーズは数値をパースすることです。 整数の場合、10進数、8進数、および16進数の表現で 値をパースできる3つのヘルパーがあります。</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb72-1"><a href="#cb72-1"></a>decimal, octal, hexadecimal</span>
<span id="cb72-2"><a href="#cb72-2"></a><span class="ot">  ::</span> (<span class="dt">MonadParsec</span> e s m, <span class="dt">Token</span> s <span class="op">~</span> <span class="dt">Char</span>, <span class="dt">Integral</span> a) <span class="ot">=&gt;</span> m a</span></code></pre></div>
<p>それらを使うのは簡単です。</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb73-1"><a href="#cb73-1"></a><span class="ot">integer ::</span> <span class="dt">Parser</span> <span class="dt">Integer</span></span>
<span id="cb73-2"><a href="#cb73-2"></a>integer <span class="ot">=</span> lexeme L.decimal</span></code></pre></div>
<div class="sourceCode" id="cb74"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb74-1"><a href="#cb74-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (integer <span class="op">&lt;</span>* eof) <span class="st">&quot;123  &quot;</span></span>
<span id="cb74-2"><a href="#cb74-2"></a><span class="ex">123</span></span>
<span id="cb74-3"><a href="#cb74-3"></a></span>
<span id="cb74-4"><a href="#cb74-4"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (integer <span class="op">&lt;</span>* eof) <span class="st">&quot;12a  &quot;</span></span>
<span id="cb74-5"><a href="#cb74-5"></a><span class="ex">1</span>:3:</span>
<span id="cb74-6"><a href="#cb74-6"></a>  <span class="kw">|</span></span>
<span id="cb74-7"><a href="#cb74-7"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">12a</span></span>
<span id="cb74-8"><a href="#cb74-8"></a>  <span class="kw">|</span>   ^</span>
<span id="cb74-9"><a href="#cb74-9"></a><span class="ex">unexpected</span> <span class="st">&#39;a&#39;</span></span>
<span id="cb74-10"><a href="#cb74-10"></a><span class="ex">expecting</span> end of input or the rest of integer</span></code></pre></div>
<p><code>scientific</code> と <code>float</code> は整数と小数の文法を受け入れます。 <code>scientific</code> は<code>scientific</code>パッケージの <code>Scientific</code>型を返しますが、 <code>float</code> はその結果の型が多相的であり、 <code>RealFloat</code> の任意のインスタンスを返すことができます。</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb75-1"><a href="#cb75-1"></a><span class="ot">scientific ::</span> (<span class="dt">MonadParsec</span> e s m, <span class="dt">Token</span> s <span class="op">~</span> <span class="dt">Char</span>)              <span class="ot">=&gt;</span> m <span class="dt">Scientific</span></span>
<span id="cb75-2"><a href="#cb75-2"></a><span class="ot">float      ::</span> (<span class="dt">MonadParsec</span> e s m, <span class="dt">Token</span> s <span class="op">~</span> <span class="dt">Char</span>, <span class="dt">RealFloat</span> a) <span class="ot">=&gt;</span> m a</span></code></pre></div>
<p>例：</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb76-1"><a href="#cb76-1"></a><span class="ot">float ::</span> <span class="dt">Parser</span> <span class="dt">Double</span></span>
<span id="cb76-2"><a href="#cb76-2"></a>float <span class="ot">=</span> lexeme L.float</span></code></pre></div>
<div class="sourceCode" id="cb77"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb77-1"><a href="#cb77-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (float <span class="op">&lt;</span>* eof) <span class="st">&quot;123&quot;</span></span>
<span id="cb77-2"><a href="#cb77-2"></a><span class="ex">1</span>:4:</span>
<span id="cb77-3"><a href="#cb77-3"></a>  <span class="kw">|</span></span>
<span id="cb77-4"><a href="#cb77-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">123</span></span>
<span id="cb77-5"><a href="#cb77-5"></a>  <span class="kw">|</span>    ^</span>
<span id="cb77-6"><a href="#cb77-6"></a><span class="ex">unexpected</span> end of input</span>
<span id="cb77-7"><a href="#cb77-7"></a><span class="ex">expecting</span> <span class="st">&#39;.&#39;</span>, <span class="st">&#39;E&#39;</span>, <span class="st">&#39;e&#39;</span>, or digit</span>
<span id="cb77-8"><a href="#cb77-8"></a></span>
<span id="cb77-9"><a href="#cb77-9"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (float <span class="op">&lt;</span>* eof) <span class="st">&quot;123.45&quot;</span></span>
<span id="cb77-10"><a href="#cb77-10"></a><span class="ex">123.45</span></span>
<span id="cb77-11"><a href="#cb77-11"></a></span>
<span id="cb77-12"><a href="#cb77-12"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (float <span class="op">&lt;</span>* eof) <span class="st">&quot;123d&quot;</span></span>
<span id="cb77-13"><a href="#cb77-13"></a><span class="ex">1</span>:4:</span>
<span id="cb77-14"><a href="#cb77-14"></a>  <span class="kw">|</span></span>
<span id="cb77-15"><a href="#cb77-15"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">123d</span></span>
<span id="cb77-16"><a href="#cb77-16"></a>  <span class="kw">|</span>    ^</span>
<span id="cb77-17"><a href="#cb77-17"></a><span class="ex">unexpected</span> <span class="st">&#39;d&#39;</span></span>
<span id="cb77-18"><a href="#cb77-18"></a><span class="ex">expecting</span> <span class="st">&#39;.&#39;</span>, <span class="st">&#39;E&#39;</span>, <span class="st">&#39;e&#39;</span>, or digit</span></code></pre></div>
<p>これらすべてのパーサは符号付き数値をパースしないことに注意してください。 符号付き数値用のパーサを作成するには、 既存のパーサを <code>signed</code> コンビネータでラップする必要があります。</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb78-1"><a href="#cb78-1"></a><span class="ot">signedInteger ::</span> <span class="dt">Parser</span> <span class="dt">Integer</span></span>
<span id="cb78-2"><a href="#cb78-2"></a>signedInteger <span class="ot">=</span> L.signed sc integer</span>
<span id="cb78-3"><a href="#cb78-3"></a></span>
<span id="cb78-4"><a href="#cb78-4"></a><span class="ot">signedFloat ::</span> <span class="dt">Parser</span> <span class="dt">Double</span></span>
<span id="cb78-5"><a href="#cb78-5"></a>signedFloat <span class="ot">=</span> L.signed sc float</span></code></pre></div>
<p><code>signed</code> の最初の引数(スペースコンシューマ)は、符号と実際の数字の間の空白の消費を制御します。スペースを入れたくない場合は、代わりに<code>return ()</code>を渡してください。</p>
<p><a name="lookAhead"></a></p>
<h2 id="notfollowedby-と-lookahead"><code>notFollowedBy</code> と <code>lookAhead</code></h2>
<p>実際にはパーサの位置を進めずに入力ストリームの 先読みを実行できる(<code>try</code> に加えて)さらに2つのプリミティブがあります。</p>
<p>１つめは <code>notFollowedBy</code> と呼ばれるものです。</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb79-1"><a href="#cb79-1"></a><span class="ot">notFollowedBy ::</span> <span class="dt">MonadParsec</span> e s m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> m ()</span></code></pre></div>
<p>引数のパーサが失敗したときにのみ成功し、 入力を消費したり、パーサの状態を変更することはありません。</p>
<p><code>notFollowedBy</code> を使いたいと思うかもしれない例として、 キーワードのパースを考えます。</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb80-1"><a href="#cb80-1"></a><span class="ot">pKeyword ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Text</span></span>
<span id="cb80-2"><a href="#cb80-2"></a>pKeyword keyword <span class="ot">=</span> lexeme (string keyword)</span></code></pre></div>
<p>このパーサは問題を抱えています。 マッチさせるキーワードが単に識別子の接頭辞であるならどうでしょうか？ その場合、それは間違いなくキーワードではありません。 したがって、<code>notFollowedBy</code> を使用して そのようなケースを排除する必要があります。</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb81-1"><a href="#cb81-1"></a><span class="ot">pKeyword ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Text</span></span>
<span id="cb81-2"><a href="#cb81-2"></a>pKeyword keyword <span class="ot">=</span> lexeme (string keyword <span class="op">&lt;*</span> notFollowedBy alphaNumChar)</span></code></pre></div>
<p>もう1つのプリミティブは<code>lookAhead</code>です。</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb82-1"><a href="#cb82-1"></a><span class="ot">lookAhead ::</span> <span class="dt">MonadParsec</span> e s m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p><code>lookAhead</code> の引数 <code>p</code> が成功すると、<code>lookAhead p</code> 全体も成功しますが、 入力ストリーム（およびパーサの状態全体）はそのまま残ります。 つまり、何も消費されません。</p>
<p>これが有用である可能性がある場所の一例は、 すでにパースされた入力に対してチェックを実行し、 失敗または正常に継続することです。 慣用表現として、次のようなコードで表すことができます。</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb83-1"><a href="#cb83-1"></a>withPredicate1</span>
<span id="cb83-2"><a href="#cb83-2"></a><span class="ot">  ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)       <span class="co">-- ^ パース後の入力の振る舞いの確認</span></span>
<span id="cb83-3"><a href="#cb83-3"></a>  <span class="ot">-&gt;</span> <span class="dt">String</span>            <span class="co">-- ^ チェックが失敗した時に表示するメッセージ</span></span>
<span id="cb83-4"><a href="#cb83-4"></a>  <span class="ot">-&gt;</span> <span class="dt">Parser</span> a          <span class="co">-- ^ 実行するパーサ</span></span>
<span id="cb83-5"><a href="#cb83-5"></a>  <span class="ot">-&gt;</span> <span class="dt">Parser</span> a          <span class="co">-- ^ 振る舞いを確認したパーサの結果</span></span>
<span id="cb83-6"><a href="#cb83-6"></a>withPredicate1 f msg p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb83-7"><a href="#cb83-7"></a>  r <span class="ot">&lt;-</span> lookAhead p</span>
<span id="cb83-8"><a href="#cb83-8"></a>  <span class="kw">if</span> f r</span>
<span id="cb83-9"><a href="#cb83-9"></a>    <span class="kw">then</span> p</span>
<span id="cb83-10"><a href="#cb83-10"></a>    <span class="kw">else</span> <span class="fu">fail</span> msg</span></code></pre></div>
<p>これは <code>lookAhead</code> を使用した例ですが、 チェックが成功した場合に2回パーサを実行しており、 良くないことにも注意してください。 ここに <code>getOffset</code> 関数を使用した代わりの解決方法があります。</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb84-1"><a href="#cb84-1"></a>withPredicate2</span>
<span id="cb84-2"><a href="#cb84-2"></a><span class="ot">  ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)       <span class="co">-- ^ パース後の入力の振る舞いの確認</span></span>
<span id="cb84-3"><a href="#cb84-3"></a>  <span class="ot">-&gt;</span> <span class="dt">String</span>            <span class="co">-- ^ チェックが失敗した時に表示するメッセージ</span></span>
<span id="cb84-4"><a href="#cb84-4"></a>  <span class="ot">-&gt;</span> <span class="dt">Parser</span> a          <span class="co">-- ^ 実行するパーサ</span></span>
<span id="cb84-5"><a href="#cb84-5"></a>  <span class="ot">-&gt;</span> <span class="dt">Parser</span> a          <span class="co">-- ^ 振る舞いを確認したパーサの結果</span></span>
<span id="cb84-6"><a href="#cb84-6"></a>withPredicate2 f msg p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb84-7"><a href="#cb84-7"></a>  o <span class="ot">&lt;-</span> getOffset</span>
<span id="cb84-8"><a href="#cb84-8"></a>  r <span class="ot">&lt;-</span> p</span>
<span id="cb84-9"><a href="#cb84-9"></a>  <span class="kw">if</span> f r</span>
<span id="cb84-10"><a href="#cb84-10"></a>    <span class="kw">then</span> <span class="fu">return</span> r</span>
<span id="cb84-11"><a href="#cb84-11"></a>    <span class="kw">else</span> <span class="kw">do</span></span>
<span id="cb84-12"><a href="#cb84-12"></a>      setOffset o</span>
<span id="cb84-13"><a href="#cb84-13"></a>      <span class="fu">fail</span> msg</span></code></pre></div>
<p>このようにして、入力ストリームの <code>offset</code> を <code>p</code> を実行する前の状態に設定してから失敗します。 未消費の残りとオフセットの位置に不一致がありますが、 <code>fail</code> を呼び出してすぐにパースを終了するので、 この場合は問題になりません。</p>
<p><a name="Expr"></a></p>
<h2 id="式のパース">式のパース</h2>
<p>「式」とは、 項とそれらの項に適用される演算子から形成される構造を意味します。 演算子は、 異なる優先順位で、前置、中置、後置、左と右の結合にすることができます。 このような構文の例として、学校でよく知られている算術式があります。</p>
<pre><code>a * (b + 2)</code></pre>
<p>2種類の項、変数(<code>a</code> と <code>b</code>)と整数(<code>2</code>)を見ることができます。 2つの演算子、<code>*</code>と<code>+</code>もあります。</p>
<p>式のパーサを書くには時間がかかるかもしれません。 これ手助けするために、 <code>megaparsec</code> には <code>Text.Megaparsec.Expr</code> モジュールが付属しています。 これは、<code>Operator</code>データ型と<code>makeExprParser</code>ヘルパーの 2つのだけをエクスポートします。</p>
<p>両方ともよくドキュメント化されているので、 このセクションではドキュメント化を繰り返すことはせず、 代わりに単純だが完全に機能する式のパーサを書くつもりです。</p>
<p>式を表すデータ型を <a href="https://ja.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E6%A7%8B%E6%96%87%E6%9C%A8">AST</a>として定義することから始めましょう。</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb86-1"><a href="#cb86-1"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb86-2"><a href="#cb86-2"></a>  <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">String</span></span>
<span id="cb86-3"><a href="#cb86-3"></a>  <span class="op">|</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb86-4"><a href="#cb86-4"></a>  <span class="op">|</span> <span class="dt">Negation</span> <span class="dt">Expr</span></span>
<span id="cb86-5"><a href="#cb86-5"></a>  <span class="op">|</span> <span class="dt">Sum</span>      <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb86-6"><a href="#cb86-6"></a>  <span class="op">|</span> <span class="dt">Subtr</span>    <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb86-7"><a href="#cb86-7"></a>  <span class="op">|</span> <span class="dt">Product</span>  <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb86-8"><a href="#cb86-8"></a>  <span class="op">|</span> <span class="dt">Division</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb86-9"><a href="#cb86-9"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p><code>makeExprParser</code> を使用するには、 項のパーサと演算子テーブルを指定する必要があります。</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb87-1"><a href="#cb87-1"></a><span class="ot">makeExprParser ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb87-2"><a href="#cb87-2"></a>  <span class="ot">=&gt;</span> m a               <span class="co">-- ^ 項のパーサ</span></span>
<span id="cb87-3"><a href="#cb87-3"></a>  <span class="ot">-&gt;</span> [[<span class="dt">Operator</span> m a]]  <span class="co">-- ^ 演算子テーブル, &#39;Operator&#39;を参照</span></span>
<span id="cb87-4"><a href="#cb87-4"></a>  <span class="ot">-&gt;</span> m a               <span class="co">-- ^ 式のパーサの結果</span></span></code></pre></div>
<p>それでは項のパーサから始めましょう。 結合性や優先順位のようなものを扱う場合、式をパースするアルゴリズムでは、 項をボックスとみなし、分割できない全体として考えることをお勧めします。 この場合、このカテゴリに分類されるものが3つあります。 変数、整数、および括弧内の式全体です。 前の章の定義を使用して、項のパーサを次のように定義できます。</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb88-1"><a href="#cb88-1"></a><span class="ot">pVariable ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb88-2"><a href="#cb88-2"></a>pVariable <span class="ot">=</span> <span class="dt">Var</span> <span class="op">&lt;$&gt;</span> lexeme</span>
<span id="cb88-3"><a href="#cb88-3"></a>  ((<span class="op">:</span>) <span class="op">&lt;$&gt;</span> letterChar <span class="op">&lt;*&gt;</span> many alphaNumChar <span class="op">&lt;?&gt;</span> <span class="st">&quot;variable&quot;</span>)</span>
<span id="cb88-4"><a href="#cb88-4"></a></span>
<span id="cb88-5"><a href="#cb88-5"></a><span class="ot">pInteger ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb88-6"><a href="#cb88-6"></a>pInteger <span class="ot">=</span> <span class="dt">Int</span> <span class="op">&lt;$&gt;</span> lexeme L.decimal</span>
<span id="cb88-7"><a href="#cb88-7"></a></span>
<span id="cb88-8"><a href="#cb88-8"></a><span class="ot">parens ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb88-9"><a href="#cb88-9"></a>parens <span class="ot">=</span> between (symbol <span class="st">&quot;(&quot;</span>) (symbol <span class="st">&quot;)&quot;</span>)</span>
<span id="cb88-10"><a href="#cb88-10"></a></span>
<span id="cb88-11"><a href="#cb88-11"></a><span class="ot">pTerm ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb88-12"><a href="#cb88-12"></a>pTerm <span class="ot">=</span> choice</span>
<span id="cb88-13"><a href="#cb88-13"></a>  [ parens pExpr</span>
<span id="cb88-14"><a href="#cb88-14"></a>  , pVariable</span>
<span id="cb88-15"><a href="#cb88-15"></a>  , pInteger ]</span>
<span id="cb88-16"><a href="#cb88-16"></a></span>
<span id="cb88-17"><a href="#cb88-17"></a><span class="ot">pExpr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb88-18"><a href="#cb88-18"></a>pExpr <span class="ot">=</span> makeExprParser pTerm operatorTable</span>
<span id="cb88-19"><a href="#cb88-19"></a></span>
<span id="cb88-20"><a href="#cb88-20"></a><span class="ot">operatorTable ::</span> [[<span class="dt">Operator</span> <span class="dt">Parser</span> <span class="dt">Expr</span>]]</span>
<span id="cb88-21"><a href="#cb88-21"></a>operatorTable <span class="ot">=</span> <span class="fu">undefined</span> <span class="co">-- TODO</span></span></code></pre></div>
<p><code>pVariable</code>、<code>pInteger</code>、および<code>parens</code>の定義は、 ここまでで問題なく進むはずです。 文法が重ならないので <code>pTerm</code> に <code>try</code> が必要ないという点も、 ここではとてもラッキーです。</p>
<ul>
<li><p>開き括弧 <code>(</code> がある場合は、括弧内に式が続くことを知っているので、そのブランチにコミットします。</p></li>
<li><p>文字を見れば、それが識別子の始まりであることがわかります。</p></li>
<li><p>数字が見えれば、それが整数の始まりであることがわかります。</p></li>
</ul>
<p>最後に、<code>pExpr</code> を終了するために、 <code>operatorTable</code> を定義する必要があります。 型からネストされたリストであることがわかります。 すべての内部リストはサポートしたい演算子のリストです。 それらはすべて同じ優先順位を持っています。 外側のリストは優先順位の降順で並べられているので、 高い位置に演算子のグループを配置するほど、 それらはより強く結合されます。</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb89-1"><a href="#cb89-1"></a><span class="kw">data</span> <span class="dt">Operator</span> m a <span class="co">-- 注意</span></span>
<span id="cb89-2"><a href="#cb89-2"></a>  <span class="ot">=</span> <span class="dt">InfixN</span>  (m (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a)) <span class="co">-- ^ 非結合の中置</span></span>
<span id="cb89-3"><a href="#cb89-3"></a>  <span class="op">|</span> <span class="dt">InfixL</span>  (m (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a)) <span class="co">-- ^ 左結合の中置</span></span>
<span id="cb89-4"><a href="#cb89-4"></a>  <span class="op">|</span> <span class="dt">InfixR</span>  (m (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a)) <span class="co">-- ^ 右結合の中置</span></span>
<span id="cb89-5"><a href="#cb89-5"></a>  <span class="op">|</span> <span class="dt">Prefix</span>  (m (a <span class="ot">-&gt;</span> a))      <span class="co">-- ^ 前置</span></span>
<span id="cb89-6"><a href="#cb89-6"></a>  <span class="op">|</span> <span class="dt">Postfix</span> (m (a <span class="ot">-&gt;</span> a))      <span class="co">-- ^ 後置</span></span>
<span id="cb89-7"><a href="#cb89-7"></a></span>
<span id="cb89-8"><a href="#cb89-8"></a><span class="ot">operatorTable ::</span> [[<span class="dt">Operator</span> <span class="dt">Parser</span> <span class="dt">Expr</span>]]</span>
<span id="cb89-9"><a href="#cb89-9"></a>operatorTable <span class="ot">=</span></span>
<span id="cb89-10"><a href="#cb89-10"></a>  [ [ prefix <span class="st">&quot;-&quot;</span> <span class="dt">Negation</span></span>
<span id="cb89-11"><a href="#cb89-11"></a>    , prefix <span class="st">&quot;+&quot;</span> <span class="fu">id</span> ]</span>
<span id="cb89-12"><a href="#cb89-12"></a>  , [ binary <span class="st">&quot;*&quot;</span> <span class="dt">Product</span></span>
<span id="cb89-13"><a href="#cb89-13"></a>    , binary <span class="st">&quot;/&quot;</span> <span class="dt">Division</span> ]</span>
<span id="cb89-14"><a href="#cb89-14"></a>  , [ binary <span class="st">&quot;+&quot;</span> <span class="dt">Sum</span></span>
<span id="cb89-15"><a href="#cb89-15"></a>    , binary <span class="st">&quot;-&quot;</span> <span class="dt">Subtr</span> ]</span>
<span id="cb89-16"><a href="#cb89-16"></a>  ]</span>
<span id="cb89-17"><a href="#cb89-17"></a></span>
<span id="cb89-18"><a href="#cb89-18"></a><span class="ot">binary ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> (<span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span>) <span class="ot">-&gt;</span> <span class="dt">Operator</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb89-19"><a href="#cb89-19"></a>binary  name f <span class="ot">=</span> <span class="dt">InfixL</span>  (f <span class="op">&lt;$</span> symbol name)</span>
<span id="cb89-20"><a href="#cb89-20"></a></span>
<span id="cb89-21"><a href="#cb89-21"></a>prefix,<span class="ot"> postfix ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> (<span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span>) <span class="ot">-&gt;</span> <span class="dt">Operator</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb89-22"><a href="#cb89-22"></a>prefix  name f <span class="ot">=</span> <span class="dt">Prefix</span>  (f <span class="op">&lt;$</span> symbol name)</span>
<span id="cb89-23"><a href="#cb89-23"></a>postfix name f <span class="ot">=</span> <span class="dt">Postfix</span> (f <span class="op">&lt;$</span> symbol name)</span></code></pre></div>
<p><code>binary</code> で <code>InfixL</code> 内部の <code>Parser (Expr -&gt; Expr -&gt; Expr)</code> を どのように配置し、 同様に<code>prefix</code> と <code>postfix</code> に <code>Parser (Expr -&gt; Expr)</code> を どのように配置しているのか注意してください。 すなわち、<code>symbol name</code> を実行し、 <code>Expr</code> 型の最終結果を得るために項に適用する関数を返します。</p>
<p>これでパーサを試すことができます。準備は完了です！</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb90-1"><a href="#cb90-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pExpr <span class="op">&lt;</span>* eof) <span class="st">&quot;a * (b + 2)&quot;</span></span>
<span id="cb90-2"><a href="#cb90-2"></a><span class="ex">Product</span> (Var <span class="st">&quot;a&quot;</span>) <span class="kw">(</span><span class="ex">Sum</span> (Var <span class="st">&quot;b&quot;</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">Int</span> 2<span class="kw">)</span>)</span>
<span id="cb90-3"><a href="#cb90-3"></a></span>
<span id="cb90-4"><a href="#cb90-4"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pExpr <span class="op">&lt;</span>* eof) <span class="st">&quot;a * b + 2&quot;</span></span>
<span id="cb90-5"><a href="#cb90-5"></a><span class="ex">Sum</span> (Product (Var <span class="st">&quot;a&quot;</span>) <span class="kw">(</span><span class="ex">Var</span> <span class="st">&quot;b&quot;</span><span class="kw">)</span>) <span class="kw">(</span><span class="ex">Int</span> 2<span class="kw">)</span></span>
<span id="cb90-6"><a href="#cb90-6"></a></span>
<span id="cb90-7"><a href="#cb90-7"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pExpr <span class="op">&lt;</span>* eof) <span class="st">&quot;a * b / 2&quot;</span></span>
<span id="cb90-8"><a href="#cb90-8"></a><span class="ex">Division</span> (Product (Var <span class="st">&quot;a&quot;</span>) <span class="kw">(</span><span class="ex">Var</span> <span class="st">&quot;b&quot;</span><span class="kw">)</span>) <span class="kw">(</span><span class="ex">Int</span> 2<span class="kw">)</span></span>
<span id="cb90-9"><a href="#cb90-9"></a></span>
<span id="cb90-10"><a href="#cb90-10"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pExpr <span class="op">&lt;</span>* eof) <span class="st">&quot;a * (b $ 2)&quot;</span></span>
<span id="cb90-11"><a href="#cb90-11"></a><span class="ex">1</span>:8:</span>
<span id="cb90-12"><a href="#cb90-12"></a>  <span class="kw">|</span></span>
<span id="cb90-13"><a href="#cb90-13"></a><span class="ex">1</span> <span class="kw">|</span> <span class="ex">a</span> * (b $ 2)</span>
<span id="cb90-14"><a href="#cb90-14"></a>  <span class="kw">|</span>        ^</span>
<span id="cb90-15"><a href="#cb90-15"></a><span class="ex">unexpected</span> <span class="st">&#39;$&#39;</span></span>
<span id="cb90-16"><a href="#cb90-16"></a><span class="ex">expecting</span> <span class="st">&#39;)&#39;</span> or operator</span></code></pre></div>
<p><code>Text.Megaparsec.Expr</code> モジュールのドキュメントには、 あまり標準的ではない状況で役立つヒントがいくつか含まれているので、 それを読むことをお勧めします。</p>
<p><a name="Indentation"></a></p>
<h2 id="indentation-sensitiveなパース">Indentation-sensitiveなパース</h2>
<p><code>Text.Megaparsec.Char.Lexer</code> モジュールには、 Indentation-sensitive な文法をパースするときに役立つツールが含まれています。 最初に利用可能なコンビネータを見直し、 次にIndentation-sensitiveなパーサを書くことによって それらを使えるようにします。</p>
<p><a name="nonIndented"></a></p>
<h2 id="nonindented-と-indentblock"><code>nonIndented</code> と <code>indentBlock</code></h2>
<p>最も単純な<code>nonIndented</code> から始めましょう。</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb91-1"><a href="#cb91-1"></a><span class="ot">nonIndented ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb91-2"><a href="#cb91-2"></a>  <span class="ot">=&gt;</span> m ()              <span class="co">-- ^ インデント (スペース) の消費方法</span></span>
<span id="cb91-3"><a href="#cb91-3"></a>  <span class="ot">-&gt;</span> m a               <span class="co">-- ^ 内側のパーサ</span></span>
<span id="cb91-4"><a href="#cb91-4"></a>  <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>それはその内側のパーサが インデントされていない入力を消費することを確認できます。 これは、Indentation-sensitiveな入力による 高レベルなパーサの背後にあるモデルの一部です。 インデントされていないトップレベルの項目があり、 すべてのインデントされたトークンはそれらのトップレベル定義の 直接的または間接的な子であると述べます。 <code>megaparsec</code>では、これを表現するために追加の状態を必要としません。 インデントは常に相対的なので、 私たちの考えは、参照トークンとインデントトークンのために パーサを明示的に結び付けることです。 そして、パーサの純粋な組み合わせによって Indentation-sensitiveな文法を定義することです。</p>
<p>それでは、インデントブロックのパーサを どのように定義すればよいのでしょうか。 <code>indentBlock</code>のシグネチャを見てみましょう。</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb92-1"><a href="#cb92-1"></a><span class="ot">indentBlock ::</span> (<span class="dt">MonadParsec</span> e s m, <span class="dt">Token</span> s <span class="op">~</span> <span class="dt">Char</span>)</span>
<span id="cb92-2"><a href="#cb92-2"></a>  <span class="ot">=&gt;</span> m ()              <span class="co">-- ^ インデント (スペース) の消費方法</span></span>
<span id="cb92-3"><a href="#cb92-3"></a>  <span class="ot">-&gt;</span> m (<span class="dt">IndentOpt</span> m a b) <span class="co">-- ^ 「参照」トークン の消費方法</span></span>
<span id="cb92-4"><a href="#cb92-4"></a>  <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>はじめに、インデントの消費方法を指定します。 ここで注意すべき重要なことは、 このスペースを消費するパーサは改行も消費しなければならないのに対し、 トークン(参照トークンとインデントトークン)は 通常改行をそれらの後に消費するべきではないということです。</p>
<p>ご覧のとおり、2番目の引数を使用すると参照トークンをパースし、 次に<code>indentBlock</code>に何をするかを指示するデータ構造を返すことができます。 いくつかのオプションがあります。</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb93-1"><a href="#cb93-1"></a><span class="kw">data</span> <span class="dt">IndentOpt</span> m a b</span>
<span id="cb93-2"><a href="#cb93-2"></a>  <span class="ot">=</span> <span class="dt">IndentNone</span> a</span>
<span id="cb93-3"><a href="#cb93-3"></a>    <span class="co">-- ^ インデントトークンを消費せず、値を返すだけ</span></span>
<span id="cb93-4"><a href="#cb93-4"></a>  <span class="op">|</span> <span class="dt">IndentMany</span> (<span class="dt">Maybe</span> <span class="dt">Pos</span>) ([b] <span class="ot">-&gt;</span> m a) (m b)</span>
<span id="cb93-5"><a href="#cb93-5"></a>    <span class="co">-- ^ 多くの(0個の場合を含む)インデントトークンをパースし, 与えられたインデント</span></span>
<span id="cb93-6"><a href="#cb93-6"></a>    <span class="co">-- レベルを使う (&#39;Nothing&#39; の場合は最初にインデントされたトークンのレベルを使う)。</span></span>
<span id="cb93-7"><a href="#cb93-7"></a>    <span class="co">-- 2番目の引数は最終結果を取得する方法を示し、三番目の</span></span>
<span id="cb93-8"><a href="#cb93-8"></a>    <span class="co">-- 引数はインデントされたトークンをパースする方法を示す。</span></span>
<span id="cb93-9"><a href="#cb93-9"></a>  <span class="op">|</span> <span class="dt">IndentSome</span> (<span class="dt">Maybe</span> <span class="dt">Pos</span>) ([b] <span class="ot">-&gt;</span> m a) (m b)</span>
<span id="cb93-10"><a href="#cb93-10"></a>    <span class="co">-- ^ &#39;IndentMany&#39;に似ているが、少なくとも1つのインデントトークンが</span></span>
<span id="cb93-11"><a href="#cb93-11"></a>    <span class="co">-- 出現することを要求する。</span></span></code></pre></div>
<p>考えを変えてインデントのないトークンをパースすることができます。 多くの（つまり、場合によっては0個の）インデントトークンをパースするか、 少なくとも1つのそのようなトークンを要求することができます。 <code>indentBlock</code>が最初のインデントトークンのインデントレベルを検出して それを使用するか、手動でインデントレベルを指定することができます。</p>
<p><a name="SimpleIndented"></a></p>
<h2 id="単純なインデントされたリストのパース">単純なインデントされたリストのパース</h2>
<p>いくつかの項目の単純なインデントされたリストをパースしましょう。 インポートセクションから始めます。</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb94-1"><a href="#cb94-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb94-2"><a href="#cb94-2"></a><span class="ot">{-# LANGUAGE TupleSections     #-}</span></span>
<span id="cb94-3"><a href="#cb94-3"></a></span>
<span id="cb94-4"><a href="#cb94-4"></a><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></span>
<span id="cb94-5"><a href="#cb94-5"></a></span>
<span id="cb94-6"><a href="#cb94-6"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb94-7"><a href="#cb94-7"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (void)</span>
<span id="cb94-8"><a href="#cb94-8"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb94-9"><a href="#cb94-9"></a><span class="kw">import</span> <span class="dt">Data.Void</span></span>
<span id="cb94-10"><a href="#cb94-10"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span></span>
<span id="cb94-11"><a href="#cb94-11"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec.Char</span></span>
<span id="cb94-12"><a href="#cb94-12"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Megaparsec.Char.Lexer</span> <span class="kw">as</span> <span class="dt">L</span></span>
<span id="cb94-13"><a href="#cb94-13"></a></span>
<span id="cb94-14"><a href="#cb94-14"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Void</span> <span class="dt">Text</span></span></code></pre></div>
<p>2種類のスペースコンシューマが必要になります。 1つは改行を消費する<code>scn</code>、もう1つは消費しない<code>sc</code>です（実際にはここではスペースとタブのみをパースします）。</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb95-1"><a href="#cb95-1"></a><span class="ot">lineComment ::</span> <span class="dt">Parser</span> ()</span>
<span id="cb95-2"><a href="#cb95-2"></a>lineComment <span class="ot">=</span> L.skipLineComment <span class="st">&quot;#&quot;</span></span>
<span id="cb95-3"><a href="#cb95-3"></a></span>
<span id="cb95-4"><a href="#cb95-4"></a><span class="ot">scn ::</span> <span class="dt">Parser</span> ()</span>
<span id="cb95-5"><a href="#cb95-5"></a>scn <span class="ot">=</span> L.space space1 lineComment empty</span>
<span id="cb95-6"><a href="#cb95-6"></a></span>
<span id="cb95-7"><a href="#cb95-7"></a><span class="ot">sc ::</span> <span class="dt">Parser</span> ()</span>
<span id="cb95-8"><a href="#cb95-8"></a>sc <span class="ot">=</span> L.space (void <span class="op">$</span> some (char <span class="ch">&#39; &#39;</span> <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;\t&#39;</span>)) lineComment empty</span>
<span id="cb95-9"><a href="#cb95-9"></a></span>
<span id="cb95-10"><a href="#cb95-10"></a><span class="ot">lexeme ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb95-11"><a href="#cb95-11"></a>lexeme <span class="ot">=</span> L.lexeme sc</span></code></pre></div>
<p>楽しみのために、<code>#</code>で始まる行のコメントを許可します。</p>
<p><code>pItemList</code> は、それ自体が参照トークン（リストのヘッダー） とインデントトークン（リストの項目）の組み合わせである トップレベルの形式です。</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb96-1"><a href="#cb96-1"></a><span class="ot">pItemList ::</span> <span class="dt">Parser</span> (<span class="dt">String</span>, [<span class="dt">String</span>]) <span class="co">-- ヘッダとアイテムのリスト</span></span>
<span id="cb96-2"><a href="#cb96-2"></a>pItemList <span class="ot">=</span> L.nonIndented scn (L.indentBlock scn p)</span>
<span id="cb96-3"><a href="#cb96-3"></a>  <span class="kw">where</span></span>
<span id="cb96-4"><a href="#cb96-4"></a>    p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb96-5"><a href="#cb96-5"></a>      header <span class="ot">&lt;-</span> pItem</span>
<span id="cb96-6"><a href="#cb96-6"></a>      <span class="fu">return</span> (<span class="dt">L.IndentMany</span> <span class="dt">Nothing</span> (<span class="fu">return</span> <span class="op">.</span> (header, )) pItem)</span></code></pre></div>
<p>私たちの目的であるアイテムは、英数字とハイフンのシーケンスです。</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb97-1"><a href="#cb97-1"></a><span class="ot">pItem ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb97-2"><a href="#cb97-2"></a>pItem <span class="ot">=</span> lexeme (some (alphaNumChar <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;-&#39;</span>)) <span class="op">&lt;?&gt;</span> <span class="st">&quot;list item&quot;</span></span></code></pre></div>
<p>GHCiでコードをロードし、 組み込みの<code>parseTest</code>の助けを借りて試してみましょう。</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb98-1"><a href="#cb98-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;&quot;</span></span>
<span id="cb98-2"><a href="#cb98-2"></a><span class="ex">1</span>:1:</span>
<span id="cb98-3"><a href="#cb98-3"></a>  <span class="kw">|</span></span>
<span id="cb98-4"><a href="#cb98-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="op">&lt;</span><span class="ex">empty</span> line<span class="op">&gt;</span></span>
<span id="cb98-5"><a href="#cb98-5"></a>  <span class="kw">|</span> ^</span>
<span id="cb98-6"><a href="#cb98-6"></a><span class="ex">unexpected</span> end of input</span>
<span id="cb98-7"><a href="#cb98-7"></a><span class="ex">expecting</span> list item</span>
<span id="cb98-8"><a href="#cb98-8"></a></span>
<span id="cb98-9"><a href="#cb98-9"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;something&quot;</span></span>
<span id="cb98-10"><a href="#cb98-10"></a><span class="kw">(</span><span class="st">&quot;something&quot;</span>,[]<span class="kw">)</span></span>
<span id="cb98-11"><a href="#cb98-11"></a></span>
<span id="cb98-12"><a href="#cb98-12"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;  something&quot;</span></span>
<span id="cb98-13"><a href="#cb98-13"></a><span class="ex">1</span>:3:</span>
<span id="cb98-14"><a href="#cb98-14"></a>  <span class="kw">|</span></span>
<span id="cb98-15"><a href="#cb98-15"></a><span class="ex">1</span> <span class="kw">|</span>   <span class="ex">something</span></span>
<span id="cb98-16"><a href="#cb98-16"></a>  <span class="kw">|</span>   ^</span>
<span id="cb98-17"><a href="#cb98-17"></a><span class="ex">incorrect</span> indentation (got 3, should be equal to 1)</span>
<span id="cb98-18"><a href="#cb98-18"></a></span>
<span id="cb98-19"><a href="#cb98-19"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;something\none\ntwo\nthree&quot;</span></span>
<span id="cb98-20"><a href="#cb98-20"></a><span class="ex">2</span>:1:</span>
<span id="cb98-21"><a href="#cb98-21"></a>  <span class="kw">|</span></span>
<span id="cb98-22"><a href="#cb98-22"></a><span class="ex">2</span> <span class="kw">|</span> <span class="ex">one</span></span>
<span id="cb98-23"><a href="#cb98-23"></a>  <span class="kw">|</span> ^</span>
<span id="cb98-24"><a href="#cb98-24"></a><span class="ex">unexpected</span> <span class="st">&#39;o&#39;</span></span>
<span id="cb98-25"><a href="#cb98-25"></a><span class="ex">expecting</span> end of input</span></code></pre></div>
<p><code>IndentMany</code> オプションを使用しているので、 空のリストでも問題ありませんが、 組み込みのコンビネータ<code>space</code>はエラーメッセージから 「より多くのスペースを期待する」というフレーズを隠しているので、 このエラーメッセージは完全に妥当です。</p>
<p>続けましょう。</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb99-1"><a href="#cb99-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;something\n  one\n    two\n  three&quot;</span></span>
<span id="cb99-2"><a href="#cb99-2"></a><span class="ex">3</span>:5:</span>
<span id="cb99-3"><a href="#cb99-3"></a>  <span class="kw">|</span></span>
<span id="cb99-4"><a href="#cb99-4"></a><span class="ex">3</span> <span class="kw">|</span>     <span class="ex">two</span></span>
<span id="cb99-5"><a href="#cb99-5"></a>  <span class="kw">|</span>     ^</span>
<span id="cb99-6"><a href="#cb99-6"></a><span class="ex">incorrect</span> indentation (got 5, should be equal to 3)</span>
<span id="cb99-7"><a href="#cb99-7"></a></span>
<span id="cb99-8"><a href="#cb99-8"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;something\n  one\n  two\n three&quot;</span></span>
<span id="cb99-9"><a href="#cb99-9"></a><span class="ex">4</span>:2:</span>
<span id="cb99-10"><a href="#cb99-10"></a>  <span class="kw">|</span></span>
<span id="cb99-11"><a href="#cb99-11"></a><span class="ex">4</span> <span class="kw">|</span>  <span class="ex">three</span></span>
<span id="cb99-12"><a href="#cb99-12"></a>  <span class="kw">|</span>  ^</span>
<span id="cb99-13"><a href="#cb99-13"></a><span class="ex">incorrect</span> indentation (got 2, should be equal to 3)</span>
<span id="cb99-14"><a href="#cb99-14"></a></span>
<span id="cb99-15"><a href="#cb99-15"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;something\n  one\n  two\n  three&quot;</span></span>
<span id="cb99-16"><a href="#cb99-16"></a><span class="kw">(</span><span class="st">&quot;something&quot;</span>,[<span class="st">&quot;one&quot;</span>,<span class="st">&quot;two&quot;</span>,<span class="st">&quot;three&quot;</span>]<span class="kw">)</span></span></code></pre></div>
<p>これは確かにうまくいきそうです。 <code>IndentMany</code> を <code>IndentSome</code> に、<code>Nothing</code> を<code>Just (mkPos 5)</code>に 置き換えます（インデントレベルは1から数えられるため、 インデントされる項目の前に4つのスペースが必要になります）。</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb100-1"><a href="#cb100-1"></a><span class="ot">pItemList ::</span> <span class="dt">Parser</span> (<span class="dt">String</span>, [<span class="dt">String</span>])</span>
<span id="cb100-2"><a href="#cb100-2"></a>pItemList <span class="ot">=</span> L.nonIndented scn (L.indentBlock scn p)</span>
<span id="cb100-3"><a href="#cb100-3"></a>  <span class="kw">where</span></span>
<span id="cb100-4"><a href="#cb100-4"></a>    p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb100-5"><a href="#cb100-5"></a>      header <span class="ot">&lt;-</span> pItem</span>
<span id="cb100-6"><a href="#cb100-6"></a>      <span class="fu">return</span> (<span class="dt">L.IndentSome</span> (<span class="dt">Just</span> (mkPos <span class="dv">5</span>)) (<span class="fu">return</span> <span class="op">.</span> (header, )) pItem)</span></code></pre></div>
<p>ここで、</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb101-1"><a href="#cb101-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;something\n&quot;</span></span>
<span id="cb101-2"><a href="#cb101-2"></a><span class="ex">2</span>:1:</span>
<span id="cb101-3"><a href="#cb101-3"></a>  <span class="kw">|</span></span>
<span id="cb101-4"><a href="#cb101-4"></a><span class="ex">2</span> <span class="kw">|</span> <span class="op">&lt;</span><span class="ex">empty</span> line<span class="op">&gt;</span></span>
<span id="cb101-5"><a href="#cb101-5"></a>  <span class="kw">|</span> ^</span>
<span id="cb101-6"><a href="#cb101-6"></a><span class="ex">incorrect</span> indentation (got 1, should be greater than 1)</span>
<span id="cb101-7"><a href="#cb101-7"></a></span>
<span id="cb101-8"><a href="#cb101-8"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;something\n  one&quot;</span></span>
<span id="cb101-9"><a href="#cb101-9"></a><span class="ex">2</span>:3:</span>
<span id="cb101-10"><a href="#cb101-10"></a>  <span class="kw">|</span></span>
<span id="cb101-11"><a href="#cb101-11"></a><span class="ex">2</span> <span class="kw">|</span>   <span class="ex">one</span></span>
<span id="cb101-12"><a href="#cb101-12"></a>  <span class="kw">|</span>   ^</span>
<span id="cb101-13"><a href="#cb101-13"></a><span class="ex">incorrect</span> indentation (got 3, should be equal to 5)</span>
<span id="cb101-14"><a href="#cb101-14"></a></span>
<span id="cb101-15"><a href="#cb101-15"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pItemList <span class="op">&lt;</span>* eof) <span class="st">&quot;something\n    one&quot;</span></span>
<span id="cb101-16"><a href="#cb101-16"></a><span class="kw">(</span><span class="st">&quot;something&quot;</span>,[<span class="st">&quot;one&quot;</span>]<span class="kw">)</span></span></code></pre></div>
<p>最初のメッセージは少し驚くかもしれませんが、 リスト内に少なくとも1つの項目がなければならないことを <code>megaparsec</code>は知っているので、インデントレベルをチェックし、 そしてそれは1であり、間違っているので報告します。</p>
<p><a name="NestedIndented"></a></p>
<h2 id="ネストされたインデントのあるリスト">ネストされたインデントのあるリスト</h2>
<p>リストのアイテムにサブアイテムを含めることを許可しましょう。 これには、新しいパーサ<code>pComplexItem</code>が必要になります。</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb102-1"><a href="#cb102-1"></a><span class="ex">pComplexItem</span> :: Parser (String, [String])</span>
<span id="cb102-2"><a href="#cb102-2"></a><span class="ex">pComplexItem</span> = L.indentBlock scn p</span>
<span id="cb102-3"><a href="#cb102-3"></a>  <span class="ex">where</span></span>
<span id="cb102-4"><a href="#cb102-4"></a>    <span class="ex">p</span> = do</span>
<span id="cb102-5"><a href="#cb102-5"></a>      <span class="ex">header</span> <span class="op">&lt;</span>- pItem</span>
<span id="cb102-6"><a href="#cb102-6"></a>      <span class="bu">return</span> (L.IndentMany Nothing (return . (header, )) <span class="ex">pItem</span>)</span>
<span id="cb102-7"><a href="#cb102-7"></a></span>
<span id="cb102-8"><a href="#cb102-8"></a><span class="ex">pItemList</span> :: Parser (String, [(String, [String])])</span>
<span id="cb102-9"><a href="#cb102-9"></a><span class="ex">pItemList</span> = L.nonIndented scn (L.indentBlock scn p)</span>
<span id="cb102-10"><a href="#cb102-10"></a>  <span class="ex">where</span></span>
<span id="cb102-11"><a href="#cb102-11"></a>    <span class="ex">p</span> = do</span>
<span id="cb102-12"><a href="#cb102-12"></a>      <span class="ex">header</span> <span class="op">&lt;</span>- pItem</span>
<span id="cb102-13"><a href="#cb102-13"></a>      <span class="bu">return</span> (L.IndentSome Nothing (return . (header, )) <span class="ex">pComplexItem</span>)</span></code></pre></div>
<p>次のような入力を与えます。</p>
<pre><code>first-chapter
  paragraph-one
      note-A # an important note here!
      note-B
  paragraph-two
    note-1
    note-2
  paragraph-three</code></pre>
<p>このような結果が得られます。</p>
<pre><code>Right
  ( &quot;first-chapter&quot;
  , [ (&quot;paragraph-one&quot;,   [&quot;note-A&quot;,&quot;note-B&quot;])
    , (&quot;paragraph-two&quot;,   [&quot;note-1&quot;,&quot;note-2&quot;])
    , (&quot;paragraph-three&quot;, []) ] )</code></pre>
<p>これは、このアプローチがネストされたインデントのある構造に対して 追加の状態を必要とせずにどのように拡張するかを示しています。</p>
<p><a name="LineFold"></a></p>
<h2 id="行の畳み込みの追加">行の畳み込みの追加</h2>
<p>行の畳み込みは、後続の項目のインデントレベルが 最初の項目のインデントレベルよりも大きい限り、 1行または複数行に配置できる複数の要素で構成されます。</p>
<p><code>lineFold</code> という別のヘルパーを利用しましょう。</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb105-1"><a href="#cb105-1"></a><span class="ot">pComplexItem ::</span> <span class="dt">Parser</span> (<span class="dt">String</span>, [<span class="dt">String</span>])</span>
<span id="cb105-2"><a href="#cb105-2"></a>pComplexItem <span class="ot">=</span> L.indentBlock scn p</span>
<span id="cb105-3"><a href="#cb105-3"></a>  <span class="kw">where</span></span>
<span id="cb105-4"><a href="#cb105-4"></a>    p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb105-5"><a href="#cb105-5"></a>      header <span class="ot">&lt;-</span> pItem</span>
<span id="cb105-6"><a href="#cb105-6"></a>      <span class="fu">return</span> (<span class="dt">L.IndentMany</span> <span class="dt">Nothing</span> (<span class="fu">return</span> <span class="op">.</span> (header, )) pLineFold)</span>
<span id="cb105-7"><a href="#cb105-7"></a></span>
<span id="cb105-8"><a href="#cb105-8"></a><span class="ot">pLineFold ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb105-9"><a href="#cb105-9"></a>pLineFold <span class="ot">=</span> L.lineFold scn <span class="op">$</span> \sc&#39; <span class="ot">-&gt;</span></span>
<span id="cb105-10"><a href="#cb105-10"></a>  <span class="kw">let</span> ps <span class="ot">=</span> some (alphaNumChar <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;-&#39;</span>) <span class="ot">`sepBy1`</span> try sc&#39;</span>
<span id="cb105-11"><a href="#cb105-11"></a>  <span class="kw">in</span> <span class="fu">unwords</span> <span class="op">&lt;$&gt;</span> ps <span class="op">&lt;*</span> scn <span class="co">-- (1)</span></span></code></pre></div>
<p><code>lineFold</code>は次のように機能します。 改行を受理するスペースコンシューマ<code>scn</code>を提供し、 行の畳み込みの要素間のスペースを消費するために コールバックで使用できる特別なスペースコンシューマ<code>sc'</code>を返します。</p>
<p>なぜ <code>try sc'</code> と (1) の行で <code>scn</code>を使うのですか？状況は以下のとおりです。</p>
<ul>
<li><p>行の畳込みの要素は、開始位置よりもインデントが大きくなります。</p></li>
<li><p><code>sc'</code>は、空白を消費した後の列が最初の列よりも大きくなるように、改行とともに空白を消費します。</p></li>
<li><p>停止させるには、<code>sc'</code> は逆の状況に遭遇する必要があります。つまり、消費後の列は最初の列以下になります。その時点では (tryのおかげで) 入力を消費せずに失敗し、<code>scn</code> はその列から始まる新しいものの前の空白を取り上げるために使用されます。</p></li>
<li><p>先程使用していた <code>sc'</code> はすでに改行文字を消費するスペースコンシューマによって空白を調べています。したがって、末尾の空白を拾うときに改行も消費するのは論理的なことです。(1) の行で <code>sc</code>ではなく<code>scn</code>が使用されるのはこのためです。</p></li>
</ul>
<p>練習問題：私たちのパーサーの最終版で遊ぶことは 読者のための練習として残されています。 複数の単語からなる「項目」を作成することができ、 それらが折り返されている限り、 それらはそれらの間の単一のスペースでパースされ連結されます。</p>
<p><a name="Efficient"></a></p>
<h2 id="効率のよいパーサを書く">効率のよいパーサを書く</h2>
<p><code>megaparsec</code> のパーサの性能を向上させるために 何を試みるべきか議論しましょう。 プロファイリングとベンチマークによって 改善があるかどうかを常に確認する必要があることに注意してください。 これは、パフォーマンスを調整するときに正しいことを 行っているかどうかを理解するための唯一の方法です。</p>
<p>一般的なアドバイス：</p>
<ul>
<li><p>あなたのパーサが普通の<code>Parsec</code>モナド (これは<code>Identity</code>を組み合わせた<code>ParsecT</code>のモナド変換子であることを思い出してください。これは非常に軽量です) の代わりにモナドスタックを使っている場合、少なくとも<code>transformer</code>ライブラリのバージョン0.5と、<code>megaparsec</code> のバージョン7.0以上を必ず使用してください。これらのバージョンでは、どちらのライブラリもパフォーマンスが大幅に向上しているため、何もしなくても優れたパフォーマンスを得ることができます。</p></li>
<li><p><code>Parsec</code> モナドは、 <code>ParsecT</code> ベースのモナド変換子よりも常に高速になります。どうしても必要な場合以外は、<code>StateT</code>、<code>WriterT</code>、およびその他のモナド変換子を使用しないでください。スタックに追加すればするほど遅くなります。</p></li>
<li><p>バックトラックはコストの高い操作です。すべての分岐が失敗する前に入力に深く入り込むことができるような長い分岐の連鎖を作ることを避けてください。</p></li>
<li><p>あなたが本当にそうしたい理由がない限り、パーサの多相性を保ってはいけません。トップレベルの定義ごとに、<code>Parser = Parsec Void Text</code> などの具体的な型を指定して、パーサの型を修正することをお勧めします。このようにすればGHCはより良く最適化できるでしょう。</p></li>
<li><p>惜しみなくインライン展開しましょう(もちろん、理にかなっているときに)。特に短い関数では、インライン展開による違いを見たとき、あなたは目を疑うでしょう。 これは特に、あるモジュールで定義され、別のモジュールで使用されるパーサに当てはまります。なぜなら<code>INLINE</code>および<code>INLINEABLE</code>プラグマはGHCに関数定義をインタフェースファイルにダンプさせるので、特殊化が容易になるからです。</p></li>
<li><p>可能な場合は、<code>takeWhileP</code>、<code>takeWhile1P</code>、および<code>takeP</code>などの高速なプリミティブを使用してください。<a href="https://markkarpov.com/post/megaparsec-more-speed-more-power.html#there-is-hope">このブログ記事</a>では、なぜそれらがとても速いのかを説明します。</p></li>
<li><p>可能であれば <code>oneOf</code>と<code>noneOf</code>を避け、<code>satisfy</code> と <code>notChar</code> を選択してください。</p></li>
</ul>
<p>上記の点のほとんどは追加のコメントを必要としませんが、 新しい高速のプリミティブ、<code>takeWhileP</code> 、 <code>takeWhile1P</code> 、 および <code>takeP</code> を使用する習慣を身に付けることが有益であると思います。 最初の2つは、いくつかの<code>many</code>と<code>some</code>ベースの構造を置き換え、 それらを早くし、返されるデータの型を入力ストリームのチャンクに変更すること、つまり以前議論した <code>Tokens s</code> 型に変更できるため、特に一般的です。</p>
<p>たとえば、URIをパースしたときに、 認証の構成要素内でユーザ名をパースするための 次のコードがあったことを思い出してください。</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb106-1"><a href="#cb106-1"></a>  user <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar</span></code></pre></div>
<p>これは <code>takeWhile1P</code> に置き換え可能です。</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb107-1"><a href="#cb107-1"></a>user <span class="ot">&lt;-</span> takeWhile1P (<span class="dt">Just</span> <span class="st">&quot;alpha num character&quot;</span>) <span class="fu">isAlphaNum</span></span>
<span id="cb107-2"><a href="#cb107-2"></a>  <span class="co">--                  ^                            ^</span></span>
<span id="cb107-3"><a href="#cb107-3"></a>  <span class="co">--                  |                            |</span></span>
<span id="cb107-4"><a href="#cb107-4"></a>  <span class="co">-- マッチさせるトークンのラベル                 述語</span></span></code></pre></div>
<p><code>ByteStrings</code> と <code>Text</code>をパースすると、 これは元の方法よりはるかに高速になります。 また、<code>takeWhile1P</code> から直接 <code>Text</code>を取得するため、 <code>T.pack</code>は不要になりました。</p>
<p>以下の式は、<code>takeWhileP</code> と <code>takeWhile1P</code> の <code>Maybe String</code> 引数の意味を理解するのに役立ちます。</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb108-1"><a href="#cb108-1"></a>takeWhileP  (<span class="dt">Just</span> <span class="st">&quot;foo&quot;</span>) f <span class="ot">=</span> many (satisfy f <span class="op">&lt;?&gt;</span> <span class="st">&quot;foo&quot;</span>)</span>
<span id="cb108-2"><a href="#cb108-2"></a>takeWhileP  <span class="dt">Nothing</span>      f <span class="ot">=</span> many (satisfy f)</span>
<span id="cb108-3"><a href="#cb108-3"></a>takeWhile1P (<span class="dt">Just</span> <span class="st">&quot;foo&quot;</span>) f <span class="ot">=</span> some (satisfy f <span class="op">&lt;?&gt;</span> <span class="st">&quot;foo&quot;</span>)</span>
<span id="cb108-4"><a href="#cb108-4"></a>takeWhile1P <span class="dt">Nothing</span>      f <span class="ot">=</span> some (satisfy f)</span></code></pre></div>
<p><a name="Error"></a></p>
<h2 id="パースエラー">パースエラー</h2>
<p><code>megaparsec</code> のほとんどの機能の使い方を調べてきたので、 パースエラーの定義する方法、通知する方法、 実行中のパーサ内での処理方法について学びましょう。</p>
<p><a name="ErrDef"></a></p>
<h2 id="パースエラーの定義">パースエラーの定義</h2>
<p>型<code>ParseError</code> は次のように定義されています。</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb109-1"><a href="#cb109-1"></a><span class="kw">data</span> <span class="dt">ParseError</span> s e</span>
<span id="cb109-2"><a href="#cb109-2"></a>  <span class="ot">=</span> <span class="dt">TrivialError</span> <span class="dt">Int</span> (<span class="dt">Maybe</span> (<span class="dt">ErrorItem</span> (<span class="dt">Token</span> s))) (<span class="dt">Set</span> (<span class="dt">ErrorItem</span> (<span class="dt">Token</span> s)))</span>
<span id="cb109-3"><a href="#cb109-3"></a>    <span class="co">-- ^ Megaparsecの機構によって生成された自明なエラー。 データコンストラクタには、</span></span>
<span id="cb109-4"><a href="#cb109-4"></a>    <span class="co">-- エラーのオフセット、予期しないトークン（存在する場合）、</span></span>
<span id="cb109-5"><a href="#cb109-5"></a>    <span class="co">-- および予期するトークンが含まれます。</span></span>
<span id="cb109-6"><a href="#cb109-6"></a>  <span class="op">|</span> <span class="dt">FancyError</span> <span class="dt">Int</span> (<span class="dt">Set</span> (<span class="dt">ErrorFancy</span> e))</span>
<span id="cb109-7"><a href="#cb109-7"></a>    <span class="co">-- ^ ファンシーなカスタムエラー。</span></span></code></pre></div>
<p><code>ParseError</code>は、多くても1つの予期しないアイテムと 予期するアイテムの（空かもしれない）コレクションを持つ <code>TrivialError</code>、 または <code>FancyError</code> のいずれかです。</p>
<p><code>ParseError s e</code> は、2つの型変数によってパラメータ化されています。</p>
<ul>
<li><code>s</code> は入力ストリームの型です。</li>
<li><code>e</code> は、パースエラーのカスタムコンポーネントの型です。</li>
</ul>
<p><code>ErrorItem</code> は次のように定義されています。</p>
<div class="sourceCode" id="cb110"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb110-1"><a href="#cb110-1"></a><span class="kw">data</span> <span class="dt">ErrorItem</span> t</span>
<span id="cb110-2"><a href="#cb110-2"></a>  <span class="ot">=</span> <span class="dt">Tokens</span> (<span class="dt">NonEmpty</span> t)      <span class="co">-- ^ 空ではないトークンのストリーム</span></span>
<span id="cb110-3"><a href="#cb110-3"></a>  <span class="op">|</span> <span class="dt">Label</span> (<span class="dt">NonEmpty</span> <span class="dt">Char</span>)    <span class="co">-- ^ ラベル (空ではない)</span></span>
<span id="cb110-4"><a href="#cb110-4"></a>  <span class="op">|</span> <span class="dt">EndOfInput</span>               <span class="co">-- ^ 入力の終わり</span></span></code></pre></div>
<p>これが<code>ErrorFancy</code> です。</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb111-1"><a href="#cb111-1"></a><span class="kw">data</span> <span class="dt">ErrorFancy</span> e</span>
<span id="cb111-2"><a href="#cb111-2"></a>  <span class="ot">=</span> <span class="dt">ErrorFail</span> <span class="dt">String</span></span>
<span id="cb111-3"><a href="#cb111-3"></a>    <span class="co">-- ^ パーサモナドで &#39;fail&#39;が使われている</span></span>
<span id="cb111-4"><a href="#cb111-4"></a>  <span class="op">|</span> <span class="dt">ErrorIndentation</span> <span class="dt">Ordering</span> <span class="dt">Pos</span> <span class="dt">Pos</span></span>
<span id="cb111-5"><a href="#cb111-5"></a>    <span class="co">-- ^ インデントの誤りによるエラー：参照レベルと実際のレベルの間の</span></span>
<span id="cb111-6"><a href="#cb111-6"></a>    <span class="co">-- 望ましい順序、参照インデントレベル、実際のインデントレベル。</span></span>
<span id="cb111-7"><a href="#cb111-7"></a>  <span class="op">|</span> <span class="dt">ErrorCustom</span> e</span>
<span id="cb111-8"><a href="#cb111-8"></a>    <span class="co">-- ^ カスタムエラーデータ、 &#39;Error Fancy&#39;の&#39;e&#39;を&#39;Void&#39;に</span></span>
<span id="cb111-9"><a href="#cb111-9"></a>    <span class="co">-- することで都合に応じて無効にすることができます。</span></span></code></pre></div>
<p><code>ErrorFancy</code>には、2つの一般的なケースのための データコンストラクタが含まれており、 <code>megaparsec</code>はそのまま使えるようになっています。</p>
<ul>
<li><p><code>fail</code>関数の使用により、パーサが任意の<code>String</code> で失敗の報告をする。</p></li>
<li><p>前の章で見たインデント関連の問題です。 すぐに使えるindentation-sensitive な文法を扱うためのツールを 提供しているので、インデントの問題に関する正しく型付けされた 情報を保存する方法が必要です。</p></li>
</ul>
<p>最後に、<code>ErrorCustom</code>は<code>ErrorFancy</code>型に任意のデータを 埋め込むことを可能にする一種の「拡張スロット」です。 パースエラーにカスタムデータが必要ない場合は、 <code>ErrorFancy</code>を<code>Void</code>でパラメータ化します。 <code>Void</code>はボトムしか含まないため、<code>ErrorCustom</code>は「キャンセル」されるか、 または代数データ型と数値の間の類推に従うと「0倍」になります。</p>
<p>ライブラリの古いバージョンでは、<code>ParseError</code> は <code>parse</code>のような 関数によって直接返していました。しかしバージョン7はエラーごとの 行と列の計算が遅れます。 同様にエラーが発生した場合に表示するために入力から関連する行を取得します。 この情報は通常、パーサが失敗した場合にのみ役立つので、 パースを高速化するために行われます。 古いバージョンのライブラリのもう1つの問題は、 一度に複数のパースエラーを表示する場合（高度な使用法の一例）では、 正しい行を取得するために毎回入力を再びトラバースする必要があることです。</p>
<p>この問題は<code>ParseErrorBundle</code>データ型で解決されます。</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb112-1"><a href="#cb112-1"></a><span class="co">-- | エラーの効率的かつ正確なプリティプリントが可能な、</span></span>
<span id="cb112-2"><a href="#cb112-2"></a><span class="co">-- &#39;PosState&#39;を備えた &#39;ParseError&#39;の空でないコレクション。</span></span>
<span id="cb112-3"><a href="#cb112-3"></a></span>
<span id="cb112-4"><a href="#cb112-4"></a><span class="kw">data</span> <span class="dt">ParseErrorBundle</span> s e <span class="ot">=</span> <span class="dt">ParseErrorBundle</span></span>
<span id="cb112-5"><a href="#cb112-5"></a>  {<span class="ot"> bundleErrors ::</span> <span class="dt">NonEmpty</span> (<span class="dt">ParseError</span> s e)</span>
<span id="cb112-6"><a href="#cb112-6"></a>    <span class="co">-- ^ パースエラーのオフセットでソートされた &#39;ParseError&#39;のコレクション</span></span>
<span id="cb112-7"><a href="#cb112-7"></a>  ,<span class="ot"> bundlePosState ::</span> <span class="dt">PosState</span> s</span>
<span id="cb112-8"><a href="#cb112-8"></a>    <span class="co">-- ^ 行と列の計算に使用される状態</span></span>
<span id="cb112-9"><a href="#cb112-9"></a>  }</span></code></pre></div>
<p>パーサを実行するすべての関数は、正しく設定された <code>bundlePosState</code>と 単一の<code>ParseError</code>を内部に持つ<code>ParseErrorBundle</code>を返します。 <code>ParseErrorBundle</code>をユーザに表示する前に、 内部の<code>ParseError</code>のコレクションを拡張できます。 <code>ParseErrors</code>をそれらのオフセットでソートしておくことはユーザーの責任です。</p>
<p><a name="SigErr"></a></p>
<h2 id="パースエラーを通知する方法">パースエラーを通知する方法</h2>
<p>パースエラーを通知するためのさまざまな方法について説明しましょう。 最も簡単な関数は<code>fail</code>です。</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb113-1"><a href="#cb113-1"></a>λ<span class="op">&gt;</span> parseTest (<span class="fu">fail</span> <span class="st">&quot;I&#39;m failing, help me!&quot;</span><span class="ot"> ::</span> <span class="dt">Parser</span> ()) <span class="st">&quot;&quot;</span></span>
<span id="cb113-2"><a href="#cb113-2"></a><span class="dv">1</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span></span>
<span id="cb113-3"><a href="#cb113-3"></a>  <span class="op">|</span></span>
<span id="cb113-4"><a href="#cb113-4"></a><span class="dv">1</span> <span class="op">|</span> <span class="op">&lt;</span>empty line<span class="op">&gt;</span></span>
<span id="cb113-5"><a href="#cb113-5"></a>  <span class="op">|</span> <span class="op">^</span></span>
<span id="cb113-6"><a href="#cb113-6"></a><span class="dt">I&#39;m</span> failing, help me<span class="op">!</span></span></code></pre></div>
<p><code>parsec</code>のような、より単純なパーサライブラリに精通している 多くの人々にとってはこれで十分です。 しかし、パースエラーをユーザーに表示することだけではなく、 それを分析したり操作したりする必要があるかもしれません。 これが<code>String</code>があまり便利ではないところです。</p>
<p>自明なパースエラーは通常 <code>megaparsec</code> によって生成されますが、 プリミティブ<code>failure</code>を使って自分自身でそのようなエラーを 知らせることができます。</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb114-1"><a href="#cb114-1"></a><span class="ot">failure ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb114-2"><a href="#cb114-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Maybe</span> (<span class="dt">ErrorItem</span> (<span class="dt">Token</span> s)) <span class="co">-- ^ 予期しないアイテム（ある場合）</span></span>
<span id="cb114-3"><a href="#cb114-3"></a>  <span class="ot">-&gt;</span> <span class="dt">Set</span> (<span class="dt">ErrorItem</span> (<span class="dt">Token</span> s)) <span class="co">-- ^ 予期するアイテム</span></span>
<span id="cb114-4"><a href="#cb114-4"></a>  <span class="ot">-&gt;</span> m a</span></code></pre></div>
<div class="sourceCode" id="cb115"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb115-1"><a href="#cb115-1"></a><span class="ot">unfortunateParser ::</span> <span class="dt">Parser</span> ()</span>
<span id="cb115-2"><a href="#cb115-2"></a>unfortunateParser <span class="ot">=</span> failure (<span class="dt">Just</span> <span class="dt">EndOfInput</span>) (Set.fromList es)</span>
<span id="cb115-3"><a href="#cb115-3"></a>  <span class="kw">where</span></span>
<span id="cb115-4"><a href="#cb115-4"></a>    es <span class="ot">=</span> [<span class="dt">Tokens</span> (NE.fromList <span class="st">&quot;a&quot;</span>), <span class="dt">Tokens</span> (NE.fromList <span class="st">&quot;b&quot;</span>)]</span></code></pre></div>
<div class="sourceCode" id="cb116"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb116-1"><a href="#cb116-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> unfortunateParser <span class="st">&quot;&quot;</span></span>
<span id="cb116-2"><a href="#cb116-2"></a><span class="ex">1</span>:1:</span>
<span id="cb116-3"><a href="#cb116-3"></a>  <span class="kw">|</span></span>
<span id="cb116-4"><a href="#cb116-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="op">&lt;</span><span class="ex">empty</span> line<span class="op">&gt;</span></span>
<span id="cb116-5"><a href="#cb116-5"></a>  <span class="kw">|</span> ^</span>
<span id="cb116-6"><a href="#cb116-6"></a><span class="ex">unexpected</span> end of input</span>
<span id="cb116-7"><a href="#cb116-7"></a><span class="ex">expecting</span> <span class="st">&#39;a&#39;</span> or <span class="st">&#39;b&#39;</span></span></code></pre></div>
<p><code>fail</code>に基づいたアプローチとは異なり、 簡単なパースエラーはパターンマッチによる検査や変更が容易です。</p>
<p>ファンシーエラーについては、 プリミティブ<code>fancyFaliure</code>で対応します。</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb117-1"><a href="#cb117-1"></a><span class="ot">fancyFailure ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb117-2"><a href="#cb117-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Set</span> (<span class="dt">ErrorFancy</span> e) <span class="co">-- ^ ファンシーエラーのコンポーネント</span></span>
<span id="cb117-3"><a href="#cb117-3"></a>  <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p><code>fancyFailure</code> を使う際には、直接 <code>fancyFailure</code> を呼び出すのではなく、 字句解析モジュールにある次のようなヘルパーとして定義するのが 望ましいことがよくあります。</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb118-1"><a href="#cb118-1"></a><span class="ot">incorrectIndent ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb118-2"><a href="#cb118-2"></a>  <span class="ot">=&gt;</span> <span class="dt">Ordering</span>  <span class="co">-- ^ 参照レベルと実際のレベル間の望ましい順序</span></span>
<span id="cb118-3"><a href="#cb118-3"></a>  <span class="ot">-&gt;</span> <span class="dt">Pos</span>               <span class="co">-- ^ 参照インデントレベル</span></span>
<span id="cb118-4"><a href="#cb118-4"></a>  <span class="ot">-&gt;</span> <span class="dt">Pos</span>               <span class="co">-- ^ 実際のインデントレベル</span></span>
<span id="cb118-5"><a href="#cb118-5"></a>  <span class="ot">-&gt;</span> m a</span>
<span id="cb118-6"><a href="#cb118-6"></a>incorrectIndent <span class="fu">ord</span> ref actual <span class="ot">=</span> fancyFailure <span class="op">.</span> E.singleton <span class="op">$</span></span>
<span id="cb118-7"><a href="#cb118-7"></a>  <span class="dt">ErrorIndentation</span> <span class="fu">ord</span> ref actual</span></code></pre></div>
<p>あなたのパーサにカスタムパースエラーコンポーネントを追加する例として、 与えられた<code>Text</code>の値がキーワードではないことを示す、 特別なパースエラーを定義することを通して見てみましょう。</p>
<p>まず、サポートしたいシナリオを表現するコンストラクタを使用して データ型を定義する必要があります。</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb119-1"><a href="#cb119-1"></a><span class="kw">data</span> <span class="dt">Custom</span> <span class="ot">=</span> <span class="dt">NotKeyword</span> <span class="dt">Text</span></span>
<span id="cb119-2"><a href="#cb119-2"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Ord</span>)</span></code></pre></div>
<p>そしてそれをパースエラーで表示する方法を<code>megaparsec</code>に伝えてください。</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb120-1"><a href="#cb120-1"></a><span class="kw">instance</span> <span class="dt">ShowErrorComponent</span> <span class="dt">Custom</span> <span class="kw">where</span></span>
<span id="cb120-2"><a href="#cb120-2"></a>  showErrorComponent (<span class="dt">NotKeyword</span> txt) <span class="ot">=</span> T.unpack txt <span class="op">++</span> <span class="st">&quot; is not a keyword&quot;</span></span></code></pre></div>
<p>次に、<code>Parser</code>型シノニムを更新します。</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb121-1"><a href="#cb121-1"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Custom</span> <span class="dt">Text</span></span></code></pre></div>
<p>その後、<code>notKeyword</code>ヘルパーを定義できます。</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb122-1"><a href="#cb122-1"></a><span class="ot">notKeyword ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb122-2"><a href="#cb122-2"></a>notKeyword <span class="ot">=</span> customFailure <span class="op">.</span> <span class="dt">NotKeyword</span></span></code></pre></div>
<p><code>customFailure</code>は<code>Text.Megaparsec</code>モジュールの便利なヘルパーです。</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb123-1"><a href="#cb123-1"></a><span class="ot">customFailure ::</span> <span class="dt">MonadParsec</span> e s m <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> m a</span>
<span id="cb123-2"><a href="#cb123-2"></a>customFailure <span class="ot">=</span> fancyFailure <span class="op">.</span> E.singleton <span class="op">.</span> <span class="dt">ErrorCustom</span></span></code></pre></div>
<p>最後に試してみましょう。</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb124-1"><a href="#cb124-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (notKeyword <span class="st">&quot;foo&quot;</span> :: Parser ()) <span class="st">&quot;&quot;</span></span>
<span id="cb124-2"><a href="#cb124-2"></a><span class="ex">1</span>:1:</span>
<span id="cb124-3"><a href="#cb124-3"></a>  <span class="kw">|</span></span>
<span id="cb124-4"><a href="#cb124-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="op">&lt;</span><span class="ex">empty</span> line<span class="op">&gt;</span></span>
<span id="cb124-5"><a href="#cb124-5"></a>  <span class="kw">|</span> ^</span>
<span id="cb124-6"><a href="#cb124-6"></a><span class="ex">foo</span> is not a keyword</span></code></pre></div>
<p><a name="DispErr"></a></p>
<h2 id="パースエラーの表示">パースエラーの表示</h2>
<p><code>ParseErrorBundle</code>の表示は<code>errorBundlePretty</code>関数で行われます。</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb125-1"><a href="#cb125-1"></a><span class="co">-- | &#39;ParseErrorBundle&#39;をプリティプリントします。バンドル内のすべての &#39;ParseError&#39;は、</span></span>
<span id="cb125-2"><a href="#cb125-2"></a><span class="co">-- 入力ストリームに対して単一の効率的なパスを実行することによって、</span></span>
<span id="cb125-3"><a href="#cb125-3"></a><span class="co">-- 対応する問題が起きている行とともに順番にプリティプリントされます。</span></span>
<span id="cb125-4"><a href="#cb125-4"></a><span class="co">-- レンダリングされた &#39;String&#39;は常に改行で終わります。</span></span>
<span id="cb125-5"><a href="#cb125-5"></a></span>
<span id="cb125-6"><a href="#cb125-6"></a>errorBundlePretty</span>
<span id="cb125-7"><a href="#cb125-7"></a><span class="ot">  ::</span> ( <span class="dt">Stream</span> s</span>
<span id="cb125-8"><a href="#cb125-8"></a>     , <span class="dt">ShowErrorComponent</span> e</span>
<span id="cb125-9"><a href="#cb125-9"></a>     )</span>
<span id="cb125-10"><a href="#cb125-10"></a>  <span class="ot">=&gt;</span> <span class="dt">ParseErrorBundle</span> s e <span class="co">-- ^ 表示するパースエラーバンドル</span></span>
<span id="cb125-11"><a href="#cb125-11"></a>  <span class="ot">-&gt;</span> <span class="dt">String</span>               <span class="co">-- ^ バンドルのテキスト表現</span></span></code></pre></div>
<p>95％のケースで、あなたはこの1つの関数だけを必要とするでしょう。</p>
<p><a name="ChatchErr"></a></p>
<h2 id="実行中のパーサでパースエラーをチャッチする">実行中のパーサでパースエラーをチャッチする</h2>
<p><code>megaparsec</code> のもう1つの便利な機能は、 パースエラーを「キャッチ」し、それを何らかの方法で変更してから、 例外のように再びスローすることが可能なことです。 これはプリミティブ <code>observing</code> によって有効になります。</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb126-1"><a href="#cb126-1"></a><span class="co">-- | @&#39;observing&#39; p@ はパーサ @p@ の失敗を「観察」することを可能にします.</span></span>
<span id="cb126-2"><a href="#cb126-2"></a><span class="co">-- 実際にはパーサを終了せずに、代わりに &#39;Left&#39;の &#39;ParseError&#39;を取得します。</span></span>
<span id="cb126-3"><a href="#cb126-3"></a><span class="co">-- 成功すると、パースされた値はいつものように &#39;Right&#39; で返されます。</span></span>
<span id="cb126-4"><a href="#cb126-4"></a><span class="co">-- このプリミティブは、発生したパースエラーを観察することを可能にするだけで、</span></span>
<span id="cb126-5"><a href="#cb126-5"></a><span class="co">-- パーサ @p@ の動作をバックトラックしたり変更したりすることはありません。</span></span>
<span id="cb126-6"><a href="#cb126-6"></a></span>
<span id="cb126-7"><a href="#cb126-7"></a><span class="ot">observing ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb126-8"><a href="#cb126-8"></a>  <span class="ot">=&gt;</span> m a             <span class="co">-- ^ The parser to run</span></span>
<span id="cb126-9"><a href="#cb126-9"></a>  <span class="ot">-&gt;</span> m (<span class="dt">Either</span> (<span class="dt">ParseError</span> (<span class="dt">Token</span> s) e) a)</span></code></pre></div>
<p>これは、の典型的な <code>observing</code> の使い方を示す完全なプログラムです。</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb127-1"><a href="#cb127-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb127-2"><a href="#cb127-2"></a><span class="ot">{-# LANGUAGE TypeApplications  #-}</span></span>
<span id="cb127-3"><a href="#cb127-3"></a></span>
<span id="cb127-4"><a href="#cb127-4"></a><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></span>
<span id="cb127-5"><a href="#cb127-5"></a></span>
<span id="cb127-6"><a href="#cb127-6"></a><span class="co">-- import Control.Applicative</span></span>
<span id="cb127-7"><a href="#cb127-7"></a><span class="kw">import</span> <span class="dt">Data.List</span> (intercalate)</span>
<span id="cb127-8"><a href="#cb127-8"></a><span class="kw">import</span> <span class="dt">Data.Set</span> (<span class="dt">Set</span>)</span>
<span id="cb127-9"><a href="#cb127-9"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb127-10"><a href="#cb127-10"></a><span class="kw">import</span> <span class="dt">Data.Void</span></span>
<span id="cb127-11"><a href="#cb127-11"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span></span>
<span id="cb127-12"><a href="#cb127-12"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec.Char</span></span>
<span id="cb127-13"><a href="#cb127-13"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb127-14"><a href="#cb127-14"></a></span>
<span id="cb127-15"><a href="#cb127-15"></a><span class="kw">data</span> <span class="dt">Custom</span></span>
<span id="cb127-16"><a href="#cb127-16"></a>  <span class="ot">=</span> <span class="dt">TrivialWithLocation</span></span>
<span id="cb127-17"><a href="#cb127-17"></a>    [<span class="dt">String</span>] <span class="co">-- 位置スタック</span></span>
<span id="cb127-18"><a href="#cb127-18"></a>    (<span class="dt">Maybe</span> (<span class="dt">ErrorItem</span> <span class="dt">Char</span>))</span>
<span id="cb127-19"><a href="#cb127-19"></a>    (<span class="dt">Set</span> (<span class="dt">ErrorItem</span> <span class="dt">Char</span>))</span>
<span id="cb127-20"><a href="#cb127-20"></a>  <span class="op">|</span> <span class="dt">FancyWithLocation</span></span>
<span id="cb127-21"><a href="#cb127-21"></a>    [<span class="dt">String</span>] <span class="co">-- 位置スタック</span></span>
<span id="cb127-22"><a href="#cb127-22"></a>    (<span class="dt">ErrorFancy</span> <span class="dt">Void</span>) <span class="co">-- Custom をネストさせないように Void になっている</span></span>
<span id="cb127-23"><a href="#cb127-23"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span>
<span id="cb127-24"><a href="#cb127-24"></a></span>
<span id="cb127-25"><a href="#cb127-25"></a><span class="kw">instance</span> <span class="dt">ShowErrorComponent</span> <span class="dt">Custom</span> <span class="kw">where</span></span>
<span id="cb127-26"><a href="#cb127-26"></a>  showErrorComponent (<span class="dt">TrivialWithLocation</span> stack us es) <span class="ot">=</span></span>
<span id="cb127-27"><a href="#cb127-27"></a>    parseErrorTextPretty (<span class="dt">TrivialError</span> <span class="op">@</span><span class="dt">Text</span> <span class="op">@</span><span class="dt">Void</span> <span class="fu">undefined</span> us es)</span>
<span id="cb127-28"><a href="#cb127-28"></a>      <span class="op">++</span> showPosStack stack</span>
<span id="cb127-29"><a href="#cb127-29"></a>  showErrorComponent (<span class="dt">FancyWithLocation</span> stack cs) <span class="ot">=</span></span>
<span id="cb127-30"><a href="#cb127-30"></a>    parseErrorTextPretty (<span class="dt">FancyError</span> <span class="op">@</span><span class="dt">Text</span> <span class="op">@</span><span class="dt">Void</span> <span class="fu">undefined</span> (Set.singleton cs))</span>
<span id="cb127-31"><a href="#cb127-31"></a>      <span class="op">++</span> showPosStack stack</span>
<span id="cb127-32"><a href="#cb127-32"></a></span>
<span id="cb127-33"><a href="#cb127-33"></a><span class="ot">showPosStack ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb127-34"><a href="#cb127-34"></a>showPosStack <span class="ot">=</span> intercalate <span class="st">&quot;, &quot;</span> <span class="op">.</span> <span class="fu">fmap</span> (<span class="st">&quot;in &quot;</span> <span class="op">++</span>)</span>
<span id="cb127-35"><a href="#cb127-35"></a></span>
<span id="cb127-36"><a href="#cb127-36"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Custom</span> <span class="dt">Text</span></span>
<span id="cb127-37"><a href="#cb127-37"></a></span>
<span id="cb127-38"><a href="#cb127-38"></a><span class="ot">inside ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb127-39"><a href="#cb127-39"></a>inside location p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb127-40"><a href="#cb127-40"></a>  r <span class="ot">&lt;-</span> observing p</span>
<span id="cb127-41"><a href="#cb127-41"></a>  <span class="kw">case</span> r <span class="kw">of</span></span>
<span id="cb127-42"><a href="#cb127-42"></a>    <span class="dt">Left</span> (<span class="dt">TrivialError</span> _ us es) <span class="ot">-&gt;</span></span>
<span id="cb127-43"><a href="#cb127-43"></a>      fancyFailure <span class="op">.</span> Set.singleton <span class="op">.</span> <span class="dt">ErrorCustom</span> <span class="op">$</span></span>
<span id="cb127-44"><a href="#cb127-44"></a>        <span class="dt">TrivialWithLocation</span> [location] us es</span>
<span id="cb127-45"><a href="#cb127-45"></a>    <span class="dt">Left</span> (<span class="dt">FancyError</span> _ xs) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb127-46"><a href="#cb127-46"></a>      <span class="kw">let</span> f (<span class="dt">ErrorFail</span> msg) <span class="ot">=</span> <span class="dt">ErrorCustom</span> <span class="op">$</span></span>
<span id="cb127-47"><a href="#cb127-47"></a>            <span class="dt">FancyWithLocation</span> [location] (<span class="dt">ErrorFail</span> msg)</span>
<span id="cb127-48"><a href="#cb127-48"></a>          f (<span class="dt">ErrorIndentation</span> <span class="fu">ord</span> rlvl alvl) <span class="ot">=</span> <span class="dt">ErrorCustom</span> <span class="op">$</span></span>
<span id="cb127-49"><a href="#cb127-49"></a>            <span class="dt">FancyWithLocation</span> [location] (<span class="dt">ErrorIndentation</span> <span class="fu">ord</span> rlvl alvl)</span>
<span id="cb127-50"><a href="#cb127-50"></a>          f (<span class="dt">ErrorCustom</span> (<span class="dt">TrivialWithLocation</span> ps us es)) <span class="ot">=</span> <span class="dt">ErrorCustom</span> <span class="op">$</span></span>
<span id="cb127-51"><a href="#cb127-51"></a>            <span class="dt">TrivialWithLocation</span> (location<span class="op">:</span>ps) us es</span>
<span id="cb127-52"><a href="#cb127-52"></a>          f (<span class="dt">ErrorCustom</span> (<span class="dt">FancyWithLocation</span> ps cs)) <span class="ot">=</span> <span class="dt">ErrorCustom</span> <span class="op">$</span></span>
<span id="cb127-53"><a href="#cb127-53"></a>            <span class="dt">FancyWithLocation</span> (location<span class="op">:</span>ps) cs</span>
<span id="cb127-54"><a href="#cb127-54"></a>      fancyFailure (Set.map f xs)</span>
<span id="cb127-55"><a href="#cb127-55"></a>    <span class="dt">Right</span> x <span class="ot">-&gt;</span> <span class="fu">return</span> x</span>
<span id="cb127-56"><a href="#cb127-56"></a></span>
<span id="cb127-57"><a href="#cb127-57"></a><span class="ot">myParser ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb127-58"><a href="#cb127-58"></a>myParser <span class="ot">=</span> some (char <span class="ch">&#39;a&#39;</span>) <span class="op">*&gt;</span> some (char <span class="ch">&#39;b&#39;</span>)</span>
<span id="cb127-59"><a href="#cb127-59"></a></span>
<span id="cb127-60"><a href="#cb127-60"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb127-61"><a href="#cb127-61"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb127-62"><a href="#cb127-62"></a>  parseTest (inside <span class="st">&quot;foo&quot;</span> myParser) <span class="st">&quot;aaacc&quot;</span></span>
<span id="cb127-63"><a href="#cb127-63"></a>  parseTest (inside <span class="st">&quot;foo&quot;</span> <span class="op">$</span> inside <span class="st">&quot;bar&quot;</span> myParser) <span class="st">&quot;aaacc&quot;</span></span></code></pre></div>
<p>演習: このプログラムがどのように機能するのか詳細に理解しなさい。</p>
<p>このプログラムを実行すると、次のように出力されます。</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb128-1"><a href="#cb128-1"></a><span class="dv">1</span><span class="op">:</span><span class="dv">4</span><span class="op">:</span></span>
<span id="cb128-2"><a href="#cb128-2"></a>  <span class="op">|</span></span>
<span id="cb128-3"><a href="#cb128-3"></a><span class="dv">1</span> <span class="op">|</span> aaacc</span>
<span id="cb128-4"><a href="#cb128-4"></a>  <span class="op">|</span>    <span class="op">^</span></span>
<span id="cb128-5"><a href="#cb128-5"></a>unexpected <span class="ch">&#39;c&#39;</span></span>
<span id="cb128-6"><a href="#cb128-6"></a>expecting <span class="ch">&#39;a&#39;</span> <span class="fu">or</span> <span class="ch">&#39;b&#39;</span></span>
<span id="cb128-7"><a href="#cb128-7"></a><span class="kw">in</span> foo</span>
<span id="cb128-8"><a href="#cb128-8"></a><span class="dv">1</span><span class="op">:</span><span class="dv">4</span><span class="op">:</span></span>
<span id="cb128-9"><a href="#cb128-9"></a>  <span class="op">|</span></span>
<span id="cb128-10"><a href="#cb128-10"></a><span class="dv">1</span> <span class="op">|</span> aaacc</span>
<span id="cb128-11"><a href="#cb128-11"></a>  <span class="op">|</span>    <span class="op">^</span></span>
<span id="cb128-12"><a href="#cb128-12"></a>unexpected <span class="ch">&#39;c&#39;</span></span>
<span id="cb128-13"><a href="#cb128-13"></a>expecting <span class="ch">&#39;a&#39;</span> <span class="fu">or</span> <span class="ch">&#39;b&#39;</span></span>
<span id="cb128-14"><a href="#cb128-14"></a><span class="kw">in</span> foo, <span class="kw">in</span> bar</span></code></pre></div>
<p>したがって、この機能を使用してパースエラーに対する位置ラベルの添付や、 実際にパースエラーが何らかの方法で処理される領域を定義できます。 このイディオムは非常に便利なので、 プリミティブ <code>observing</code> の観点から構築された <code>region</code> と呼ばれる非プリミティブヘルパーもあります。</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb129-1"><a href="#cb129-1"></a><span class="co">-- | 内部のラッパーで発生する &#39;ParseError&#39;の処理方法を指定します。</span></span>
<span id="cb129-2"><a href="#cb129-2"></a><span class="co">-- 現在の実装の副作用として、このコンビネータで &#39;errorPos&#39; を変更すると、</span></span>
<span id="cb129-3"><a href="#cb129-3"></a><span class="co">-- 最終的にパーサの状態 &#39;statePos&#39;も変更されま(&#39;statePos&#39; が</span></span>
<span id="cb129-4"><a href="#cb129-4"></a><span class="co">-- 入力ストリームの実際の位置と同期しなくなるので、それを避けてください。</span></span>
<span id="cb129-5"><a href="#cb129-5"></a><span class="co">-- 直後にパースを終了すれば、おそらく問題ありませんが、注意してください)。</span></span>
<span id="cb129-6"><a href="#cb129-6"></a></span>
<span id="cb129-7"><a href="#cb129-7"></a><span class="ot">region ::</span> <span class="dt">MonadParsec</span> e s m</span>
<span id="cb129-8"><a href="#cb129-8"></a>  <span class="ot">=&gt;</span> (<span class="dt">ParseError</span> s e <span class="ot">-&gt;</span> <span class="dt">ParseError</span> s e)</span>
<span id="cb129-9"><a href="#cb129-9"></a>     <span class="co">-- ^ &#39;ParseError&#39; を処理する方法</span></span>
<span id="cb129-10"><a href="#cb129-10"></a>  <span class="ot">-&gt;</span> m a</span>
<span id="cb129-11"><a href="#cb129-11"></a>     <span class="co">-- ^ 処理を適用する 「領域」</span></span>
<span id="cb129-12"><a href="#cb129-12"></a>  <span class="ot">-&gt;</span> m a</span>
<span id="cb129-13"><a href="#cb129-13"></a>region f m <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb129-14"><a href="#cb129-14"></a>  r <span class="ot">&lt;-</span> observing m</span>
<span id="cb129-15"><a href="#cb129-15"></a>  <span class="kw">case</span> r <span class="kw">of</span></span>
<span id="cb129-16"><a href="#cb129-16"></a>    <span class="dt">Left</span> err <span class="ot">-&gt;</span></span>
<span id="cb129-17"><a href="#cb129-17"></a>      <span class="kw">case</span> f err <span class="kw">of</span></span>
<span id="cb129-18"><a href="#cb129-18"></a>        <span class="dt">TrivialError</span> o us ps <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb129-19"><a href="#cb129-19"></a>          updateParserState <span class="op">$</span> \st <span class="ot">-&gt;</span> st { stateOffset <span class="ot">=</span> o }</span>
<span id="cb129-20"><a href="#cb129-20"></a>          failure us ps</span>
<span id="cb129-21"><a href="#cb129-21"></a>        <span class="dt">FancyError</span> o xs <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb129-22"><a href="#cb129-22"></a>          updateParserState <span class="op">$</span> \st <span class="ot">-&gt;</span> st { stateOffset <span class="ot">=</span> o }</span>
<span id="cb129-23"><a href="#cb129-23"></a>          fancyFailure xs</span>
<span id="cb129-24"><a href="#cb129-24"></a>    <span class="dt">Right</span> x <span class="ot">-&gt;</span> <span class="fu">return</span> x</span></code></pre></div>
<p>演習: 上記のプログラムで <code>region</code> を使用して <code>inside</code> 関数を書き換えなさい。</p>
<p>回答例:</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb130-1"><a href="#cb130-1"></a><span class="ot">inside&#39; ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb130-2"><a href="#cb130-2"></a>inside&#39; location p <span class="ot">=</span> region (processParseError location) p</span>
<span id="cb130-3"><a href="#cb130-3"></a></span>
<span id="cb130-4"><a href="#cb130-4"></a><span class="ot">processParseError ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ParseError</span> <span class="dt">Text</span> <span class="dt">Custom</span> <span class="ot">-&gt;</span> <span class="dt">ParseError</span> <span class="dt">Text</span> <span class="dt">Custom</span></span>
<span id="cb130-5"><a href="#cb130-5"></a>processParseError location (<span class="dt">TrivialError</span> i us es) <span class="ot">=</span></span>
<span id="cb130-6"><a href="#cb130-6"></a>  <span class="dt">FancyError</span> i <span class="op">.</span> Set.singleton <span class="op">.</span> <span class="dt">ErrorCustom</span> <span class="op">$</span></span>
<span id="cb130-7"><a href="#cb130-7"></a>    <span class="dt">TrivialWithLocation</span> [location] us es</span>
<span id="cb130-8"><a href="#cb130-8"></a>processParseError location (<span class="dt">FancyError</span> i xs) <span class="ot">=</span></span>
<span id="cb130-9"><a href="#cb130-9"></a>  <span class="dt">FancyError</span> i <span class="op">$</span> Set.map (processErrorFancy location) xs</span>
<span id="cb130-10"><a href="#cb130-10"></a></span>
<span id="cb130-11"><a href="#cb130-11"></a><span class="ot">processErrorFancy ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ErrorFancy</span> <span class="dt">Custom</span> <span class="ot">-&gt;</span> <span class="dt">ErrorFancy</span> <span class="dt">Custom</span></span>
<span id="cb130-12"><a href="#cb130-12"></a>processErrorFancy location (<span class="dt">ErrorFail</span> msg) <span class="ot">=</span> <span class="dt">ErrorCustom</span> <span class="op">$</span></span>
<span id="cb130-13"><a href="#cb130-13"></a>  <span class="dt">FancyWithLocation</span> [location] (<span class="dt">ErrorFail</span> msg)</span>
<span id="cb130-14"><a href="#cb130-14"></a>processErrorFancy location (<span class="dt">ErrorIndentation</span> <span class="fu">ord</span> rlvl alvl) <span class="ot">=</span> <span class="dt">ErrorCustom</span> <span class="op">$</span></span>
<span id="cb130-15"><a href="#cb130-15"></a>  <span class="dt">FancyWithLocation</span> [location] (<span class="dt">ErrorIndentation</span> <span class="fu">ord</span> rlvl alvl)</span>
<span id="cb130-16"><a href="#cb130-16"></a>processErrorFancy location (<span class="dt">ErrorCustom</span> (<span class="dt">TrivialWithLocation</span> ps us es)) <span class="ot">=</span></span>
<span id="cb130-17"><a href="#cb130-17"></a>  <span class="dt">ErrorCustom</span> <span class="op">$</span> <span class="dt">TrivialWithLocation</span> (location<span class="op">:</span>ps) us es</span>
<span id="cb130-18"><a href="#cb130-18"></a>processErrorFancy location (<span class="dt">ErrorCustom</span> (<span class="dt">FancyWithLocation</span> ps cs)) <span class="ot">=</span></span>
<span id="cb130-19"><a href="#cb130-19"></a>  <span class="dt">ErrorCustom</span> <span class="op">$</span> <span class="dt">FancyWithLocation</span> (location<span class="op">:</span>ps) cs</span></code></pre></div>
<p><a name="Testing"></a></p>
<h2 id="megaparsec-パーサのテスト">Megaparsec パーサのテスト</h2>
<p>パーサのテストは、ほとんどの人が遅かれ早かれ直面する実践的なタスクであり、 それをカバーしなければなりません。 <code>megaparsec</code> のパーサをテストするための推奨される方法は <a href="https://hackage.haskell.org/package/hspec-megaparsec"><code>hspec-megaparsec</code></a>パッケージを使うことです。 このパッケージは、<code>hspec</code> テストフレームワークで動作する <code>shouldParse</code>、 <code>parseSatisfies</code> などのユーティリティテスト関数のを追加します。</p>
<p>次の例から見てみましょう。</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb131-1"><a href="#cb131-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb131-2"><a href="#cb131-2"></a></span>
<span id="cb131-3"><a href="#cb131-3"></a><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></span>
<span id="cb131-4"><a href="#cb131-4"></a></span>
<span id="cb131-5"><a href="#cb131-5"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb131-6"><a href="#cb131-6"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb131-7"><a href="#cb131-7"></a><span class="kw">import</span> <span class="dt">Data.Void</span></span>
<span id="cb131-8"><a href="#cb131-8"></a><span class="kw">import</span> <span class="dt">Test.Hspec</span></span>
<span id="cb131-9"><a href="#cb131-9"></a><span class="kw">import</span> <span class="dt">Test.Hspec.Megaparsec</span></span>
<span id="cb131-10"><a href="#cb131-10"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span></span>
<span id="cb131-11"><a href="#cb131-11"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec.Char</span></span>
<span id="cb131-12"><a href="#cb131-12"></a></span>
<span id="cb131-13"><a href="#cb131-13"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Void</span> <span class="dt">Text</span></span>
<span id="cb131-14"><a href="#cb131-14"></a></span>
<span id="cb131-15"><a href="#cb131-15"></a><span class="ot">myParser ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb131-16"><a href="#cb131-16"></a>myParser <span class="ot">=</span> some (char <span class="ch">&#39;a&#39;</span>)</span>
<span id="cb131-17"><a href="#cb131-17"></a></span>
<span id="cb131-18"><a href="#cb131-18"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb131-19"><a href="#cb131-19"></a>main <span class="ot">=</span> hspec <span class="op">$</span></span>
<span id="cb131-20"><a href="#cb131-20"></a>  describe <span class="st">&quot;myParser&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb131-21"><a href="#cb131-21"></a>    it <span class="st">&quot;returns correct result&quot;</span> <span class="op">$</span></span>
<span id="cb131-22"><a href="#cb131-22"></a>      parse myParser <span class="st">&quot;&quot;</span> <span class="st">&quot;aaa&quot;</span> <span class="ot">`shouldParse`</span> <span class="st">&quot;aaa&quot;</span></span>
<span id="cb131-23"><a href="#cb131-23"></a>    it <span class="st">&quot;result of parsing satisfies what it should&quot;</span> <span class="op">$</span></span>
<span id="cb131-24"><a href="#cb131-24"></a>      parse myParser <span class="st">&quot;&quot;</span> <span class="st">&quot;aaaa&quot;</span> <span class="ot">`parseSatisfies`</span> ((<span class="op">==</span> <span class="dv">4</span>) <span class="op">.</span> <span class="fu">length</span>)</span></code></pre></div>
<p><code>shouldParse</code> は、パース結果 <code>Either（ParseErrorBundle s e）a</code> と比較する型 <code>a</code> の値を引数として受け取ります。 おそらく最も一般的なヘルパーです。 <code>parseSatisfies</code> は非常に似ていますが、期待される結果と等しいかどうかを比較する代わりに、任意の述語を適用することによって結果をチェックすることができます。</p>
<p>その他の単純なテスト関数は、 <code>shouldSucceedOn</code> と <code>shouldFailOn</code> です（これらはめったに使われません）。</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb132-1"><a href="#cb132-1"></a>    it <span class="st">&quot;should parse &#39;a&#39;s all right&quot;</span> <span class="op">$</span></span>
<span id="cb132-2"><a href="#cb132-2"></a>      parse myParser <span class="st">&quot;&quot;</span> <span class="ot">`shouldSucceedOn`</span> <span class="st">&quot;aaaa&quot;</span></span>
<span id="cb132-3"><a href="#cb132-3"></a>    it <span class="st">&quot;should fail on &#39;b&#39;s&quot;</span> <span class="op">$</span></span>
<span id="cb132-4"><a href="#cb132-4"></a>      parse myParser <span class="st">&quot;&quot;</span> <span class="ot">`shouldFailOn`</span> <span class="st">&quot;bbb&quot;</span></span></code></pre></div>
<p><code>megaparsec</code> で、パーサが生み出すパースエラーを詳細にテストしたいです。 パースエラーをテストするには <code>shouldFailWith</code> があります。 これは次のように使用できます。</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb133-1"><a href="#cb133-1"></a>    it <span class="st">&quot;fails on &#39;b&#39;s producing correct error message&quot;</span> <span class="op">$</span></span>
<span id="cb133-2"><a href="#cb133-2"></a>      parse myParser <span class="st">&quot;&quot;</span> <span class="st">&quot;bbb&quot;</span> <span class="ot">`shouldFailWith`</span></span>
<span id="cb133-3"><a href="#cb133-3"></a>        <span class="dt">TrivialError</span></span>
<span id="cb133-4"><a href="#cb133-4"></a>          <span class="dv">0</span></span>
<span id="cb133-5"><a href="#cb133-5"></a>          (<span class="dt">Just</span> (<span class="dt">Tokens</span> (<span class="ch">&#39;b&#39;</span> <span class="op">:|</span> [])))</span>
<span id="cb133-6"><a href="#cb133-6"></a>          (Set.singleton (<span class="dt">Tokens</span> (<span class="ch">&#39;a&#39;</span> <span class="op">:|</span> [])))</span></code></pre></div>
<p>このように <code>TrivialError</code> を書き出すのは面倒です。 <code>ParseError</code> の定義には、<code>Set</code> や <code>NonEmpty</code> のような 「不便な」型が含まれています。これらは、 今見たとおり直接入力するのには便利ではありません。 幸い、<code>Test.Hspec.Megaparsec</code> は、 <code>ParserErrors</code>をより簡単に構築するためのAPIを提供する <code>Text.Megaparsec.Error.Builder</code> モジュールも再エクスポートします。 代わりに <code>err</code> ヘルパーを使用しましょう。</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb134-1"><a href="#cb134-1"></a>    it <span class="st">&quot;fails on &#39;b&#39;s producing correct error message&quot;</span> <span class="op">$</span></span>
<span id="cb134-2"><a href="#cb134-2"></a>      parse myParser <span class="st">&quot;&quot;</span> <span class="st">&quot;bbb&quot;</span> <span class="ot">`shouldFailWith`</span> err <span class="dv">0</span> (utok <span class="ch">&#39;b&#39;</span> <span class="op">&lt;&gt;</span> etok <span class="ch">&#39;a&#39;</span>)</span></code></pre></div>
<ul>
<li><p><code>err</code> の最初の引数は、パースエラーのオフセット（エラーが発生する前に消費されたトークンの数）です。今回はそれは単に0です。</p></li>
<li><p><code>utok</code> は「期待しないトークン」を表し、同様に <code>etok</code> は「期待するトークン」を意味します。</p></li>
</ul>
<p>演習: ファンシーパースエラーを構築するために、<code>errFancy</code> と呼ばれる同様のヘルパーがありますので、それをよく理解してください。</p>
<p>最後に、<code>failsLeaving</code> と <code>succeedsLeaving</code> を使用して、 パース後に入力のどの部分が未消費のままであるかをテストすることができます。</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb135-1"><a href="#cb135-1"></a>    it <span class="st">&quot;consumes all &#39;a&#39;s but does not touch &#39;b&#39;s&quot;</span> <span class="op">$</span></span>
<span id="cb135-2"><a href="#cb135-2"></a>      runParser&#39; myParser (initialState <span class="st">&quot;aaabbb&quot;</span>) <span class="ot">`succeedsLeaving`</span> <span class="st">&quot;bbb&quot;</span></span>
<span id="cb135-3"><a href="#cb135-3"></a>    it <span class="st">&quot;fails without consuming anything&quot;</span> <span class="op">$</span></span>
<span id="cb135-4"><a href="#cb135-4"></a>      runParser&#39; myParser (initialState <span class="st">&quot;bbbccc&quot;</span>) <span class="ot">`failsLeaving`</span> <span class="st">&quot;bbbccc&quot;</span></span></code></pre></div>
<p>これらは、パーサのカスタム初期状態を受け取り、 その最終状態を返す <code>runParser'</code> または <code>runParserT'</code> と共に 使用する必要があります（これにより、 パース後に入力ストリームの残りをチェックすることができます）。</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb136-1"><a href="#cb136-1"></a>runParser&#39;</span>
<span id="cb136-2"><a href="#cb136-2"></a><span class="ot">  ::</span> <span class="dt">Parsec</span> e s a      <span class="co">-- ^ Parser to run</span></span>
<span id="cb136-3"><a href="#cb136-3"></a>  <span class="ot">-&gt;</span> <span class="dt">State</span> s           <span class="co">-- ^ Initial state</span></span>
<span id="cb136-4"><a href="#cb136-4"></a>  <span class="ot">-&gt;</span> (<span class="dt">State</span> s, <span class="dt">Either</span> (<span class="dt">ParseError</span> (<span class="dt">Token</span> s) e) a)</span>
<span id="cb136-5"><a href="#cb136-5"></a></span>
<span id="cb136-6"><a href="#cb136-6"></a><span class="ot">runParserT&#39; ::</span> <span class="dt">Monad</span> m</span>
<span id="cb136-7"><a href="#cb136-7"></a>  <span class="ot">=&gt;</span> <span class="dt">ParsecT</span> e s m a   <span class="co">-- ^ Parser to run</span></span>
<span id="cb136-8"><a href="#cb136-8"></a>  <span class="ot">-&gt;</span> <span class="dt">State</span> s           <span class="co">-- ^ Initial state</span></span>
<span id="cb136-9"><a href="#cb136-9"></a>  <span class="ot">-&gt;</span> m (<span class="dt">State</span> s, <span class="dt">Either</span> (<span class="dt">ParseError</span> (<span class="dt">Token</span> s) e) a)</span></code></pre></div>
<p><code>initialState</code> 関数は入力ストリームを受け取り、 その入力ストリームとデフォルト値で埋められた レコードフィールドの初期状態を返します。</p>
<p><code>hspec-megaparsec</code> を使用するためのその他のヒントは次のとおりです。</p>
<ul>
<li><p><a href="https://github.com/mrkkrp/megaparsec/tree/master/megaparsec-tests">Megaparsec自身のテスト</a> はhspec-megaparsecを使って書かれています。</p></li>
<li><p><code>hspec-megaparsec</code> 自体に付属している<a href="https://github.com/mrkkrp/hspec-megaparsec/blob/master/tests/Main.hs">トイテストスイート</a>。</p></li>
</ul>
<p><a name="CustomInput"></a></p>
<h2 id="カスタム入力ストリームの操作">カスタム入力ストリームの操作</h2>
<p><code>megaparsec</code> は、 <code>Stream</code> 型クラスのインスタンスである入力をパースできます。 これは、<code>alex</code>などの字句解析ツールと組み合わせて使用できることを 意味します。</p>
<p>主題から離れないようにするため、 <code>alex</code> がどのようにしてトークンのストリーム生成するのかは説明しません。 また、次の形式を想定します。</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb137-1"><a href="#cb137-1"></a><span class="ot">{-# LANGUAGE LambdaCase        #-}</span></span>
<span id="cb137-2"><a href="#cb137-2"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb137-3"><a href="#cb137-3"></a><span class="ot">{-# LANGUAGE TypeFamilies      #-}</span></span>
<span id="cb137-4"><a href="#cb137-4"></a></span>
<span id="cb137-5"><a href="#cb137-5"></a><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></span>
<span id="cb137-6"><a href="#cb137-6"></a></span>
<span id="cb137-7"><a href="#cb137-7"></a><span class="kw">import</span> <span class="dt">Data.List.NonEmpty</span> (<span class="dt">NonEmpty</span> (..))</span>
<span id="cb137-8"><a href="#cb137-8"></a><span class="kw">import</span> <span class="dt">Data.Proxy</span></span>
<span id="cb137-9"><a href="#cb137-9"></a><span class="kw">import</span> <span class="dt">Data.Void</span></span>
<span id="cb137-10"><a href="#cb137-10"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span></span>
<span id="cb137-11"><a href="#cb137-11"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.List</span>          <span class="kw">as</span> <span class="dt">DL</span></span>
<span id="cb137-12"><a href="#cb137-12"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.List.NonEmpty</span> <span class="kw">as</span> <span class="dt">NE</span></span>
<span id="cb137-13"><a href="#cb137-13"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span>           <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb137-14"><a href="#cb137-14"></a></span>
<span id="cb137-15"><a href="#cb137-15"></a><span class="kw">data</span> <span class="dt">MyToken</span></span>
<span id="cb137-16"><a href="#cb137-16"></a>  <span class="ot">=</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb137-17"><a href="#cb137-17"></a>  <span class="op">|</span> <span class="dt">Plus</span></span>
<span id="cb137-18"><a href="#cb137-18"></a>  <span class="op">|</span> <span class="dt">Mul</span></span>
<span id="cb137-19"><a href="#cb137-19"></a>  <span class="op">|</span> <span class="dt">Div</span></span>
<span id="cb137-20"><a href="#cb137-20"></a>  <span class="op">|</span> <span class="dt">OpenParen</span></span>
<span id="cb137-21"><a href="#cb137-21"></a>  <span class="op">|</span> <span class="dt">CloseParen</span></span>
<span id="cb137-22"><a href="#cb137-22"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p>パースエラーを報告するために、 トークンの開始位置と終了位置を知る方法が必要なので、 <code>WithPos</code> を追加しましょう。</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb138-1"><a href="#cb138-1"></a><span class="kw">data</span> <span class="dt">WithPos</span> a <span class="ot">=</span> <span class="dt">WithPos</span></span>
<span id="cb138-2"><a href="#cb138-2"></a>  {<span class="ot"> startPos ::</span> <span class="dt">SourcePos</span></span>
<span id="cb138-3"><a href="#cb138-3"></a>  ,<span class="ot"> endPos   ::</span> <span class="dt">SourcePos</span></span>
<span id="cb138-4"><a href="#cb138-4"></a>  ,<span class="ot"> tokenVal ::</span> a</span>
<span id="cb138-5"><a href="#cb138-5"></a>  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span></code></pre></div>
<p>これでストリームのデータ型ができます。</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb139-1"><a href="#cb139-1"></a><span class="kw">newtype</span> <span class="dt">MyStream</span> <span class="ot">=</span> <span class="dt">MyStream</span></span>
<span id="cb139-2"><a href="#cb139-2"></a>  {<span class="ot"> unMyStream ::</span> [<span class="dt">WithPos</span> <span class="dt">MyToken</span>]</span>
<span id="cb139-3"><a href="#cb139-3"></a>  }</span></code></pre></div>
<p>次に、<code>MyStream</code> を <code>Stream</code> 型クラスのインスタンスにする必要があります。 関連型関数 <code>Token</code> と <code>Tokens</code> を定義したいので、 <code>TypeFamilies</code> の言語拡張が必要です。</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb140-1"><a href="#cb140-1"></a><span class="kw">instance</span> <span class="dt">Stream</span> <span class="dt">MyStream</span> <span class="kw">where</span></span>
<span id="cb140-2"><a href="#cb140-2"></a>  <span class="kw">type</span> <span class="dt">Token</span>  <span class="dt">MyStream</span> <span class="ot">=</span> <span class="dt">WithPos</span> <span class="dt">MyToken</span></span>
<span id="cb140-3"><a href="#cb140-3"></a>  <span class="kw">type</span> <span class="dt">Tokens</span> <span class="dt">MyStream</span> <span class="ot">=</span> [<span class="dt">WithPos</span> <span class="dt">MyToken</span>]</span>
<span id="cb140-4"><a href="#cb140-4"></a>  <span class="co">-- …</span></span></code></pre></div>
<p><code>Stream</code> は <code>Text.Megaparsec.Stream</code> モジュールに 詳しいドキュメントがあります。 足りないメソッドを定義していきましょう。</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb141-1"><a href="#cb141-1"></a><span class="co">-- …</span></span>
<span id="cb141-2"><a href="#cb141-2"></a>  tokenToChunk <span class="dt">Proxy</span> x <span class="ot">=</span> [x]</span>
<span id="cb141-3"><a href="#cb141-3"></a>  tokensToChunk <span class="dt">Proxy</span> xs <span class="ot">=</span> xs</span>
<span id="cb141-4"><a href="#cb141-4"></a>  chunkToTokens <span class="dt">Proxy</span> <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb141-5"><a href="#cb141-5"></a>  chunkLength <span class="dt">Proxy</span> <span class="ot">=</span> <span class="fu">length</span></span>
<span id="cb141-6"><a href="#cb141-6"></a>  chunkEmpty <span class="dt">Proxy</span> <span class="ot">=</span> <span class="fu">null</span></span>
<span id="cb141-7"><a href="#cb141-7"></a>  take1_ (<span class="dt">MyStream</span> []) <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb141-8"><a href="#cb141-8"></a>  take1_ (<span class="dt">MyStream</span> (t<span class="op">:</span>ts)) <span class="ot">=</span> <span class="dt">Just</span> (t, <span class="dt">MyStream</span> ts)</span>
<span id="cb141-9"><a href="#cb141-9"></a>  takeN_ n (<span class="dt">MyStream</span> s)</span>
<span id="cb141-10"><a href="#cb141-10"></a>    <span class="op">|</span> n <span class="op">&lt;=</span> <span class="dv">0</span>    <span class="ot">=</span> <span class="dt">Just</span> ([], <span class="dt">MyStream</span> s)</span>
<span id="cb141-11"><a href="#cb141-11"></a>    <span class="op">|</span> <span class="fu">null</span> s    <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb141-12"><a href="#cb141-12"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span></span>
<span id="cb141-13"><a href="#cb141-13"></a>        <span class="kw">let</span> (x, s&#39;) <span class="ot">=</span> <span class="fu">splitAt</span> n s</span>
<span id="cb141-14"><a href="#cb141-14"></a>        <span class="kw">in</span> <span class="dt">Just</span> (x, <span class="dt">MyStream</span> s&#39;)</span>
<span id="cb141-15"><a href="#cb141-15"></a>  takeWhile_ f (<span class="dt">MyStream</span> s) <span class="ot">=</span></span>
<span id="cb141-16"><a href="#cb141-16"></a>    <span class="kw">let</span> (x, s&#39;) <span class="ot">=</span> DL.span f s</span>
<span id="cb141-17"><a href="#cb141-17"></a>    <span class="kw">in</span> (x, <span class="dt">MyStream</span> s&#39;)</span>
<span id="cb141-18"><a href="#cb141-18"></a>  showTokens <span class="dt">Proxy</span> <span class="ot">=</span> DL.intercalate <span class="st">&quot;, &quot;</span></span>
<span id="cb141-19"><a href="#cb141-19"></a>    <span class="op">.</span> NE.toList</span>
<span id="cb141-20"><a href="#cb141-20"></a>    <span class="op">.</span> <span class="fu">fmap</span> (showMyToken <span class="op">.</span> tokenVal)</span>
<span id="cb141-21"><a href="#cb141-21"></a>  reachOffset o pst<span class="op">@</span><span class="dt">PosState</span> {<span class="op">..</span>} <span class="ot">=</span></span>
<span id="cb141-22"><a href="#cb141-22"></a>    <span class="kw">case</span> <span class="fu">drop</span> (o <span class="op">-</span> pstateOffset) (unMyStream pstateInput) <span class="kw">of</span></span>
<span id="cb141-23"><a href="#cb141-23"></a>      [] <span class="ot">-&gt;</span></span>
<span id="cb141-24"><a href="#cb141-24"></a>        ( pstateSourcePos</span>
<span id="cb141-25"><a href="#cb141-25"></a>        , <span class="st">&quot;&lt;missing input&gt;&quot;</span></span>
<span id="cb141-26"><a href="#cb141-26"></a>        , pst { pstateInput <span class="ot">=</span> <span class="dt">MyStream</span> [] }</span>
<span id="cb141-27"><a href="#cb141-27"></a>        )</span>
<span id="cb141-28"><a href="#cb141-28"></a>      (x<span class="op">:</span>xs) <span class="ot">-&gt;</span></span>
<span id="cb141-29"><a href="#cb141-29"></a>        ( startPos x</span>
<span id="cb141-30"><a href="#cb141-30"></a>        , <span class="st">&quot;&lt;missing input&gt;&quot;</span></span>
<span id="cb141-31"><a href="#cb141-31"></a>        , pst { pstateInput <span class="ot">=</span> <span class="dt">MyStream</span> (x<span class="op">:</span>xs) }</span>
<span id="cb141-32"><a href="#cb141-32"></a>        )</span>
<span id="cb141-33"><a href="#cb141-33"></a></span>
<span id="cb141-34"><a href="#cb141-34"></a><span class="ot">showMyToken ::</span> <span class="dt">MyToken</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb141-35"><a href="#cb141-35"></a>showMyToken <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb141-36"><a href="#cb141-36"></a>  (<span class="dt">Int</span> n)    <span class="ot">-&gt;</span> <span class="fu">show</span> n</span>
<span id="cb141-37"><a href="#cb141-37"></a>  <span class="dt">Plus</span>       <span class="ot">-&gt;</span> <span class="st">&quot;+&quot;</span></span>
<span id="cb141-38"><a href="#cb141-38"></a>  <span class="dt">Mul</span>        <span class="ot">-&gt;</span> <span class="st">&quot;*&quot;</span></span>
<span id="cb141-39"><a href="#cb141-39"></a>  <span class="dt">Div</span>        <span class="ot">-&gt;</span> <span class="st">&quot;/&quot;</span></span>
<span id="cb141-40"><a href="#cb141-40"></a>  <span class="dt">OpenParen</span>  <span class="ot">-&gt;</span> <span class="st">&quot;(&quot;</span></span>
<span id="cb141-41"><a href="#cb141-41"></a>  <span class="dt">CloseParen</span> <span class="ot">-&gt;</span> <span class="st">&quot;)&quot;</span></span></code></pre></div>
<p><code>Stream</code> 型クラスに関する詳しい参考資料 (そしてなぜこのようになっているのか)は <a href="https://markkarpov.com/post/megaparsec-more-speed-more-power.html">このブログ記事</a> に書いてあります。 <code>reachOffset</code> 関数では、元の入力ストリームが不足しているため、 問題のある行を実際に表示することはできません。 これは解決できますが、解決策はこの記事の範囲外です。</p>
<p>これで <code>Parser</code> 型が定義できます。</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb142-1"><a href="#cb142-1"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Void</span> <span class="dt">MyStream</span></span></code></pre></div>
<p>次のステップは、 <code>token</code> と (意味があるなら)<code>tokens</code> のプリミティブを使って、 基本的なパーサを定義することです。 そのまま使用できるストリームには、 <code>Text.Megaparsec.Byte</code> および <code>Text.Megaparsec.Char</code> モジュールが ありますが、カスタムトークンを使用する場合はカスタムヘルパーが必要です。</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb143-1"><a href="#cb143-1"></a><span class="ot">liftMyToken ::</span> <span class="dt">MyToken</span> <span class="ot">-&gt;</span> <span class="dt">WithPos</span> <span class="dt">MyToken</span></span>
<span id="cb143-2"><a href="#cb143-2"></a>liftMyToken myToken <span class="ot">=</span> <span class="dt">WithPos</span> pos pos myToken</span>
<span id="cb143-3"><a href="#cb143-3"></a>  <span class="kw">where</span></span>
<span id="cb143-4"><a href="#cb143-4"></a>    pos <span class="ot">=</span> initialPos <span class="st">&quot;&quot;</span></span>
<span id="cb143-5"><a href="#cb143-5"></a></span>
<span id="cb143-6"><a href="#cb143-6"></a><span class="ot">pToken ::</span> <span class="dt">MyToken</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">MyToken</span></span>
<span id="cb143-7"><a href="#cb143-7"></a>pToken c <span class="ot">=</span> token test (Set.singleton <span class="op">.</span> <span class="dt">Tokens</span> <span class="op">.</span> nes <span class="op">.</span> liftMyToken <span class="op">$</span> c)</span>
<span id="cb143-8"><a href="#cb143-8"></a>  <span class="kw">where</span></span>
<span id="cb143-9"><a href="#cb143-9"></a>    test wpos<span class="op">@</span>(<span class="dt">WithPos</span> _ _ x) <span class="ot">=</span></span>
<span id="cb143-10"><a href="#cb143-10"></a>      <span class="kw">if</span> x <span class="op">==</span> c</span>
<span id="cb143-11"><a href="#cb143-11"></a>        <span class="kw">then</span> <span class="dt">Just</span> x</span>
<span id="cb143-12"><a href="#cb143-12"></a>        <span class="kw">else</span> <span class="dt">Nothing</span></span>
<span id="cb143-13"><a href="#cb143-13"></a>    nes x <span class="ot">=</span> x <span class="op">:|</span> []</span>
<span id="cb143-14"><a href="#cb143-14"></a></span>
<span id="cb143-15"><a href="#cb143-15"></a><span class="ot">pInt ::</span> <span class="dt">Parser</span> <span class="dt">Int</span></span>
<span id="cb143-16"><a href="#cb143-16"></a>pInt <span class="ot">=</span> token test Set.empty <span class="op">&lt;?&gt;</span> <span class="st">&quot;integer&quot;</span></span>
<span id="cb143-17"><a href="#cb143-17"></a>  <span class="kw">where</span></span>
<span id="cb143-18"><a href="#cb143-18"></a>    test (<span class="dt">WithPos</span> _ _ (<span class="dt">Int</span> n)) <span class="ot">=</span> <span class="dt">Just</span> n</span>
<span id="cb143-19"><a href="#cb143-19"></a>    test _ <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>最後に、足し算をパースするテストパーサを用意しましょう。</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb144-1"><a href="#cb144-1"></a><span class="ot">pSum ::</span> <span class="dt">Parser</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb144-2"><a href="#cb144-2"></a>pSum <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb144-3"><a href="#cb144-3"></a>  a <span class="ot">&lt;-</span> pInt</span>
<span id="cb144-4"><a href="#cb144-4"></a>  _ <span class="ot">&lt;-</span> pToken <span class="dt">Plus</span></span>
<span id="cb144-5"><a href="#cb144-5"></a>  b <span class="ot">&lt;-</span> pInt</span>
<span id="cb144-6"><a href="#cb144-6"></a>  <span class="fu">return</span> (a, b)</span></code></pre></div>
<p>入力例は次のようにします。</p>
<div class="sourceCode" id="cb145"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb145-1"><a href="#cb145-1"></a><span class="ot">exampleStream ::</span> <span class="dt">MyStream</span></span>
<span id="cb145-2"><a href="#cb145-2"></a>exampleStream <span class="ot">=</span> <span class="dt">MyStream</span></span>
<span id="cb145-3"><a href="#cb145-3"></a>  [ at <span class="dv">1</span> <span class="dv">1</span> (<span class="dt">Int</span> <span class="dv">5</span>)</span>
<span id="cb145-4"><a href="#cb145-4"></a>  , at <span class="dv">1</span> <span class="dv">3</span> <span class="dt">Plus</span>         <span class="co">-- (1)</span></span>
<span id="cb145-5"><a href="#cb145-5"></a>  , at <span class="dv">1</span> <span class="dv">5</span> (<span class="dt">Int</span> <span class="dv">6</span>) ]</span>
<span id="cb145-6"><a href="#cb145-6"></a>  <span class="kw">where</span></span>
<span id="cb145-7"><a href="#cb145-7"></a>    at  l c <span class="ot">=</span> <span class="dt">WithPos</span> (at&#39; l c) (at&#39; l (c <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb145-8"><a href="#cb145-8"></a>    at&#39; l c <span class="ot">=</span> <span class="dt">SourcePos</span> <span class="st">&quot;&quot;</span> (mkPos l) (mkPos c)</span></code></pre></div>
<p>試してみましょう。</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb146-1"><a href="#cb146-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pSum <span class="op">&lt;</span>* eof) <span class="ex">exampleStream</span></span>
<span id="cb146-2"><a href="#cb146-2"></a><span class="kw">(</span><span class="ex">5</span>,6<span class="kw">)</span></span></code></pre></div>
<p>行(1)の <code>Plus</code> を <code>Div</code> に変更すると、正しいパースエラーが発生します。</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb147-1"><a href="#cb147-1"></a>λ<span class="op">&gt;</span> <span class="ex">parseTest</span> (pSum <span class="op">&lt;</span>* eof) <span class="ex">exampleStream</span></span>
<span id="cb147-2"><a href="#cb147-2"></a><span class="ex">1</span>:3:</span>
<span id="cb147-3"><a href="#cb147-3"></a>  <span class="kw">|</span></span>
<span id="cb147-4"><a href="#cb147-4"></a><span class="ex">1</span> <span class="kw">|</span> <span class="op">&lt;</span><span class="ex">missing</span> input<span class="op">&gt;</span></span>
<span id="cb147-5"><a href="#cb147-5"></a>  <span class="kw">|</span>   ^</span>
<span id="cb147-6"><a href="#cb147-6"></a><span class="ex">unexpected</span> /</span>
<span id="cb147-7"><a href="#cb147-7"></a><span class="ex">expecting</span> +</span></code></pre></div>
<p>言い換えると、カスタムストリームのパースが可能な 十分に機能するパーサができました。</p>
<h2 id="演習の回答例puri-を完成させる">演習の回答例(<code>pUri</code> を完成させる)</h2>
<div class="sourceCode" id="cb148"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb148-1"><a href="#cb148-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb148-2"><a href="#cb148-2"></a><span class="ot">{-# LANGUAGE RecordWildCards   #-}</span></span>
<span id="cb148-3"><a href="#cb148-3"></a></span>
<span id="cb148-4"><a href="#cb148-4"></a><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></span>
<span id="cb148-5"><a href="#cb148-5"></a></span>
<span id="cb148-6"><a href="#cb148-6"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span> <span class="kw">hiding</span> (some,many)</span>
<span id="cb148-7"><a href="#cb148-7"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb148-8"><a href="#cb148-8"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb148-9"><a href="#cb148-9"></a><span class="kw">import</span> <span class="dt">Data.Void</span></span>
<span id="cb148-10"><a href="#cb148-10"></a><span class="kw">import</span> <span class="dt">Data.Char</span></span>
<span id="cb148-11"><a href="#cb148-11"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span> <span class="kw">hiding</span> (<span class="dt">State</span>)</span>
<span id="cb148-12"><a href="#cb148-12"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec.Char</span></span>
<span id="cb148-13"><a href="#cb148-13"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb148-14"><a href="#cb148-14"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Megaparsec.Char.Lexer</span> <span class="kw">as</span> <span class="dt">L</span></span>
<span id="cb148-15"><a href="#cb148-15"></a></span>
<span id="cb148-16"><a href="#cb148-16"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Void</span> <span class="dt">Text</span></span>
<span id="cb148-17"><a href="#cb148-17"></a></span>
<span id="cb148-18"><a href="#cb148-18"></a><span class="kw">data</span> <span class="dt">Uri</span> <span class="ot">=</span> <span class="dt">Uri</span></span>
<span id="cb148-19"><a href="#cb148-19"></a>  {<span class="ot"> uriScheme    ::</span> <span class="dt">Scheme</span></span>
<span id="cb148-20"><a href="#cb148-20"></a>  ,<span class="ot"> uriAuthority ::</span> <span class="dt">Maybe</span> <span class="dt">Authority</span></span>
<span id="cb148-21"><a href="#cb148-21"></a>  ,<span class="ot"> uriPath      ::</span> [<span class="dt">Text</span>]</span>
<span id="cb148-22"><a href="#cb148-22"></a>  ,<span class="ot"> uriQuery     ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span></span>
<span id="cb148-23"><a href="#cb148-23"></a>  ,<span class="ot"> uriFlagment  ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span></span>
<span id="cb148-24"><a href="#cb148-24"></a>  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb148-25"><a href="#cb148-25"></a></span>
<span id="cb148-26"><a href="#cb148-26"></a><span class="kw">data</span> <span class="dt">Scheme</span></span>
<span id="cb148-27"><a href="#cb148-27"></a>  <span class="ot">=</span> <span class="dt">SchemeData</span></span>
<span id="cb148-28"><a href="#cb148-28"></a>  <span class="op">|</span> <span class="dt">SchemeFile</span></span>
<span id="cb148-29"><a href="#cb148-29"></a>  <span class="op">|</span> <span class="dt">SchemeFtp</span></span>
<span id="cb148-30"><a href="#cb148-30"></a>  <span class="op">|</span> <span class="dt">SchemeHttp</span></span>
<span id="cb148-31"><a href="#cb148-31"></a>  <span class="op">|</span> <span class="dt">SchemeHttps</span></span>
<span id="cb148-32"><a href="#cb148-32"></a>  <span class="op">|</span> <span class="dt">SchemeIrc</span></span>
<span id="cb148-33"><a href="#cb148-33"></a>  <span class="op">|</span> <span class="dt">SchemeMailto</span></span>
<span id="cb148-34"><a href="#cb148-34"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb148-35"><a href="#cb148-35"></a></span>
<span id="cb148-36"><a href="#cb148-36"></a><span class="kw">data</span> <span class="dt">Authority</span> <span class="ot">=</span> <span class="dt">Authority</span></span>
<span id="cb148-37"><a href="#cb148-37"></a>  {<span class="ot"> authUser ::</span> <span class="dt">Maybe</span> (<span class="dt">Text</span>, <span class="dt">Text</span>) <span class="co">-- (user, password)</span></span>
<span id="cb148-38"><a href="#cb148-38"></a>  ,<span class="ot"> authHost ::</span> <span class="dt">Text</span></span>
<span id="cb148-39"><a href="#cb148-39"></a>  ,<span class="ot"> authPort ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb148-40"><a href="#cb148-40"></a>  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb148-41"><a href="#cb148-41"></a></span>
<span id="cb148-42"><a href="#cb148-42"></a><span class="ot">pScheme ::</span> <span class="dt">Parser</span> <span class="dt">Scheme</span></span>
<span id="cb148-43"><a href="#cb148-43"></a>pScheme <span class="ot">=</span> choice</span>
<span id="cb148-44"><a href="#cb148-44"></a>  [ <span class="dt">SchemeData</span>   <span class="op">&lt;$</span> string <span class="st">&quot;data&quot;</span></span>
<span id="cb148-45"><a href="#cb148-45"></a>  , <span class="dt">SchemeFile</span>   <span class="op">&lt;$</span> string <span class="st">&quot;file&quot;</span></span>
<span id="cb148-46"><a href="#cb148-46"></a>  , <span class="dt">SchemeFtp</span>    <span class="op">&lt;$</span> string <span class="st">&quot;ftp&quot;</span></span>
<span id="cb148-47"><a href="#cb148-47"></a>  , <span class="dt">SchemeHttps</span>  <span class="op">&lt;$</span> string <span class="st">&quot;https&quot;</span></span>
<span id="cb148-48"><a href="#cb148-48"></a>  , <span class="dt">SchemeHttp</span>   <span class="op">&lt;$</span> string <span class="st">&quot;http&quot;</span></span>
<span id="cb148-49"><a href="#cb148-49"></a>  , <span class="dt">SchemeIrc</span>    <span class="op">&lt;$</span> string <span class="st">&quot;irc&quot;</span></span>
<span id="cb148-50"><a href="#cb148-50"></a>  , <span class="dt">SchemeMailto</span> <span class="op">&lt;$</span> string <span class="st">&quot;mailto&quot;</span> ]</span>
<span id="cb148-51"><a href="#cb148-51"></a></span>
<span id="cb148-52"><a href="#cb148-52"></a><span class="ot">alternatives ::</span> <span class="dt">Parser</span> (<span class="dt">Char</span>, <span class="dt">Char</span>)</span>
<span id="cb148-53"><a href="#cb148-53"></a>alternatives <span class="ot">=</span> try foo <span class="op">&lt;|&gt;</span> bar</span>
<span id="cb148-54"><a href="#cb148-54"></a>  <span class="kw">where</span></span>
<span id="cb148-55"><a href="#cb148-55"></a>    foo <span class="ot">=</span> (,) <span class="op">&lt;$&gt;</span> char <span class="ch">&#39;a&#39;</span> <span class="op">&lt;*&gt;</span> char <span class="ch">&#39;b&#39;</span></span>
<span id="cb148-56"><a href="#cb148-56"></a>    bar <span class="ot">=</span> (,) <span class="op">&lt;$&gt;</span> char <span class="ch">&#39;a&#39;</span> <span class="op">&lt;*&gt;</span> char <span class="ch">&#39;c&#39;</span></span>
<span id="cb148-57"><a href="#cb148-57"></a></span>
<span id="cb148-58"><a href="#cb148-58"></a><span class="ot">pPath ::</span> <span class="dt">Parser</span> [<span class="dt">Text</span>]</span>
<span id="cb148-59"><a href="#cb148-59"></a>pPath <span class="ot">=</span> choice</span>
<span id="cb148-60"><a href="#cb148-60"></a>  [ pPathAbempty</span>
<span id="cb148-61"><a href="#cb148-61"></a>  , pPathAbsolute</span>
<span id="cb148-62"><a href="#cb148-62"></a>  , pPathNoScheme</span>
<span id="cb148-63"><a href="#cb148-63"></a>  , pPathRootless</span>
<span id="cb148-64"><a href="#cb148-64"></a>  , pPathEmpty</span>
<span id="cb148-65"><a href="#cb148-65"></a>  ]</span>
<span id="cb148-66"><a href="#cb148-66"></a></span>
<span id="cb148-67"><a href="#cb148-67"></a><span class="ot">pPathAbempty ::</span> <span class="dt">Parser</span> [<span class="dt">Text</span>]</span>
<span id="cb148-68"><a href="#cb148-68"></a>pPathAbempty <span class="ot">=</span> many (char <span class="ch">&#39;/&#39;</span> <span class="op">*&gt;</span> pSegment)</span>
<span id="cb148-69"><a href="#cb148-69"></a></span>
<span id="cb148-70"><a href="#cb148-70"></a><span class="ot">pPathAbsolute ::</span> <span class="dt">Parser</span> [<span class="dt">Text</span>]</span>
<span id="cb148-71"><a href="#cb148-71"></a>pPathAbsolute <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb148-72"><a href="#cb148-72"></a>  void (char <span class="ch">&#39;/&#39;</span>)</span>
<span id="cb148-73"><a href="#cb148-73"></a>  option [] <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb148-74"><a href="#cb148-74"></a>    seg <span class="ot">&lt;-</span> pSegmentNz</span>
<span id="cb148-75"><a href="#cb148-75"></a>    segs <span class="ot">&lt;-</span>  many (char <span class="ch">&#39;/&#39;</span> <span class="op">*&gt;</span> pSegment)</span>
<span id="cb148-76"><a href="#cb148-76"></a>    <span class="fu">return</span> (seg<span class="op">:</span>segs)</span>
<span id="cb148-77"><a href="#cb148-77"></a></span>
<span id="cb148-78"><a href="#cb148-78"></a><span class="ot">pPathNoScheme ::</span> <span class="dt">Parser</span> [<span class="dt">Text</span>]</span>
<span id="cb148-79"><a href="#cb148-79"></a>pPathNoScheme <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb148-80"><a href="#cb148-80"></a>  seg <span class="ot">&lt;-</span> pSegmentNzNc</span>
<span id="cb148-81"><a href="#cb148-81"></a>  segs <span class="ot">&lt;-</span> many (char <span class="ch">&#39;/&#39;</span> <span class="op">*&gt;</span> pSegment)</span>
<span id="cb148-82"><a href="#cb148-82"></a>  <span class="fu">return</span> (seg<span class="op">:</span>segs)</span>
<span id="cb148-83"><a href="#cb148-83"></a></span>
<span id="cb148-84"><a href="#cb148-84"></a><span class="ot">pPathRootless ::</span> <span class="dt">Parser</span> [<span class="dt">Text</span>]</span>
<span id="cb148-85"><a href="#cb148-85"></a>pPathRootless <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb148-86"><a href="#cb148-86"></a>  seg <span class="ot">&lt;-</span> pSegmentNz</span>
<span id="cb148-87"><a href="#cb148-87"></a>  segs <span class="ot">&lt;-</span> many (char <span class="ch">&#39;/&#39;</span> <span class="op">*&gt;</span> pSegment)</span>
<span id="cb148-88"><a href="#cb148-88"></a>  <span class="fu">return</span> (seg<span class="op">:</span>segs)</span>
<span id="cb148-89"><a href="#cb148-89"></a></span>
<span id="cb148-90"><a href="#cb148-90"></a><span class="ot">pPathEmpty ::</span> <span class="dt">Parser</span> [<span class="dt">Text</span>]</span>
<span id="cb148-91"><a href="#cb148-91"></a>pPathEmpty <span class="ot">=</span> <span class="fu">return</span> []</span>
<span id="cb148-92"><a href="#cb148-92"></a></span>
<span id="cb148-93"><a href="#cb148-93"></a><span class="ot">pSegment ::</span> <span class="dt">Parser</span> <span class="dt">Text</span></span>
<span id="cb148-94"><a href="#cb148-94"></a>pSegment <span class="ot">=</span> T.pack <span class="op">&lt;$&gt;</span> many pPchar</span>
<span id="cb148-95"><a href="#cb148-95"></a></span>
<span id="cb148-96"><a href="#cb148-96"></a><span class="ot">pSegmentNz ::</span> <span class="dt">Parser</span> <span class="dt">Text</span></span>
<span id="cb148-97"><a href="#cb148-97"></a>pSegmentNz <span class="ot">=</span> T.pack <span class="op">&lt;$&gt;</span> some pPchar</span>
<span id="cb148-98"><a href="#cb148-98"></a></span>
<span id="cb148-99"><a href="#cb148-99"></a><span class="ot">pSegmentNzNc ::</span> <span class="dt">Parser</span> <span class="dt">Text</span></span>
<span id="cb148-100"><a href="#cb148-100"></a>pSegmentNzNc <span class="ot">=</span> T.pack <span class="op">&lt;$&gt;</span> some (pUnreserved <span class="op">&lt;|&gt;</span> pPctEncoded <span class="op">&lt;|&gt;</span> pSubDelims <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;@&#39;</span>)</span>
<span id="cb148-101"><a href="#cb148-101"></a></span>
<span id="cb148-102"><a href="#cb148-102"></a><span class="ot">pPchar ::</span> <span class="dt">Parser</span> <span class="dt">Char</span></span>
<span id="cb148-103"><a href="#cb148-103"></a>pPchar <span class="ot">=</span> pUnreserved <span class="op">&lt;|&gt;</span> pPctEncoded <span class="op">&lt;|&gt;</span> pSubDelims <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;:&#39;</span> <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;@&#39;</span></span>
<span id="cb148-104"><a href="#cb148-104"></a></span>
<span id="cb148-105"><a href="#cb148-105"></a><span class="ot">pUnreserved ::</span> <span class="dt">Parser</span> <span class="dt">Char</span></span>
<span id="cb148-106"><a href="#cb148-106"></a>pUnreserved <span class="ot">=</span> alphaNumChar <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;-&#39;</span> <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;.&#39;</span> <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;_&#39;</span> <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;~&#39;</span></span>
<span id="cb148-107"><a href="#cb148-107"></a></span>
<span id="cb148-108"><a href="#cb148-108"></a><span class="ot">pPctEncoded ::</span> <span class="dt">Parser</span> <span class="dt">Char</span></span>
<span id="cb148-109"><a href="#cb148-109"></a>pPctEncoded <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb148-110"><a href="#cb148-110"></a>  void (char <span class="ch">&#39;%&#39;</span>)</span>
<span id="cb148-111"><a href="#cb148-111"></a>  a <span class="ot">&lt;-</span> hexDigitChar</span>
<span id="cb148-112"><a href="#cb148-112"></a>  b <span class="ot">&lt;-</span> hexDigitChar</span>
<span id="cb148-113"><a href="#cb148-113"></a>  <span class="fu">return</span> <span class="op">.</span> <span class="fu">chr</span> <span class="op">$</span> (<span class="fu">digitToInt</span> a)<span class="op">*</span><span class="dv">16</span> <span class="op">+</span> <span class="fu">digitToInt</span> b</span>
<span id="cb148-114"><a href="#cb148-114"></a></span>
<span id="cb148-115"><a href="#cb148-115"></a><span class="ot">pSubDelims ::</span> <span class="dt">Parser</span> <span class="dt">Char</span></span>
<span id="cb148-116"><a href="#cb148-116"></a>pSubDelims <span class="ot">=</span> choice <span class="op">$</span> <span class="fu">map</span> char <span class="st">&quot;!$&amp;&#39;()*+,;=&quot;</span></span>
<span id="cb148-117"><a href="#cb148-117"></a></span>
<span id="cb148-118"><a href="#cb148-118"></a><span class="ot">pUri ::</span> <span class="dt">Parser</span> <span class="dt">Uri</span></span>
<span id="cb148-119"><a href="#cb148-119"></a>pUri <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb148-120"><a href="#cb148-120"></a>  uriScheme <span class="ot">&lt;-</span> pScheme <span class="op">&lt;?&gt;</span> <span class="st">&quot;valid scheme&quot;</span></span>
<span id="cb148-121"><a href="#cb148-121"></a>  void (char <span class="ch">&#39;:&#39;</span>)</span>
<span id="cb148-122"><a href="#cb148-122"></a>  uriAuthority <span class="ot">&lt;-</span> optional <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb148-123"><a href="#cb148-123"></a>    void (string <span class="st">&quot;//&quot;</span>)</span>
<span id="cb148-124"><a href="#cb148-124"></a>    authUser <span class="ot">&lt;-</span> optional <span class="op">.</span> try <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb148-125"><a href="#cb148-125"></a>      user <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar <span class="op">&lt;?&gt;</span> <span class="st">&quot;username&quot;</span></span>
<span id="cb148-126"><a href="#cb148-126"></a>      void (char <span class="ch">&#39;:&#39;</span>)</span>
<span id="cb148-127"><a href="#cb148-127"></a>      password <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some alphaNumChar <span class="op">&lt;?&gt;</span> <span class="st">&quot;password&quot;</span></span>
<span id="cb148-128"><a href="#cb148-128"></a>      void (char <span class="ch">&#39;@&#39;</span>)</span>
<span id="cb148-129"><a href="#cb148-129"></a>      <span class="fu">return</span> (user, password)</span>
<span id="cb148-130"><a href="#cb148-130"></a>    authHost <span class="ot">&lt;-</span> T.pack <span class="op">&lt;$&gt;</span> some (alphaNumChar <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;.&#39;</span>) <span class="op">&lt;?&gt;</span> <span class="st">&quot;hostname&quot;</span></span>
<span id="cb148-131"><a href="#cb148-131"></a>    authPort <span class="ot">&lt;-</span> optional (char <span class="ch">&#39;:&#39;</span> <span class="op">*&gt;</span> label <span class="st">&quot;port number&quot;</span> L.decimal)</span>
<span id="cb148-132"><a href="#cb148-132"></a>    <span class="fu">return</span> <span class="dt">Authority</span> {<span class="op">..</span>}</span>
<span id="cb148-133"><a href="#cb148-133"></a>  uriPath <span class="ot">&lt;-</span> pPath</span>
<span id="cb148-134"><a href="#cb148-134"></a>  uriQuery <span class="ot">&lt;-</span> optional (T.pack <span class="op">&lt;$&gt;</span> (char <span class="ch">&#39;?&#39;</span> <span class="op">*&gt;</span> many (pPchar <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;/&#39;</span> <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;?&#39;</span>)))</span>
<span id="cb148-135"><a href="#cb148-135"></a>  uriFlagment <span class="ot">&lt;-</span> optional (T.pack <span class="op">&lt;$&gt;</span> (char <span class="ch">&#39;#&#39;</span> <span class="op">*&gt;</span> many (pPchar <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;/&#39;</span> <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;?&#39;</span>)) <span class="op">&lt;?&gt;</span> <span class="st">&quot;flagment&quot;</span>)</span>
<span id="cb148-136"><a href="#cb148-136"></a>  <span class="fu">return</span> <span class="dt">Uri</span> {<span class="op">..</span>}</span></code></pre></div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>RFC 3986 に従ってURIのパースが可能であり Megaparsec パーサを含む <a href="https://hackage.haskell.org/package/modern-uri"><code>modern-uri</code></a> パッケージが実際にあります。ただし、パッケージのパーサはここで説明したものよりもはるかに複雑です。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>]]></summary>
</entry>
<entry>
    <title>Sum Monoid</title>
    <link href="https://haskell.e-bigmoon.com/posts/2019/02-13-sum-monoid%20copy.html" />
    <id>https://haskell.e-bigmoon.com/posts/2019/02-13-sum-monoid%20copy.html</id>
    <published>2019-02-13T00:00:00Z</published>
    <updated>2019-02-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Monoid.html">Data.Monoid</a> に <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Monoid.html#t:Sum">Sum</a> 型が定義されています。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">newtype</span> <span class="dt">Sum</span> a <span class="ot">=</span> <span class="dt">Sum</span> {<span class="ot"> getSum ::</span> a }</span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">instance</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">Sum</span> a) <span class="kw">where</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>  <span class="dt">Sum</span> a <span class="op">&lt;&gt;</span> <span class="dt">Sum</span> b <span class="ot">=</span> <span class="dt">Sum</span> (a <span class="op">+</span> b)</span>
<span id="cb1-5"><a href="#cb1-5"></a></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">instance</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Sum</span> a) <span class="kw">where</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Sum</span> <span class="dv">0</span></span></code></pre></div>
<p>使い方は簡単。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a>ghci<span class="op">&gt;</span> getSum (<span class="dt">Sum</span> <span class="dv">1</span> <span class="op">&lt;&gt;</span> <span class="dt">Sum</span> <span class="dv">2</span> <span class="op">&lt;&gt;</span> <span class="fu">mempty</span>)</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="dv">3</span></span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a>ghci<span class="op">&gt;</span> getSum <span class="op">$</span> <span class="fu">foldMap</span> <span class="dt">Sum</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">10</span>]</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="dv">55</span></span></code></pre></div>
<!--more-->
<h2 id="semigroup-monoid-law-の確認">Semigroup, Monoid law の確認</h2>
<p>Semigroup Law</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a>  <span class="dt">Sum</span> a <span class="op">&lt;&gt;</span> (<span class="dt">Sum</span> b <span class="op">&lt;&gt;</span> <span class="dt">Sum</span> c)</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="ot">=</span> <span class="dt">Sum</span> a <span class="op">&lt;&gt;</span> <span class="dt">Sum</span> (b <span class="op">+</span> c)</span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="ot">=</span> <span class="dt">Sum</span> (a <span class="op">+</span> (b <span class="op">+</span> c))</span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="co">-- (+) の結合律より</span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="ot">=</span> <span class="dt">Sum</span> ((a <span class="op">+</span> b) <span class="op">+</span> c)</span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="ot">=</span> <span class="dt">Sum</span> (a <span class="op">+</span> b) <span class="op">&lt;&gt;</span> <span class="dt">Sum</span> c</span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="ot">=</span> (<span class="dt">Sum</span> a <span class="op">&lt;&gt;</span> <span class="dt">Sum</span> b) <span class="op">&lt;&gt;</span> <span class="dt">Sum</span> c</span></code></pre></div>
<p>Monoid Law</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a>  <span class="dt">Sum</span> a <span class="op">&lt;&gt;</span> (<span class="fu">mempty</span><span class="ot"> ::</span> <span class="dt">Sum</span> a)</span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="ot">=</span> <span class="dt">Sum</span> a <span class="op">&lt;&gt;</span> <span class="dt">Sum</span> <span class="dv">0</span></span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="ot">=</span> <span class="dt">Sum</span> (a <span class="op">+</span> <span class="dv">0</span>)</span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="ot">=</span> <span class="dt">Sum</span> a</span>
<span id="cb4-5"><a href="#cb4-5"></a></span>
<span id="cb4-6"><a href="#cb4-6"></a>  (<span class="fu">mempty</span><span class="ot"> ::</span> <span class="dt">Sum</span> a) <span class="op">&lt;&gt;</span> <span class="dt">Sum</span> a</span>
<span id="cb4-7"><a href="#cb4-7"></a><span class="ot">=</span> <span class="dt">Sum</span> <span class="dv">0</span> <span class="op">+</span> <span class="dt">Sum</span> a</span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="ot">=</span> <span class="dt">Sum</span> (<span class="dv">0</span> <span class="op">+</span> a)</span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="ot">=</span> <span class="dt">Sum</span> a</span></code></pre></div>
<h2 id="newtype-を使って定義する理由">newtype を使って定義する理由</h2>
<p>わざわざ <code>Sum</code> という新しい型を作ってインスタンスを定義しなくても、<code>Int</code> を使って直接 <code>Semigroup</code> と <code>Monoid</code> のインスタンスを定義すれば良いんじゃないか？と普通は思います。</p>
<p>実際に以下の定義は問題なく動きます。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">instance</span> <span class="dt">Semigroup</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>  (<span class="op">&lt;&gt;</span>) <span class="ot">=</span> (<span class="op">+</span>)</span>
<span id="cb5-3"><a href="#cb5-3"></a></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dv">0</span></span></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a>ghci<span class="op">&gt;</span> <span class="dv">1</span> <span class="op">&lt;&gt;</span> <span class="dv">2</span> <span class="op">&lt;&gt;</span><span class="ot"> mempty ::</span> <span class="dt">Int</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="dv">3</span></span>
<span id="cb6-3"><a href="#cb6-3"></a></span>
<span id="cb6-4"><a href="#cb6-4"></a>ghci<span class="op">&gt;</span> <span class="fu">mconcat</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">10</span>]<span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="dv">55</span></span></code></pre></div>
<p>しかし、足し算と同様に掛け算もモノイドとして定義したいと思う人もいるでしょう。</p>
<p>この時 <code>Int</code> は既に <code>Semigroup</code>, <code>Monoid</code> のインスタンス定義があるため、同じファイルに以下のように定義することはできません。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">instance</span> <span class="dt">Semigroup</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>  (<span class="op">&lt;&gt;</span>) <span class="ot">=</span> (<span class="op">*</span>)</span>
<span id="cb7-3"><a href="#cb7-3"></a></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dv">1</span></span></code></pre></div>
<p>この問題を解決する方法はいくつかありますが、このような例では <code>newtype</code> が適切ということです。</p>
<h2 id="law-の自動チェック-quickcheck-classes">Law の自動チェック (quickcheck-classes)</h2>
<p><a href="https://hackage.haskell.org/package/quickcheck-classes">quickcheck-classes</a> を使って <code>Semigroup law</code> と <code>Monoid law</code> がちゃんと法則を満たすかどうかチェックしてみます。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="kw">newtype</span> <span class="dt">Sum</span> a <span class="ot">=</span> <span class="dt">Sum</span> {<span class="ot"> getSum ::</span> a }</span>
<span id="cb8-3"><a href="#cb8-3"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Arbitrary</span>)</span>
<span id="cb8-4"><a href="#cb8-4"></a></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="kw">instance</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">Sum</span> a) <span class="kw">where</span></span>
<span id="cb8-6"><a href="#cb8-6"></a>  <span class="dt">Sum</span> a <span class="op">&lt;&gt;</span> <span class="dt">Sum</span> b <span class="ot">=</span> <span class="dt">Sum</span> (a <span class="op">+</span> b)</span>
<span id="cb8-7"><a href="#cb8-7"></a></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="kw">instance</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Sum</span> a) <span class="kw">where</span></span>
<span id="cb8-9"><a href="#cb8-9"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Sum</span> <span class="dv">0</span></span></code></pre></div>
<p><code>Eq</code>, <code>Show</code>, <code>Arbitrary</code> が無いとチェックできないので <code>derive</code> しています。</p>
<p>実行はめっちゃ簡単で、<code>lawsCheck</code> 関数と <code>semigroupLaws</code> や <code>monoidLaws</code> などのチェックしたい則に対応する関数を使うだけです。</p>
<pre class="shell"><code>&gt; import Test.QuickCheck.Classes
&gt; import Data.Proxy

&gt; lawsCheck (semigroupLaws (Proxy :: Proxy (Sum Int)))
Semigroup: Associative +++ OK, passed 100 tests.
Semigroup: Concatenation +++ OK, passed 100 tests.
Semigroup: Times +++ OK, passed 100 tests; 99 discarded.

&gt; lawsCheck (monoidLaws (Proxy :: Proxy (Sum Int)))
Monoid: Associative +++ OK, passed 100 tests.
Monoid: Left Identity +++ OK, passed 100 tests.
Monoid: Right Identity +++ OK, passed 100 tests.
Monoid: Concatenation +++ OK, passed 100 tests.</code></pre>
<p>参考までに <code>mempty</code> の定義が Law を満たさない場合の例も載せておきます。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">instance</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Sum</span> a) <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Sum</span> <span class="dv">1</span></span></code></pre></div>
<pre class="shell"><code>&gt; import Test.QuickCheck.Classes
&gt; import Data.Proxy

&gt; lawsCheck (semigroupLaws (Proxy :: Proxy (Sum Int)))
Semigroup: Associative +++ OK, passed 100 tests.
Semigroup: Concatenation +++ OK, passed 100 tests.
Semigroup: Times +++ OK, passed 100 tests; 113 discarded.

&gt; lawsCheck (monoidLaws (Proxy :: Proxy (Sum Int)))
Monoid: Associative +++ OK, passed 100 tests.
Monoid: Left Identity *** Failed! Falsifiable (after 1 test):
  Description: mappend mempty a = a
  a = Sum {getSum = 0}
  mappend mempty a = Sum {getSum = 1}
Monoid: Right Identity *** Failed! Falsifiable (after 1 test):
  Description: mappend a mempty = a
  a = Sum {getSum = 0}
  mappend a mempty = Sum {getSum = 1}
Monoid: Concatenation +++ OK, passed 100 tests.</code></pre>
<p>こんな感じでモノイドの左単位元則 (Left Identity law) と右単位元則 (Right Identity law) が満たされていないことを教えてくれます。</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://people.cs.kuleuven.be/~tom.schrijvers/Research/talks/lhug4.pdf">Lists and Other Monoids</a></li>
</ul>]]></summary>
</entry>
<entry>
    <title>Last Monoid</title>
    <link href="https://haskell.e-bigmoon.com/posts/2019/02-12-last-monoid.html" />
    <id>https://haskell.e-bigmoon.com/posts/2019/02-12-last-monoid.html</id>
    <published>2019-02-12T00:00:00Z</published>
    <updated>2019-02-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p><a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Monoid.html">Data.Monoid</a> に <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Data-Monoid.html#t:Last">Last</a> 型が定義されています。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">newtype</span> <span class="dt">Last</span> a <span class="ot">=</span> <span class="dt">Last</span> {<span class="ot"> getLast ::</span> <span class="dt">Maybe</span> a }</span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">instance</span> <span class="dt">Semigroup</span> (<span class="dt">Last</span> a) <span class="kw">where</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>  a <span class="op">&lt;&gt;</span> <span class="dt">Last</span> <span class="dt">Nothing</span> <span class="ot">=</span> a</span>
<span id="cb1-5"><a href="#cb1-5"></a>  _ <span class="op">&lt;&gt;</span> b            <span class="ot">=</span> b</span>
<span id="cb1-6"><a href="#cb1-6"></a></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Last</span> a) <span class="kw">where</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Last</span> <span class="dt">Nothing</span></span></code></pre></div>
<p><code>Last</code> モノイドは <code>First</code> モノイドとほとんど同じですが、<code>&lt;&gt;</code> で結合した時に最後の値を返すという部分が異なります。</p>
<p>使い方は簡単。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a>ghci<span class="op">&gt;</span> getLast (<span class="dt">Last</span> (<span class="dt">Just</span> <span class="st">&quot;hello&quot;</span>) <span class="op">&lt;&gt;</span> <span class="fu">mempty</span> <span class="op">&lt;&gt;</span> <span class="dt">Last</span> (<span class="dt">Just</span> <span class="st">&quot;world&quot;</span>))</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="dt">Just</span> <span class="st">&quot;world&quot;</span></span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a>ghci<span class="op">&gt;</span> getLast <span class="op">$</span> <span class="fu">foldMap</span> <span class="dt">Last</span> [<span class="dt">Just</span> <span class="st">&quot;hello&quot;</span>, <span class="dt">Nothing</span>, <span class="dt">Just</span> <span class="st">&quot;world&quot;</span>]</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="dt">Just</span> <span class="st">&quot;world&quot;</span></span></code></pre></div>
<!--more-->
<h2 id="semigroup-law-の確認">Semigroup law の確認</h2>
<h3 id="case-1-b-nothing-c-nothing">Case (1) (b == Nothing, c == Nothing)</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a>  <span class="dt">Last</span> a <span class="op">&lt;&gt;</span> (<span class="dt">Last</span> b <span class="op">&lt;&gt;</span> <span class="dt">Last</span> c)</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="ot">=</span> <span class="dt">Last</span> a <span class="op">&lt;&gt;</span> <span class="dt">Last</span> b</span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="ot">=</span> <span class="dt">Last</span> a</span></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a>  (<span class="dt">Last</span> a <span class="op">&lt;&gt;</span> <span class="dt">Last</span> b) <span class="op">&lt;&gt;</span> <span class="dt">Last</span> c</span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="ot">=</span> <span class="dt">Last</span> a <span class="op">&lt;&gt;</span> <span class="dt">Last</span> b</span>
<span id="cb4-3"><a href="#cb4-3"></a><span class="ot">=</span> <span class="dt">Last</span> a</span></code></pre></div>
<h3 id="case-2-b-just-b-c-nothing">Case (2) (b == Just b’, c == Nothing)</h3>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a>  <span class="dt">Last</span> a <span class="op">&lt;&gt;</span> (<span class="dt">Last</span> b <span class="op">&lt;&gt;</span> <span class="dt">Last</span> c)</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="ot">=</span> <span class="dt">Last</span> a <span class="op">&lt;&gt;</span> <span class="dt">Last</span> b</span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="ot">=</span> <span class="dt">Last</span> b</span></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a>  (<span class="dt">Last</span> a <span class="op">&lt;&gt;</span> <span class="dt">Last</span> b) <span class="op">&lt;&gt;</span> <span class="dt">Last</span> c</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="ot">=</span> <span class="dt">Last</span> a <span class="op">&lt;&gt;</span> <span class="dt">Last</span> b</span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="ot">=</span> <span class="dt">Last</span> b</span></code></pre></div>
<h3 id="case-3-c-just-c">Case (3) (c == Just c’)</h3>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a>  <span class="dt">Last</span> a <span class="op">&lt;&gt;</span> (<span class="dt">Last</span> b <span class="op">&lt;&gt;</span> <span class="dt">Last</span> c)</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="ot">=</span> <span class="dt">Last</span> a <span class="op">&lt;&gt;</span> <span class="dt">Last</span> c</span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="ot">=</span> <span class="dt">Last</span> c</span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a>  (<span class="dt">Last</span> a <span class="op">&lt;&gt;</span> <span class="dt">Last</span> b) <span class="op">&lt;&gt;</span> <span class="dt">Last</span> c</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="ot">=</span> <span class="dt">Last</span> c</span></code></pre></div>
<h2 id="monoid-law">Monoid Law</h2>
<h3 id="case-1-a-nothing">Case (1) (a = Nothing)</h3>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a>  <span class="dt">Last</span> a <span class="op">&lt;&gt;</span> <span class="fu">mempty</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="ot">=</span> <span class="dt">Last</span> a <span class="op">&lt;&gt;</span> <span class="dt">Last</span> <span class="dt">Nothing</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="ot">=</span> <span class="dt">Last</span> a</span>
<span id="cb9-4"><a href="#cb9-4"></a></span>
<span id="cb9-5"><a href="#cb9-5"></a>  <span class="fu">mempty</span> <span class="op">&lt;&gt;</span> <span class="dt">Last</span> a</span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="ot">=</span> <span class="fu">mempty</span></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="ot">=</span> <span class="dt">Last</span> <span class="dt">Nothing</span></span></code></pre></div>
<h3 id="case-2-a-just-a">Case (2) (a = Just a’)</h3>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a>  <span class="dt">Last</span> a <span class="op">&lt;&gt;</span> <span class="fu">mempty</span></span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="ot">=</span> <span class="dt">Last</span> a <span class="op">&lt;&gt;</span> <span class="dt">Last</span> <span class="dt">Nothing</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="ot">=</span> <span class="dt">Last</span> a</span>
<span id="cb10-4"><a href="#cb10-4"></a></span>
<span id="cb10-5"><a href="#cb10-5"></a>  <span class="fu">mempty</span> <span class="op">&lt;&gt;</span> <span class="dt">Last</span> a</span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="ot">=</span> <span class="dt">Last</span> a</span></code></pre></div>
<h2 id="具体例-partial-options-monoid">具体例: Partial Options Monoid</h2>
<p>コマンドライン引数によりオプションを受け取り、指定されなかったオプションの値に対してはデフォルト値を利用するという場面で <code>Last</code> モノイドが活用できそうです。</p>
<h3 id="コード">コード</h3>
<p><a href="https://hackage.haskell.org/package/optparse-applicative">optparse-applicative</a> を使った具体的なサンプルはこんな感じです。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="ot">{-# LANGUAGE RecordWildCards #-}</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></span>
<span id="cb11-3"><a href="#cb11-3"></a></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="kw">import</span> <span class="dt">Data.Monoid</span></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="kw">import</span> <span class="dt">Options.Applicative</span></span>
<span id="cb11-6"><a href="#cb11-6"></a></span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="kw">data</span> <span class="dt">Options</span> <span class="ot">=</span> <span class="dt">Options</span></span>
<span id="cb11-8"><a href="#cb11-8"></a>  {<span class="ot"> oInputPath  ::</span> <span class="dt">FilePath</span></span>
<span id="cb11-9"><a href="#cb11-9"></a>  ,<span class="ot"> oOutputPath ::</span> <span class="dt">FilePath</span></span>
<span id="cb11-10"><a href="#cb11-10"></a>  ,<span class="ot"> oLogLevel   ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb11-11"><a href="#cb11-11"></a>  } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span>
<span id="cb11-12"><a href="#cb11-12"></a></span>
<span id="cb11-13"><a href="#cb11-13"></a><span class="kw">data</span> <span class="dt">PartialOptions</span> <span class="ot">=</span> <span class="dt">PartialOptions</span></span>
<span id="cb11-14"><a href="#cb11-14"></a>  {<span class="ot"> poInputPath  ::</span> <span class="dt">Last</span> <span class="dt">FilePath</span></span>
<span id="cb11-15"><a href="#cb11-15"></a>  ,<span class="ot"> poOutputPath ::</span> <span class="dt">Last</span> <span class="dt">FilePath</span></span>
<span id="cb11-16"><a href="#cb11-16"></a>  ,<span class="ot"> poLogLevel   ::</span> <span class="dt">Last</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span>
<span id="cb11-17"><a href="#cb11-17"></a>  } <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span>
<span id="cb11-18"><a href="#cb11-18"></a></span>
<span id="cb11-19"><a href="#cb11-19"></a><span class="kw">instance</span> <span class="dt">Semigroup</span> <span class="dt">PartialOptions</span> <span class="kw">where</span></span>
<span id="cb11-20"><a href="#cb11-20"></a>  x <span class="op">&lt;&gt;</span> y <span class="ot">=</span></span>
<span id="cb11-21"><a href="#cb11-21"></a>    <span class="dt">PartialOptions</span></span>
<span id="cb11-22"><a href="#cb11-22"></a>      { poInputPath  <span class="ot">=</span> poInputPath  x <span class="op">&lt;&gt;</span> poInputPath  y</span>
<span id="cb11-23"><a href="#cb11-23"></a>      , poOutputPath <span class="ot">=</span> poOutputPath x <span class="op">&lt;&gt;</span> poOutputPath y</span>
<span id="cb11-24"><a href="#cb11-24"></a>      , poLogLevel   <span class="ot">=</span> poLogLevel   x <span class="op">&lt;&gt;</span> poLogLevel   y</span>
<span id="cb11-25"><a href="#cb11-25"></a>      }</span>
<span id="cb11-26"><a href="#cb11-26"></a></span>
<span id="cb11-27"><a href="#cb11-27"></a><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">PartialOptions</span> <span class="kw">where</span></span>
<span id="cb11-28"><a href="#cb11-28"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">PartialOptions</span> <span class="fu">mempty</span> <span class="fu">mempty</span> <span class="fu">mempty</span></span>
<span id="cb11-29"><a href="#cb11-29"></a></span>
<span id="cb11-30"><a href="#cb11-30"></a><span class="ot">defaultPartialOptions ::</span> <span class="dt">PartialOptions</span></span>
<span id="cb11-31"><a href="#cb11-31"></a>defaultPartialOptions <span class="ot">=</span> <span class="fu">mempty</span></span>
<span id="cb11-32"><a href="#cb11-32"></a>  { poInputPath  <span class="ot">=</span> <span class="fu">pure</span> <span class="st">&quot;input&quot;</span></span>
<span id="cb11-33"><a href="#cb11-33"></a>  , poLogLevel   <span class="ot">=</span> <span class="fu">pure</span> <span class="dt">Nothing</span></span>
<span id="cb11-34"><a href="#cb11-34"></a>  }</span>
<span id="cb11-35"><a href="#cb11-35"></a></span>
<span id="cb11-36"><a href="#cb11-36"></a><span class="ot">lastOption ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> (<span class="dt">Last</span> a)</span>
<span id="cb11-37"><a href="#cb11-37"></a>lastOption <span class="ot">=</span> <span class="fu">fmap</span> <span class="dt">Last</span> <span class="op">.</span> optional</span>
<span id="cb11-38"><a href="#cb11-38"></a></span>
<span id="cb11-39"><a href="#cb11-39"></a><span class="ot">partialOptionsParser ::</span> <span class="dt">Parser</span> <span class="dt">PartialOptions</span></span>
<span id="cb11-40"><a href="#cb11-40"></a>partialOptionsParser <span class="ot">=</span> <span class="dt">PartialOptions</span></span>
<span id="cb11-41"><a href="#cb11-41"></a>  <span class="op">&lt;$&gt;</span> lastOption (strOption (short <span class="ch">&#39;i&#39;</span>))</span>
<span id="cb11-42"><a href="#cb11-42"></a>  <span class="op">&lt;*&gt;</span> lastOption (strOption (short <span class="ch">&#39;o&#39;</span>))</span>
<span id="cb11-43"><a href="#cb11-43"></a>  <span class="op">&lt;*&gt;</span> lastOption (<span class="dt">Just</span> <span class="op">&lt;$&gt;</span> option auto (short <span class="ch">&#39;l&#39;</span>))</span>
<span id="cb11-44"><a href="#cb11-44"></a></span>
<span id="cb11-45"><a href="#cb11-45"></a><span class="ot">lastToEither ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Last</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> a</span>
<span id="cb11-46"><a href="#cb11-46"></a>lastToEither errMsg <span class="ot">=</span> <span class="fu">maybe</span> (<span class="dt">Left</span> errMsg) <span class="dt">Right</span> <span class="op">.</span> getLast</span>
<span id="cb11-47"><a href="#cb11-47"></a></span>
<span id="cb11-48"><a href="#cb11-48"></a><span class="ot">mkOptions ::</span> <span class="dt">PartialOptions</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Options</span></span>
<span id="cb11-49"><a href="#cb11-49"></a>mkOptions <span class="dt">PartialOptions</span> {<span class="op">..</span>} <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-50"><a href="#cb11-50"></a>  oInputPath  <span class="ot">&lt;-</span> lastToEither <span class="st">&quot;Missing input path&quot;</span>  poInputPath</span>
<span id="cb11-51"><a href="#cb11-51"></a>  oOutputPath <span class="ot">&lt;-</span> lastToEither <span class="st">&quot;Missing output path&quot;</span> poOutputPath</span>
<span id="cb11-52"><a href="#cb11-52"></a>  oLogLevel   <span class="ot">&lt;-</span> lastToEither <span class="st">&quot;Missing loglevel&quot;</span>    poLogLevel</span>
<span id="cb11-53"><a href="#cb11-53"></a>  <span class="fu">return</span> <span class="dt">Options</span> {<span class="op">..</span>}</span>
<span id="cb11-54"><a href="#cb11-54"></a></span>
<span id="cb11-55"><a href="#cb11-55"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb11-56"><a href="#cb11-56"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-57"><a href="#cb11-57"></a>  options <span class="ot">&lt;-</span> execParser <span class="op">$</span> info partialOptionsParser <span class="fu">mempty</span></span>
<span id="cb11-58"><a href="#cb11-58"></a>  <span class="kw">case</span> mkOptions (defaultPartialOptions <span class="op">&lt;&gt;</span> options) <span class="kw">of</span></span>
<span id="cb11-59"><a href="#cb11-59"></a>    <span class="dt">Left</span>  msg <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> msg</span>
<span id="cb11-60"><a href="#cb11-60"></a>    <span class="dt">Right</span> opt <span class="ot">-&gt;</span> <span class="fu">print</span> opt</span></code></pre></div>
<p><code>defaultPartialOptions</code> でオプションの初期値を用意しておきます。ここで指定されなかったフィールドの値はオプションで必ず指定しなければなりません。今回の例では <code>poOutputPath</code> が必須オプションになっています。</p>
<p>また <code>Last</code> モノイドが効いている部分は <code>defaultPartialOptions &lt;&gt; options</code> です。<code>mempty = Last Nothing</code> となるため、期待通りの動作が得られます。</p>
<p>デフォルト値の無いオプションが省略された場合にエラーメッセージが表示される理由としては <code>lastToEither</code> で <code>getLast</code> した際に <code>Nothing</code> となるためです。</p>
<h3 id="実行結果">実行結果</h3>
<p>実行結果は見やすく整形しています。</p>
<pre class="shell"><code># オプション無しで実行
λ&gt; stack run ex3
Missing output path

# 必須オプションの -o のみ指定 (他はデフォルト値)
$ stack run ex3 -- -o &quot;oDir&quot;
Options
  { oInputPath  = &quot;input&quot;
  , oOutputPath = &quot;oDir&quot;
  , oLogLevel   = Nothing
  }

# 必須オプションの -o と -i を指定
$ stack run ex3 -- -o &quot;oDir&quot; -i &quot;myDir&quot;
Options
  { oInputPath  = &quot;myDir&quot;
  , oOutputPath = &quot;oDir&quot;
  , oLogLevel   = Nothing
  }

# オプションを全部指定
$ stack run ex3 -- -o &quot;oDir&quot; -i &quot;myDir&quot; -l 10
Options
  { oInputPath  = &quot;myDir&quot;
  , oOutputPath = &quot;oDir&quot;
  , oLogLevel   = Just 10
  }</code></pre>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://medium.com/@jonathangfischoff/the-partial-options-monoid-pattern-31914a71fc67">The Partial Options Monoid</a></li>
<li><a href="https://kazu-yamamoto.hatenablog.jp/entry/2018/11/29/155311">SemigroupがMonoidに恋するとき</a></li>
<li><a href="https://qiita.com/philopon/items/a29717af62831d3c8c07">optparse-applicativeをふわっと使う</a></li>
</ul>]]></summary>
</entry>
<entry>
    <title>Lambdabot for Slack</title>
    <link href="https://haskell.e-bigmoon.com/posts/2019/02-11-lambdabot.html" />
    <id>https://haskell.e-bigmoon.com/posts/2019/02-11-lambdabot.html</id>
    <published>2019-02-11T00:00:00Z</published>
    <updated>2019-02-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>最近 slack で <a href="https://github.com/lambdabot/lambdabot">Lambdabot</a> というツールを知りました。こいつを導入するとこんな事ができます。</p>
<figure>
<img src="/images/2019/02-11/1.png" alt="" /><figcaption>Lambdabot と遊んでいる図</figcaption>
</figure>
<p>実務で本格的に使えるものではありませんが、入れてみると楽しいですよ。(カスタマイズして改良すれば、かなり使えるかもしれない)</p>
<!--more-->
<h2 id="lambdabot-の導入">Lambdabot の導入</h2>
<p>導入はとても簡単で slack app から Lambdabot をインストールするだけです！</p>
<figure>
<img src="/images/2019/02-11/2.png" alt="" /><figcaption>Slack app で検索</figcaption>
</figure>
<figure>
<img src="/images/2019/02-11/3.png" alt="" /><figcaption>Lambdabot のインストール画面</figcaption>
</figure>
<p>検索するのが面倒な人は <a href="https://lambdabot.brianmckenna.org/slack/install.html">Add Lambdabot to Slack</a> の App ボタンからもインストール可能です。</p>
<p>アプリのソースコード等は <a href="https://github.com/markandrus/slack-lambdabot">markandrus/slack-lambdabot</a> にありますので、気になる方はこちらもご参照ください。</p>
<p>自分でビルドしてホスティングする場合は fork の <a href="https://github.com/ezoerner/slack-lambdabot">ezoerner/slack-lambdabot</a> の方が良いかもしれません。(要検証)</p>
<h2 id="lambdabot-for-slack-でできること">Lambdabot for Slack でできること</h2>
<p>どうやら本家の Lambdabot の機能全てが使えるわけではないようです。</p>
<p>また、利用可能な機能のうち <code>type</code> や <code>hoogle</code>等はちゃんと使えるようですが、<code>run</code> や <code>check</code> などは結果がおかしい場合があります。</p>
<h3 id="hoogle">hoogle</h3>
<p>どうやら結果は3件しか返さないようです。</p>
<figure>
<img src="/images/2019/02-11/hoogle-1.png" alt="" /><figcaption>関数名で検索</figcaption>
</figure>
<figure>
<img src="/images/2019/02-11/hoogle-2.png" alt="" /><figcaption>型名で検索</figcaption>
</figure>
<figure>
<img src="/images/2019/02-11/hoogle-3.png" alt="" /><figcaption>型で検索 (型変数有り)</figcaption>
</figure>
<figure>
<img src="/images/2019/02-11/hoogle-4.png" alt="" /><figcaption>型で検索 (型変数無し)</figcaption>
</figure>
<h3 id="type">type</h3>
<p>どのパッケージが含まれているかわかりませんが、lens の演算子を試したところだめでした。</p>
<figure>
<img src="/images/2019/02-11/type-1.png" alt="" /><figcaption>関数</figcaption>
</figure>
<figure>
<img src="/images/2019/02-11/type-2.png" alt="" /><figcaption>メソッド</figcaption>
</figure>
<figure>
<img src="/images/2019/02-11/type-3.png" alt="" /><figcaption>複雑な式</figcaption>
</figure>
<figure>
<img src="/images/2019/02-11/type-4.png" alt="" /><figcaption>演算子</figcaption>
</figure>
<figure>
<img src="/images/2019/02-11/type-5.png" alt="" /><figcaption>セクション</figcaption>
</figure>
<figure>
<img src="/images/2019/02-11/type-6.png" alt="" /><figcaption>エラー</figcaption>
</figure>
<h3 id="run">run</h3>
<p>式を実行することができるようですが、全然動かないです。</p>
<figure>
<img src="/images/2019/02-11/run-1.png" alt="" /><figcaption>print はエラー</figcaption>
</figure>
<figure>
<img src="/images/2019/02-11/run-2.png" alt="" /><figcaption>奇跡的に動いた例</figcaption>
</figure>
<figure>
<img src="/images/2019/02-11/run-3.png" alt="" /><figcaption>文字列を含む場合にはエラーになる</figcaption>
</figure>
<figure>
<img src="/images/2019/02-11/run-4.png" alt="" /><figcaption>無限リストは適当に打ち切り</figcaption>
</figure>
<h3 id="check">check</h3>
<p>QuickCheck も実行可能ですが、上手く行く例が作れません・・・。</p>
<figure>
<img src="/images/2019/02-11/check-1.png" alt="" /><figcaption>実行時間の制約に引っかかってるっぽい</figcaption>
</figure>
<h3 id="free">free</h3>
<p>たぶん実装は <a href="https://github.com/lambdabot/lambdabot/blob/0b26cb6ca0e0389bcff68d360c18775a787c9d52/lambdabot-haskell-plugins/src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs">FreeTheorem.hs</a> です。</p>
<p>良くわからないので解説できません。実行結果だけ貼っておきます。</p>
<figure>
<img src="/images/2019/02-11/free-1.png" alt="" /><figcaption>reverse</figcaption>
</figure>
<figure>
<img src="/images/2019/02-11/free-2.png" alt="" /><figcaption>const</figcaption>
</figure>
<figure>
<img src="/images/2019/02-11/free-3.png" alt="" /><figcaption>id</figcaption>
</figure>
<figure>
<img src="/images/2019/02-11/free-4.png" alt="" /><figcaption>flip</figcaption>
</figure>
<figure>
<img src="/images/2019/02-11/free-5.png" alt="" /><figcaption>filter</figcaption>
</figure>
<h3 id="pl">pl</h3>
<p>ポイントフリーにしてくれます。また fusion もいくつか可能っぽいです。</p>
<figure>
<img src="/images/2019/02-11/pl-1.png" alt="" /><figcaption>ポイントフリー化1</figcaption>
</figure>
<figure>
<img src="/images/2019/02-11/pl-2.png" alt="" /><figcaption>ポイントフリー化2</figcaption>
</figure>
<figure>
<img src="/images/2019/02-11/pl-3.png" alt="" /><figcaption>f . id = id</figcaption>
</figure>
<figure>
<img src="/images/2019/02-11/pl-4.png" alt="" /><figcaption>map f . map g = map (f . g)</figcaption>
</figure>
<h2 id="終わりに">終わりに</h2>
<p>ちゃんと作り込んだら結構使えそうな気がします。</p>]]></summary>
</entry>

</feed>
