<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>BIG MOON</title>
    <link href="https://haskell.e-bigmoon.com/feed.xml" rel="self" />
    <link href="https://haskell.e-bigmoon.com" />
    <id>https://haskell.e-bigmoon.com/feed.xml</id>
    <author>
        <name>BIG MOON</name>
        <email>it@e-bigmoon.com</email>
    </author>
    <updated>2018-03-03T00:00:00Z</updated>
    <entry>
    <title>Liquid Haskell のインストールと学習方法</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018-03-03-liquidhaskell-intro.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018-03-03-liquidhaskell-intro.html</id>
    <published>2018-03-03T00:00:00Z</published>
    <updated>2018-03-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p><code>Liquid Haskell</code> を半年ほど勉強した結果、色々と出来ることが増えて楽しくなってきました。</p>
<p>現状、日本語で詳しく説明しているブログ記事や <code>Qiita</code> 記事はほとんどありません。</p>
<p>とても面白いツールだと思いますので、色々と紹介していけたらと思います。</p>
<p>今回は <code>Liquid Haskell</code> の導入方法について簡単に説明したいと思います。</p>
<!--more-->
<h2 id="liquid-haskell-とは">Liquid Haskell とは？</h2>
<p><code>Liquid Haskell</code> は <code>GHC</code> の型よりも、さらに厳密な <code>篩型 (Refinement Type)</code> の型検査器です。</p>
<p>既存のコードを実行することなく利用できるため、既存のプロジェクトの一部にだけ導入することも可能です。</p>
<p>また、つい最近も <code>GADT</code> をサポートしたりと、開発はとても活発に行われています。</p>
<p>正しいソフトウェアを楽しく作るために、<code>Liquid Haskell</code> を学習してみるのはどうでしょうか！</p>
<p>ちなみに <code>Liquid</code> という単語は <code>液体</code> と言いたくなりますが、それとはあまり関係なく、実際は <code>Logically Qualified Data</code> の略です。(ロゴは <code>水滴</code> + <code>&gt;&gt;=</code> なので、全く無関係では無いかもですが)</p>
<h2 id="インストール">インストール</h2>
<p><code>Liquid Haskell</code> は以下の2つのリポジトリで開発が進められています。</p>
<ul>
<li><a href="https://github.com/ucsd-progsys/liquidhaskell">ucsd-progsys/liquidhaskell</a></li>
<li><a href="https://github.com/ucsd-progsys/liquid-fixpoint">ucsd-progsys/liquid-fixpoint</a></li>
</ul>
<p><code>liquidhaskell</code> がフロントエンド (コマンドライン処理やパーサーなどの処理等) を行い <code>liquid-fixpoint</code> が <code>SMT</code> ソルバに投げるための処理を色々とやっている印象です。(詳しくないので間違ってたらすみません)</p>
<p>なので、僕らが関係するのは基本的に <code>liquidhaskell</code> リポジトリの方です。(<code>liquid-fixpoint</code> はサブモジュールになっています)</p>
<p>また、実際にチェックを行うのは <code>SMT</code> ソルバなので、そちらも同様にインストールが必要です。</p>
<h3 id="smt-ソルバのインストール">SMT ソルバのインストール</h3>
<p><code>SMT</code> ソルバも色々と種類があるようで、公式では以下の3種類が紹介されています。</p>
<ul>
<li>Z3</li>
<li>CVC4</li>
<li>MathSat</li>
</ul>
<p>どれでもちゃんと動くので好きなソルバを使えば良いのですが、どれを選んだら良いかわからない人は <code>Z3</code> にしましょう。</p>
<p>理由としてはインストール方法が簡単で、性能も良いそうです。</p>
<h4 id="ubuntu">Ubuntu</h4>
<pre class="shell"><code>$ sudo apt install z3

$ z3 --version
Z3 version 4.4.1</code></pre>
<h4 id="mac-brew">Mac (brew)</h4>
<pre class="shell"><code>$ brew install z3

$ z3 --version
Z3 version 4.6.0 - 64 bit</code></pre>
<h3 id="liquid-haskell-のインストール">Liquid Haskell のインストール</h3>
<p>現状、一番安定しているのは <code>github</code> の <a href="https://github.com/ucsd-progsys/liquidhaskell"><strong>develop</strong></a> ブランチを <code>stack</code> でビルドしてインストールする方法だと思います。</p>
<p>また、その他のインストール方法等は <a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/INSTALL.md">INSTALL.md</a> をご参照下さい。</p>
<pre class="shell"><code>$ git clone --recursive git@github.com:ucsd-progsys/liquidhaskell.git
$ cd liquidhaskell
$ stack install

$ liquid
LiquidHaskell Version 0.8.2.4, Git revision d641244775cd842776cecf2c5d3e9afa01549e76 (dirty)
Copyright 2013-18 Regents of the University of California. All Rights Reserved.</code></pre>
<p>stack プロジェクトで利用する場合は。以下のように stack exec コマンドで呼び出します。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">$</span> stack exec <span class="co">-- liquid</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="dt">LiquidHaskell</span> <span class="dt">Version</span> <span class="fl">0.8</span><span class="fu">.</span><span class="fl">2.4</span>, <span class="dt">Git</span> revision d641244775cd842776cecf2c5d3e9afa01549e76 (dirty)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="dt">Copyright</span> <span class="dv">2013</span><span class="fu">-</span><span class="dv">18</span> <span class="dt">Regents</span> <span class="kw">of</span> the <span class="dt">University</span> <span class="kw">of</span> <span class="dt">California</span><span class="fu">.</span> <span class="dt">All</span> <span class="dt">Rights</span> <span class="dt">Reserved</span><span class="fu">.</span></a></code></pre></div>
<h2 id="サンプルプログラム">サンプルプログラム</h2>
<p><code>myDiv</code> 関数の例を使って <code>LiquidHaskell</code> に慣れましょう！</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">-- MyDiv.hs</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">module</span> <span class="dt">MyDiv</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="ot">myDiv ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">myDiv <span class="fu">=</span> div</a></code></pre></div>
<p><code>myDiv</code> の実装は単に <code>div</code> をラップしただけです。</p>
<p>この関数はだいたい上手く動きますが、もし第二引数に0が与えられたらどうでしょうか？そう、実行時エラーになります・・・。試してみましょう。</p>
<pre class="shell"><code>$ stack repl -- MyDiv.hs
*myDiv&gt; myDiv 10 2
5
*myDiv&gt; myDiv 10 0
*** Exception: divide by zero</code></pre>
<p>全然安全ではありませんね。</p>
<p>では、どうしたら本当に安全な <code>myDiv</code> を作れるのでしょうか？</p>
<p>その答えは<code>篩(ふるい)型</code>にあります。</p>
<p><code>Liquid Haskell</code> では <code>篩型</code> を <code>{-@ ... @-}</code> のコメント形式で記述します。<code>Liquid Haskell</code> を利用するメリットの1つに、篩型をある程度、推論してくれるというものがあります。</p>
<p>実は、先程の <code>myDiv</code> は篩型を書いていませんが、こういう場合 <code>Liquid Haskell</code> は <code>Haskell</code> の型をそのまま篩型として利用します。</p>
<p><code>myDiv</code> に対して明示的に篩型を書いてみましょう！</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="co">{-@ myDiv :: Int -&gt; Int -&gt; Int @-}</span> <span class="co">-- これが篩型</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">myDiv ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">myDiv <span class="fu">=</span> div</a></code></pre></div>
<p>この <code>myDiv</code> 関数を <code>LquidHaskell</code> でチェックしてみましょう。</p>
<pre class="shell"><code>$ liquid MyDiv.hs
**** RESULT: UNSAFE ************************************************************

 MyDiv.hs:4:11-13: Error: Liquid Type Mismatch

 4 | myDiv = div
               ^^^

   Inferred type
     VV : Int

   not a subtype of Required type
     VV : {VV : Int | VV /= 0}

   In Context</code></pre>
<p>なぜか <code>UNSAFE</code> が表示されましたね。これは <code>Liquid Haskell</code> で既に <code>div</code> の篩型が定義されているからです。(<a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/include/GHC/Real.spec#L19">div</a> 以外にも色々ありますが、充実しているとは言い難いと思います)</p>
<p>だいたいこんな感じで、第二引数が0ではないという条件がついているのです。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="co">{-@ div :: Int -&gt; {v:Int | v /= 0} -&gt; Int @-}</span></a></code></pre></div>
<p>そのため、先程のエラーメッセージで以下のように指摘されてしまったのです。</p>
<pre class="shell"><code>not a subtype of Required type
     VV : {VV : Int | VV /= 0}</code></pre>
<p>つまり、僕らの定義した篩型は <code>0</code> を許容する <code>Int</code> 型なので、このままだと <code>div</code> に <code>0</code> が与えられてしまう可能性があるよ！ということを言っています。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="co">{-@ myDiv :: Int -&gt; Int -&gt; Int @-}</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="ot">myDiv ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">myDiv <span class="fu">=</span> div</a></code></pre></div>
<p><code>myDiv</code> にも同じ篩型をつけてみましょう。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="co">{-@ myDiv :: Int -&gt; {v:Int | v /= 0} -&gt; Int @-}</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="ot">myDiv ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">myDiv <span class="fu">=</span> div</a></code></pre></div>
<p>これで <code>SAFE</code> になります。</p>
<pre class="shell"><code>$ liquid MyDiv.hs
**** RESULT: SAFE **************************************************************</code></pre>
<p><code>0</code> を含まない <code>Int</code> 型というのは、よく使いそうなので篩型のエイリアスとして定義してみます。</p>
<p>篩型のエイリアスは <code>type</code> キーワードを使います。<code>Haskell</code> と同じですね。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="co">{-@ type NonZero = {v:Int | v /= 0} @-}</span></a></code></pre></div>
<p>そして <code>myDiv</code> の篩型も <code>NonZero</code> で置き換えます。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="co">{-@ type NonZero = {v:Int | v /= 0} @-}</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="co">{-@ myDiv :: Int -&gt; NonZero -&gt; Int @-}</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="ot">myDiv ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">myDiv <span class="fu">=</span> div</a></code></pre></div>
<p>意味は全く同じですが、先程よりもわかりやすくなりました。</p>
<pre class="shell"><code>$ liquid SafeDiv.hs
**** RESULT: SAFE **************************************************************</code></pre>
<p>最後に <code>myDiv</code> を呼び出す関数を定義してみましょう。</p>
<p><code>good</code> は問題の無い使い方です。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">good ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">good <span class="fu">=</span> myDiv <span class="dv">10</span> <span class="dv">2</span></a></code></pre></div>
<p>もし、このような関数 <code>bad</code> が定義されたとすると、<code>Liquid Haskell</code> は <code>UNSAFE</code> を返します。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">bad ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">bad <span class="fu">=</span> myDiv <span class="dv">10</span> <span class="dv">0</span></a></code></pre></div>
<pre class="shell"><code>$ liquid MyDiv.hs
**** RESULT: UNSAFE ************************************************************

 MyDiv.hs:13:7-16: Error: Liquid Type Mismatch

 13 | bad = myDiv 10 0
            ^^^^^^^^^^

   Inferred type
     VV : {v : Int | v == (0 : int)
                     &amp;&amp; v == ?a}

   not a subtype of Required type
     VV : {VV : Int | VV /= 0}

   In Context
     ?a : {?a : Int | ?a == (0 : int)}</code></pre>
<h2 id="問題">問題</h2>
<p>以下のプログラムは標準入力から入力された数 <code>n</code>, <code>m</code> で <code>safeDiv n m</code> を計算します。</p>
<p><code>safeDiv</code> の <code>check</code> を正しく実装して <code>Liquid Haskell</code> の結果を <code>SAFE</code> にしてみましょう。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="co">-- Main.hs</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"></a>
<a class="sourceLine" id="cb20-4" data-line-number="4"><span class="co">{-@ type NonZero = {v:Int | v /= 0} @-}</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5"></a>
<a class="sourceLine" id="cb20-6" data-line-number="6"><span class="co">{-@ myDiv :: Int -&gt; NonZero -&gt; Int @-}</span></a>
<a class="sourceLine" id="cb20-7" data-line-number="7"><span class="ot">myDiv ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb20-8" data-line-number="8">myDiv <span class="fu">=</span> div</a>
<a class="sourceLine" id="cb20-9" data-line-number="9"></a>
<a class="sourceLine" id="cb20-10" data-line-number="10"><span class="co">{-@ lazy main @-}</span></a>
<a class="sourceLine" id="cb20-11" data-line-number="11"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb20-12" data-line-number="12">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb20-13" data-line-number="13">  n <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb20-14" data-line-number="14">  m <span class="ot">&lt;-</span> getLine</a>
<a class="sourceLine" id="cb20-15" data-line-number="15">  <span class="kw">case</span> safeDiv (read n) (read m) <span class="kw">of</span></a>
<a class="sourceLine" id="cb20-16" data-line-number="16">    <span class="dt">Just</span> res <span class="ot">-&gt;</span> print res</a>
<a class="sourceLine" id="cb20-17" data-line-number="17">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb20-18" data-line-number="18">      putStrLn <span class="st">&quot;第二引数に0が入力されています&quot;</span></a>
<a class="sourceLine" id="cb20-19" data-line-number="19">      putStrLn <span class="st">&quot;もう一度入力してください&quot;</span></a>
<a class="sourceLine" id="cb20-20" data-line-number="20">      main</a>
<a class="sourceLine" id="cb20-21" data-line-number="21"></a>
<a class="sourceLine" id="cb20-22" data-line-number="22"><span class="co">{-@ safeDiv :: Int -&gt; Int -&gt; Maybe Int @-}</span></a>
<a class="sourceLine" id="cb20-23" data-line-number="23"><span class="ot">safeDiv ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb20-24" data-line-number="24">safeDiv n m</a>
<a class="sourceLine" id="cb20-25" data-line-number="25">  <span class="fu">|</span> check     <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> div n m</a>
<a class="sourceLine" id="cb20-26" data-line-number="26">  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb20-27" data-line-number="27">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-28" data-line-number="28">   check <span class="fu">=</span> <span class="dt">True</span></a></code></pre></div>
<p>Hint: <code>div</code> に <code>0</code> を通さないよう <code>check</code> でバリデーションすれば良いです。</p>
<h3 id="エラーメッセージ">エラーメッセージ</h3>
<p>現状では、<code>Liquid Haskell</code> は以下のエラーメッセージを返します。</p>
<pre class="shell"><code>$ liquid Main.hs
**** RESULT: UNSAFE ************************************************************

 Main.hs:24:24-30: Error: Liquid Type Mismatch

 24 |   | check     = Just $ div n m
                             ^^^^^^^

   Inferred type
     VV : {v : Int | v == m}

   not a subtype of Required type
     VV : {VV : Int | VV /= 0}

   In Context
     m : Int</code></pre>
<h3 id="実行例">実行例</h3>
<p><code>Liquid Haskell</code> が <code>UNSAFE</code> の場合は実行時エラーが発生します。</p>
<pre class="shell"><code>$ stack repl -- Main.hs
*Main&gt; main
10
2
5

*MyDiv&gt; main
10
0
*** Exception: divide by zero</code></pre>
<p><code>Liquid Haskell</code> を <code>SAFE</code> にすると、再入力を促すようになります。</p>
<pre class="shell"><code>*Main&gt; main
10
0
第二引数に0が入力されています
もう一度入力してください
10
2
5</code></pre>
<h2 id="興味を持った方へ">興味を持った方へ</h2>
<p><code>Liquid Haskell</code> に興味を持った方は以下の文献を読んで <code>Liquid Haskell</code> に詳しくなりましょう！(個人的にまとめているやつを貼り付けただけなので雑ですみません・・・)</p>
<p>たぶん、おすすめは以下のチュートリアルです。(僕はまだ読んでないですが、かなり最近できたものなので情報が新しく良いのではないかと思います)</p>
<ul>
<li><a href="https://liquid.kosmikus.org/">Liquid Haskell Tutorial</a></li>
</ul>
<h3 id="日本語の情報">日本語の情報</h3>
<ul>
<li><a href="http://ccvanishing.hateblo.jp/entry/2016/12/24/193038">LiquidHaskell コトハジメ</a></li>
<li><a href="https://dodgsonlabs.booth.pm/items/490689">入門 LiquidHaskell −篩型による静的コード解析−</a></li>
<li><a href="http://demand-side-science.jp/blog/2014/flops2014%E5%A0%B1%E5%91%8A/">FLOPS2014報告</a></li>
</ul>
<h3 id="ブログ">ブログ</h3>
<ul>
<li><a href="https://ucsd-progsys.github.io/liquidhaskell-blog/">liquidhaskell-blog</a></li>
<li><a href="http://www.haskellforall.com/2015/12/compile-time-memory-safety-using-liquid.html">Compile-time memory safety using Liquid Haskell</a></li>
<li><a href="http://conscientiousprogrammer.com/blog/2015/12/23/24-days-of-hackage-2015-day-23-liquid-haskell-refinement-types-for-the-real-world/">Liquid Haskell: refinement types for the real world</a></li>
</ul>
<h3 id="チュートリアル">チュートリアル</h3>
<ul>
<li><a href="https://liquid.kosmikus.org/">Liquid Haskell Tutorial</a></li>
<li><a href="https://github.com/ucsd-progsys/liquidhaskell-tutorial">liquidhaskell-tutorial</a>
<ul>
<li>long tutorial</li>
<li><a href="http://ucsd-progsys.github.io/liquidhaskell-tutorial/book.pdf">book</a></li>
<li><a href="https://github.com/ucsd-progsys/liquidhaskell-tutorial/blob/master/pdf/programming-with-refinement-types.pdf">programming-with-refinement-types.pdf</a></li>
</ul></li>
<li><a href="https://github.com/ucsd-progsys/lh-workshop">lh-workshop</a>
<ul>
<li>short tutorial</li>
</ul></li>
<li><a href="http://goto.ucsd.edu/~nvazou/presentations/shonan17/01-index.html">Liquid Haskell: Verification of Haskell Code</a></li>
</ul>
<h3 id="スライド">スライド</h3>
<ol type="1">
<li><a href="http://goto.ucsd.edu/~rjhala/flops14/lhs/00_Index.lhs.slides.html#/">Liquid Types For Haskell</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/flops14/lhs/01_SimpleRefinements.lhs.slides.html#/">Simple Refinement Types</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/flops14/lhs/02_Measures.lhs.slides.html#/">Measuring Data Types</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/flops14/lhs/03_HigherOrderFunctions.lhs.slides.html#/">Higher-Order Specifications</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/flops14/lhs/04_AbstractRefinements.lhs.slides.html#/">Abstract Refinements</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/flops14/lhs/09_Laziness.lhs.slides.html#/">Lazy Evaluation?</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/flops14/lhs/10_Termination.lhs.slides.html#/">Refinements &amp; Termination</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/flops14/lhs/11_Evaluation.lhs.slides.html#/">Evaluation</a></li>
</ol>
<ul>
<li><a href="https://web.eecs.umich.edu/~weimerw/students/anish-ms-pres.pdf">Finding and Fixing Bugs in Liquid Haskell</a></li>
<li><a href="https://github.com/Gabriel439/slides/blob/master/liquidhaskell/slides.md">Scrap your Bounds Checks with Liquid Haskell</a></li>
<li><a href="https://nikivazou.github.io/static/popl18/reflection.pdf">Refinement Reflection: Complete Verification with SMT</a></li>
<li><a href="https://popl18.sigplan.org/event/plmw-popl-2018-liquidhaskell-overview">Liquid Haskell: Refinement Types for Haskell</a></li>
</ul>
<h3 id="論文">論文</h3>
<ul>
<li><a href="http://goto.ucsd.edu/~pmr/papers/rondon-liquid-types.pdf">Pat Rondon’s Ph.D Dissertation</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/liquid/liquid_types_techrep.pdf">Tech Report</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/papers/refinement_types_for_haskell.pdf">Refinement Types For Haskell, ICFP 2014</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/papers/real_world_liquid.pdf">LiquidHaskell in the Real World, Haskell 2014</a></li>
<li><a href="http://goto.ucsd.edu/~rjhala/papers/abstract_refinement_types.pdf">Abstract Refinement Types, ESOP 2013</a></li>
<li><a href="https://arxiv.org/pdf/1701.03320.pdf">An Introduction to Liquid Haskell</a></li>
<li><a href="http://goto.ucsd.edu/~nvazou/thesis/main.pdf">Liquid Haskell: Haskell as a Theorem Prover</a></li>
<li><a href="https://nikivazou.github.io/static/Haskell17/a-tale.pdf">A Tale of Two Provers Verifying Monoidal String Matching in Liquid Haskell and Coq</a></li>
</ul>
<h3 id="youtube">Youtube</h3>
<ul>
<li><a href="https://www.youtube.com/watch?v=LEsEME7JwEE">Liquid Types for Haskell</a></li>
<li><a href="https://www.youtube.com/watch?v=vYh27zz9530">Ranjit Jhala - Liquid Haskell</a></li>
<li><a href="https://www.youtube.com/watch?v=vQrutfPAERQ">LambdaConf 2015 - LiquidHaskell Refinement Types for Haskell Ranjit Jhala</a></li>
<li><a href="https://www.youtube.com/watch?v=vqvNQixKr6w">Haskell 2014: LiquidHaskell: Refinement Types for the Real World, Eric L. Seidel</a></li>
<li><a href="https://www.youtube.com/watch?v=nd3buP97Ryw">07 Bounded Refinement Types</a></li>
</ul>
<h2 id="まとめ">まとめ</h2>
<ul>
<li>篩型は <code>{-@ ... @-}</code> で記述する</li>
<li>篩型の型エイリアスは <code>{-@ type @-}</code> で記述する</li>
</ul>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Liquid Haskell</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018-03-01-liquidhaskell.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018-03-01-liquidhaskell.html</id>
    <published>2018-03-01T00:00:00Z</published>
    <updated>2018-03-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>Liquid Haskell で少しハマったのでメモとして残しておきます。</p>
<p>本来なら先に仕様を書いて実装を書くべきだと思いますが、今回の例は既存のコードにリファインメント型をつけるような場合を想定しています。</p>
<pre class="shell"><code>$ liquid
LiquidHaskell Version 0.8.2.4, Git revision d641244775cd842776cecf2c5d3e9afa01549e76 (dirty)
Copyright 2013-18 Regents of the University of California. All Rights Reserved.</code></pre>
<p>Liquid Haskell を気になってる人向けの記事です。</p>
<!--more-->
<h2 id="やりたいこと">やりたいこと</h2>
<p>データの挿入と更新操作を次のような型で表現します。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Operation</span> <span class="fu">=</span> <span class="dt">Insert</span> <span class="fu">|</span> <span class="dt">Update</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="kw">deriving</span> <span class="dt">Eq</span></a></code></pre></div>
<p>上記のデータ型を使って、次のような関数を定義します。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">adjustBound ::</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">adjustBound op lower upper n <span class="fu">|</span> isInsert op <span class="fu">=</span> upper <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">                             <span class="fu">|</span> otherwise   <span class="fu">=</span> lower <span class="ot">`max`</span> (n <span class="ot">`min`</span> upper)</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">isInsert ::</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">isInsert <span class="dt">Insert</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">isInsert _      <span class="fu">=</span> <span class="dt">False</span></a></code></pre></div>
<p><code>adjustBound</code> 関数は以下のように動作します。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">&gt;</span> adjustBound <span class="dt">Insert</span> <span class="dv">0</span> <span class="dv">10</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="dv">11</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="fu">&gt;</span> adjustBound <span class="dt">Insert</span> <span class="dv">0</span> <span class="dv">10</span> <span class="dv">100</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="dv">11</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="fu">&gt;</span> adjustBound <span class="dt">Insert</span> <span class="dv">0</span> <span class="dv">10</span> (<span class="fu">-</span><span class="dv">100</span>)</a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="dv">11</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"></a>
<a class="sourceLine" id="cb4-8" data-line-number="8"><span class="fu">&gt;</span> adjustBound <span class="dt">Update</span> <span class="dv">0</span> <span class="dv">10</span> <span class="dv">5</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="dv">5</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10"><span class="fu">&gt;</span> adjustBound <span class="dt">Update</span> <span class="dv">0</span> <span class="dv">10</span> <span class="dv">100</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11"><span class="dv">10</span></a>
<a class="sourceLine" id="cb4-12" data-line-number="12"><span class="fu">&gt;</span> adjustBound <span class="dt">Update</span> <span class="dv">0</span> <span class="dv">10</span> (<span class="fu">-</span><span class="dv">100</span>)</a>
<a class="sourceLine" id="cb4-13" data-line-number="13"><span class="dv">0</span></a></code></pre></div>
<p><code>adjustBound</code> のような関数でバグが無いことを確認するためには何をしたら良いでしょうか？</p>
<p>型は非常に強力ですが、値について何も教えてくれません。</p>
<h2 id="バグの少ない世界を目指して">バグの少ない世界を目指して</h2>
<p>僕が Haskell を使う理由は、第一に <code>楽しい</code> からです。そのため、「勉強しても就職する時に役に立たないでしょ？」などと言われても全く気になりません。(そもそも、就職するために勉強するわけじゃないですよね)</p>
<p>また Haskell を使えば、正しいソフトウェアを普通に作ることができます。また、<code>hspec</code> などで単体テストを書いたり、<code>QuichCheck</code> などでランダムテストを書くことで、過去に起こった問題を再発させないようにする努力や、バグを少なくするための取り組みが行われています。</p>
<p>しかしながら、個人的にはどれもまだ不安です。もしかしたら、チェックしてない部分にバグがあるんじゃないの・・・？</p>
<p>そんな心配性の方は <code>Liquid Haskell (LH)</code> を使いましょう！</p>
<h2 id="型をより厳しく">型をより厳しく</h2>
<p>最初に定義した <code>Operation</code> 型と <code>adjustBound</code> を再掲します。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">-- LH.hs</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="kw">module</span> <span class="dt">LH</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="kw">data</span> <span class="dt">Operation</span> <span class="fu">=</span> <span class="dt">Insert</span> <span class="fu">|</span> <span class="dt">Update</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  <span class="kw">deriving</span> <span class="dt">Eq</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="ot">adjustBound ::</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8">adjustBound op lower upper n <span class="fu">|</span> isInsert op <span class="fu">=</span> upper <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">                             <span class="fu">|</span> otherwise   <span class="fu">=</span> lower <span class="ot">`max`</span> (n <span class="ot">`min`</span> upper)</a>
<a class="sourceLine" id="cb5-10" data-line-number="10"></a>
<a class="sourceLine" id="cb5-11" data-line-number="11"><span class="ot">isInsert ::</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">isInsert <span class="dt">Insert</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb5-13" data-line-number="13">isInsert _      <span class="fu">=</span> <span class="dt">False</span></a></code></pre></div>
<p>とりあえず、現在のコードを <code>LH</code> にかけてみます。</p>
<pre class="shell"><code>$ liquid LH.hs
LiquidHaskell Version 0.8.2.4, Git revision d641244775cd842776cecf2c5d3e9afa01549e76 (dirty)
Copyright 2013-18 Regents of the University of California. All Rights Reserved.


**** DONE:  A-Normalization ****************************************************


**** DONE:  Extracted Core using GHC *******************************************


**** DONE:  Transformed Core ***************************************************

Working 100% [=================================================================]

**** DONE:  annotate ***********************************************************


**** RESULT: SAFE **************************************************************</code></pre>
<p><code>RESULT: SAFE</code> が表示されれば問題ありません！</p>
<h3 id="入力を自然数に限定させよう">入力を自然数に限定させよう</h3>
<p>例えば <code>lower</code> と <code>upper</code> が自然数 (0含む) しか許容しないという仕様が与えられた時、どうしますか？</p>
<p>よくある対応としては、コメントにその旨を書いたり、テストを作ったりという作業になるでしょう。</p>
<p><code>Liquid Haskell</code> では上記の仕様を <code>事前条件</code> として記述することができます。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="co">{-@ adjustBound :: _ -&gt; Nat -&gt; Nat -&gt; _ -&gt; _ @-}</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">adjustBound ::</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">adjustBound op lower upper n <span class="fu">|</span> isInsert op <span class="fu">=</span> upper <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">                             <span class="fu">|</span> otherwise   <span class="fu">=</span> lower <span class="ot">`max`</span> (n <span class="ot">`min`</span> upper)</a></code></pre></div>
<p><code>Nat</code> は <a href="https://github.com/ucsd-progsys/liquidhaskell/blob/develop/include/Prelude.spec">Prelude</a> で以下のように定義されています。つまり、0以上の <code>Int</code> のみを含むリファインメント型です。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">{-@ type Nat = {v: Int | v &gt;= 0 } @-}</span></a></code></pre></div>
<p>これだけです。<code>LH</code> で結果を確かめてみましょう。</p>
<pre class="shell"><code>$ liquid LH.hs
...

**** RESULT: SAFE **************************************************************</code></pre>
<p><code>SAFE</code> ですね！</p>
<p>これでもう <code>adjustBound</code> の <code>lower</code> と <code>upper</code> は <code>0</code> 以上の自然数でしか呼び出されていないことが示されました。</p>
<h3 id="もう少し具体例">もう少し具体例</h3>
<p>では、別のプログラマが <code>adjustBound</code> を利用した関数を作ったとしましょう。この関数自体に意味はないですが、<code>LH</code> を理解するためにはとても良い例だと思います。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">f ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">f <span class="fu">=</span> adjustBound <span class="dt">Insert</span> (<span class="fu">-</span><span class="dv">100</span>) (<span class="fu">-</span><span class="dv">50</span>) (<span class="fu">-</span><span class="dv">70</span>)</a></code></pre></div>
<p>この関数 <code>f</code> は、型が正しいため当然コンパイルできます。</p>
<pre class="shell"><code>$ stack repl -- LH.hs
&gt; f
-49</code></pre>
<p>けれども、僕らの仕様では <code>adjustBound</code> の <code>lower</code> と <code>upper</code> には自然数しか適用してはいけないはずです。</p>
<p>次に <code>LH</code> を実行してみましょう。</p>
<pre class="shell"><code>$ liquid LH.hs
**** RESULT: UNSAFE ************************************************************


 LH.hs:18:25-28: Error: Liquid Type Mismatch

 18 | f = adjustBound Insert (-100) (-50) (-70)
                              ^^^^


   Inferred type
    VV : {v : Int | v == (-?a)
                    &amp;&amp; v == ?b}

  not a subtype of Required type
    VV : {VV : Int | VV &gt;= 0}

  In Context
    ?b : {?b : Int | ?b == (-?a)}

    ?a : {?a : Int | ?a == (100 : int)}


 LH.hs:18:32-34: Error: Liquid Type Mismatch

 18 | f = adjustBound Insert (-100) (-50) (-70)
                                     ^^^


   Inferred type
    VV : {v : Int | v == (-?b)
                    &amp;&amp; v == ?a}

  not a subtype of Required type
    VV : {VV : Int | VV &gt;= 0}

  In Context
    ?b : {?b : Int | ?b == (50 : int)}

    ?a : {?a : Int | ?a == (-?b)}</code></pre>
<p><code>UNSAFE</code> になりましたね。こういうことです。</p>
<p>つまり、<strong>自分たちが使っている範囲</strong>で <code>Liquid Haskell</code> のリファインメント型について、正しく整合性が取れているのかということを判定しています。</p>
<h3 id="戻り値の型も厳しくしよう">戻り値の型も厳しくしよう！</h3>
<p>先程、事前条件についてリファインメント型を書きました。</p>
<p>次は事後条件についてリファインメントを書きましょう！</p>
<p>同様に戻り値の型も自然数という仕様にします。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="co">{-@ adjustBound :: _ -&gt; Nat -&gt; Nat -&gt; _ -&gt; Nat @-}</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="ot">adjustBound ::</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">adjustBound op lower upper n <span class="fu">|</span> isInsert op <span class="fu">=</span> upper <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">                             <span class="fu">|</span> otherwise   <span class="fu">=</span> lower <span class="ot">`max`</span> (n <span class="ot">`min`</span> upper)</a></code></pre></div>
<pre class="shell"><code>$ liquid LH.hs
**** RESULT: SAFE **************************************************************</code></pre>
<p>リファインメント型 (Refinement type) は <code>篩 (ふるい) 型</code> と訳されている本 (<a href="https://taimen.jp/f/389">入門LiquidHaskell−篩型による静的コード解析−</a>) もありますが、それは <code>Haskell</code> の型の値が条件によって <code>ふるい</code> 落とされて、新しい型 (リファインメント型) になっているというイメージから来ているのだと思います。(読んだこと無いので間違ってたらすみません・・・。)</p>
<p>追記: チェシャ猫さんから <code>篩型</code> について教えてもらいました！</p>
<blockquote class="twitter-tweet" data-lang="ja">
<p lang="ja" dir="ltr">
&gt; リファインメント型 (Refinement type) は 篩 (ふるい) 型 と訳されている本もありますが<br><br>頒布したときに最も多かった質問は「これ何て読むんですか？」だった。ちなみに「篩型」はこの本で勝手に作った造語ではなく、論文タイトルなどにも使われています。<a href="https://t.co/Du6mK1hqdD">https://t.co/Du6mK1hqdD</a>
</p>
— チェシャ猫 (<span class="citation" data-cites="y_taka_23">@y_taka_23</span>) <a href="https://twitter.com/y_taka_23/status/969499842895495168?ref_src=twsrc%5Etfw">2018年3月2日</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<blockquote class="twitter-tweet" data-lang="ja">
<p lang="ja" dir="ltr">
五十嵐先生と末永先生が発案した訳語のようです。 <a href="https://t.co/rcZuFuptl6">https://t.co/rcZuFuptl6</a>
</p>
— チェシャ猫 (<span class="citation" data-cites="y_taka_23">@y_taka_23</span>) <a href="https://twitter.com/y_taka_23/status/969515905737621506?ref_src=twsrc%5Etfw">2018年3月2日</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<h2 id="もっと仕様を">もっと仕様を</h2>
<p><code>adjustBound</code> 関数はこれで十分なのでしょうか？人によっては十分だね。と答えるかもしれません。</p>
<p>しかし、今回は次のような仕様を与えることにします。</p>
<ol type="1">
<li><code>upper</code> は <code>lower</code> 以上の自然数</li>
<li><code>Insert</code> の操作の場合の戻り値は <code>lower</code> 〜 <code>upper + 1</code> の間の自然数</li>
<li><code>Update</code> の操作の場合の戻り値は <code>lower</code> 〜 <code>lower `max` (n `min` upper)</code> の間の自然数</li>
</ol>
<p>ここからが面白いところです。</p>
<p>まずは前準備として <code>x 〜 y</code> までの間の自然数を表すリファインメント型と述語を定義します。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="co">{-@ type Btwn Lo Hi = {v:Int | Lo &lt;= v &amp;&amp; v &lt;= Hi} @-}</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="co">{-@ predicate BtwnP Lo Hi = Lo &lt;= v &amp;&amp; v &lt;= Hi @-}</span></a></code></pre></div>
<p>では、<code>仕様1</code>を反映させてみましょう。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="co">{-@ adjustBound :: _ -&gt; l:Nat -&gt; {u:Nat | l &lt;= u} -&gt; _ -&gt; Nat @-}</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="ot">adjustBound ::</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">adjustBound op lower upper n <span class="fu">|</span> isInsert op <span class="fu">=</span> upper <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">                             <span class="fu">|</span> otherwise   <span class="fu">=</span> lower <span class="ot">`max`</span> (n <span class="ot">`min`</span> upper)</a></code></pre></div>
<pre class="shell"><code>$ liquid LH.hs
**** RESULT: SAFE **************************************************************</code></pre>
<p>では次に、<code>仕様2</code> と <code>仕様3</code> です。</p>
<p>リファインメント型は以下のようになります。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="co">{-@ adjustBound ::</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="co">      op:Operation -&gt;</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3"><span class="co">      l:Nat -&gt;</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4"><span class="co">      {u:Nat | l &lt;= u} -&gt;</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5"><span class="co">      _ -&gt;</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6"><span class="co">      {v:Nat | if (isInsert op) then (BtwnP l (u+1)) else BtwnP l u }</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7"><span class="co">@-}</span></a>
<a class="sourceLine" id="cb18-8" data-line-number="8"><span class="ot">adjustBound ::</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb18-9" data-line-number="9">adjustBound op lower upper n <span class="fu">|</span> isInsert op <span class="fu">=</span> upper <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb18-10" data-line-number="10">                             <span class="fu">|</span> otherwise   <span class="fu">=</span> lower <span class="ot">`max`</span> (n <span class="ot">`min`</span> upper)</a>
<a class="sourceLine" id="cb18-11" data-line-number="11"></a>
<a class="sourceLine" id="cb18-12" data-line-number="12"><span class="co">{-@ measure isInsert @-}</span></a>
<a class="sourceLine" id="cb18-13" data-line-number="13"><span class="ot">isInsert ::</span> <span class="dt">Operation</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb18-14" data-line-number="14">isInsert <span class="dt">Insert</span> <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb18-15" data-line-number="15">isInsert _      <span class="fu">=</span> <span class="dt">False</span></a></code></pre></div>
<pre class="shell"><code>$ liquid LH.hs
**** RESULT: SAFE **************************************************************</code></pre>
<h2 id="はまったポイント">はまったポイント</h2>
<p><code>if (isInsert op) then (BtwnP l (u+1)) else BtwnP l u</code> の部分でかなりはまりました。</p>
<p>例えば <code>if</code> の括弧を外した場合は次のようなエラーになります。</p>
<p><code>if isInsert op then (BtwnP l (u+1)) else BtwnP l u</code></p>
<pre class="shell"><code>**** RESULT: ERROR *************************************************************


 LH.hs:10:73: Error: Cannot parse specification:

 10 | {-@ adjustBound :: op:Operation -&gt; l:Nat -&gt; {u:Nat | l &lt;= u}  -&gt; _ -&gt; {v:Nat | if isInsert op then (BtwnP l (u+1)) else BtwnP l u } @-}
                                                                              ^

     unexpected &quot;:&quot;
     expecting operator, white space or &quot;}&quot;</code></pre>
<p>また、同様に <code>then</code> の括弧を外してもエラーになります。</p>
<p><code>if (isInsert op) then BtwnP l (u+1) else BtwnP l u</code></p>
<pre class="shell"><code>**** RESULT: ERROR *************************************************************


 LH.hs:10:73: Error: Cannot parse specification:

 10 | {-@ adjustBound :: op:Operation -&gt; l:Nat -&gt; {u:Nat | l &lt;= u}  -&gt; _ -&gt; {v:Nat | if (isInsert op) then BtwnP l (u+1) else BtwnP l u } @-}
                                                                              ^

     unexpected &quot;:&quot;
     expecting operator, white space or &quot;}&quot;</code></pre>
<p><code>else</code> については括弧があっても無くても <code>SAFE</code> です。</p>
<p>この挙動が本当にわからなくてつらかったです・・・。</p>
<p>ちなみに、以下のような場合も同様にはまるので、ご注意ください。</p>
<pre><code>-- UNSAFE
{-@ adjustBound :: _ -&gt; l:Nat -&gt; {u:Nat | l &lt;= u}  -&gt; _ -&gt; Btwn l (u+1) @-}
{-@ adjustBound :: _ -&gt; l:Nat -&gt; {u:Nat | l &lt;= u}  -&gt; _ -&gt; Btwn l {u+1} @-}

-- SAFE
{-@ adjustBound :: _ -&gt; l:Nat -&gt; {u:Nat | l &lt;= u}  -&gt; _ -&gt; Btwn {l} {u+1} @-}</code></pre>
<h2 id="まとめ">まとめ</h2>
<ul>
<li><code>if</code> を使う場合は多めに括弧を付けておいた方が良さそう。</li>
<li><code>{}</code> で囲むと上手くいく場合もある</li>
<li><code>LiquidHaskell</code> はすごい</li>
</ul>
<p>この良くわからない挙動について一緒に考えてくれた友人の tkg さんありがとうございました。</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>debug パッケージのアナウンス (翻訳)</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018-02-26-Announcing-the-debug-package.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018-02-26-Announcing-the-debug-package.html</id>
    <published>2018-02-26T00:00:00Z</published>
    <updated>2018-02-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="debug-パッケージのアナウンス-翻訳">debug パッケージのアナウンス (翻訳)</h2>
<p>Original post: <a href="http://neilmitchell.blogspot.jp/2017/12/announcing-debug-package.html">Announcing the ‘debug’ package</a></p>
<p>Haskell は素晴らしい言語ですが、Haskell のデバッグは間違いなく弱い部分です。この問題をどうにかするために、<a href="https://hackage.haskell.org/package/debug">debug ライブラリ</a> をリリースしました。このライブラリは全てのことを解決するのではなく、一般的なデバッグのタスクに対してシンプルで簡単に使えるような設計を目指しました。デバッグをするにあたって、みなさんが興味を持ってくれるような関数を例に取って見てみましょう。</p>
<!--more-->
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">module</span> <span class="dt">QuickSort</span>(quicksort) <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Data.List</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">quicksort ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">quicksort [] <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">quicksort (x<span class="fu">:</span>xs) <span class="fu">=</span> quicksort lt <span class="fu">++</span> [x] <span class="fu">++</span> quicksort gt</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    <span class="kw">where</span> (lt, gt) <span class="fu">=</span> partition (<span class="fu">&lt;=</span> x) xs</a></code></pre></div>
<p><code>TemplateHaskell</code> と <code>ViewPatterns</code> を有効にしてから、<code>Debug</code> をインポートし、コードをインデントして <code>debug</code> の引数に渡してやりましょう。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">{-# LANGUAGE TemplateHaskell, ViewPatterns #-}</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">module</span> <span class="dt">QuickSort</span>(quicksort) <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Data.List</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Debug</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">debug [d|</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">   quicksort :: Ord a =&gt; [a] -&gt; [a]</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">   quicksort [] = []</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">   quicksort (x:xs) = quicksort lt ++ [x] ++ quicksort gt</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">       where (lt, gt) = partition (&lt;= x) xs</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">   |]</a></code></pre></div>
<p>以下のコマンドでデバッガを走らせることができます。</p>
<pre class="shell"><code>$ ghci QuickSort.hs
GHCi, version 8.2.1: http://www.haskell.org/ghc/  :? for help
[1 of 1] Compiling QuickSort        ( QuickSort.hs, interpreted )
Ok, 1 module loaded.
*QuickSort&gt; quicksort &quot;haskell&quot;
&quot;aehklls&quot;
*QuickSort&gt; debugView</code></pre>
<p><code>debugView</code> を呼ぶと Webブラウザが起動して、記録されたデバッグの結果を見ることができます。こんな感じです。</p>
<figure>
<img src="https://cdn.rawgit.com/ndmitchell/debug/f6e8dbc9/debug.png" alt="debugView の実行結果" /><figcaption>debugView の実行結果</figcaption>
</figure>
<p>ここから、計算の経過をクリックしつつ探すことができます。</p>
<p>私は <code>debug</code> を使った感想や、これを改善できるようなアイディアを求めています。そのため、フィードバックや<a href="https://github.com/ndmitchell/debug/issues">バグトラッカー</a>経由のお手伝いなどをお待ちしています。</p>
<p>また別の Haskell のデバッガに興味があるのなら、<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html#the-ghci-debugger">GHCi デバッガ</a>や <a href="https://hackage.haskell.org/package/Hoed">Hood/Hoed</a> などを試してみるべきでしょう。</p>]]></summary>
</entry>
<entry>
    <title>SLURP (翻訳)</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018-02-25-SLURP.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018-02-25-SLURP.html</id>
    <published>2018-02-25T00:00:00Z</published>
    <updated>2018-02-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="slurp">SLURP</h2>
<p>Great original post: <a href="https://www.snoyman.com/blog/2018/01/slurp">SLURP</a></p>
<p>すでにコミュニティの多くの人々が SLURP の提案を見ていると思います。何人かの人たちに私の意見を聞かれたり、私が議論に参加しないことについて、まぁいろいろな意見をもらいました。この議題を私が避けてきた理由を今ここで書かせてください。作者はその提案をリリース前に教えてくれましたが、その時はサポートしないことを伝えました。私はまた、失礼にならないような形で SLURP へのコメントを控えていることも伝えました。残念ながら、その結果2つのことが起こりました。</p>
<ul>
<li>人によっては、とても良くない影響を与えてしまいました。</li>
<li>“fork” という用語の使い方の誤解、そして残念ながら作者はその間違いを訂正していません。</li>
</ul>
<p>つまりまとめると: 提案は私のものではなく、変更を頼んだわけでも、誰かの頭に銃を向けているわけでもありません。この説明は間違っています。他に出すことができるコメントはいくらでもありますが、正直価値はないでしょう。</p>
<p>間違ってはいないことは、私は日常的に多くの人や Haskell のコミュニティやエコシステムマネジメントチームと直面している問題についてコミュニケーションを取っています。仕事で幅広いユーザーと交流し、不満を聞けばそれを誰かに伝えます。私も不満を持つことがあって、それを誰かに聞いてもらいます。この不満の中には、全てが同じようなものを指しているものもあります。</p>
<p>私が公開できる情報というのは限られています。なぜなら、私に寄せられるかなり多くのコメントが、公にされることを嫌うようなプライベートなメールで書かれているからです。そして経験上、私のことを嘘つきだと誹謗中傷する人たちがいることも分かっています。この絶え間ない誹謗中傷を理由に発言を避けてきましたが、私はここに残しておくべきだと決断しました。わかったのは次の2つのことです。</p>
<ul>
<li>私のやること成すこと全てが悪だと信じている人は、私が何か根拠を持っていてもそれを見ようとはしません。</li>
<li>私が悪魔ではないという可能性を否定しない人は、もしかしたら私の声明をその通りに受け取ってくれるかもしれないということです。</li>
</ul>
<p>以前の私は、アーキテクチャとエコシステム開発についてオープンに議論していました。これはオープンソースコミュニティを作る唯一無二の方法だと私は信じています。Stack 対 cabal の時代の緊張が最も高まったときに、多くの人がオープンな議論に異論を唱えたため、私はより静かなコミュニケーションのチャネルに移ることにしました。これはとても残念なことだったと感じています。私はエコシステムの計画についてもっとオープンに、声高に議論をしたいと思っています。他の人たちが簡単に情報にたどり着けるようにしたいと思っています。私は閉じた扉の裏側で全てを議論することを強く反対します。オープンな議論が再開できるかどうかはいずれわかることでしょう。</p>
<!--more-->
<h2 id="fork-ってなに">“fork” ってなに?</h2>
<p>SLURP に関する議論の大部分が SLURP そのものとはなんの関係もないことは明らかですが、fork に関するコメントは関係があります。作者がドキュメントの中で fork という言葉を使うつもりだったのなら、まずは fork についてしっかりと説明することが望ましかったのではないでしょうか。これから Stackage と Stack の世界で使われている fork という言葉の意味について、私が知っていることをお話しようと思います。この話が本当に作者たちの意図を反映しているのかどうか、それは作者たちの発言を待って確認するしかありません。</p>
<p>ここでいう “fork” という用語は、「何かソフトウェアのプロジェクトを取ってきて、ソースコードを他の場所にホストして、別名で開発を続ける」といった文字通りの意味で使われているわけではありません (私の定義ですが)。この用語は、より一般的なものです。例えば、Stack はコードなんて何も共有していないのに、多くの人に cabal-install の fork だと言われています (もちろん、Cabal のようなベースとなるライブラリは共有していますが)。</p>
<p>誰もが固執していることについて、明確に言及しておきましょう。誰もが考えるような Hackage の直接の競争相手を作ろうとするやりとりには、全く関わっていません。私が知っている人で、こういうことをしたい人はいませんし、私もしたくありません。なぜなら、今日の Stackage と Stack は Hackage あってこそのものだからです。そして私の知人で、この構図を変えたい人は誰一人としていません。Hackage をコントロールしたいなどと考えている人はいないのです。</p>
<p>Hackage の “fork” というと、論理的にそういう結論に至るかもしれませんが、そうではないのです。</p>
<p>次に、この “fork” に関する具体的な頭痛のタネについてお話しましょう。</p>
<h2 id="hackage-のリビジョン">Hackage のリビジョン</h2>
<p>多くの人が Hackage のリビジョンについて嫌悪感を示しています。私も Hackage リビジョンは嫌いです。そして、他の誰よりも嫌悪感を抱く理由を持っています。私は数週間から数ヶ月ほどの自分の人生を使って、いくつかのツールにリビジョンをサポートさせたことがあります。この凄惨な歴史を辿ることもできますが、プログラマの戦記になるだけで価値はないでしょう。それよりも今に向き合うことにします。</p>
<p>私はついに Stack 1.6 で、リビジョンの指定 (pinning) を完全にサポートしました。Stackage は既に長い間リビジョンの指定をサポートし続けています。Stackage にはいくつかのパッケージのリビジョンを無視しているものとしてリストアップする機能があります。</p>
<p>もし仮に、今聞かれたら私はリビジョンが悪いアイディアで、無効にすべきだと答えるでしょう。そして、依存関係の解決に関する問題について、より良い解決方法があると依然として答えるでしょう (これらについては、過去に長々と議論したことがあります)。同時に、そのコストは下がっています。ユーザーが extra-deps に特定のリビジョンを付けていないこと、そして Hackage におけるリビジョンのルールが緩すぎることについては実際、いまだに心配です。これについて懸念を抱いていることは確かですが、私の中の最優先事項ではありません。</p>
<p>ところが他の人は違う考えを持っているようです。私は Hackage Truestee が強制的に cabalファイルを編集することについて腹を立てている多くの人を知っています。彼らに反対することはありませんが、この話題に情熱を持っているわけでもありません。コミュニティのリーダーとの会話の中で、私はこの区別を明確に強調しました (少なくともそうしようとはしました)。</p>
<p>リビジョンに関する最大の懸念は、それの持つ社会的な影響です。すなわち、誰か別のものが自分のビルドの安定性を担うということです。これまでに何度も言及してきましたが、社会的緊張の原因の最たるものに、ビルドがいきなり止まったので上流の開発者に文句を言う、というものがあります。これは大惨事への第一歩で、PVP (Package Versioning Policy) + 依存解決という手法が持つ原理的な欠陥でした。そのため、固定ビルドプランに焦点を当てたツールが必要となるのです。私はこれを何年も主張してきましたが、結局は上流を説得することができなかったので Stack を大々的に作りました。</p>
<p>以上のことから、リビジョンとはフォークのような何かなのでしょうか? 違います。</p>
<h2 id="キュレーション">キュレーション</h2>
<p>数週間前、私はこんなツイートをしました。</p>
<blockquote class="twitter-tweet" data-lang="en">
<p lang="en" dir="ltr">
I did that initially. When collaborating on GPS Haskell, I removed that functionality as a requirement of the Hackage, Cabal, and Haskell Platform teams. Then GPS died and we're stuck unable to work around upstream breakage like this.
</p>
— Michael Snoyman (<span class="citation" data-cites="snoyberg">@snoyberg</span>) <a href="https://twitter.com/snoyberg/status/949385673982730240?ref_src=twsrc%5Etfw">January 5, 2018</a>
</blockquote>
<p>Stackage のオリジナルデザインは、標準的な Linux ディストリビューションモデルに準拠していました。Hackage は私たちの上流でしたが、バージョンの境界が大きく壊れるのを防ぐために一連のパッチを整備し、あまりありませんでしたが時折 (たとえそうでも、正直覚えていませんが)、バグを修正するためにソースを編集したりしました。</p>
<p>2014年に Stackage を cabal と Haskell のプラットフォームに組み込む計画 (GPS Haskell のコードネームで開発していました。それが地面から飛び立つことは一度もありませんでしたが) について議論をしたとき、cabal, Hackage, そして Haskell Platform のメンテナに、ローカルの変更を Stackage が整備しないことを要求されました。なので私はその機能を削除したのですが、それは私たちが今までいた世界の話です。</p>
<p>この機能を復活させるかどうかは再検討中です。その理由を簡潔に説明しますと、これはフォークと捉えることができます。ソフトフォークと呼ぶ人もいるかもしれません。正直なところ、一連のパッチを整備するのは重労働なので Stackage に追加し直したい機能ではありません。しかし、多くのコミュニティがこの作業を必要としています。私がこのことを理解しているように、Nix も理解しています。もしもこれをフォークと言うのなら、私たちのエコシステムに広く浸透しているフォークなんでしょう。</p>
<p>このキュレーションで扱う理由としては、新しい依存バージョンへの更新が遅いパッケージを避けるため、というものがあります。Stackage のパッケージメンテナにとって、誰か他の人がその上限に満足しないからといって、自分のパッケージのバージョンを下げるのはかなりイライラするものがあるでしょう。キュレーションはこの辺の問題を何とかできるかもしれません。私はこれをおまけの特典のように考えていますが、必要なものではないです。</p>
<p>しかし、キュレーションには cabal-install 界隈では問題になっていないものの、Stackage や Stack 界隈で問題を引き起こしているパッケージをどうにかする、というもっと重要な理由があります。ここ数ヶ月の間に何回も問題が起こるまで、私は本当の問題だとは認識していませんでした。<a href="https://github.com/haskell-hvr/cassava/pull/155">例えばこんな例があります</a></p>
<p>私はこの記事で、作者の誰かに何かを要求するつもりはありません。でも私は結局、これらの類の問題に多くの自分の時間を費やして対処してきています。これが現実です。私の友達や同僚は、緊急のリリースポイントを切ったり、様々な持ち越し作業に巻き込まれています。Cabal のライブラリの仕様に明記されているべきだが文書化されていないような何かのために、多くの時間を割いて Stack を変更しなければならないような現状に私の人生を浪費したくはありません。</p>
<p>Hackage は cabal-install を壊さないために、既に大きな苦労をしています。多くの人が、 <code>^&gt;=</code> 演算子の導入がどのように Stack 1.5 を破壊したか聞いたことがあるのではないでしょうか。しかし、実はこの演算子の導入は cabal-install 1.24 も壊していたのです。この事実を知っている人がいないのは、<a href="https://github.com/haskell/cabal/issues/4624">Hackage がこれらのファイルを古いバージョンの cabal-install から隠すような措置を導入した</a>からです。このキュレーションのアイディアは Stack の破壊に対応する術を Stackage に対して提供するものです。Hackage も同じ方法で cabal-install へのダメージに対処するでしょう。</p>
<p>そして、私は同じ類の処置を、Hackage から Stack へしてもらえないかとお願いしました。このお願いは、優先的な処置を求める声に後押しされています。この記事の読者は、各々の判断で自分がどう感じるか考えてください。</p>
<p>まとめると: 私は Stackage に上流のパッケージのパッチを当てられるようにしようとしています。他の人はフォークという言葉を使うかもしれませんが、私はこれをフォークではなくキュレーションだと考えています。</p>
<h2 id="hackage-へのアップロードを避ける">Hackage へのアップロードを避ける</h2>
<p>まず、これは私の好みですが、私のパッケージは Hackage に上げ続けたいと考えています。conduit や yesod, その他鋭意 Hackage でメンテ中の 80 を超えるパッケージの更新をやめるつもりも、そうしたいという願望もありません。そうは言っても、全員が全員同じように感じているわけではありません。</p>
<p>現在 Stackage は Hackage の下流になっています。最初にパッケージが Hackage にアップロードされない限り、そのパッケージを Stackage に入れることはできません。しかし、この状況は終わりを告げようとしています。およそ、現状を変えようとしているグループは以下の 3 パターンに分けられるでしょう。</p>
<ol type="1">
<li>少なくとも一部の PVP 支持者は、PVP に従わないパッケージ作成者に対して、そのパッケージを Hackage にアップロードしないように要請 (要求) しています。これは私が幾度となく指摘してきたように、Hackage 公式のガイドラインと完全に矛盾しているにも関わらず、彼らはしつこく同じ趣旨の発言を続けています。</li>
<li>PVP に反対する人の中には、基本的に (1) の理由で、Hackage にアップロードしたくない、という人もいます。PVP の遵守という観点で、たくさんの張りつめた議論がありました。これを避けるための最も簡単な方法は Hackage にアップロードしない、というものでした。私はこういった事情があって Hackage や Stackage にコードをリリースしない人たちを知っています。しぶしぶこうしている人もいますが、その全員が同じ理由で Hackage を避けたがっています。</li>
<li>技術的に見て、中央リポジトリに手作業で tarball をアップロードするようなモデルは、時代遅れになってきていると感じる人もいます。そういった人たちは、タグやリリースブランチを使って自動化された、Git ベースのリリースに基づいたワークフローを考えています。これによる社会的な影響は何もなく、どちらかと言うと Hackage が現在サポートしていない、技術的に違うものを探してみたいという願望です。</li>
</ol>
<ol type="1">
<li>番目の状況は、私の大きな頭痛の種でした。私は Hackage Trustee のガイドラインと Hackage のルールを変更して、彼らの言動 (Hackage にアップロードしないように私的なメールで要求したり、個人や企業に対して PVP に従っていないことを公に批判したり) について明確に禁止するように要望を出していました。実際、私が思うに、この要望は究極的には SLURP に結びつくものです。私は変更しなければフォークするぞと脅したりしたでしょうか? あー、そう思いたいならそれでもいいでしょう。私は Hackage を使うのをやめようと言い続けてきました。完全にです。私はこのような Hackage の使い方が許可されるように、公式のポリシーに対して変更を求めました。</li>
</ol>
<p>現状を見たらわかりますが、Hackage のポリシーにそんな変更はされませんでした。私は (2) と (3) のグループに対して何を思うのか、言及していませんでしたね。しかし (3) の主張からもわかるように、Hackage とは別の代替パッケージリポジトリをホストしたりするのは全くもって意味がありません。なので、私はまたここで保証します。最も文字通りの Hackage の fork は、私も私が話しかけているあなたも誰も望んでいないものになるでしょう。</p>
<p>また他の選択肢は Stackage に Hackage に加え、Git リポジトリから直接パッケージをプルできるようにする、というものです。これは先に挙げた 問題 (1) に対するワークアラウンドとして議論されています。あることを主張して、一度離れてもう一度それを主張するようになる… なんてことはありません。私はむしろ、Hackage が全員からパッケージのアップロードを受け付けることを明確にすることを望んでいますし、それと比べれば Stackage を別のソースに対して解放するような要求は少なくなります (3 番目のグループは純粋に技術的な観点から実験したいと思っているようですが)。</p>
<p>私は銃で誰かの頭を狙っているでしょうか? それはあなたが決めることです。これが私が知る限りの本当の物語です。</p>
<p>まとめると、これは潜在的な fork に最も近いもので、Git リポジトリが Hackage の代替のソースとして許可されたらこうなります。</p>
<h2 id="まとめ">まとめ</h2>
<p>私は上記の問題を解決するための努力をするにあたって、複数の人と長く非公開な議論をしてきました。先ほども話したように、私はいつも公の場で行われる議論が好きです。SLURP の提案がどうなったかを鑑み、私はやはり公の議論はより良いという立場を取ろうと思います。“fork” という言葉を使って、とても多くの人を怖がらせてしまったことは申し訳なく思っています。本当に怖がっていた人に対して、私は鬼のようなことをしてしまっていたようです。説明に 2 日間待たせてしまい、申し訳ありませんでした。</p>]]></summary>
</entry>
<entry>
    <title>stack でどうしてもビルドできないとき</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018-02-23-stack-build-failure.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018-02-23-stack-build-failure.html</id>
    <published>2018-02-23T00:00:00Z</published>
    <updated>2018-02-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>僕は <code>stack</code>, <code>hlint</code>, <code>liquidhaskell</code> などのパッケージを毎日なんとなくビルドしてインストールしているのですが、ある時 <code>stack</code> のビルドで <code>GHC panic</code> が発生し、ビルドができなくなってしまいました。</p>
<p>数日放置していたのですが、直らず・・・。そればかりか別のPCでは問題なくビルドができているため <code>stack</code> の問題だな！と意気揚々と <a href="https://github.com/commercialhaskell/stack/issues/3876">issue</a> を作ったのですが、結局は自分の環境の問題でした・・・。</p>
<p>僕は英語が得意ではありませんが、こういった時に批判だけするのは良くないと思っているので、頑張って <code>issue</code> や <code>PR</code> を投げるようにしています。Google 翻訳とかもありますし、誰か助けてくれますよ、きっと。 (放置されたり却下されることもありますが、気にせずコツコツ続けると楽しいです)</p>
<!--more-->
<h2 id="stack-のビルドがどうしてもできない時">Stack のビルドがどうしてもできない時</h2>
<p>ちゃんと <code>stack clean --full</code> を行った上でビルドコマンドを叩いたら、以下のような <code>ghc panic</code> エラーになりました。</p>
<pre class="shell"><code>$ stack build
...

ghc: panic! (the &#39;impossible&#39; happened)
      (GHC version 8.2.2 for x86_64-apple-darwin):
    	Loading temp shared object failed: dlopen(/var/folders/ky/8g7fv32j4js337c85sy5gy0h0000gn/T/ghc43457_0/libghc_437.dylib, 5): Symbol not found: _hackagezmsecurityzm0zi5zi2zi2zm9BfzzLHvNB6mEIMD9YTAK2zz_HackageziSecurityziUtilziChecked_zdwthrowChecked_closure
      Referenced from: /var/folders/ky/8g7fv32j4js337c85sy5gy0h0000gn/T/ghc43457_0/libghc_437.dylib
      Expected in: flat namespace
     in /var/folders/ky/8g7fv32j4js337c85sy5gy0h0000gn/T/ghc43457_0/libghc_437.dylib

    Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug</code></pre>
<p><code>ghc panic</code> は、言語拡張とか最新の機能とかを触っていれば良く見るエラーですが、なぜこれが起きたのか全くわかりません・・・。</p>
<p><code>issue</code> のアドバイス通り <code>stack exec -- ghc-pkg unregister hackage-security</code> も試してみたのですがダメでした。</p>
<p>なので最終手段の <code>~/.stack</code> を削除することになったんですが、今までどのフォルダを削除したら良いのかイマイチわかっていませんでした。</p>
<p>しかし <code>stack</code> の中の人は違います！ <code>precompiled</code>, <code>snapshots</code> を削除しなよ！と優しく教えてくれたので、指示通りこんな感じで削除したところ、無事にビルドが通るようになりました！</p>
<pre class="shell"><code>$ stack path --stack-root
~/.stack

$ rm -rf $(stack path --stack-root)/precompiled
$ rm -rf $(stack path --stack-root)/snapshots</code></pre>
<p>もう知ってるよ・・・。という話かもしれませんが、どうしてもビルドできない人は試してみてはいかがでしょうか。</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>stack 1.6.5 がリリースされました。</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018-02-21-stack165.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018-02-21-stack165.html</id>
    <published>2018-02-21T00:00:00Z</published>
    <updated>2018-02-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>先日 Stack version 1.6.5 が<a href="https://github.com/commercialhaskell/stack/blob/master/ChangeLog.md#v165">リリース</a>されました。</p>
<p>バグフィックスのみです。</p>
<p>いくつか前回の <a href="https://haskell.e-bigmoon.com/posts/2017-12-24-stack163.html">1.6.3</a> に含まれていた内容が 1.6.5 に移動してますね。</p>
<!--more-->
<h2 id="更新方法">更新方法</h2>
<pre class="shell"><code>$ stack upgrade

$ stack --version
Version 1.6.5, Git revision 24ab0d6ff07f28276e082c3ce74dfdeb1a2ca9e9 (5514 commits) x86_64 hpack-0.20.0</code></pre>
<h2 id="バグフィックス">バグフィックス</h2>
<ul>
<li>Windows でプリコンパイルされたキャッシュファイルのパス名が長過ぎる場合にビルドが失敗する問題を修正しました (<a href="https://github.com/commercialhaskell/stack/issues/3649">#3649</a>)</li>
</ul>
<p>僕は Windows ユーザではないので、どのぐらいこのバグが深刻なのかわかりません。</p>
<p><code>stack</code> の内部的には <a href="https://github.com/commercialhaskell/stack/blob/v1.6.5/src/Stack/Build/Cache.hs#L372">pathTooLong</a> が新しく定義され、以前まではただの <code>length</code> で比較していたところを <code>utf16StringLength</code> の比較に修正したようです。</p>
<hr />
<ul>
<li>スクリプトインタプリタ形式で暗黙的に渡されるファイル引数を他の引数より先に処理するようにしました (<a href="https://github.com/commercialhaskell/stack/issues/3658">#3658</a>)。この修正により、スクリプト実行時に <code>-- +RTS ... -RTS</code> を渡せるようになりました。</li>
</ul>
<p>以下のような <code>RTS</code> オプションの指定が適切に処理できるようになりました。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">{- stack</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="co">  script</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="co">  --resolver lts-6.25</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="co">  --package turtle</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="co">  --</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="co">  +RTS -s -RTS</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="co">-}</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"></a>
<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="ot">main ::</span> <span class="dt">IO</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">main <span class="fu">=</span> putStrLn <span class="st">&quot;Hello, world!&quot;</span></a></code></pre></div>
<hr />
<ul>
<li>stack 設定ファイルで <code>year</code> パラメータが設定できるようになりました。それに伴い、ドキュメントもわかりやすくしました。 (<a href="https://github.com/commercialhaskell/stack/issues/2275">#2275</a>)。</li>
</ul>
<p>こんな感じで指定できるようです。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">templates:</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  <span class="fu">params:</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">    <span class="fu">author-email:</span><span class="at"> 415fox@gmail.com</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    <span class="fu">author-name:</span><span class="at"> michael fox</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    <span class="fu">category:</span><span class="at"> Application</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    <span class="fu">copyright:</span><span class="at"> copytright michael fox 2016</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    <span class="fu">github-username:</span><span class="at"> gitfoxi</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8">    <span class="fu">year:</span><span class="at"> 2016</span></a></code></pre></div>
<p>ドキュメントを見る限り <code>copyright</code> を省略した場合は <code>author-name</code> と <code>year</code> を使って <code>copyright</code> が生成されるようです。</p>
<p>また <code>year</code> を省略した場合は現在の年が設定されるとのことなので、設定しなくても良さそうですね。</p>
<hr />
<ul>
<li>ベンチーマークが別のベンチマークやビルドステップと並行して実行されてしまう問題を修正しました。これは別のプロセスのCPU利用がベンチマークに悪影響を及ぼすと思われるので理想的ではありません。また、デフォルトでベンチマークの出力が表示されないようになっていた件も同様に修正しました (<a href="https://github.com/commercialhaskell/stack/issues/3663">#3663</a>)</li>
</ul>
<p><a href="https://github.com/commercialhaskell/stack/pull/3666">Never run benchmarks concurrently, always output to console #3663 #3666</a>が修正のPRです。</p>
<p>良くわかりませんが <code>Actiontype</code> 型に <code>ConcurrencyDisallowed</code> というデータコンストラクタを追加し <code>bench</code> が呼ばれた際はこの値を <code>Action</code> 型の <code>actionConcurrency</code> フィールドに設定することで処理を切り替えるようにしているっぽいです。</p>
<hr />
<ul>
<li>パッケージのコンポーネントごとに別々のビルドキャッシュを持つことによって、未変更のファイルについて不要なリビルドを回避するようになりました (<a href="https://github.com/commercialhaskell/stack/issues/3732">#3732</a>)</li>
</ul>
<p><code>issue</code> にあがっている具体例だと <code>foo</code> と <code>bar</code> の2つのパッケージを作り、<code>bar</code> は <code>foo</code> に依存しているという関係です。</p>
<pre class="shell"><code>$ stack test --no-run-tests
$ stack test --no-run-tests bar</code></pre>
<p>この時、1回目でテストが終わってるので2回目で <code>bar</code> を指定した時に何も起こらないはずです。</p>
<p>しかし、実際にはこうなります。</p>
<pre class="shell"><code>$ stack test --no-run-tests bar
bar-0.1.0.0: unregistering (missing dependencies: foo)
foo-0.1.0.0: unregistering (local file changes: app/Main.hs test/Spec.hs)
foo-0.1.0.0: build (lib + exe)
foo-0.1.0.0: copy/register
bar-0.1.0.0: configure (lib + exe + test)</code></pre>
<p><a href="https://github.com/commercialhaskell/stack/pull/3750">Use a separate build cache for each component of a package #3750</a>で修正されています。</p>
<p>実装を見る感じ、コンポーネントというのは <code>lib</code>, <code>exe</code>, <code>test</code>, <code>bench</code> のことで、それぞれを接頭辞にしたビルドキャッシュを持つようになったみたい？です。</p>
<hr />
<ul>
<li>スナップショットからローカルパッケージにパッケージを反映させる処理の動作を修正しました。これはスナップショットのバージョン境界が衝突する時に発生する問題なので、古いパッケージの Hackage リビジョンによって引き起こされます。同様にカスタムスナップショットでも、問題の起きないパッケージの衝突するバージョンが定義できるようになりました。(<a href="https://github.com/fpco/stackage/issues/3185">Stackage issue #3185</a>)</li>
</ul>
<p><a href="https://github.com/commercialhaskell/stack/pull/3758/">Fix package promotion to snapshot #3758</a> で修正されました。コードの差分は以下の1行です。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot"># 変更前</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="dt">Just</span> version <span class="ot">-&gt;</span> version <span class="ot">`withinIntervals`</span> intervals</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="ot"># 変更後</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="dt">Just</span> _version <span class="ot">-&gt;</span> <span class="dt">True</span></a></code></pre></div>
<p>このようにローカルパッケージ反映時？にバージョンチェックを行わないようになりました。</p>
<p>以下のようにカスタムスナップショットに追加する場合はビルドできます。(<code>async-2.1.1.1</code> には <code>stm &gt;= 2.2 &amp;&amp; &lt; 2.5</code> の依存関係が設定されています。<a href="https://hackage.haskell.org/package/async-2.1.1.1/src/async.cabal">async.cabal</a>)</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="co"># stack.yaml</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="fu">resolver:</span><span class="at"> snapshot.yaml</span></a></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co"># snapshot.yaml</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="fu">resolver:</span><span class="at"> ghc-8.0.2</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="fu">name:</span><span class="at"> hackage-revisions-are-annoying</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="fu">packages:</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="kw">-</span> async-2.1.1.1</a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="kw">-</span> stm-2.1.2.2</a></code></pre></div>
<p>実行結果。</p>
<pre class="shell"><code>$ stack build --stack-yaml as-snapshot.yaml
WARNING: Ignoring out of range dependency (trusting snapshot over Hackage revisions): stm-2.1.2.2. async requires: &gt;=2.2 &amp;&amp; &lt;2.5

...

Process exited with code: ExitFailure 1
    Logs have been written to: /home/bm12/Desktop/testProj/test/.stack-work/logs/async-2.1.1.1.log

    Configuring async-2.1.1.1...
    Cabal-simple_mPHDZzAJ_1.24.2.0_ghc-8.0.2: Encountered missing dependencies:
    stm &gt;=2.2 &amp;&amp; &lt;2.5 &amp;&amp; ==2.1.2.2</code></pre>
<p>また、以下のように <code>extra-deps</code> に追加する場合はビルドが実行される前にバージョンエラーになります。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="co"># stack.yaml</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="fu">resolver:</span><span class="at"> ghc-8.0.2</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="fu">extra-deps:</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="kw">-</span> async-2.1.1.1</a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="kw">-</span> stm-2.1.2.2</a></code></pre></div>
<p>実行結果</p>
<pre class="shell"><code>$ stack build --stack-yaml as-extra-dep.yaml

Error: While constructing the build plan, the following exceptions were encountered:

In the dependencies for async-2.1.1.1:
    stm-2.1.2.2 from stack configuration does not match &gt;=2.2 &amp;&amp; &lt;2.5  (latest matching version is 2.4.5.0)
needed due to test-0.1.0.0 -&gt; async-2.1.1.1

Some different approaches to resolving this:

  * Set &#39;allow-newer: true&#39; to ignore all version constraints and build anyway.

  * Consider trying &#39;stack solver&#39;, which uses the cabal-install solver to attempt to find some working build configuration. This can be convenient when
    dealing with many complicated constraint errors, but results may be unpredictable.

  * Recommended action: try adding the following to your extra-deps in /home/bm12/Desktop/testProj/test/as-extra-dep.yaml:

- stm-2.4.5.0

Plan construction failed.</code></pre>
<hr />
<ul>
<li><code>stack ghci</code> で複数のパッケージで定義されている同名のモジュールを読み込めるようになりました (<a href="https://github.com/commercialhaskell/stack/pull/3776">#3776</a>)。</li>
</ul>
<p>あんまりわかってないですが、<code>issue</code> の内容は <code>stack</code> と <code>rio</code> の両方のパッケージで同名のモジュールがある場合でも、ちゃんと読み込めるようになったみたいです。</p>
<pre><code>Path.Extra (in stack, rio)
RIO (in stack, rio)
RIO.Logger (in stack, rio)
RIO.Prelude (in stack, rio)
RIO.Process (in stack, rio)</code></pre>
<p><a href="https://github.com/commercialhaskell/stack/pull/3779">With ghci, allow multiple packages to use the same module #3776 #3779</a> で修正されました。</p>
<p><code>ghciPkgModules</code> の型を <code>Set ModuleName</code> から <code>ModuleMap</code> に変更しています。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">type</span> <span class="dt">ModuleMap</span> <span class="fu">=</span> <span class="dt">Map</span> <span class="dt">ModuleName</span> (<span class="dt">Map</span> (<span class="dt">Path</span> <span class="dt">Abs</span> <span class="dt">File</span>) (<span class="dt">Set</span> (<span class="dt">PackageName</span>, <span class="dt">NamedComponent</span>)))</a></code></pre></div>
<p><code>モジュール名</code> → <code>ファイルの絶対パス</code> の順番で探して、その中を <code>Set (PackageName, NamedComponent)</code> で持つようになっています。今まではモジュール名の <code>Set</code> だったので確かに複数のパッケージでも上手く処理できそうな感じがします。</p>
<hr />
<ul>
<li><code>stack ghci</code> で <code>base</code> の依存関係を追加する必要が無くなりました。これはローカルターゲットが存在しない場合に自動的に追加されるためです。これにより、<code>base</code> を置き換えているコードも同様に読み込めるようになります (<a href="https://github.com/commercialhaskell/stack/issues/3589">#3589</a>)</li>
</ul>
<p>修正の<a href="https://github.com/commercialhaskell/stack/commit/196bdbae986ddf887f92999b26129085a8ed0be5">コミット</a>を見ると <code>&quot;-package&quot; : &quot;base&quot;</code> が明示的に追加されています。</p>
<hr />
<ul>
<li><code>--no-rerun-tests</code> が修正されました。今まではテストを実行した後に結果の記録を忘れていました。そのため、前回テストにパスしていたとしても、常に全てのテストが実行されていました (<a href="https://github.com/commercialhaskell/stack/pull/3770">#3770</a>)</li>
</ul>
<hr />
<ul>
<li><code>hackage-security</code> のパッチを当てたバージョンを含めるようにしました。このパッチには機械故障や <code>SIGKILL</code> に対して更新処理が正しく復帰できるように、非同期例外処理に関する問題とディレクトリロックからファイルロックへの変更の2つが含まれます (<a href="https://github.com/haskell/hackage-security/issues/187">hackage-security #187</a>, <a href="https://github.com/commercialhaskell/stack/issues/3073">#3073</a>)</li>
</ul>
<p>この問題よくわかってないのですが、<code>stack</code> のコミットは <code>extra-deps</code> にパッチの当たっている <code>hackage-security</code> を追加しただけです。(<a href="https://github.com/commercialhaskell/stack/commit/4bf68f02d901a6ffc7f4b81a22985d98435fbb14">コミット</a>)</p>
<p>実際のパッチは以下の2つです。</p>
<ul>
<li><a href="https://github.com/haskell/hackage-security/pull/202">Detect asynchronous exceptions via their types #187 #202</a></li>
<li><a href="https://github.com/haskell/hackage-security/pull/203">Use file instead of dir locking #187 #203</a></li>
</ul>
<h2 id="bug-fix-オリジナル">Bug fix (オリジナル)</h2>
<ul>
<li>1.6.1 introduced a change that made some precompiled cache files use longer paths, sometimes causing builds to fail on windows. This has been fixed. See <a href="https://github.com/commercialhaskell/stack/issues/3649">#3649</a></li>
<li>The script interpreter’s implicit file arguments are now passed before other arguments. See <a href="https://github.com/commercialhaskell/stack/issues/3658">#3658</a>. In particular, this makes it possible to pass <code>-- +RTS ... -RTS</code> to specify RTS arguments used when running the script.</li>
<li>Don’t ignore the template <code>year</code> parameter in config files, and clarify the surrounding documentation. See <a href="https://github.com/commercialhaskell/stack/issues/2275">#2275</a>.</li>
<li>Benchmarks used to be run concurrently with other benchmarks and build steps. This is non-ideal because CPU usage of other processes may interfere with benchmarks. It also prevented benchmark output from being displayed by default. This is now fixed. See <a href="https://github.com/commercialhaskell/stack/issues/3663">#3663</a>.</li>
<li>Some unnecessary rebuilds when no files were changed are now avoided, by having a separate build cache for each component of a package. See <a href="https://github.com/commercialhaskell/stack/issues/3732">#3732</a>.</li>
<li>Correct the behavior of promoting a package from snapshot to local package. This would get triggered when version bounds conflicted in a snapshot, which could be triggered via Hackage revisions for old packages. This also should allow custom snapshots to define conflicting versions of packages without issue. See <a href="https://github.com/fpco/stackage/issues/3185">Stackage issue #3185</a>.</li>
<li>When promoting packages from snapshot to local, we were occassionally discarding the actual package location content and instead defaulting to pulling the package from the index. We now correctly retain this information. Note that if you were affected by this bug, you will likely need to delete the binary build cache associated with the relevant custom snapshot. See <a href="https://github.com/commercialhaskell/stack/issues/3714">#3714</a>.</li>
<li><code>stack ghci</code> now allows loading multiple packages with the same module name, as long as they have the same filepath. See <a href="https://github.com/commercialhaskell/stack/pull/3776">#3776</a>.</li>
<li><code>stack ghci</code> no longer always adds a dependency on <code>base</code>. It is now only added when there are no local targets. This allows it to be to load code that uses replacements for <code>base</code>. See <a href="https://github.com/commercialhaskell/stack/issues/3589#issuecomment">#3589</a></li>
<li><code>--no-rerun-tests</code> has been fixed. Previously, after running a test we were forgetting to record the result, which meant that all tests always ran even if they had already passed before. See <a href="https://github.com/commercialhaskell/stack/pull/3770">#3770</a>.</li>
<li>Includes a patched version of <code>hackage-security</code> which fixes both some issues around asynchronous exception handling, and moves from directory locking to file locking, making the update mechanism resilient against SIGKILL and machine failure. See <a href="https://github.com/haskell/hackage-security/issues/187">hackage-security #187</a> and <a href="https://github.com/commercialhaskell/stack/issues/3073">#3073</a>.</li>
</ul>
<h2 id="まとめ">まとめ</h2>
<ul>
<li><code>stack ghci</code> 周りのバグフィックスもいくつかあったので <code>ghci</code> を多用する人にとっては嬉しいですね。</li>
<li>古い <code>LTS</code> を使っているプロジェクトでビルドができなくて困っている人は <code>1.6.5</code> にアップデートすると直るかもしれません。</li>
</ul>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Pattern Synonyms で DEPRECATED</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018-02-12-pattern-synonyms.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018-02-12-pattern-synonyms.html</id>
    <published>2018-02-12T00:00:00Z</published>
    <updated>2018-02-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p><code>persistent</code> ライブラリで <code>SomeField</code> を <code>CopyField</code> に置き換える際の<a href="https://github.com/yesodweb/persistent/pull/760">PR</a>で、パターンシノニム (Pattern Synonyms) の面白い使い方を見つけました。</p>
<p>もしかしたら良く知られた技なのかもしれませんが、ご紹介したいと思います。</p>
<p>パターンシノニムが何かについての説明は、今回全くしていませんのでわかる人向けです。</p>
<!--more-->
<h2 id="モチベーション">モチベーション</h2>
<p>パターンシノニムはパターンの再利用を可能にするための言語拡張です。詳しくは <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#pattern-synonyms">User’s Guide 10.7. Pattern synonyms</a> をご確認ください。</p>
<p>使いみちは色々あると思いますが、今回はコンストラクタを <code>DEPRECATED</code> にするために利用する例をご紹介します。（実際のコードは<a href="https://github.com/parsonsmatt/persistent/blob/c882203c9cc09ba28b2012b58b4cd0fdc415e6ce/persistent-mysql/Database/Persist/MySQL.hs#L1080">このあたり</a>です)</p>
<p><code>Persistent</code> ライブラリの <code>3.0.0</code> から <code>SomeField</code> が廃止され <code>HandleUpdateCollision</code> 型が導入されました。</p>
<p><code>SomeField</code> 型は <code>Persistent</code> の中でも結構重要な型 (<code>SomeException</code> と同じような雰囲気の型) です。また <code>Yesod</code> のプロジェクトでは多数のユーザがいるため、このような変更に対しては、いきなり削除するのではなく <code>DEPRECATED</code> プラグマを利用して、新しい関数への移行を促しています。</p>
<p>今回の場合、<strong>関数</strong>ではなく<strong>データ型</strong>を変更する必要があるためパターンシノニムが利用されています。</p>
<h2 id="実際のコード">実際のコード</h2>
<p>コメント等を適宜削除しましたが、実際にはこんな感じで利用されています。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">HandleUpdateCollision</span> record <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="dt">CopyField</span><span class="ot"> ::</span> <span class="dt">EntityField</span> record typ <span class="ot">-&gt;</span> <span class="dt">HandleUpdateCollision</span> record</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  <span class="dt">CopyUnlessEq</span><span class="ot"> ::</span> <span class="dt">PersistField</span> typ <span class="ot">=&gt;</span> <span class="dt">EntityField</span> record typ <span class="ot">-&gt;</span> typ <span class="ot">-&gt;</span> <span class="dt">HandleUpdateCollision</span> record</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">type</span> <span class="dt">SomeField</span> <span class="fu">=</span> <span class="dt">HandleUpdateCollision</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="ot">#if MIN_VERSION_base(4,8,0)</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">pattern <span class="dt">SomeField</span><span class="ot"> ::</span> <span class="dt">EntityField</span> record typ <span class="ot">-&gt;</span> <span class="dt">SomeField</span> record</a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="ot">#endif</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">pattern <span class="dt">SomeField</span> x <span class="fu">=</span> <span class="dt">CopyField</span> x</a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="ot">{-# DEPRECATED SomeField &quot;The type SomeField is deprecated. Use the type HandleUpdateCollision instead, and use the function copyField instead of the data constructor.&quot; #-}</span></a></code></pre></div>
<p>重要な部分はここですね。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">pattern <span class="dt">SomeField</span> x <span class="fu">=</span> <span class="dt">CopyField</span> x</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ot">{-# DEPRECATED SomeField &quot;...&quot; #-}</span></a></code></pre></div>
<p><code>Haskell</code> には<strong>型シノニム</strong>があるのに<strong>データシノニム</strong>って無いんですね。。。って思った人はパターンシノニムを使えばこんな感じで実現可能です。</p>
<p>通常、パターンシノニムを利用するモチベーションはパターンマッチの再利用にあると思うのですが、単純にデータコンストラクタのエイリアスにしておいて <code>DEPRECATED</code> を促すやり方も結構使えるなーと思いました。</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>素晴らしき HLint を使いこなす</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018-01-29-awesome-hlint.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018-01-29-awesome-hlint.html</id>
    <published>2018-01-29T00:00:00Z</published>
    <updated>2018-01-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p><a href="https://github.com/ndmitchell/hlint">HLint</a> は <a href="https://www.stackage.org/package/haskell-src-exts">haskell-src-exts</a> を使って実装されている静的解析ツールです。</p>
<p><code>HLint</code> を使えば <code>github</code> などを使って <code>PR</code> ベースで開発する場合のコードレビューでこんな事を言わなくて済みます。</p>
<ul>
<li><code>fromJust</code> とかの部分関数は使わないで！</li>
<li><code>maybe</code> 関数って知ってる？</li>
<li>この言語拡張って本当に使ってるの？</li>
<li><code>undefined</code> まだ残ってるじゃん！</li>
</ul>
<p>嬉しいことに <code>Travis CI</code> や <code>CircleCI</code> などで一度設定するだけなので導入もお手軽です！ また、最近知ったのですが、プロジェクト内で使って欲しくない関数なども <code>HLint</code> によって検出可能です。</p>
<p>さらに、独学で <code>Haskell</code> の学習を進めている人は <code>HLint</code> が素晴らしい教師役となってくれるでしょう。</p>
<ul>
<li><a href="https://github.com/waddlaw/blog-example-hlint">利用したコード</a></li>
</ul>
<!--more-->
<h2 id="hlint-の参考記事">HLint の参考記事</h2>
<p><code>HLint</code> は割と有名なので日本語の解説記事がいくつかありました。</p>
<ul>
<li><a href="https://qiita.com/suzuki-hoge/items/6d101e523620178c6f7b">Haskellの静的解析ツール HLint を使おう</a></li>
<li><a href="https://www.ncaq.net/2017/10/07/">Haskellを書くときはstylish-haskellとhlintを使って労せずして綺麗なコードを書きましょう</a></li>
<li><a href="https://qiita.com/VoQn/items/fe7953aec010d8f68a59">OverloadedStringsとANNプラグマが干渉する場合の回避方法</a></li>
</ul>
<p>ちゃんと使おうとすると上記の解説記事では少し物足りません。具体的には以下の点が不足しています。</p>
<ul>
<li>カスタムヒントの設定方法</li>
<li>関数の利用制限方法</li>
<li>関数・モジュール・ファイル単位でヒントを無視する方法</li>
<li><code>CI</code> で利用するための設定方法</li>
</ul>
<p>本記事では、これらの内容について解説を行います。<code>HLint</code> でどんなことが出来るかについては、上記の記事または<a href="https://github.com/ndmitchell/hlint">公式リポジトリ</a>をご参考ください。</p>
<p>また、内部の仕組みについては、作者の <code>Neil Mitchell</code> さんの解説記事が参考になります。</p>
<ul>
<li><a href="https://qiita.com/rounddelta/items/4584f5486c1061c93f0b">HLint のルールを理解する (和訳)</a></li>
</ul>
<h2 id="hlint-の導入">HLint の導入</h2>
<p><code>HLint</code> は以下のコマンドで簡単に導入できます。</p>
<pre class="shell"><code>$ stack install hlint

$ hlint --version
HLint v2.0.15, (C) Neil Mitchell 2006-2018</code></pre>
<p>現在の最新版は <code>v2.0.15</code> となっています。<code>HLint</code> のバージョンによって出力内容が異なることが良くありますのでご注意ください。</p>
<p>また、お試しで使ってみたい人は以下のコマンドを実行してみましょう。カレントディレクトリ以下のファイルが検査されます。</p>
<pre class="shell"><code>$ curl -sL https://raw.github.com/ndmitchell/hlint/master/misc/travis.sh | sh -s .</code></pre>
<h2 id="hlint-の実行方法">HLint の実行方法</h2>
<p><code>HLint</code> はディレクトリを指定すると再帰的に解析を行ってくれます。</p>
<h3 id="プロジェクト全体に対して再帰的に実行">プロジェクト全体に対して再帰的に実行</h3>
<pre class="shell"><code>$ hlint .</code></pre>
<h3 id="特定のディレクトリ-src-に対して再帰的に実行">特定のディレクトリ (src) に対して再帰的に実行</h3>
<pre class="shell"><code>$ hlint src</code></pre>
<h3 id="複数のディレクトリ-src-test-に対して再帰的に実行">複数のディレクトリ (src, test) に対して再帰的に実行</h3>
<pre class="shell"><code>$ hlint src test</code></pre>
<h3 id="単一のファイル-appmain.hs-にのみ実行">単一のファイル (app/Main.hs) にのみ実行</h3>
<pre class="shell"><code>$ hlint app/Main.hs</code></pre>
<h2 id="hlint-のヒント">HLint のヒント</h2>
<p>以下のように <code>stack new</code> で新規プロジェクトを作ってすぐの状態では <code>HLint</code> は何もヒントを出してくれません。</p>
<p>つまり、とても良い状態ということです。</p>
<pre class="shell"><code>$ stacke new test-proj
$ cd test-proj

$ hlint .
No hints</code></pre>
<p>ここで、ファイルを少し修正して <code>HLint</code> に働いてもらいましょう！</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">-- src/Lib.hs</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Lib</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="ot">someFunc ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">someFunc <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  <span class="kw">let</span> x1 <span class="fu">=</span> concat (map toUpper [<span class="ch">&#39;a&#39;</span> <span class="fu">..</span> <span class="ch">&#39;z&#39;</span>])</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">      x2 <span class="fu">=</span> maybe <span class="st">&quot;&quot;</span> id <span class="st">&quot;abc&quot;</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">  putStrLn <span class="st">&quot;someFunc&quot;</span></a></code></pre></div>
<p>上記のコードは以下のようなヒントを2つ提案してくれます。</p>
<pre class="shell"><code>$ hlint .
./src/Lib.hs:7:12: Warning: Use concatMap
Found:
  concat (map toUpper [&#39;a&#39; .. &#39;z&#39;])
Why not:
  concatMap toUpper [&#39;a&#39; .. &#39;z&#39;]

./src/Lib.hs:8:12: Warning: Use fromMaybe
Found:
  maybe &quot;&quot; id
Why not:
  Data.Maybe.fromMaybe &quot;&quot;

2 hints</code></pre>
<p>これは、このような意味になります。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="co"># 1つ目のヒント</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="kw">-</span> <span class="fu">ヒントレベル:</span><span class="at"> 警告</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="kw">-</span> <span class="fu">ヒント:</span><span class="at"> Use concatMap</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="kw">-</span> <span class="fu">出力の意味:</span><span class="at"> concat (map toUpper [&#39;a&#39; .. &#39;z&#39;]) を見つけたけど、どうして concatMap toUpper [&#39;a&#39; .. &#39;z&#39;] と書かないんだい？</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"></a>
<a class="sourceLine" id="cb10-6" data-line-number="6"><span class="co"># 2つ目のヒント</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="kw">-</span> <span class="fu">ヒントレベル:</span><span class="at"> 警告</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8"><span class="kw">-</span> <span class="fu">ヒント:</span><span class="at"> Use fromMaybe</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9"><span class="kw">-</span> <span class="fu">出力の意味:</span><span class="at"> maybe &quot;&quot; id は Data.Maybe モジュールにある fromMaybe 関数を使えば fromMaybe &quot;&quot; と同じですよ</span></a></code></pre></div>
<p>素晴らしいですね。とてもわかりやすいです。また、<code>--report</code> オプションを利用することで結果を <code>HTML</code> として出力することも可能です。</p>
<pre class="shell"><code>$ hlint . --report</code></pre>
<p>とても素晴らしいのですが、<code>HLint</code> の提案するヒントに賛成できない時はどうしましょう? もし <code>HLint</code> の言うとおりにしかできないのであれば、とても使いづらいツールになってしまいます。</p>
<p>そういった場合のためにルールを無視する方法も用意されています。また、プロジェクト固有のカスタムヒントについても同様に設定方法が用意されています。</p>
<h2 id="hlint-のヒントについて">HLint のヒントについて</h2>
<p>デフォルトで適用されるヒントの一覧は <a href="https://github.com/ndmitchell/hlint/blob/master/data/hlint.yaml">hlint.yaml</a> で確認できます。この中に無いヒントについては、自分でカスタムヒントを追加して対応することになります。</p>
<h3 id="カスタムヒントファイルの生成">カスタムヒントファイルの生成</h3>
<p>まずは、カスタムヒントファイルの雛形を生成するために、プロジェクトのルートで以下のコマンドを実行しましょう。</p>
<pre class="shell"><code>$ hlint --default &gt; .hlint.yaml</code></pre>
<p>中身はこんな感じで、ヒントの書き方について具体例が載っています。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="co"># HLint configuration file</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="co"># https://github.com/ndmitchell/hlint</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="co">##########################</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"></a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="co"># This file contains a template configuration file, which is typically</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6"><span class="co"># placed as .hlint.yaml in the root of your project</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7"></a>
<a class="sourceLine" id="cb13-8" data-line-number="8"></a>
<a class="sourceLine" id="cb13-9" data-line-number="9"><span class="co"># Specify additional command line arguments</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10"><span class="co">#</span></a>
<a class="sourceLine" id="cb13-11" data-line-number="11"><span class="co"># - arguments: [--color, --cpp-simple, -XQuasiQuotes]</span></a>
<a class="sourceLine" id="cb13-12" data-line-number="12"></a>
<a class="sourceLine" id="cb13-13" data-line-number="13"></a>
<a class="sourceLine" id="cb13-14" data-line-number="14"><span class="co"># Control which extensions/flags/modules/functions can be used</span></a>
<a class="sourceLine" id="cb13-15" data-line-number="15"><span class="co">#</span></a>
<a class="sourceLine" id="cb13-16" data-line-number="16"><span class="co"># - extensions:</span></a>
<a class="sourceLine" id="cb13-17" data-line-number="17"><span class="co">#   - default: false # all extension are banned by default</span></a>
<a class="sourceLine" id="cb13-18" data-line-number="18"><span class="co">#   - name: [PatternGuards, ViewPatterns] # only these listed extensions can be used</span></a>
<a class="sourceLine" id="cb13-19" data-line-number="19"><span class="co">#   - {name: CPP, within: CrossPlatform} # CPP can only be used in a given module</span></a>
<a class="sourceLine" id="cb13-20" data-line-number="20"><span class="co">#</span></a>
<a class="sourceLine" id="cb13-21" data-line-number="21"><span class="co"># - flags:</span></a>
<a class="sourceLine" id="cb13-22" data-line-number="22"><span class="co">#   - {name: -w, within: []} # -w is allowed nowhere</span></a>
<a class="sourceLine" id="cb13-23" data-line-number="23"><span class="co">#</span></a>
<a class="sourceLine" id="cb13-24" data-line-number="24"><span class="co"># - modules:</span></a>
<a class="sourceLine" id="cb13-25" data-line-number="25"><span class="co">#   - {name: [Data.Set, Data.HashSet], as: Set} # if you import Data.Set qualified, it must be as &#39;Set&#39;</span></a>
<a class="sourceLine" id="cb13-26" data-line-number="26"><span class="co">#   - {name: Control.Arrow, within: []} # Certain modules are banned entirely</span></a>
<a class="sourceLine" id="cb13-27" data-line-number="27"><span class="co">#</span></a>
<a class="sourceLine" id="cb13-28" data-line-number="28"><span class="co"># - functions:</span></a>
<a class="sourceLine" id="cb13-29" data-line-number="29"><span class="co">#   - {name: unsafePerformIO, within: []} # unsafePerformIO can only appear in no modules</span></a>
<a class="sourceLine" id="cb13-30" data-line-number="30"></a>
<a class="sourceLine" id="cb13-31" data-line-number="31"></a>
<a class="sourceLine" id="cb13-32" data-line-number="32"><span class="co"># Add custom hints for this project</span></a>
<a class="sourceLine" id="cb13-33" data-line-number="33"><span class="co">#</span></a>
<a class="sourceLine" id="cb13-34" data-line-number="34"><span class="co"># Will suggest replacing &quot;wibbleMany [myvar]&quot; with &quot;wibbleOne myvar&quot;</span></a>
<a class="sourceLine" id="cb13-35" data-line-number="35"><span class="co"># - error: {lhs: &quot;wibbleMany [x]&quot;, rhs: wibbleOne x}</span></a>
<a class="sourceLine" id="cb13-36" data-line-number="36"></a>
<a class="sourceLine" id="cb13-37" data-line-number="37"></a>
<a class="sourceLine" id="cb13-38" data-line-number="38"><span class="co"># Turn on hints that are off by default</span></a>
<a class="sourceLine" id="cb13-39" data-line-number="39"><span class="co">#</span></a>
<a class="sourceLine" id="cb13-40" data-line-number="40"><span class="co"># Ban &quot;module X(module X) where&quot;, to require a real export list</span></a>
<a class="sourceLine" id="cb13-41" data-line-number="41"><span class="co"># - warn: {name: Use explicit module export list}</span></a>
<a class="sourceLine" id="cb13-42" data-line-number="42"><span class="co">#</span></a>
<a class="sourceLine" id="cb13-43" data-line-number="43"><span class="co"># Replace a $ b $ c with a . b $ c</span></a>
<a class="sourceLine" id="cb13-44" data-line-number="44"><span class="co"># - group: {name: dollar, enabled: true}</span></a>
<a class="sourceLine" id="cb13-45" data-line-number="45"><span class="co">#</span></a>
<a class="sourceLine" id="cb13-46" data-line-number="46"><span class="co"># Generalise map to fmap, ++ to &lt;&gt;</span></a>
<a class="sourceLine" id="cb13-47" data-line-number="47"><span class="co"># - group: {name: generalise, enabled: true}</span></a>
<a class="sourceLine" id="cb13-48" data-line-number="48"></a>
<a class="sourceLine" id="cb13-49" data-line-number="49"></a>
<a class="sourceLine" id="cb13-50" data-line-number="50"><span class="co"># Ignore some builtin hints</span></a>
<a class="sourceLine" id="cb13-51" data-line-number="51"><span class="co"># - ignore: {name: Use let}</span></a>
<a class="sourceLine" id="cb13-52" data-line-number="52"><span class="co"># - ignore: {name: Use const, within: SpecialModule} # Only within certain modules</span></a>
<a class="sourceLine" id="cb13-53" data-line-number="53"></a>
<a class="sourceLine" id="cb13-54" data-line-number="54"></a>
<a class="sourceLine" id="cb13-55" data-line-number="55"><span class="co"># Define some custom infix operators</span></a>
<a class="sourceLine" id="cb13-56" data-line-number="56"><span class="co"># - fixity: infixr 3 ~^#^~</span></a>
<a class="sourceLine" id="cb13-57" data-line-number="57"></a>
<a class="sourceLine" id="cb13-58" data-line-number="58"></a>
<a class="sourceLine" id="cb13-59" data-line-number="59"><span class="co"># To generate a suitable file for HLint do:</span></a>
<a class="sourceLine" id="cb13-60" data-line-number="60"><span class="co"># $ hlint --default &gt; .hlint.yaml</span></a></code></pre></div>
<p><code>HLint</code> はデフォルトヒントが記述されている <code>hlint.yaml</code> と、カスタムヒントが記述されている <code>.hlint.yaml</code> の両方のヒント使って検査を行うため、プロジェクト固有のヒントについては、<code>.hlint.yaml</code> に記述していくことになります。</p>
<h3 id="カスタムヒントの追加">カスタムヒントの追加</h3>
<p>ここでは説明のため以下のような <code>tshow</code> という関数があるとしましょう。この関数は <code>show :: Show a =&gt; a -&gt; String</code> の <code>Text</code> バージョンです。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Text</span> (pack)</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="ot">tshow ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">tshow <span class="fu">=</span> pack <span class="fu">.</span> show</a></code></pre></div>
<p>目的としてはプロジェクトのコード中で <code>pack . show</code> となっている部分を <code>tshow</code> に直すようにヒントを出させることです。まだヒントを追加していないため、当然ながら現時点では <code>pack . show</code> というコードが使われていたとしても何も起こりません。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="co">-- src/Lib.hs</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Lib</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Data.Text</span> (pack)</a>
<a class="sourceLine" id="cb15-5" data-line-number="5"></a>
<a class="sourceLine" id="cb15-6" data-line-number="6"><span class="ot">intToText ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7">intToText <span class="fu">=</span> pack <span class="fu">.</span> show</a></code></pre></div>
<pre class="shell"><code>$ hlint .
No hints</code></pre>
<p>それでは <code>.hlint.yaml</code> に <code>tshow = pack . show</code> を検出するためのヒントを追記しましょう。以下の1行を追記するだけです。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">-</span> <span class="fu">error:</span><span class="at"> </span><span class="kw">{</span><span class="fu">lhs:</span><span class="at"> pack (show x)</span><span class="kw">,</span> <span class="fu">rhs:</span><span class="at"> tshow x</span><span class="kw">}</span></a></code></pre></div>
<p><code>lhs</code>, <code>rhs</code> はそれぞれ <code>Left Hand Side (左辺)</code>, <code>Right Hand Side (右辺)</code> の略です。またヒントのレベルは <code>error</code> 以外にも <code>warm</code>, <code>suggest (hint キーワードはただのエイリアスです)</code> も指定できるため、好きなレベルを指定しましょう。(ヒントレベルの使い分けについては <a href="https://github.com/ndmitchell/hlint#what-is-the-difference-between-errorwarningsuggestion">What is the difference between error/warning/suggestion?</a> をご参照ください)</p>
<p>では、実行してみましょう。</p>
<pre class="shell"><code>$ hlint .
./src/Lib.hs:14:13: Error: Use tshow
Found:
  pack . show
Why not:
  tshow

1 hint</code></pre>
<p>無事に <code>Error</code> として <code>tshow</code> のためのヒントが表示されました！</p>
<p>ヒントの修正方法は、先程定義した <code>intToText</code> 関数の実装をヒント通りに書き換えるだけです。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="ot">intToText ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2">intToText <span class="fu">=</span> tshow</a></code></pre></div>
<pre class="shell"><code>$ hlint .
No hints</code></pre>
<h3 id="ヒントの定義方法について">ヒントの定義方法について</h3>
<p>さきほど定義したヒントはこのようにポイントフリー形式で書くこともできます。</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="kw">-</span> <span class="fu">error:</span><span class="at"> </span><span class="kw">{</span><span class="fu">lhs:</span><span class="at"> pack . show</span><span class="kw">,</span> <span class="fu">rhs:</span><span class="at"> tshow</span><span class="kw">}</span></a></code></pre></div>
<p>上記のヒント形式で次の内容を解析してみましょう。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="co">-- src/Lib.hs</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Lib</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3"></a>
<a class="sourceLine" id="cb22-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Data.Text</span> (pack)</a>
<a class="sourceLine" id="cb22-5" data-line-number="5"></a>
<a class="sourceLine" id="cb22-6" data-line-number="6"><span class="ot">intToText ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb22-7" data-line-number="7">intToText <span class="fu">=</span> pack <span class="fu">.</span> show</a>
<a class="sourceLine" id="cb22-8" data-line-number="8"></a>
<a class="sourceLine" id="cb22-9" data-line-number="9"><span class="ot">intToText2  ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb22-10" data-line-number="10">intToText2 x <span class="fu">=</span> pack <span class="fu">$</span> show x</a></code></pre></div>
<pre class="shell"><code>$ hlint .
./src/Lib.hs:6:13: Error: Use tshow
Found:
  pack . show
Why not:
  tshow

1 hint</code></pre>
<p><code>intToText</code> と <code>intToText2</code> どちらも検出して欲しいですが <code>intToText</code> しか検出できていません。<code>HLint</code> では自動的に η-簡約 (eta-reduction) が行われるため <code>error: {lhs: pack (show x), rhs: tshow x}</code> というように定義しておいた方が良いです。</p>
<h2 id="プロジェクトで利用を禁止している関数を検出する">プロジェクトで利用を禁止している関数を検出する</h2>
<p>プロジェクト内で部分関数 (例: <code>fromJust</code>) を使わせないようにさせたり、<code>undefined</code> が残っていないかなどのチェックをレビュー時に人間が行っていたりしませんか？</p>
<p>人間が介入するということは必ずミスが起こります。人間が気をつければミスは起こらないと思っていたり、精神力でなんとかしようとしている場合は能力不足を疑われても仕方がありません。</p>
<p>また、そのようなつまらない間違い探しのような非クリエイティブな作業に大切な時間を割いてしまうのはとても良くないことです。</p>
<p><code>HLint</code> を使えば、そのような関数を検出することが可能です。実際には <code>関数</code> だけでなく <code>言語拡張</code>, <code>フラグ</code>, <code>モジュール</code> も指定することができます。</p>
<h3 id="関数を指定する方法">関数を指定する方法</h3>
<p><code>.hlint.yaml</code> に以下の内容を追記します。今回は <code>undefined</code> を検出してみたいと思います。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="co"># .hlint.yaml</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2"><span class="kw">-</span> <span class="fu">functions:</span></a>
<a class="sourceLine" id="cb24-3" data-line-number="3">  <span class="kw">-</span> <span class="kw">{</span><span class="fu">name:</span><span class="at"> undefined</span><span class="kw">,</span> <span class="fu">within:</span><span class="at"> </span><span class="kw">[]}</span></a></code></pre></div>
<p>現状はどこにも使われていないためヒントは表示されません。</p>
<pre class="shell"><code>$ hlint .
No hints</code></pre>
<p>では、以下の関数を追加してみましょう。このように型レベルで設計して、実装を <code>undefined</code> にしておくことは良くあります。</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="co">-- src/Lib.hs</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2"><span class="ot">doubleToText ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3">doubleToText <span class="fu">=</span> undefined</a></code></pre></div>
<p>忘れずに実装してしまえば問題無いのですが、たまには忘れることもあります。しかし、<code>HLint</code> があれば安心です。</p>
<pre class="shell"><code>$ hlint .
./src/Lib.hs:18:16: Warning: Avoid restricted function
Found:
  undefined
Note: may break the code

1 hint</code></pre>
<p><code>Lib</code> モジュールのみを検査対象とする場合は <code>within</code> キーワードを次のようにします。</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="co"># .hlint.yaml</span></a>
<a class="sourceLine" id="cb28-2" data-line-number="2"><span class="kw">-</span> <span class="fu">functions:</span></a>
<a class="sourceLine" id="cb28-3" data-line-number="3">  <span class="kw">-</span> <span class="kw">{</span><span class="fu">name:</span><span class="at"> undefined</span><span class="kw">,</span> <span class="fu">within:</span><span class="at"> </span><span class="kw">[</span>Lib<span class="kw">]}</span></a></code></pre></div>
<h2 id="hlint-のヒントを無視する方法">HLint のヒントを無視する方法</h2>
<p><code>HLint</code> のヒントを無視する方法には以下の2種類があります。</p>
<ul>
<li><code>.hlint.yaml</code> ファイルで指定する (<strong>全てのファイル</strong>に影響)</li>
<li>ファイルに直接 <code>{-# ANN -#}</code> アノテーションを記述する (<strong>アノテーションの範囲</strong>にのみ影響)</li>
</ul>
<p>書式がちょっとわかりづらいので、実際に色々試してみましょう。</p>
<h3 id="関数単位で全てのヒントを無視する">関数単位で全てのヒントを無視する</h3>
<p>最初に定義した <code>someFunc</code> 関数はヒントを2つ提案してくれていました。</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="co">-- src/Lib.hs</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Lib</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3"></a>
<a class="sourceLine" id="cb29-4" data-line-number="4"><span class="ot">someFunc ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb29-5" data-line-number="5">someFunc <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb29-6" data-line-number="6">  <span class="kw">let</span> x1 <span class="fu">=</span> concat (map toUpper [<span class="ch">&#39;a&#39;</span> <span class="fu">..</span> <span class="ch">&#39;z&#39;</span>])</a>
<a class="sourceLine" id="cb29-7" data-line-number="7">      x2 <span class="fu">=</span> maybe <span class="st">&quot;&quot;</span> id <span class="st">&quot;abc&quot;</span></a>
<a class="sourceLine" id="cb29-8" data-line-number="8">  putStrLn <span class="st">&quot;someFunc&quot;</span></a></code></pre></div>
<pre class="shell"><code>$ hlint .
./src/Lib.hs:6:12: Warning: Use concatMap
Found:
  concat (map toUpper [&#39;a&#39; .. &#39;z&#39;])
Why not:
  concatMap toUpper [&#39;a&#39; .. &#39;z&#39;]

./src/Lib.hs:7:12: Warning: Use fromMaybe
Found:
  maybe &quot;&quot; id
Why not:
  Data.Maybe.fromMaybe &quot;&quot;

2 hints</code></pre>
<p>提案されているヒントは以下の2つです。</p>
<ul>
<li>Warning: <code>Use concatMap</code></li>
<li>Warning: <code>Use fromMaybe</code></li>
</ul>
<p>とりあえず <code>someFunc</code> のヒントを全て無視するようにしてしまいましょう。</p>
<p>こんな感じで <code>{-# ANN someFunc &quot;HLint: ignore&quot; #-}</code> というアノテーションをつけます。</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="co">-- src/Lib.hs</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Lib</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-3" data-line-number="3"></a>
<a class="sourceLine" id="cb31-4" data-line-number="4"><span class="ot">{-# ANN someFunc &quot;HLint: ignore&quot; #-}</span></a>
<a class="sourceLine" id="cb31-5" data-line-number="5"><span class="ot">someFunc ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb31-6" data-line-number="6">someFunc <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb31-7" data-line-number="7">  <span class="kw">let</span> x1 <span class="fu">=</span> concat (map toUpper [<span class="ch">&#39;a&#39;</span> <span class="fu">..</span> <span class="ch">&#39;z&#39;</span>])</a>
<a class="sourceLine" id="cb31-8" data-line-number="8">      x2 <span class="fu">=</span> maybe <span class="st">&quot;&quot;</span> id <span class="st">&quot;abc&quot;</span></a>
<a class="sourceLine" id="cb31-9" data-line-number="9">  putStrLn <span class="st">&quot;someFunc&quot;</span></a></code></pre></div>
<pre class="shell"><code>$ hlint .
No hints</code></pre>
<p>これで <code>src/Lib.hs</code> に記述されている <code>someFunc</code> 関数のみ <code>HLint</code> のヒントを無視できるようになりました。</p>
<h3 id="ヒントを無視する様々な方法">ヒントを無視する様々な方法</h3>
<p>ヒントレベルは <code>ignore</code> 以外にも <code>suggest</code>, <code>warn</code>, <code>error</code> が利用可能です。これらの値を利用した場合は出力時のヒントレベルが強制的にそのレベルに上書きされます。つまり、ヒントファイルに <code>warn</code> で定義されていたとしても <code>error</code> や <code>ignore</code> として処理されることになります。</p>
<h4 id="関数単位で全てのヒントを無視する方法">関数単位で全てのヒントを無視する方法</h4>
<p><code>ANN</code> のあとに対象の関数名を書きます。</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="ot">{-# ANN someFunc &quot;HLint: ignore&quot; #-}</span></a></code></pre></div>
<h4 id="関数単位で特定のヒントのみを無視する方法">関数単位で特定のヒントのみを無視する方法</h4>
<p><code>HLint: ignore</code> の後にヒント名を書きます。</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="ot">{-# ANN someFunc &quot;HLint: ignore Use fromMaybe&quot; #-}</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2"><span class="ot">{-# ANN someFunc &quot;HLint: ignore Use concatMap&quot; #-}</span></a></code></pre></div>
<h4 id="モジュール単位で無視する方法">モジュール単位で無視する方法</h4>
<p><code>module</code> キーワードを使う場合はアノテーションを <code>import</code> 文の後に設置しないと上手く動かないので、その点のみ注意が必要です。</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="ot">{-# ANN module &quot;HLint: ignore&quot; #-}</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2"></a>
<a class="sourceLine" id="cb35-3" data-line-number="3"><span class="ot">{-# ANN module &quot;HLint: ignore Use fromMaybe&quot; #-}</span></a>
<a class="sourceLine" id="cb35-4" data-line-number="4"><span class="ot">{-# ANN module &quot;HLint: ignore Use concatMap&quot; #-}</span></a></code></pre></div>
<h3 id="overloadedstrings-言語拡張">OverloadedStrings 言語拡張</h3>
<p>言語拡張の <code>OverloadedStrings</code> を有効化している場合は上手く動かないため、明示的に <code>String</code> の型注釈を指定する必要があります。</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="ot">{-# ANN someFunc (&quot;HLint: ignore&quot; :: String) #-}</span></a></code></pre></div>
<h3 id="ヒントファイルを使って無視する方法">ヒントファイルを使って無視する方法</h3>
<p>プロジェクト全体で無視したいヒントについては <code>.hint.yaml</code> に追記します。</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="co"># .hint.yaml</span></a>
<a class="sourceLine" id="cb37-2" data-line-number="2"><span class="kw">-</span> <span class="fu">ignore:</span><span class="at"> </span><span class="kw">{</span><span class="fu">name:</span><span class="at"> Use fromMaybe</span><span class="kw">}</span></a>
<a class="sourceLine" id="cb37-3" data-line-number="3"><span class="kw">-</span> <span class="fu">ignore:</span><span class="at"> </span><span class="kw">{</span><span class="fu">name:</span><span class="at"> Use concatMap</span><span class="kw">}</span></a></code></pre></div>
<p><code>within</code> キーワードでヒントを適用するモジュールを指定できます。</p>
<p>例として <code>Lib</code> モジュールのみを対象とする場合は次のようになります。(この場合は <code>ignore</code> が指定されているので <code>Lib</code> モジュールのみヒントを無視します)</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="co"># .hlint.yaml</span></a>
<a class="sourceLine" id="cb38-2" data-line-number="2"><span class="kw">-</span> <span class="fu">ignore:</span><span class="at"> </span><span class="kw">{</span><span class="fu">name:</span><span class="at"> Use fromMaybe</span><span class="kw">,</span> <span class="fu">within:</span><span class="at"> </span><span class="kw">[</span>Lib<span class="kw">]}</span></a>
<a class="sourceLine" id="cb38-3" data-line-number="3"><span class="kw">-</span> <span class="fu">ignore:</span><span class="at"> </span><span class="kw">{</span><span class="fu">name:</span><span class="at"> Use concatMap</span><span class="kw">,</span> <span class="fu">within:</span><span class="at"> </span><span class="kw">[</span>Lib<span class="kw">]}</span></a></code></pre></div>
<h2 id="ci-を回す">CI を回す！</h2>
<p><code>Haskell</code> のプロジェクトでよく見る <code>CI</code> ツールといえば以下の2つでしょう。</p>
<ul>
<li><a href="https://travis-ci.org/">Travis CI</a></li>
<li><a href="https://circleci.com/">CircleCI 2.0</a></li>
</ul>
<p>個人的には以下の点で <code>CircleCI</code> が好きです。</p>
<ul>
<li>プライベートリポジトリも無料で使える</li>
<li><code>Docker</code>, <code>docker-compose</code> と親和性が高い</li>
</ul>
<p>ここでは <code>HLint</code> の内容にしか言及しませんが、機会があれば <code>CI</code> については別途記事にしたいと思います。</p>
<h3 id="travis-ci">Travis CI</h3>
<p><code>.travis.yml</code> に以下の内容を記述するだけです。</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="co"># .travis.yml</span></a>
<a class="sourceLine" id="cb39-2" data-line-number="2"><span class="fu">sudo:</span><span class="at"> false</span></a>
<a class="sourceLine" id="cb39-3" data-line-number="3"><span class="fu">language:</span><span class="at"> generic</span></a>
<a class="sourceLine" id="cb39-4" data-line-number="4"><span class="fu">jobs:</span></a>
<a class="sourceLine" id="cb39-5" data-line-number="5">  <span class="fu">include:</span></a>
<a class="sourceLine" id="cb39-6" data-line-number="6">    <span class="kw">-</span> <span class="fu">stage:</span><span class="at"> Run hlint</span></a>
<a class="sourceLine" id="cb39-7" data-line-number="7">      <span class="fu">script:</span><span class="at"> curl -sL https://raw.github.com/ndmitchell/hlint/master/misc/travis.sh | sh -s .</span></a></code></pre></div>
<h3 id="circleci-2.0">CircleCI 2.0</h3>
<p><code>.circleci/config.yml</code> に以下の内容を記述するだけです。</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="fu">version:</span><span class="at"> 2</span></a>
<a class="sourceLine" id="cb40-2" data-line-number="2"><span class="fu">jobs:</span></a>
<a class="sourceLine" id="cb40-3" data-line-number="3">  <span class="fu">hlint:</span></a>
<a class="sourceLine" id="cb40-4" data-line-number="4">    <span class="fu">docker:</span></a>
<a class="sourceLine" id="cb40-5" data-line-number="5">      <span class="kw">-</span> <span class="fu">image:</span><span class="at"> ubuntu:16.04</span></a>
<a class="sourceLine" id="cb40-6" data-line-number="6">    <span class="fu">steps:</span></a>
<a class="sourceLine" id="cb40-7" data-line-number="7">      <span class="kw">-</span> checkout</a>
<a class="sourceLine" id="cb40-8" data-line-number="8">      <span class="kw">-</span> <span class="fu">run:</span></a>
<a class="sourceLine" id="cb40-9" data-line-number="9">          <span class="fu">name:</span><span class="at"> Run hlint</span></a>
<a class="sourceLine" id="cb40-10" data-line-number="10">          <span class="fu">command:</span><span class="at"> |</span></a>
<a class="sourceLine" id="cb40-11" data-line-number="11">            apt update</a>
<a class="sourceLine" id="cb40-12" data-line-number="12">            apt install -y curl</a>
<a class="sourceLine" id="cb40-13" data-line-number="13">            <span class="fu">curl -sL https:</span><span class="at">//raw.github.com/ndmitchell/hlint/master/misc/travis.sh | sh -s .</span></a>
<a class="sourceLine" id="cb40-14" data-line-number="14"><span class="fu">workflows:</span></a>
<a class="sourceLine" id="cb40-15" data-line-number="15">  <span class="fu">version:</span><span class="at"> 2</span></a>
<a class="sourceLine" id="cb40-16" data-line-number="16">  <span class="fu">hlint:</span></a>
<a class="sourceLine" id="cb40-17" data-line-number="17">    <span class="fu">jobs:</span></a>
<a class="sourceLine" id="cb40-18" data-line-number="18">      <span class="kw">-</span> hlint</a></code></pre></div>
<h2 id="まとめ">まとめ</h2>
<p>今回は紹介していませんが <code>HLint</code> のヒントを自動的に適用してくれる <a href="https://github.com/mpickering/apply-refact">apply-refact</a> というツールもあります。使い方については各種ドキュメントをご確認ください。</p>
<ul>
<li><a href="https://github.com/ndmitchell/hlint#automatically-applying-hints">Automatically Applying Hints</a></li>
</ul>
<p>今回は <code>Haskell</code> の静的解析ツール <code>HLint</code> について説明を行いました。需要があれば <code>LiquidHaskell</code> などの他の静的解析ツールについても、チュートリアル的な解説記事を書いていきたいところです。</p>]]></summary>
</entry>
<entry>
    <title>Yesod の破壊的変更予定</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018-01-27-Upcoming-Yesod-breaking-changes.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018-01-27-Upcoming-Yesod-breaking-changes.html</id>
    <published>2018-01-27T00:00:00Z</published>
    <updated>2018-01-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Original post: <a href="https://www.yesodweb.com/blog/2018/01/upcoming-yesod-breaking-changes">Upcoming Yesod breaking changes</a></p>
<p>2018年 1月 11日 Michael Snoyman</p>
<p>私が作ったライブラリの破壊的変更点について話をしてきましたが、Yesod をその変更から取り残したくはありませんでした。yesod-core は 2014年からバージョン1.4 で安定しています。しかし、私のパッケージエコシステムにおける <code>MonadUnliftIO</code> の変更は Yesod にも影響してくるでしょう。問題は、どの程度かということです。</p>
<!--more-->
<p>知らない人のために補足しておくと、<code>MonadUnliftIO</code> は <code>monad-control</code> と <code>exceptions</code> にそれぞれ存在する <code>MonadBaseControl</code> と <code>MonadCatch/MonadMask</code> クラスの代替となる型クラスです。私はこれまでこの新しいアプローチのメリットを至る所で言及してきましたが、おそらく一番良い資料は<a href="https://www.fpcomplete.com/blog/2017/07/announcing-new-unliftio-library">リリースアナウンスのブログ記事</a>でしょう。</p>
<p>予定されている Yesod の変更点を簡潔に述べると:</p>
<ul>
<li><code>WidgetT</code> の内部表現を変更する。現在は <code>WriterT</code> として実装されているので変更が必要です。<code>MonadUnliftIO</code> とマッチさせるために、<code>IORef</code> を持つ <code>ReaderT</code> にする必要があります。この変更は内部モジュールにしか影響しないため、私の想像ではかなり小さな変更になります (非破壊的変更と言い換えることもできる)。</li>
<li><code>MonadBaseControl</code> と <code>MonadCatch/MonadMask</code> のインスタンスを削除する。これは厳密には必要ないですが、2つのアドバンテージがあります: 依存関係の数を少なくし、<code>HandlerT</code> の上に <code>StateT</code> を乗せた状態で <code>concurrently</code> を使うような危険な振る舞いを避けることができます。</li>
<li>依存しているライブラリを、変更後の新しいバージョンに切り替える。特に conduit や resourcet など。これも厳密には破壊的変更ではないですが、私は依存関係のメジャーバージョンへのサポートを打ち切ることを半破壊的変更だと捉えています。</li>
<li>破壊的変更に伴う、いくつもの小さなお片付け。いくつかの場所に正格化のためのアノテーションを追加するとか、死んでいる <code>GoogleEmail</code> や <code>BrowserId</code> 等のモジュールの削除などです。</li>
</ul>
<p>これは完全に筋の通った変更で、Yesod 1.5 (2.0) としてリリースします。私が実験しているもう少し大きな変更があるので、それをここで共有しておきます。この変更が Yesod のユーザーにとって価値があるかどうか、フィードバックをお願いしたいです。</p>
<h2 id="トランスフォーマーから離れろ">トランスフォーマーから離れろ!</h2>
<p>以下の説明は、こういう議論ではいつもそうであるように、仕方なく <code>IO</code> に入れなければならないコードについて言及したものです。純粋なコードは今回はパスです。</p>
<p>(実際の変更よりも大きく見えますが) 変更は <a href="https://github.com/yesodweb/yesod/pull/1466">no-transformer ブランチ</a> で確認できます。まぁすぐに嘘だと分かると思いますが、意図を正確に表しています。ここ 1年間のブログ記事の雰囲気と推奨しているベストプラクティスについての私の議論を見れば、次の簡単な主張に帰結します: モダンな Haskell はモナドトランスフォーマーを使いすぎなのです</p>
<p>この主張に対して最も過激な反応をするなら、全てのトランスフォーマーを削除し、全てのコードを <code>IO</code> に入れる、というものになります。私はちょっと妥協して、reader の機能は残す価値があると判断しました。なぜなら、<code>logInfo</code> のような単純な関数に何かを追加で渡すのは、かなりの苦痛だからです。Yesod の核となっている型は <code>HandlerT</code> で、<code>getHomeR :: HandlerT App IO Html</code> のように使われます。内部では、<code>HandlerT</code> は以下のようになっています:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">HandlerT</span> site m a <span class="fu">=</span> <span class="dt">HandlerT</span> (<span class="dt">HandlerData</span> site <span class="ot">-&gt;</span> m a)</a></code></pre></div>
<p>簡単な質問をしましょう: <code>HandlerT</code> は本当にトランスフォーマーである必要があるのでしょうか?</p>
<p>なぜシンプルにこんな風に書かないのでしょうか:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">HandlerFor</span> site a <span class="fu">=</span> <span class="dt">HandlerFor</span> (<span class="dt">HandlerData</span> site <span class="ot">-&gt;</span> <span class="dt">IO</span> a)</a></code></pre></div>
<p><code>m</code> という型引数を <code>IO</code> という具体的なものに変えただけです。どんな場所でもハンドラはベースモナドとして <code>IO</code> を持つ、という前提がすでにあるので、汎用性が無くなるわけではありません。</p>
<p>しかしこの結果得られるものは:</p>
<ul>
<li>少し分かりやすいエラーメッセージ</li>
<li>より少ない型制約。思い浮かぶのは <code>MonadUnliftIO m</code> みたいな</li>
<li>内部で、型族周りの汚い部分をかなりシンプルにできる。</li>
</ul>
<p>ヘルパー型シノニムを導入すれば、多くの後方互換性を得ることができます:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">type</span> <span class="dt">HandlerT</span> site m <span class="fu">=</span> <span class="dt">HandlerFor</span> site</a></code></pre></div>
<p>さらに、Template Haskell によって生成された <code>Handler</code> という型シノニムを使っているなら、新しいバージョンの Yesod は正しいものを生成してくれるでしょう。全体として、これはほんの少しの改善です。この変更によって得られる利益と破壊のコストを天秤にかける必要があります。ただ、まだ折衷案が残っています。</p>
<h2 id="サブサイトを扱う-ええトランスフォーマーです">サブサイトを扱う (ええ、トランスフォーマーです)</h2>
<p>私は 2回嘘をつきました: さっきのブランチはトランスフォーマーを使っています。そして <code>HandlerT</code> は <code>HandlerFor</code> よりも一般的です。いずれの場合もサブサイトをどうにかする必要がありますが、これは歴史的に苦痛を伴う作業です (使う分にはひどすぎることもないです)。実は、今日 <code>HandlerT</code> が存在する唯一の理由に、サブサイトを綺麗に層に分けるやり方で実装しようとした、というものがあります (失敗しましたが)。Yesod を長く使っている人は <code>GHandler</code> という前回のアプローチを覚えているかもしれません。そして、サブサイトを書いたことがあって <code>defaultLayout</code> を使う時に起こる地獄を知っている人は、現在の状況は良くないということに同意してくれると思います。</p>
<p>なので、問題を全て解決するため: サブサイトを書く時、ほとんど全てが普通の handler のコードを書くのと同じです。以下の点が違いますが:</p>
<ul>
<li><code>getYesod</code> を呼ぶ時、マスターサイトの app データを受け取る (例えば、スキャフォールドサイトの <code>App</code>)。サブサイトのデータを入手する方法も必要になります (例えば、<code>yesod-static</code> の <code>Static</code> という値)。</li>
<li><code>getCurrentRoute</code> を呼ぶと、マスターサイトのルートを返してくれます。例えば、<code>yesod-auth</code> の中にいる時、親サイトの取りうる全てのルートを扱いたくはないでしょう。その代わりに、サブサイト自身のルートを知りたいはずです。</li>
<li>URL を生成する時、サブサイトのルートを親サイトのルートに変換する手段が必要になります。</li>
</ul>
<p>今日の Yesod では、これらの違いを <code>HandlerT</code> の中で提供しています。こうすると、ベースケースの <code>m</code> を <code>IO</code> にする時に、やけに複雑になります。その代わりに、新しいブランチでは <code>HandlerFor</code> の上に <code>ReaderT</code> 1層を置き、これら 3つの機能を提供しています。詳しく知りたい方は<a href="https://github.com/yesodweb/yesod/blob/3e06942449cad0b52e218cb7e9f2c06b45b85e69/yesod-core/Yesod/Core/Class/Dispatch.hs#L38">コードを見てください</a>。</p>
<h2 id="何をすべきか">何をすべきか?</h2>
<p>全体的に、私はこの設計をエレガントで、理解しやすく、コードを綺麗にしてくれるものだと思っています。現実問題、昔のものから大きく離れたわけでも大きく改善されたわけでもありませんし、私はトランスフォーマーを無くすような変更の道半ばで進めなくなっています。</p>
<p>近い将来、Yesod には破壊的変更が行われますが、必ずしもこの変更を含む必要はありません。もしこの変更が追加されないのなら、破壊的変更は上で言及した、かなりマイナーなものになるでしょう。この変更が好ましいという一般のコンセンサスが得られたなら、同時に追加した方がいいでしょうね。</p>]]></summary>
</entry>
<entry>
    <title>最近遭遇した stack build 時の ld (pthread, -fPIC) エラー</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018-01-06-stack-ld-errors.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018-01-06-stack-ld-errors.html</id>
    <published>2018-01-06T00:00:00Z</published>
    <updated>2018-01-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>ここ最近、プロジェクトのビルド時に謎のエラーが発生するようになりました。</p>
<p>以下の2種類のエラーに遭遇したので、今後のために記録しておきます。</p>
<ul>
<li><code>pthread link error</code></li>
<li><code>-fPIC error</code></li>
</ul>
<pre class="shell"><code>$ stack --version
Version 1.7.0, Git revision 19e3460496f8fd2c462fb35a5825301e5c3c4eb0 (5527 commits) x86_64 hpack-0.20.0</code></pre>
<!--more-->
<h2 id="pthread-link-error">pthread link error</h2>
<p>このエラーは <code>Hakyll</code> を利用しているサイトをビルドしている時に発生したものです。</p>
<p>関連する <code>issue</code> は以下の通りです。</p>
<ul>
<li><a href="https://github.com/jgm/pandoc/issues/4130">pthread link errors on linux with GHC 8.2 #4130</a></li>
<li><a href="https://github.com/jgm/pandoc-citeproc/issues/311">Error building on Ubuntu 16 #311</a></li>
</ul>
<p><code>issue</code> に掲載されているエラーメッセージですが、以下のように <code>pthread</code> 系のエラーが表示され、結果として <code>gcc failed in phase Linker. (Exit code: 1)</code> となります。</p>
<pre class="shell"><code>    Linking .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/pandoc-citeproc/pandoc-citeproc ...

    /tmp/stack11451/pandoc-citeproc-0.12.1.1/rts/posix/OSThreads.c:137:0: error:
         error: undefined reference to &#39;pthread_create&#39;

    /tmp/stack11451/pandoc-citeproc-0.12.1.1/rts/posix/OSThreads.c:139:0: error:
         error: undefined reference to &#39;pthread_detach&#39;

    /tmp/stack11451/pandoc-citeproc-0.12.1.1/rts/posix/OSThreads.c:141:0: error:
         error: undefined reference to &#39;pthread_setname_np&#39;

    /tmp/stack11451/pandoc-citeproc-0.12.1.1/rts/posix/OSThreads.c:184:0: error:
         error: undefined reference to &#39;pthread_key_create&#39;

    /tmp/stack11451/pandoc-citeproc-0.12.1.1/rts/posix/OSThreads.c:192:0: error:
         error: undefined reference to &#39;pthread_getspecific&#39;

    /tmp/stack11451/pandoc-citeproc-0.12.1.1/rts/posix/OSThreads.c:203:0: error:
         error: undefined reference to &#39;pthread_setspecific&#39;

    /tmp/stack11451/pandoc-citeproc-0.12.1.1/rts/posix/OSThreads.c:212:0: error:
         error: undefined reference to &#39;pthread_key_delete&#39;

    /tmp/stack11451/pandoc-citeproc-0.12.1.1/rts/posix/OSThreads.c:371:0: error:
         error: undefined reference to &#39;pthread_kill&#39;

    /tmp/stack11451/pandoc-citeproc-0.12.1.1/includes/rts/OSThreads.h:59:0: error:
         error: undefined reference to &#39;pthread_mutex_trylock&#39;
    collect2: error: ld returned 1 exit status
    `gcc&#39; failed in phase `Linker&#39;. (Exit code: 1)</code></pre>
<p>修正方法は簡単で <code>package.yaml</code> や <code>cabal</code> ファイルの <code>ghc-options</code> に <code>-threaded</code> を追記するだけです。</p>
<p>具体的にはこんな感じで修正しました。</p>
<ul>
<li><a href="https://github.com/jaspervdj/hakyll/pull/601/files">Added -threaded to ghc-options. pthread link errors on linux with GHC 8.2 #601</a></li>
</ul>
<p>なぜこのエラーが発生したのかはわからないのですが <code>lts-10</code> 系にしたタイミングで遭遇しました。</p>
<h2 id="fpic-error">-fPIC error</h2>
<p><code>Mac</code> では確認できなかったのですが <code>Ubuntu 17.10</code> で以下のエラーに遭遇しました。</p>
<pre class="shell"><code>    /usr/bin/ld: /home/bm12/.stack/programs/x86_64-linux/ghc-8.0.2/lib/ghc-8.0.2/rts/libHSrts_thr.a(Arena.thr_o): relocation R_X86_64_32 against .rodata.str1.1 can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。
    /usr/bin/ld: /home/bm12/.stack/programs/x86_64-linux/ghc-8.0.2/lib/ghc-8.0.2/rts/libCffi.a(closures.o): relocation R_X86_64_32 against .rodata can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。
    /usr/bin/ld: /home/bm12/.stack/programs/x86_64-linux/ghc-8.0.2/lib/ghc-8.0.2/rts/libCffi.a(ffi64.o): relocation R_X86_64_32S against .rodata can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。
    /usr/bin/ld: 最終リンクに失敗しました: 出力に対応するセクションがありません
    collect2: error: ld returned 1 exit status
    gcc failed in phase Linker. (Exit code: 1)</code></pre>
<p><code>stack</code> の <code>issue</code> でも話題になってました。</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/issues/3518">Stack 1.6 linking issues on Arch Linux #3518</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/2712">Linker error makes it impossible to use a stack-provided ghc #2712</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/3630">Benchmarks can no longer be built with Stack 1.6.1 #3630</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/3648">ghc-tinfo6-nopie-8.2.2 requires changes to its settings file to work on Arch Linux #3648</a></li>
</ul>
<p>解決策がまとまり <code>faq</code> に追加されたので、同じエラーで悩んでいる人は一度ご確認ください。</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/3725">faq update: ld errors about recompiling with -fPIC #3725</a></li>
</ul>
<p>解決方法がとても簡単で、以下のコマンドを実行して <code>ghc</code> を再インストールするだけです。</p>
<pre class="shell"><code>$ stack setup --reinstall</code></pre>
<h2 id="まとめ">まとめ</h2>
<p>突然ビルドできなくなることもあるんですね・・・。</p>]]></summary>
</entry>

</feed>
