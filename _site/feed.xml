<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>BIG MOON</title>
    <link href="https://haskell.e-bigmoon.com/feed.xml" rel="self" />
    <link href="https://haskell.e-bigmoon.com" />
    <id>https://haskell.e-bigmoon.com/feed.xml</id>
    <author>
        <name>BIG MOON</name>
        <email>it@e-bigmoon.com</email>
    </author>
    <updated>2018-04-08T00:00:00Z</updated>
    <entry>
    <title>Haskell Quiz No.8 Conduit Part.4</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/04-08-quiz-8.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/04-08-quiz-8.html</id>
    <published>2018-04-08T00:00:00Z</published>
    <updated>2018-04-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="haskell-quiz-no.8">Haskell Quiz No.8</h2>
<p>難易度: λλλ</p>
<p>以下の <code>Conduit</code> を使ったコードの実行結果を予想してみてください！</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.3</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">main <span class="fu">=</span> print <span class="fu">$</span> runConduitPure <span class="fu">$</span> return () <span class="fu">.|</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    mapM_ leftover [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    sinkList</a></code></pre></div>
<p>答えは次回。</p>
<!--more-->
<h2 id="はじめに">はじめに</h2>
<p><a href="./04-07-quiz-7.html">前回</a>の問題と答えは以下の通りです。</p>
<h3 id="問題">問題</h3>
<p>難易度: λλ</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.3</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">myTakeWhileC ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (i <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">ConduitM</span> i i m ()</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">myTakeWhileC f <span class="fu">=</span> loop</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">    loop <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">      mx <span class="ot">&lt;-</span> await</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">      <span class="kw">case</span> mx <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> return ()</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">        <span class="dt">Just</span> x</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">          <span class="fu">|</span> f x       <span class="ot">-&gt;</span> yield x <span class="fu">&gt;&gt;</span> loop</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">          <span class="fu">|</span> otherwise <span class="ot">-&gt;</span> return ()</a>
<a class="sourceLine" id="cb2-15" data-line-number="15"></a>
<a class="sourceLine" id="cb2-16" data-line-number="16"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-17" data-line-number="17">main <span class="fu">=</span> print <span class="fu">$</span> runConduitPure <span class="fu">$</span> yieldMany [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">.|</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-18" data-line-number="18">  x <span class="ot">&lt;-</span> myTakeWhileC (<span class="fu">&lt;=</span> <span class="dv">5</span>) <span class="fu">.|</span> sinkList</a>
<a class="sourceLine" id="cb2-19" data-line-number="19">  y <span class="ot">&lt;-</span> sinkList</a>
<a class="sourceLine" id="cb2-20" data-line-number="20">  return (x, y)</a></code></pre></div>
<h3 id="こたえ">こたえ</h3>
<p>実際に実行してみましょう！</p>
<pre class="shell"><code>$ ./Quiz7.hs
([1,2,3,4,5],[7,8,9,10])</code></pre>
<p><strong>6</strong> が抜けていることに注意してくださいね！</p>
<h3 id="解説">解説</h3>
<p>今回の問題は <code>[1,2,3,4,5],[7,8,9,10]</code> ではなく <code>[1,2,3,4,5],[6,7,8,9,10]</code> と思った人もいるのではないでしょうか？</p>
<p>では何故このような動作になってしまうのか、それは <code>myTakeWhileC</code> 関数に秘密があります。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">myTakeWhileC ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (i <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">ConduitM</span> i i m ()</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">myTakeWhileC f <span class="fu">=</span> loop</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    loop <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">      mx <span class="ot">&lt;-</span> await</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">      <span class="kw">case</span> mx <span class="kw">of</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> return ()</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">        <span class="dt">Just</span> x</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">          <span class="fu">|</span> f x       <span class="ot">-&gt;</span> yield x <span class="fu">&gt;&gt;</span> loop</a>
<a class="sourceLine" id="cb4-10" data-line-number="10">          <span class="fu">|</span> otherwise <span class="ot">-&gt;</span> return ()</a></code></pre></div>
<p>この関数を理解するためには、以下の2点を抑えておけば十分です。</p>
<ul>
<li><code>await</code> は上流のパイプに対して、値をチャンクサイズで1つ要求する関数です。(チャンクサイズは型によって違います。リストであれば要素1つですが、<code>ByteString</code> であれば <strong>1byte</strong> や <strong>1文字</strong> ではなく！ <strong>32kbyte</strong>になります。)</li>
<li><code>yield</code> は下流のパイプに値を流す関数です</li>
</ul>
<p>つまり、この関数は上流からデータを取得し、<code>f x</code> が <code>True</code> であれば下流にデータを流す準備を行い、同じ処理を繰り返します。(また、上流のデータが無くなれば <code>await</code> の結果は <code>Nothing</code> となるため、そこで処理が止まります)</p>
<p>今回の <code>f</code> は <code>(&lt;= 5)</code> なので流れてくる値が <code>5</code> 以下の間は、上流から流れてきた値をそのまま下流に流す準備をします。</p>
<p>図で書くとこんな感じでしょうか。<code>yield</code> の準備完了と <code>await</code> の要求を青と赤の実線で表現しています。(破線はそうでない場合)</p>
<p>下記の図は一番最初の <code>await</code> です。<code>sinkList</code> も <code>await</code> していますが、先に <code>myTakeWhileC</code> 関数によって消費されてしまうため、データは届きません。</p>
<p><code>myTakeWhileC</code> に適用した <strong>1</strong> は条件を満たすため、さらに下流の <code>sinkList</code> にデータを流す準備を行い、<code>sinkList</code> が <code>await</code> したタイミングでデータが流れます。</p>
<p><img class="no-border" src="/images/2018/04-08/quiz8-1.png"></p>
<p><strong>2 〜 5</strong> の場合も同様に処理されます。そのため、<code>main</code> 関数の <code>x &lt;- myTakeWhileC (&lt;= 5) .| sinkList</code> の <code>x</code> は <code>[1,2,3,5,]</code> という値になります。</p>
<p>次に条件を満たさない <strong>6</strong> の場合を考えましょう。</p>
<p>この場合は <code>myTakeWhileC</code> 関数は <code>return ()</code> を返します。そのため下流の <code>sinkList</code> にはデータを流しません。</p>
<p><img class="no-border" src="/images/2018/04-08/quiz8-2.png"></p>
<p>ここで <strong>6</strong> のデータが消え去ります。通常、一度消費してしまった値については再利用できません。(ここでは解説しませんが、<code>Conduit</code> では <code>leftover</code> という関数を使って一度消費してしまった値を上流に返すための関数が定義されています)</p>
<p><img class="no-border" src="/images/2018/04-08/quiz8-3.png"></p>
<p>そのため、次は <strong>7</strong> が2つ目の <code>sinkList</code> に流れます。</p>
<p><strong>8 〜 10</strong> についても同様に処理されるため、結果として <code>y &lt;- sinkList</code> の <code>y</code> は <code>[7,8,9,10]</code> となります。</p>
<h2 id="まとめ">まとめ</h2>
<ul>
<li>パイプを流れるデータは<strong>チャンクサイズ</strong>ということを意識する。</li>
<li>消費してしまったデータは <code>leftover</code> を使わない限り取り戻せない</li>
</ul>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Haskell Quiz No.7 Conduit Part.3</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/04-07-quiz-7.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/04-07-quiz-7.html</id>
    <published>2018-04-07T00:00:00Z</published>
    <updated>2018-04-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="haskell-quiz-no.7">Haskell Quiz No.7</h2>
<p>難易度: λλ</p>
<p>以下の <code>Conduit</code> を使ったコードの実行結果を予想してみてください！</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.3</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">myTakeWhileC ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (i <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">ConduitM</span> i i m ()</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">myTakeWhileC f <span class="fu">=</span> loop</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    loop <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">      mx <span class="ot">&lt;-</span> await</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">      <span class="kw">case</span> mx <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> return ()</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">        <span class="dt">Just</span> x</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">          <span class="fu">|</span> f x       <span class="ot">-&gt;</span> yield x <span class="fu">&gt;&gt;</span> loop</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">          <span class="fu">|</span> otherwise <span class="ot">-&gt;</span> return ()</a>
<a class="sourceLine" id="cb1-15" data-line-number="15"></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-17" data-line-number="17">main <span class="fu">=</span> print <span class="fu">$</span> runConduitPure <span class="fu">$</span> yieldMany [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">.|</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">  x <span class="ot">&lt;-</span> myTakeWhileC (<span class="fu">&lt;=</span> <span class="dv">5</span>) <span class="fu">.|</span> sinkList</a>
<a class="sourceLine" id="cb1-19" data-line-number="19">  y <span class="ot">&lt;-</span> sinkList</a>
<a class="sourceLine" id="cb1-20" data-line-number="20">  return (x, y)</a></code></pre></div>
<p>答えは<a href="04-08-quiz-8.html">次回</a>。</p>
<!--more-->
<h2 id="はじめに">はじめに</h2>
<p><a href="./04-06-quiz-6.html">前回</a>の問題と答えは以下の通りです。</p>
<h3 id="問題">問題</h3>
<p>難易度: λλ</p>
<p>以下の <code>Conduit</code> を使ったコードの実行結果を予想してみてください！</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.2</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">trans ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ConduitM</span> <span class="dt">Int</span> <span class="dt">Int</span> m ()</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">trans <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  takeC <span class="dv">5</span> <span class="fu">.|</span> mapC (<span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  mapC (<span class="fu">*</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb2-9" data-line-number="9"></a>
<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">main <span class="fu">=</span> runConduit <span class="fu">$</span> yieldMany [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">.|</span> trans <span class="fu">.|</span> mapM_C print</a></code></pre></div>
<h3 id="こたえ">こたえ</h3>
<p>実際に実行してみましょう！</p>
<pre class="shell"><code>$ ./Quiz6.hs
2
3
4
5
6
12
14
16
18
20</code></pre>
<h2 id="haskell-quiz-no.6-の解説">Haskell Quiz No.6 の解説</h2>
<p>この問題で重要なのは <code>trans</code> 関数です。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">trans ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ConduitM</span> <span class="dt">Int</span> <span class="dt">Int</span> m ()</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">trans <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  takeC <span class="dv">5</span> <span class="fu">.|</span> mapC (<span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  mapC (<span class="fu">*</span> <span class="dv">2</span>)</a></code></pre></div>
<ul>
<li>1つめのパイプ <code>takeC 5 .| mapC (+ 1)</code> によって <code>[1..10]</code> のうち <code>[1..5]</code> が <code>mapC (+ 1)</code> によって処理されます。</li>
<li>2つめのパイプ <code>mapC (* 2)</code> によって残りの <code>[6..10]</code> が <code>mapC (* 2)</code> によって処理されます。</li>
</ul>
<p>そのため、結果として以下のような出力となりました。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="dv">2</span>  <span class="co">-- 1+1</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="dv">3</span>  <span class="co">-- 2+1</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="dv">4</span>  <span class="co">-- 3+1</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="dv">5</span>  <span class="co">-- 4+1</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="dv">6</span>  <span class="co">-- 5+1</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="dv">12</span> <span class="co">-- 6*2</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="dv">14</span> <span class="co">-- 7*2</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="dv">16</span> <span class="co">-- 8*2</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="dv">18</span> <span class="co">-- 9*2</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10"><span class="dv">20</span> <span class="co">-- 10*2</span></a></code></pre></div>
<p>大前提として、このパイプにデータが流れるのは <code>mapM_C print</code> によって上流のデータが無くなるまでデータを要求するという操作があるためです。</p>
<p>そのため、 <code>mapM_C print</code> を <code>sinkNull</code> にすると何も表示されなくなります。</p>
<h2 id="まとめ">まとめ</h2>
<p><code>Conduit</code> は何も知らずにいつも通りの感覚で利用すると、直感と違う動きをすることがあるので、簡単な例を通して慣れていくと良いと思います。</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Haskell Quiz No.6 Conduit Part.2</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/04-06-quiz-6.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/04-06-quiz-6.html</id>
    <published>2018-04-06T00:00:00Z</published>
    <updated>2018-04-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="haskell-quiz-no.6">Haskell Quiz No.6</h2>
<p>難易度: λλ</p>
<p>以下の <code>Conduit</code> を使ったコードの実行結果を予想してみてください！</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.2</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">trans ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ConduitM</span> <span class="dt">Int</span> <span class="dt">Int</span> m ()</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">trans <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  takeC <span class="dv">5</span> <span class="fu">.|</span> mapC (<span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">  mapC (<span class="fu">*</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb1-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">main <span class="fu">=</span> runConduit <span class="fu">$</span> yieldMany [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">.|</span> trans <span class="fu">.|</span> mapM_C print</a></code></pre></div>
<p>答えは<a href="04-07-quiz-7.html">次回</a>。</p>
<p>最近は <code>Conduit</code> にはまっているので、クイズも <code>Conduit</code> が続きます。</p>
<!--more-->
<h2 id="はじめに">はじめに</h2>
<p><a href="./03-31-quiz-5.html">前回</a>の問題と答えは以下の通りです。</p>
<h3 id="問題">問題</h3>
<p>難易度: λλ</p>
<p>以下の <code>Conduit</code> を使ったコードの実行結果を予想してみてください！</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.0</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">sink ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ConduitM</span> <span class="dt">Int</span> o m (<span class="dt">String</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">sink <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  x <span class="ot">&lt;-</span> takeC <span class="dv">5</span> <span class="fu">.|</span> mapC show <span class="fu">.|</span> foldC</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  y <span class="ot">&lt;-</span> sumC</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  return (x, y)</a>
<a class="sourceLine" id="cb2-10" data-line-number="10"></a>
<a class="sourceLine" id="cb2-11" data-line-number="11"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13">  <span class="kw">let</span> res <span class="fu">=</span> runConduitPure <span class="fu">$</span> yieldMany [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">.|</span> sink</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">  print res</a></code></pre></div>
<h3 id="こたえ">こたえ</h3>
<p>実際に実行してみましょう！</p>
<pre class="shell"><code>$ ./Quiz5.hs
(&quot;12345&quot;,40)</code></pre>
<p>どうですか？予想通りでしたか？？</p>
<h2 id="haskell-quiz-no.5-の解説">Haskell Quiz No.5 の解説</h2>
<p>この問題を解くためには <a href="https://www.stackage.org/lts-11.3/package/conduit-1.3.0.2">conduit</a> というストリーム処理ライブラリの知識が必要になります。</p>
<h3 id="conduit-を使うモチベーション">Conduit を使うモチベーション</h3>
<p>具体例として指定したディレクトリ以下の<strong>ファイル数</strong>と<strong>容量の合計</strong>を出力するようなプログラムを作ってみましょう。</p>
<p>ディレクトリ操作については <a href="https://www.stackage.org/lts-11.3/package/directory-1.3.0.2">directory</a> パッケージに便利な関数が色々と定義されているので、このパッケージを利用します。</p>
<p>必要な操作と、対応する関数は以下の通りです。</p>
<ul>
<li>ファイルの列挙: <a href="https://www.stackage.org/haddock/lts-11.3/directory-1.3.0.2/System-Directory.html#v:listDirectory">listDirectory</a></li>
<li>ファイルサイズの取得: <a href="https://www.stackage.org/haddock/lts-11.3/directory-1.3.0.2/System-Directory.html#v:getFileSize">getFileSize</a></li>
<li>ファイル・ディレクトリの判定: <a href="https://www.stackage.org/haddock/lts-11.3/directory-1.3.0.2/System-Directory.html#v:doesFileExist">doesFileExist</a></li>
</ul>
<p>これらの関数を使って、こんな感じでプログラムを作ることができます。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="co">{-</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="co">stack script --resolver lts-11.3</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="co">  --package extra</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="co">  --package filepath</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="co">  --package directory</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="co">-}</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8"></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="kw">import</span> <span class="dt">System.Environment</span> (getArgs)</a>
<a class="sourceLine" id="cb4-10" data-line-number="10"><span class="kw">import</span> <span class="dt">System.Directory</span> (listDirectory, doesFileExist, getFileSize)</a>
<a class="sourceLine" id="cb4-11" data-line-number="11"><span class="kw">import</span> <span class="dt">System.FilePath</span> ((&lt;/&gt;))</a>
<a class="sourceLine" id="cb4-12" data-line-number="12"><span class="kw">import</span> <span class="dt">Control.Monad.Extra</span> (partitionM, ifM)</a>
<a class="sourceLine" id="cb4-13" data-line-number="13"><span class="kw">import</span> <span class="dt">Control.Monad</span> (when)</a>
<a class="sourceLine" id="cb4-14" data-line-number="14"></a>
<a class="sourceLine" id="cb4-15" data-line-number="15"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-16" data-line-number="16">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-17" data-line-number="17">  arg <span class="ot">&lt;-</span> getArgs</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">  when (length arg <span class="fu">==</span> <span class="dv">1</span>) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-19" data-line-number="19">    (cnt, size) <span class="ot">&lt;-</span> recListDir <span class="fu">$</span> head arg</a>
<a class="sourceLine" id="cb4-20" data-line-number="20">    putStrLn <span class="fu">$</span> <span class="st">&quot;総ファイル数: &quot;</span> <span class="fu">++</span> show cnt</a>
<a class="sourceLine" id="cb4-21" data-line-number="21">    putStrLn <span class="fu">$</span> <span class="st">&quot;総ファイルサイズ: &quot;</span> <span class="fu">++</span> show size</a>
<a class="sourceLine" id="cb4-22" data-line-number="22"></a>
<a class="sourceLine" id="cb4-23" data-line-number="23"><span class="ot">recListDir ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Int</span>, <span class="dt">Integer</span>)</a>
<a class="sourceLine" id="cb4-24" data-line-number="24">recListDir fp <span class="fu">=</span> loop (<span class="dv">0</span>, <span class="dv">0</span>) [fp]</a>
<a class="sourceLine" id="cb4-25" data-line-number="25">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-26" data-line-number="26">    loop summary [] <span class="fu">=</span> return summary</a>
<a class="sourceLine" id="cb4-27" data-line-number="27">    loop (accCnt, accSize) (fp<span class="fu">:</span>fps) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-28" data-line-number="28">      dirs <span class="ot">&lt;-</span> listDirectory fp</a>
<a class="sourceLine" id="cb4-29" data-line-number="29">      (files, childDirs) <span class="ot">&lt;-</span> partitionM doesFileExist <span class="fu">$</span> map (fp <span class="fu">&lt;/&gt;</span>) dirs</a>
<a class="sourceLine" id="cb4-30" data-line-number="30">      size <span class="ot">&lt;-</span> sum <span class="fu">&lt;$&gt;</span> mapM getFileSize files</a>
<a class="sourceLine" id="cb4-31" data-line-number="31">      <span class="kw">let</span> summary <span class="fu">=</span> (accCnt <span class="fu">+</span> length files, accSize <span class="fu">+</span> size)</a>
<a class="sourceLine" id="cb4-32" data-line-number="32">      loop summary <span class="fu">$</span> fps <span class="fu">++</span> childDirs</a></code></pre></div>
<p>実際に、プロファイリングを取得しつつ動かしてみます。</p>
<pre class="shell"><code>$ stack ghc Ex &amp;&amp; sudo ./Ex /home/bm12/Desktop/ +RTS -s
総ファイル数: 338866
総ファイルサイズ: 37870090712</code></pre>
<p>とりあえず、上手く動いているような気がします。</p>
<p>しかし、メモリ使用量は・・・</p>
<pre class="shell"><code>  13,440,124,048 bytes allocated in the heap
   8,760,418,592 bytes copied during GC
   1,225,650,008 bytes maximum residency (23 sample(s))
      19,423,400 bytes maximum slop
            2599 MB total memory in use (0 MB lost due to fragmentation)

                                     Tot time (elapsed)  Avg pause  Max pause
  Gen  0      9869 colls,     0 par    7.821s   9.831s     0.0010s    1.1223s
  Gen  1        23 colls,     0 par    0.011s   0.013s     0.0006s    0.0009s

  INIT    time    0.000s  (  0.000s elapsed)
  MUT     time    5.255s  (  6.347s elapsed)
  GC      time    7.832s  (  9.845s elapsed)
  EXIT    time    0.032s  (  0.123s elapsed)
  Total   time   13.118s  ( 16.315s elapsed)

  %GC     time      59.7%  (60.3% elapsed)

  Alloc rate    2,557,607,298 bytes per MUT second

  Productivity  40.3% of total user, 39.7% of total elapsed</code></pre>
<ul>
<li><strong>2599 MB total memory in use</strong></li>
<li><strong>%GC time 59.7% (60.3% elapsed)</strong></li>
</ul>
<p>ということで、非常にやばいですね。</p>
<h3 id="conduit-で書き直そう">Conduit で書き直そう！</h3>
<p>先程作ったプログラムは、どうやらスペースリークしているようです。指定したディレクトリ以下のファイルの数とファイルサイズの合計を取得するだけなのに、メモリを使いすぎですね。</p>
<p>解決方法は色々ありますが、今回はストリームライブラリの <code>Conduit</code> を使って解決していきましょう。</p>
<p><code>Conduit</code> には <a href="https://www.stackage.org/haddock/lts-11.3/conduit-1.3.0.2/Conduit.html#v:sourceDirectoryDeep">sourceDirectoryDeep</a> という、関数が用意されています。</p>
<p>だいたいこんな感じで書き直すことができます。先程の定義と比べると <strong>sourceDirectoryDeep</strong> 関数のおかげでスッキリした印象です。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="co">{-</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="co">stack script --resolver lts-11.3</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="co">  --package conduit</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5"><span class="co">  --package extra</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6"><span class="co">  --package directory</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7"><span class="co">-}</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8"></a>
<a class="sourceLine" id="cb7-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10"></a>
<a class="sourceLine" id="cb7-11" data-line-number="11"><span class="kw">import</span> <span class="dt">System.Environment</span> (getArgs)</a>
<a class="sourceLine" id="cb7-12" data-line-number="12"><span class="kw">import</span> <span class="dt">System.Directory</span> (doesFileExist, getFileSize)</a>
<a class="sourceLine" id="cb7-13" data-line-number="13"><span class="kw">import</span> <span class="dt">Control.Monad.Extra</span> (whenM)</a>
<a class="sourceLine" id="cb7-14" data-line-number="14"><span class="kw">import</span> <span class="dt">Control.Monad</span> (when)</a>
<a class="sourceLine" id="cb7-15" data-line-number="15"></a>
<a class="sourceLine" id="cb7-16" data-line-number="16"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-17" data-line-number="17">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-18" data-line-number="18">  arg <span class="ot">&lt;-</span> getArgs</a>
<a class="sourceLine" id="cb7-19" data-line-number="19">  when (length arg <span class="fu">==</span> <span class="dv">1</span>) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-20" data-line-number="20">    (cnt, size) <span class="ot">&lt;-</span></a>
<a class="sourceLine" id="cb7-21" data-line-number="21">      runConduitRes <span class="fu">$</span> sourceDirectoryDeep <span class="dt">True</span> (head arg)</a>
<a class="sourceLine" id="cb7-22" data-line-number="22">                   <span class="fu">.|</span> awaitForever getInfo</a>
<a class="sourceLine" id="cb7-23" data-line-number="23">                   <span class="fu">.|</span> getZipSink ((,) <span class="fu">&lt;$&gt;</span> <span class="dt">ZipSink</span> lengthC <span class="fu">&lt;*&gt;</span> <span class="dt">ZipSink</span> sumC)</a>
<a class="sourceLine" id="cb7-24" data-line-number="24">    putStrLn <span class="fu">$</span> <span class="st">&quot;総ファイル数: &quot;</span> <span class="fu">++</span> show cnt</a>
<a class="sourceLine" id="cb7-25" data-line-number="25">    putStrLn <span class="fu">$</span> <span class="st">&quot;総ファイルサイズ: &quot;</span> <span class="fu">++</span> show size</a>
<a class="sourceLine" id="cb7-26" data-line-number="26"></a>
<a class="sourceLine" id="cb7-27" data-line-number="27"><span class="ot">getInfo ::</span> <span class="dt">MonadResource</span> m <span class="ot">=&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">ConduitM</span> FilePath <span class="dt">Integer</span> m ()</a>
<a class="sourceLine" id="cb7-28" data-line-number="28">getInfo path <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-29" data-line-number="29">  whenM (liftIO <span class="fu">$</span> doesFileExist path) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-30" data-line-number="30">    size <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> getFileSize path</a>
<a class="sourceLine" id="cb7-31" data-line-number="31">    yield size</a></code></pre></div>
<p>では、同様にプロファイルを取得しつつ、実行してみましょう。</p>
<pre class="shell"><code>$ stack ghc Ex2 &amp;&amp; sudo ./Ex2 /home/bm12/Desktop/ +RTS -s
総ファイル数: 338866
総ファイルサイズ: 37870092264</code></pre>
<p>肝心のメモリ使用量はと言うと・・・</p>
<pre class="shell"><code>  10,742,224,392 bytes allocated in the heap
      86,720,088 bytes copied during GC
          87,576 bytes maximum residency (19 sample(s))
          33,320 bytes maximum slop
               3 MB total memory in use (0 MB lost due to fragmentation)

                                     Tot time (elapsed)  Avg pause  Max pause
  Gen  0     10347 colls,     0 par    0.146s   0.198s     0.0000s    0.0008s
  Gen  1        19 colls,     0 par    0.000s   0.001s     0.0000s    0.0001s

  INIT    time    0.000s  (  0.000s elapsed)
  MUT     time    5.252s  (  7.444s elapsed)
  GC      time    0.146s  (  0.198s elapsed)
  EXIT    time    0.000s  (  0.000s elapsed)
  Total   time    5.398s  (  7.642s elapsed)

  %GC     time       2.7%  (2.6% elapsed)

  Alloc rate    2,045,428,118 bytes per MUT second

  Productivity  97.3% of total user, 97.4% of total elapsed</code></pre>
<ul>
<li><strong>3 MB total memory in use</strong></li>
<li><strong>%GC time 2.7% (2.6% elapsed)</strong></li>
</ul>
<p>どうですか？ストリーム処理って凄いですよね。</p>
<h3 id="解説">解説</h3>
<p>この問題の重要なポイントは、実行すると <code>(&quot;12345&quot;, 6+7+8+9+10)</code> という結果のように、<code>[1..10]</code> のリストの前半と後半で異なる処理になっているという点です。</p>
<pre class="shell"><code>$ ./Quiz5.hs
(&quot;12345&quot;,40)</code></pre>
<p>ここで理解しておきたい知識は以下の3点です。</p>
<ul>
<li>データは<strong>パイプ</strong> (ストリーム) を流れて処理されます</li>
<li><code>yieldMany</code> 関数は受け取ったデータをパイプに流す<strong>準備</strong>をします (<code>yieldMany</code> は自分から積極的にデータを流すことはしません。準備だけしておき <code>await</code> 関数などで、実際に必要になった際にだけデータを流します)</li>
<li><code>.|</code> はパイプを<strong>合成</strong>します</li>
</ul>
<div class="sourceCode" id="cb11"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="kw">let</span> res <span class="fu">=</span> runConduitPure <span class="fu">$</span> yieldMany [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">.|</span> sink</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  print res</a></code></pre></div>
<p><code>sink</code> 関数は <code>takeC 5 .| mapC show .| foldC</code> というパイプと <code>sumC</code> というパイプからなる、大きなパイプです。</p>
<p><code>takeC 5 .| mapC show .| foldC</code> 関数は <code>takeC 5</code> の部分でデータを <strong>5つだけ</strong> 上流のパイプに要求します。そのため、残りの5つのデータは次の <code>sumC</code> に流れることになります。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">sink ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ConduitM</span> <span class="dt">Int</span> o m (<span class="dt">String</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">sink <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  x <span class="ot">&lt;-</span> takeC <span class="dv">5</span> <span class="fu">.|</span> mapC show <span class="fu">.|</span> foldC <span class="co">-- 1,2,3,4,5  のデータが処理される</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  y <span class="ot">&lt;-</span> sumC                          <span class="co">-- 6,7,8,9,10 のデータが処理される</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  return (x, y)</a></code></pre></div>
<p>そのため、最終的には <code>(&quot;12345&quot;,40)</code> となりました。</p>
<p><code>&quot;12345&quot;</code> はそれぞれの <strong>Int</strong> 型が <code>mapC show</code> によって <strong>String</strong> 型に変換され、<code>foldC</code> の <code>mappend</code> による畳込みによって文字列連結されます。</p>
<h2 id="まとめ">まとめ</h2>
<p>実用的なアプリケーションを作ろうと考えている方は <code>Conduit</code> などのストリームライブラリを理解していると、色々と面倒なことを考えなくて済むのでとても良いですよ。</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Haskell Quiz No.5 Conduit Part.1</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-31-quiz-5.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-31-quiz-5.html</id>
    <published>2018-03-31T00:00:00Z</published>
    <updated>2018-03-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="haskell-quiz-no.5">Haskell Quiz No.5</h2>
<p>難易度: λλ</p>
<p>以下の <code>Conduit</code> を使ったコードの実行結果を予想してみてください！</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.0</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">sink ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ConduitM</span> <span class="dt">Int</span> o m (<span class="dt">String</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">sink <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  x <span class="ot">&lt;-</span> takeC <span class="dv">5</span> <span class="fu">.|</span> mapC show <span class="fu">.|</span> foldC</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">  y <span class="ot">&lt;-</span> sumC</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  return (x, y)</a>
<a class="sourceLine" id="cb1-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  <span class="kw">let</span> res <span class="fu">=</span> runConduitPure <span class="fu">$</span> yieldMany [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">.|</span> sink</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">  print res</a></code></pre></div>
<p>答えは<a href="04-01-quiz-6.html">次回</a>。</p>
<!--more-->
<h2 id="はじめに">はじめに</h2>
<p><a href="./03-28-quiz-4.html">前回</a>の問題と答えは以下の通りです。</p>
<h3 id="問題">問題</h3>
<p>難易度: λ</p>
<p>今回は、与えられた値がリストのリストに含まれているかどうかを判定する問題です。</p>
<p>幅優先で探索する関数 <code>bfs</code> と深さ優先で探索する関数 <code>dfs</code> をそれぞれ定義してみましょう。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">bfs ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [[<span class="dt">Int</span>]] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">bfs <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ot">dfs ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [[<span class="dt">Int</span>]] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">dfs <span class="fu">=</span> undefined</a></code></pre></div>
<p>実行結果はだいたいこんな感じです。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1">$ <span class="ex">stack</span> repl -- Quiz4.hs</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="ex">*Quiz4</span><span class="op">&gt;</span> xs = [[10..],[4,5,6],[7,8,9]]</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="ex">*Quiz4</span><span class="op">&gt;</span> bfs 9 xs</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ex">True</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ex">*Quiz4</span><span class="op">&gt;</span> dfs 9 xs</a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="ex">.....</span></a></code></pre></div>
<h3 id="こたえ">こたえ</h3>
<p>素晴らしい回答が <strong>Haskeller</strong> から届きました。(一部修正)</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">dfs x <span class="fu">=</span> elem x <span class="fu">.</span> concat</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">bfs x <span class="fu">=</span> elem x <span class="fu">.</span> concat <span class="fu">.</span> transpose</a></code></pre></div>
<p>まさに <code>Haskell</code> ！！！って感じのコードですよね。</p>
<h2 id="haskell-quiz-no.4-の解説">Haskell Quiz No.4 の解説</h2>
<p>完全なコードはこちら</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Quiz4</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Data.List</span> (transpose)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="ot">dfs ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [[a]] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">dfs x <span class="fu">=</span> elem x <span class="fu">.</span> concat</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="ot">bfs ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [[a]] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">bfs x <span class="fu">=</span> elem x <span class="fu">.</span> concat <span class="fu">.</span> transpose</a></code></pre></div>
<ul>
<li><strong>dfs</strong> は <code>depth farst search</code> なので、<strong>深さ優先探索</strong>を行うように実装しています。</li>
<li><strong>bfs</strong> は <code>breadth first search</code> なので、<strong>幅優先探索</strong>を行うように実装しています。</li>
</ul>
<h3 id="data.list-モジュール">Data.List モジュール</h3>
<p>リスト操作系の関数は基本的に <a href="http://hackage.haskell.org/package/base-4.11.0.0/docs/Data-List.html">Data.List</a> を探せば見つかります。</p>
<p><code>Prelude</code> に含まれている関数と重複するものもありますが、それ以外にも有用な関数がいくつも定義されているため、 <code>Data.List</code> モジュールにどんな関数があるか把握しておくと良いと思います。</p>
<p>ここで定義されている関数の命名規則は別のパッケージでも慣習的に利用されていることが多いため、関数がどんな操作なのか<strong>理解</strong> (暗記ではない) しておくと、全く知らないパッケージでも何となく読める時があります。</p>
<p>例えば今回の <code>transpose</code> 関数は <code>Data.List</code> 以外にも色々なモジュールで同様に定義されています。</p>
<ul>
<li><a href="http://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString-Char8.html#v:transpose">ByteString</a></li>
<li><a href="http://hackage.haskell.org/package/text-1.2.3.0/docs/Data-Text-Lazy.html#v:transpose">Text</a></li>
</ul>
<p>つまり、データ構造はリストとは違うけども、操作としては同じと言うことです。</p>
<h3 id="transpose">transpose</h3>
<p><a href="http://hackage.haskell.org/package/base-4.11.0.0/docs/Data-List.html#v:transpose">transpose</a> は <code>base</code> パッケージの <code>Data.List</code> で定義されています。<code>Prelude</code> には含まれていないため、明示的に <code>import</code> する必要があります。</p>
<p><code>haddock</code> の説明通り、リストを転置させる関数です。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> transpose [[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">[[<span class="dv">1</span>,<span class="dv">4</span>],[<span class="dv">2</span>,<span class="dv">5</span>],[<span class="dv">3</span>,<span class="dv">6</span>]]</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="fu">&gt;&gt;&gt;</span> transpose [[<span class="dv">10</span>,<span class="dv">11</span>],[<span class="dv">20</span>],[],[<span class="dv">30</span>,<span class="dv">31</span>,<span class="dv">32</span>]]</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">[[<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">30</span>],[<span class="dv">11</span>,<span class="dv">31</span>],[<span class="dv">32</span>]]</a></code></pre></div>
<p>その際、空リストは取り除かれるようですね。</p>
<p><code>transpose</code> 関数の実装は <a href="http://hackage.haskell.org/package/base-4.11.0.0/docs/src/Data.OldList.html#transpose">Data.OldList</a> で以下のように定義されています。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">transpose ::</span> [[a]] <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">transpose []           <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">transpose ([]<span class="fu">:</span>xss)     <span class="fu">=</span> transpose xss</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">transpose ((x<span class="fu">:</span>xs)<span class="fu">:</span>xss) <span class="fu">=</span> (x <span class="fu">:</span> [h <span class="fu">|</span> (h<span class="fu">:</span>_) <span class="ot">&lt;-</span> xss]) <span class="fu">:</span> transpose (xs <span class="fu">:</span> [ t <span class="fu">|</span> (_<span class="fu">:</span>t) <span class="ot">&lt;-</span> xss])</a></code></pre></div>
<p>たしかに2つ目の等式で空白が除去されていることがわかりますね。</p>
<p>3つ目の等式は少し複雑ですが、面白いので見てみましょう。</p>
<p>それぞれのリストの <code>head</code> を取りたいので <code>map head xss</code> がすぐに思いつきそうですが <code>[h | (h:_) &lt;- xss]</code> となっています。うまいやりかたですね。</p>
<p>普通に <code>head</code> をかけてしまうと空リストで実行時エラーとなってしまいます。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="fu">*</span><span class="dt">Quiz4</span><span class="fu">&gt;</span> xss <span class="fu">=</span> [[<span class="dv">1</span>,<span class="dv">2</span>],[],[<span class="dv">3</span>,<span class="dv">4</span>]]</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="fu">*</span><span class="dt">Quiz4</span><span class="fu">&gt;</span> map head xss</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">[<span class="dv">1</span>,<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> Prelude.head<span class="fu">:</span> empty list</a></code></pre></div>
<p>しかし <code>[h | (h:_) &lt;- xss]</code> ではどうでしょうか？</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="fu">*</span><span class="dt">Quiz4</span><span class="fu">&gt;</span> xss <span class="fu">=</span> [[<span class="dv">1</span>,<span class="dv">2</span>],[],[<span class="dv">3</span>,<span class="dv">4</span>]]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="fu">*</span><span class="dt">Quiz4</span><span class="fu">&gt;</span> [h <span class="fu">|</span> (h<span class="fu">:</span>_) <span class="ot">&lt;-</span> xss]</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">[<span class="dv">1</span>,<span class="dv">3</span>]</a></code></pre></div>
<p>はい。空リストを含んでいたとしてもエラーにならずに、良い感じに先頭の要素から成るリストが生成できました。</p>
<p>では、なぜこのような動作になるのでしょうか？</p>
<p>それを理解するためには <strong>Haskell 2010 Language Report</strong> の <a href="https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11">3.11 List Comprehensions</a> を参照する必要があります。</p>
<p>ここにリスト内包表記がどのように変換されるか、変換規則が載っています。(ここでは一部のみ掲載)</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="co">-- ルール1</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">[ e <span class="fu">|</span> <span class="dt">True</span> ] <span class="fu">=</span> [e]</a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="co">-- ルール2</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">[ e <span class="fu">|</span> q ] <span class="fu">=</span> [ e <span class="fu">|</span> q, <span class="dt">True</span> ]</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="co">-- ルール3</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">[ e <span class="fu">|</span> p <span class="ot">&lt;-</span> l, <span class="dt">Q</span> ] <span class="fu">=</span> <span class="kw">let</span> ok p <span class="fu">=</span> [ e <span class="fu">|</span> <span class="dt">Q</span> ]</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">                        ok _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">                    <span class="kw">in</span> concatMap ok l</a></code></pre></div>
<p>上記の規則により、先程の <code>[h | (h:_) &lt;- xss]</code> は以下のように変換できます。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">[ h <span class="fu">|</span> (h<span class="fu">:</span>_) <span class="ot">&lt;-</span> xss ]</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="fu">=</span> { ルール2 より }</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">[ h <span class="fu">|</span> (h<span class="fu">:</span>_) <span class="ot">&lt;-</span> xss, <span class="dt">True</span> ]</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  <span class="fu">=</span> { ルール3 より }</a>
<a class="sourceLine" id="cb11-5" data-line-number="5"><span class="kw">let</span> ok (h<span class="fu">:</span>_) <span class="fu">=</span> [ h <span class="fu">|</span> <span class="dt">True</span> ]</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">    ok _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb11-7" data-line-number="7"><span class="kw">in</span> concatMap ok xss</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">  <span class="fu">=</span> { ルール1 より }</a>
<a class="sourceLine" id="cb11-9" data-line-number="9"><span class="kw">let</span> ok (h<span class="fu">:</span>_) <span class="fu">=</span> [h]</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">    ok _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb11-11" data-line-number="11"><span class="kw">in</span> concatMap ok xss</a></code></pre></div>
<p>最終的には <code>f = [h | (h:_) &lt;- xss]</code> とすると</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">f <span class="fu">=</span> concatMap ok xss</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    ok (h<span class="fu">:</span>_) <span class="fu">=</span> [h]</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">    ok _     <span class="fu">=</span> []</a></code></pre></div>
<p>になります。</p>
<p>パターンマッチに失敗した場合は <code>ok _ = []</code> ということで自動的に空リストになるという部分が実行時エラーにならない秘密のようですね。</p>
<p>最終的に <code>concatMap</code> によって、空リストが自然に除去されていることがわかります。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="fu">*</span><span class="dt">Quiz4</span><span class="fu">&gt;</span> concatMap ok [[<span class="dv">1</span>,<span class="dv">2</span>], [], [<span class="dv">3</span>,<span class="dv">4</span>]]</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</a></code></pre></div>
<p>ということで、もとの式に戻ると <code>transpose</code> 関数の主張はこういうことです。</p>
<figure>
<img src="/images/2018/03-31/transpose.png" alt="transpose 関数の処理" /><figcaption>transpose 関数の処理</figcaption>
</figure>
<div class="sourceCode" id="cb14"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">transpose []           <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">transpose ([]<span class="fu">:</span>xss)     <span class="fu">=</span> transpose xss</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">transpose ((x<span class="fu">:</span>xs)<span class="fu">:</span>xss) <span class="fu">=</span> (x <span class="fu">:</span> [h <span class="fu">|</span> (h<span class="fu">:</span>_) <span class="ot">&lt;-</span> xss]) <span class="fu">:</span> transpose (xs <span class="fu">:</span> [ t <span class="fu">|</span> (_<span class="fu">:</span>t) <span class="ot">&lt;-</span> xss])</a></code></pre></div>
<h3 id="幅優先探索と深さ優先探索">幅優先探索と深さ優先探索</h3>
<p>アルゴリズムの本などを読むと、必ずこの <strong>幅優先探索</strong> と <strong>深さ優先探索</strong> というキーワードを目にすると思います。(また、同時に説明に利用されるのは木構造のデータでしょう)</p>
<p>幅優先探索と深さ優先探索の概念を理解するために木構造に触れる必要は無く、リストだけで十分です。</p>
<p>本質は以下のように凄く簡単なことです。</p>
<figure>
<img src="/images/2018/03-31/search.png" alt="リストを使った幅優先探索と深さ優先探索" /><figcaption>リストを使った幅優先探索と深さ優先探索</figcaption>
</figure>
<p>そのため <code>[10..]</code> のような無限リストが与えられた場合に <strong>深さ優先探索</strong> では結果を返すことができないのです。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb15-1" data-line-number="1">$ <span class="ex">stack</span> repl -- Quiz4.hs</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="ex">*Quiz4</span><span class="op">&gt;</span> xs = [[10..],[4,5,6],[7,8,9]]</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="ex">*Quiz4</span><span class="op">&gt;</span> bfs 9 xs</a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="ex">True</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5"><span class="ex">*Quiz4</span><span class="op">&gt;</span> dfs 9 xs</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"><span class="ex">.....</span></a></code></pre></div>
<h3 id="コードの解説">コードの解説</h3>
<p><code>dfs</code> は <code>concat</code> によってリストのリストを直列につないだ結果に対して <code>elem x</code> で要素を検索すれば良いということになります。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">dfs ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [[a]] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">dfs x <span class="fu">=</span> elem x <span class="fu">.</span> concat</a></code></pre></div>
<p>それに対して <code>bfs</code> は各リストの先頭要素だけを先に処理していく必要があります。自分でその辺りの処理を書いても良いのですが <code>transpose</code> で一発です。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">bfs ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [[a]] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">bfs x <span class="fu">=</span> elem x <span class="fu">.</span> concat <span class="fu">.</span> transpose</a></code></pre></div>
<p><code>bfs</code> はこのように書くこともできます。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">bfs ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [[a]] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">bfs x <span class="fu">=</span> dfs x <span class="fu">.</span> transpose</a></code></pre></div>
<p>つまり、リストのリストのようなデータ構造に対して幅優先探索を行うということは、リストを転置した結果に対して深さ優先探索を行うことと等しいということです。</p>
<figure>
<img src="/images/2018/03-31/bfs.png" alt="bfs と dfs の関係" /><figcaption>bfs と dfs の関係</figcaption>
</figure>
<h2 id="まとめ">まとめ</h2>
<p>Haskell 2010 Language Report ってどういう時に利用するんだろう？って思っている人もいるとは思いますが、こういう場合に参照すると便利です。</p>
<p>今回は幅優先探索と深さ優先探索を <strong>リストのリスト</strong> で説明しましたが、一般的に説明される木構造では、これが少し複雑になっただけです。</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>prettyprinter パッケージ</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-30-prettyprinter.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-30-prettyprinter.html</id>
    <published>2018-03-30T00:00:00Z</published>
    <updated>2018-03-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>今回は <a href="https://www.stackage.org/package/prettyprinter">prettyprinter</a> を使ってみました。</p>
<p>使おうと思ったモチベーションとしては、以下のようなデータ型をデバッグ表示させる際に <code>prettyprinter</code> 系パッケージを使って良い感じに表示してみようかな？という感じです。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span> <span class="dt">Text</span> <span class="dt">String</span></a></code></pre></div>
<p>表示をカスタマイズするために <code>Show</code> クラスのインスタンスを書き換えることは、経験上嫌なことしか起きないです・・。</p>
<p>自分でそれっぽい型クラスを作っても良いのですが、普通は素直に <code>prettyprinter</code> 系のパッケージを使った方が良いと思います！</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1">$ <span class="ex">stack</span> repl --package text</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ex">Prelude</span><span class="op">&gt;</span> import Data.Text</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ex">Prelude</span> Data.Text<span class="op">&gt;</span> data Person = Person Text String deriving Show</a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ex">Prelude</span> Data.Text<span class="op">&gt;</span> :set -XOverloadedStrings</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ex">Prelude</span> Data.Text<span class="op">&gt;</span> Person <span class="st">&quot;はすける&quot;</span> <span class="st">&quot;らむだ&quot;</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="ex">Person</span> <span class="st">&quot;\12399\12377\12369\12427&quot;</span> <span class="st">&quot;\12425\12416\12384&quot;</span></a></code></pre></div>
<!--more-->
<h2 id="パッケージの選定理由">パッケージの選定理由</h2>
<p>ぐぐって一番始めに出てきたのは <a href="https://github.com/haskell/pretty">pretty</a> というパッケージだったんですが <code>String</code> にしか対応してない感じだったので見送りました。</p>
<p><code>prettyprinter</code> は <strong>A modern, easy to use, well-documented, extensible prettyprinter.</strong> というコメント通り、とても使いやすいです。</p>
<h2 id="使ってみました">使ってみました</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="co">-- stack --resolver lts-11.2 script</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Data.Text.Prettyprint.Doc</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Data.Text.Prettyprint.Doc.Render.Text</span> (putDoc)</a>
<a class="sourceLine" id="cb3-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb3-10" data-line-number="10"></a>
<a class="sourceLine" id="cb3-11" data-line-number="11"><span class="kw">data</span> <span class="dt">A</span> <span class="fu">=</span> <span class="dt">A</span> <span class="dt">Text</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12">  <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13"></a>
<a class="sourceLine" id="cb3-14" data-line-number="14"><span class="kw">data</span> <span class="dt">B</span> <span class="fu">=</span> <span class="dt">B</span> <span class="dt">Text</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb3-15" data-line-number="15"></a>
<a class="sourceLine" id="cb3-16" data-line-number="16"><span class="kw">instance</span> <span class="dt">Pretty</span> <span class="dt">B</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-17" data-line-number="17">  pretty (<span class="dt">B</span> l r) <span class="fu">=</span> <span class="st">&quot;B&quot;</span> <span class="fu">&lt;+&gt;</span> pretty l <span class="fu">&lt;+&gt;</span> pretty r</a>
<a class="sourceLine" id="cb3-18" data-line-number="18"></a>
<a class="sourceLine" id="cb3-19" data-line-number="19"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-20" data-line-number="20">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-21" data-line-number="21">  print <span class="fu">$</span> <span class="dt">A</span> <span class="st">&quot;あ&quot;</span> <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb3-22" data-line-number="22">  putDoc <span class="fu">$</span> pretty <span class="fu">$</span> <span class="dt">B</span> <span class="st">&quot;あ&quot;</span> <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb3-23" data-line-number="23">  putStrLn <span class="st">&quot;&quot;</span></a></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1">$ <span class="fu">chmod</span> u+x Pretty.hs</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">$ <span class="ex">./Pretty.hs</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="ex">A</span> <span class="st">&quot;\12354&quot;</span> <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="ex">B</span> あ a</a></code></pre></div>
<p><a href="https://www.stackage.org/haddock/lts-11.2/prettyprinter-1.2.0.1/Data-Text-Prettyprint-Doc.html#t:Pretty">Pretty</a> 型クラスのインスタンスを普通に定義するだけです。</p>
<p>適当に改行したい場合は <a href="https://www.stackage.org/haddock/lts-11.2/prettyprinter-1.2.0.1/Data-Text-Prettyprint-Doc.html#v:line">line</a> を追加するだけです。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Pretty</span> <span class="dt">B</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  pretty (<span class="dt">B</span> l r) <span class="fu">=</span> <span class="st">&quot;B&quot;</span> <span class="fu">&lt;&gt;</span> line</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">                <span class="fu">&lt;+&gt;</span> pretty l <span class="fu">&lt;&gt;</span> line</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">                <span class="fu">&lt;+&gt;</span> pretty r</a></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" data-line-number="1">$ <span class="ex">./test.hs</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ex">A</span> <span class="st">&quot;\12354&quot;</span> <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="ex">B</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"> あ</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"> <span class="ex">a</span></a></code></pre></div>
<p>区切りの空白が不要な場合は <a href="https://www.stackage.org/haddock/lts-11.2/prettyprinter-1.2.0.1/Data-Text-Prettyprint-Doc.html#v:-60--43--62-">&lt;+&gt;</a> を <a href="https://www.stackage.org/haddock/lts-11.2/prettyprinter-1.2.0.1/Data-Text-Prettyprint-Doc.html#v:-60--62-">&lt;&gt;</a> にするだけです。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Pretty</span> <span class="dt">B</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  pretty (<span class="dt">B</span> l r) <span class="fu">=</span> <span class="st">&quot;B&quot;</span> <span class="fu">&lt;&gt;</span> line</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">                <span class="fu">&lt;&gt;</span> pretty l <span class="fu">&lt;&gt;</span> line</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">                <span class="fu">&lt;&gt;</span> pretty r</a></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" data-line-number="1">$ <span class="ex">./test.hs</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ex">A</span> <span class="st">&quot;\12354&quot;</span> <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="ex">B</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">あ</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="ex">a</span></a></code></pre></div>
<p>適当にネストさせたい場合も簡単です。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Pretty</span> <span class="dt">B</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  pretty (<span class="dt">B</span> l r) <span class="fu">=</span> nest <span class="dv">4</span> (<span class="st">&quot;B&quot;</span> <span class="fu">&lt;&gt;</span> line</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">                <span class="fu">&lt;&gt;</span> pretty l <span class="fu">&lt;&gt;</span> line</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">                <span class="fu">&lt;&gt;</span> pretty r)</a></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb10-1" data-line-number="1">$ <span class="ex">./test.hs</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ex">A</span> <span class="st">&quot;\12354&quot;</span> <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="ex">B</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">    あ</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">    <span class="ex">a</span></a></code></pre></div>
<h2 id="まとめ">まとめ</h2>
<p>めちゃめちゃ簡単だったので、使ってみると楽しいですよー。ドキュメントが充実しているのが良いですね。</p>
<p>今回は短めでした。</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Haskell Quiz No.4 幅優先探索と深さ優先探索</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-28-quiz-4.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-28-quiz-4.html</id>
    <published>2018-03-28T00:00:00Z</published>
    <updated>2018-03-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="haskell-quiz-no.4">Haskell Quiz No.4</h2>
<p>難易度: λ</p>
<p>今回は、与えられた値がリストのリストに含まれているかどうかを判定する問題です。</p>
<p>幅優先で探索する関数 <code>bfs</code> と深さ優先で探索する関数 <code>dfs</code> をそれぞれ定義してみましょう。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">bfs ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [[<span class="dt">Int</span>]] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">bfs <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">dfs ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [[<span class="dt">Int</span>]] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">dfs <span class="fu">=</span> undefined</a></code></pre></div>
<p>実行結果はだいたいこんな感じです。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1">$ <span class="ex">stack</span> repl -- Quiz4.hs</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ex">*Quiz4</span><span class="op">&gt;</span> xs = [[10..],[4,5,6],[7,8,9]]</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ex">*Quiz4</span><span class="op">&gt;</span> bfs 9 xs</a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ex">True</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ex">*Quiz4</span><span class="op">&gt;</span> dfs 9 xs</a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="ex">.....</span></a></code></pre></div>
<p>答えは<a href="03-31-quiz-5.html">次回</a>。</p>
<!--more-->
<h2 id="はじめに">はじめに</h2>
<p><a href="./03-27-quiz-3.html">前回</a>の問題と答えは以下の通りです。</p>
<h3 id="問題">問題</h3>
<p>難易度: λ</p>
<p><code>propIsDigit</code> テストをパスするように <code>Digit</code> 型の <code>Arbitrary</code> インスタンスを定義してみましょう。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Quiz3</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Test.QuickCheck</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Data.Char</span> (isDigit)</a>
<a class="sourceLine" id="cb3-5" data-line-number="5"></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="kw">newtype</span> <span class="dt">Digit</span> <span class="fu">=</span> <span class="dt">Digit</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"></a>
<a class="sourceLine" id="cb3-9" data-line-number="9"><span class="ot">propIsDigit ::</span> <span class="dt">Digit</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10">propIsDigit (<span class="dt">Digit</span> c) <span class="fu">=</span> isDigit c</a>
<a class="sourceLine" id="cb3-11" data-line-number="11"></a>
<a class="sourceLine" id="cb3-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Digit</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13">  arbitrary <span class="fu">=</span> undefined</a></code></pre></div>
<p>テストは以下のように実行します。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1">$ <span class="ex">stack</span> repl --package QuickCheck -- Quiz3.hs</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ex">*Quiz3</span><span class="op">&gt;</span> quickCheck propIsDigit</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="ex">+++</span> OK, passed 100 tests.</a></code></pre></div>
<h3 id="こたえ">こたえ</h3>
<p>実装方法はいくつかあるのですが、例えば <a href="https://www.stackage.org/haddock/lts-11.2/QuickCheck-2.10.1/Test-QuickCheck.html#v:elements">elements</a> を使う方法だとこんな感じです。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Digit</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  arbitrary <span class="fu">=</span> <span class="dt">Digit</span> <span class="fu">&lt;$&gt;</span> elements <span class="st">&quot;1234567890&quot;</span></a></code></pre></div>
<p>ちょっと反則っぽいですが <a href="https://www.stackage.org/haddock/lts-11.2/QuickCheck-2.10.1/Test-QuickCheck.html#v:suchThat">suchThat</a> を使う方法もありそうですね。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Digit</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  arbitrary <span class="fu">=</span> <span class="dt">Digit</span> <span class="fu">&lt;$&gt;</span> arbitrary <span class="ot">`suchThat`</span> isDigit</a></code></pre></div>
<p>こんな方法もあるよーと言う方は教えてください！</p>
<h2 id="haskell-quiz-no.3-の解説">Haskell Quiz No.3 の解説</h2>
<p><code>QuickCheck</code> を使っている人にとっては簡単な問題だったと思います。</p>
<p>逆に全く使ったこと無い人にとっては、結構難しかったのではないでしょうか。</p>
<h3 id="arbitrary-型クラス">Arbitrary 型クラス</h3>
<p><a href="https://www.stackage.org/haddock/lts-11.2/QuickCheck-2.10.1/Test-QuickCheck.html#t:Arbitrary">Arbitrary</a> 型クラスは <a href="https://www.stackage.org/lts-11.2/package/QuickCheck-2.10.1">QuickCheck</a> パッケージの <a href="https://www.stackage.org/haddock/lts-11.2/QuickCheck-2.10.1/Test-QuickCheck-Arbitrary.html#t:Arbitrary">Test.QuickCheck.Arbitrary</a> で定義されています。</p>
<p><code>Minimal complete definition</code> は <code>arbitrary</code> メソッド (関数) です。</p>
<p><code>Minimal complete definition</code> とは、型クラスのインスタンスを全て実装しなくても <code>Minimal complete definition</code> だけ実装すれば全てのメソッドが (デフォルト実装で) 利用できるというものです。効率が悪い場合もあるので、その場合は自分で定義を上書きします。</p>
<p>つまり、今回の場合だと <code>arbitrary</code> メソッドさえ定義してしまえば <a href="https://www.stackage.org/haddock/lts-11.2/QuickCheck-2.10.1/Test-QuickCheck-Arbitrary.html#v:shrink">shrink</a> メソッドも同様に利用可能になるということです。</p>
<p>実際の定義は以下の通りです。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Arbitrary</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">  arbitrary ::</span> <span class="dt">Gen</span> a</a>
<a class="sourceLine" id="cb7-3" data-line-number="3"></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="ot">  shrink ::</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  shrink _ <span class="fu">=</span> []</a></code></pre></div>
<h3 id="arbitrary-メソッド">arbitrary メソッド</h3>
<p><code>arbitrary</code> の型は <code>Arbitrary a =&gt; Gen a</code> なので、最初はどうやって定義して良いのか困惑してしまうかもしれません。</p>
<p><code>Gen a</code> はランダムな値を生成するジェネレータを意味する型です。</p>
<p>定義の方法は本当に色々ありますが、まずは基本のユーティリティ関数を抑えておきましょう。</p>
<p><a href="https://www.stackage.org/haddock/lts-11.2/QuickCheck-2.10.1/Test-QuickCheck.html#g:6">Generator combinators</a> に列挙されている関数の一部をご紹介します。</p>
<h4 id="elements">elements</h4>
<p>与えられたリストの値を元に <code>Gen a</code> を作ります。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> <span class="fu">:</span>t elements</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ot">elements ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Gen</span> a</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> sample&#39; <span class="fu">$</span> elements <span class="st">&quot;1234567890&quot;</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="st">&quot;55316502254&quot;</span></a></code></pre></div>
<p>今回の問題もこれを使って <code>isDigit</code> に通る値のみをリストに含めてあげたら良いのです。</p>
<h4 id="choose">choose</h4>
<p>タプルで指定した範囲で値を生成します。その際 <code>Random</code> 型クラスのクラス制約が発生することに注意してください。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> <span class="fu">:</span>t choose</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="ot">choose ::</span> random<span class="fu">-</span><span class="fl">1.1</span><span class="fu">:</span><span class="dt">System.Random.Random</span> a <span class="ot">=&gt;</span> (a, a) <span class="ot">-&gt;</span> <span class="dt">Gen</span> a</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> sample&#39; <span class="fu">$</span> choose (<span class="dv">1</span>,<span class="dv">10</span>)</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">[<span class="dv">3</span>,<span class="dv">7</span>,<span class="dv">5</span>,<span class="dv">9</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="dv">6</span>,<span class="dv">1</span>]</a></code></pre></div>
<h4 id="oneof">oneof</h4>
<p><code>oneof</code> は <code>[Gen a]</code> からランダムに1つ <code>Gen a</code> を選びます。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> <span class="fu">:</span>t oneof</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ot">oneof ::</span> [<span class="dt">Gen</span> a] <span class="ot">-&gt;</span> <span class="dt">Gen</span> a</a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> sample&#39; <span class="fu">$</span> oneof [choose (<span class="dv">1</span>,<span class="dv">3</span>)]</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> sample&#39; <span class="fu">$</span> oneof [choose (<span class="dv">1</span>,<span class="dv">3</span>), choose (<span class="dv">10</span>,<span class="dv">30</span>)]</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">[<span class="dv">18</span>,<span class="dv">26</span>,<span class="dv">2</span>,<span class="dv">17</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">25</span>,<span class="dv">13</span>,<span class="dv">25</span>,<span class="dv">16</span>,<span class="dv">2</span>]</a></code></pre></div>
<h4 id="frequency">frequency</h4>
<p><code>oneof</code> と似ていますが、完全にランダムではなく頻出度合いを制御することができます。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> <span class="fu">:</span>t frequency</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="ot">frequency ::</span> [(<span class="dt">Int</span>, <span class="dt">Gen</span> a)] <span class="ot">-&gt;</span> <span class="dt">Gen</span> a</a>
<a class="sourceLine" id="cb11-3" data-line-number="3"></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> sample&#39; <span class="fu">$</span> frequency  [(<span class="dv">1</span>,choose (<span class="dv">1</span>,<span class="dv">1</span>)), (<span class="dv">100</span>,choose (<span class="dv">100</span>,<span class="dv">100</span>))]</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">[<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">100</span>]</a>
<a class="sourceLine" id="cb11-6" data-line-number="6"></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> sample&#39; <span class="fu">$</span> frequency  [(<span class="dv">30</span>,choose (<span class="dv">1</span>,<span class="dv">1</span>)), (<span class="dv">70</span>,choose (<span class="dv">100</span>,<span class="dv">100</span>))]</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">[<span class="dv">100</span>,<span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">1</span>,<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">100</span>,<span class="dv">1</span>]</a></code></pre></div>
<h4 id="suchthat">suchThat</h4>
<p>第二引数の述語を満たす値だけで <code>Gen a</code> を作ります。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> <span class="fu">:</span>t suchThat</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="ot">suchThat ::</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Gen</span> a</a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> sample&#39; <span class="fu">$</span> suchThat arbitrary even</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">[<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">2</span>,<span class="dv">6</span>,<span class="fu">-</span><span class="dv">8</span>,<span class="dv">10</span>,<span class="fu">-</span><span class="dv">10</span>,<span class="fu">-</span><span class="dv">6</span>,<span class="fu">-</span><span class="dv">6</span>,<span class="fu">-</span><span class="dv">6</span>,<span class="fu">-</span><span class="dv">22</span>]</a>
<a class="sourceLine" id="cb12-6" data-line-number="6"></a>
<a class="sourceLine" id="cb12-7" data-line-number="7"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> sample&#39; <span class="fu">$</span> suchThat arbitrary odd</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">[<span class="fu">-</span><span class="dv">1</span>,<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="fu">-</span><span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">11</span>,<span class="fu">-</span><span class="dv">9</span>,<span class="dv">7</span>,<span class="fu">-</span><span class="dv">11</span>,<span class="fu">-</span><span class="dv">13</span>]</a></code></pre></div>
<h4 id="vectorof">vectorOf</h4>
<p>与えられた長さの <code>[Gen a]</code> を作ります。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> <span class="fu">:</span>t vectorOf</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="ot">vectorOf ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> <span class="dt">Gen</span> [a]</a>
<a class="sourceLine" id="cb13-3" data-line-number="3"></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="fu">*</span><span class="dt">Quiz3</span><span class="fu">&gt;</span> sample&#39; <span class="fu">$</span> vectorOf <span class="dv">2</span> (<span class="ot">arbitrary ::</span> <span class="dt">Gen</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">[[<span class="dv">0</span>,<span class="dv">0</span>],[<span class="dv">0</span>,<span class="fu">-</span><span class="dv">2</span>],[<span class="dv">0</span>,<span class="dv">4</span>],[<span class="fu">-</span><span class="dv">3</span>,<span class="fu">-</span><span class="dv">2</span>],[<span class="dv">2</span>,<span class="fu">-</span><span class="dv">5</span>],[<span class="dv">6</span>,<span class="fu">-</span><span class="dv">8</span>],[<span class="dv">1</span>,<span class="fu">-</span><span class="dv">10</span>],[<span class="fu">-</span><span class="dv">12</span>,<span class="dv">9</span>],[<span class="dv">3</span>,<span class="fu">-</span><span class="dv">5</span>],[<span class="dv">13</span>,<span class="dv">4</span>],[<span class="fu">-</span><span class="dv">8</span>,<span class="dv">12</span>]]</a></code></pre></div>
<h3 id="shrink-メソッド">shrink メソッド</h3>
<p>参考: <a href="https://stackoverflow.com/questions/16968549/what-is-a-shrink-with-regard-to-haskells-quickcheck/16970029">What is a shrink, with regard to Haskell’s QuickCheck?</a></p>
<p><code>shrink</code> はテストに失敗した際にできるだけ小さな反例を返すために利用されるようです。</p>
<p><a href="https://www.stackage.org/haddock/lts-11.2/QuickCheck-2.10.1/Test-QuickCheck.html#v:verboseCheck">verboseCheck</a> 関数を使えば、実際に生成されたテストケースと結果を全てみることができます。</p>
<p>例として <code>5</code> を含まないリストという <code>prop</code> でチェックしてみましょう。(結果は少し見やすいように整形してあります)</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="op">&gt;&gt;&gt;</span> <span class="ex">prop</span> l = all (/= 5) <span class="ex">l</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="op">&gt;&gt;&gt;</span> <span class="ex">verboseCheck</span> prop</a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="ex">Passed</span>:[]</a>
<a class="sourceLine" id="cb14-4" data-line-number="4"><span class="ex">Passed</span>:[]</a>
<a class="sourceLine" id="cb14-5" data-line-number="5"><span class="ex">Passed</span>:[1,2]</a>
<a class="sourceLine" id="cb14-6" data-line-number="6"><span class="ex">Passed</span>:[2,2]</a>
<a class="sourceLine" id="cb14-7" data-line-number="7"><span class="ex">Passed</span>:[-1,1,2]</a>
<a class="sourceLine" id="cb14-8" data-line-number="8"><span class="ex">Passed</span>:[3,-1]</a>
<a class="sourceLine" id="cb14-9" data-line-number="9"><span class="ex">Passed</span>:[-4,-4,-5,3,-4]</a>
<a class="sourceLine" id="cb14-10" data-line-number="10"><span class="ex">Passed</span>:[-6,1,4,-6,-5]</a>
<a class="sourceLine" id="cb14-11" data-line-number="11"><span class="ex">Passed</span>:[4]</a>
<a class="sourceLine" id="cb14-12" data-line-number="12"><span class="ex">Passed</span>:[2,-2]</a>
<a class="sourceLine" id="cb14-13" data-line-number="13"><span class="ex">Passed</span>:[2,8,7]</a>
<a class="sourceLine" id="cb14-14" data-line-number="14"><span class="ex">Passed</span>:[-7,-8,7,6,9,-10,1]</a>
<a class="sourceLine" id="cb14-15" data-line-number="15"><span class="ex">Passed</span>:[-10,11,2]</a>
<a class="sourceLine" id="cb14-16" data-line-number="16"><span class="ex">Passed</span>:[12,0,3,-12,7,-13,-6,9,-8,7,-10,9]</a>
<a class="sourceLine" id="cb14-17" data-line-number="17"><span class="ex">Passed</span>:[4,4,-11,3,-7]</a>
<a class="sourceLine" id="cb14-18" data-line-number="18"><span class="ex">Passed</span>:[2,1,-9]</a>
<a class="sourceLine" id="cb14-19" data-line-number="19"><span class="ex">Passed</span>:[16,3,-8,14,-7,-7,9,-3,-15,3,-10,-14,9,-8,-3]</a>
<a class="sourceLine" id="cb14-20" data-line-number="20"><span class="ex">Passed</span>:[-2,0,-6,0,4,8,17,13]</a>
<a class="sourceLine" id="cb14-21" data-line-number="21"><span class="ex">Passed</span>:[1,15,17]</a>
<a class="sourceLine" id="cb14-22" data-line-number="22"><span class="ex">Passed</span>:[9,-17,-15,-16,-18,16,-19,15]</a>
<a class="sourceLine" id="cb14-23" data-line-number="23"><span class="ex">Passed</span>:[0,10,6,8,0,4,-9,-12,20,0,3,1,-2,14,13,-11]</a>
<a class="sourceLine" id="cb14-24" data-line-number="24"><span class="ex">Passed</span>:[16,-5,-21,2,2,-6,6]</a>
<a class="sourceLine" id="cb14-25" data-line-number="25"><span class="ex">Passed</span>:[-22,14,10,-18,-22,-10,8,8,-14,12,-22]</a>
<a class="sourceLine" id="cb14-26" data-line-number="26"><span class="ex">Passed</span>:[-18,18,0,-1,-16,-4,13,0,11,-20,10,11,0,-9]</a>
<a class="sourceLine" id="cb14-27" data-line-number="27"><span class="ex">Passed</span>:[-9,22,-2,-18,-9,-4,21,-7,0,9,-11]</a>
<a class="sourceLine" id="cb14-28" data-line-number="28"><span class="ex">Passed</span>:[9,21,11,-17,8,-10,0,6,16,17,6,-16,10,24,-7,9,-1,11,-14,-22,-1,-5,2,11,12]</a>
<a class="sourceLine" id="cb14-29" data-line-number="29"><span class="ex">Passed</span>:[-9,-21,25,-11,9,-11,-14,16,-9,-17,-8,9,4,-10,-6,-6,-17,-21,-26,-12]</a>
<a class="sourceLine" id="cb14-30" data-line-number="30"><span class="ex">Passed</span>:[-8,-11,-21,3,4,13,27,-24,-13,-12,-21,-13,-25,10]</a>
<a class="sourceLine" id="cb14-31" data-line-number="31"></a>
<a class="sourceLine" id="cb14-32" data-line-number="32"><span class="ex">Failed</span>:[25,10,-17,27,8,17,5,14,-1,22,-13,13,-9,-23,26,16,0,10]</a></code></pre></div>
<p>生成されるリストがどんどん大きくなり、やっとリストに <code>5</code> を含む反例 <code>[25,10,-17,27,8,17,5,14,-1,22,-13,13,-9,-23,26,16,0,10]</code> を見つけました。この反例をそのまま返しても良いのですが、もしかしたらもっと小さな反例が見つかるかもしれません。</p>
<p><code>verboseCheck</code> は実際にさきほどの反例を、今度は逆に減らしてテストしていきます。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="ex">***</span> Failed!</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="ex">Passed</span>:[]</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="ex">Passed</span>:[22,-13,13,-9,-23,26,16,0,10]</a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="ex">Failed</span>:[25,10,-17,27,8,17,5,14,-1]   -- より小さい反例が見つかった</a>
<a class="sourceLine" id="cb15-5" data-line-number="5"><span class="ex">Passed</span>:[]</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"><span class="ex">Failed</span>:[8,17,5,14,-1]                -- より小さい反例が見つかった</a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="ex">Passed</span>:[]</a>
<a class="sourceLine" id="cb15-8" data-line-number="8"><span class="ex">Failed</span>:[5,14,-1]                     -- より小さい反例が見つかった</a>
<a class="sourceLine" id="cb15-9" data-line-number="9"><span class="ex">Passed</span>:[]</a>
<a class="sourceLine" id="cb15-10" data-line-number="10"><span class="ex">Passed</span>:[14,-1]</a>
<a class="sourceLine" id="cb15-11" data-line-number="11"><span class="ex">Failed</span>:[5,-1]                        -- より小さい反例が見つかった</a>
<a class="sourceLine" id="cb15-12" data-line-number="12"><span class="ex">Passed</span>:[]</a>
<a class="sourceLine" id="cb15-13" data-line-number="13"><span class="ex">Passed</span>:[-1]</a>
<a class="sourceLine" id="cb15-14" data-line-number="14"><span class="ex">Failed</span>:[5]                           -- 最小の反例が見つかった</a>
<a class="sourceLine" id="cb15-15" data-line-number="15"><span class="ex">Passed</span>:[]</a>
<a class="sourceLine" id="cb15-16" data-line-number="16"><span class="ex">Passed</span>:[0]</a>
<a class="sourceLine" id="cb15-17" data-line-number="17"><span class="ex">Passed</span>:[3]</a>
<a class="sourceLine" id="cb15-18" data-line-number="18"><span class="ex">Passed</span>:[4]</a>
<a class="sourceLine" id="cb15-19" data-line-number="19"></a>
<a class="sourceLine" id="cb15-20" data-line-number="20"><span class="ex">Falsifiable</span> (after 29 tests and 5 shrinks)<span class="bu">:</span></a>
<a class="sourceLine" id="cb15-21" data-line-number="21">[<span class="ex">5</span>]</a></code></pre></div>
<p>ということで <code>Falsifiable (after 29 tests and 5 shrinks): [5]</code> は <strong>テストの29回目に反例が見つかりました。さらにその反例を5回小さくしたよ</strong> という意味になります。</p>
<p>デフォルト実装では <code>shrink _ = []</code> となっていたので、見つかった反例をそのまま返すようですね。(<a href="https://www.stackage.org/haddock/lts-11.2/QuickCheck-2.10.1/Test-QuickCheck.html#v:shrink">haddock</a> を見るともっと詳しく書いてあるので、気になる方はそちらをご参照ください)</p>
<h2 id="quickcheck-instances-パッケージ">quickcheck-instances パッケージ</h2>
<p>ここまでで <code>QuickCheck</code> がどんなものか何となくわかってもらえたと思います。</p>
<p><code>base</code> パッケージで提供されている型については、ほとんどデフォルトで <code>Arbitrary</code> のインスタンス定義があります。</p>
<p>しかしながら、<a href="https://www.stackage.org/lts-11.2/package/time-1.8.0.2">time</a> パッケージの <a href="https://www.stackage.org/haddock/lts-11.2/time-1.8.0.2/Data-Time-Clock.html#t:UTCTime">UTCTime</a> 型や <a href="https://www.stackage.org/lts-11.2/package/text-1.2.3.0">text</a> パッケージの <a href="https://www.stackage.org/haddock/lts-11.2/text-1.2.3.0/Data-Text.html#t:Text">Text</a> 型などのインスタンス定義は別途自分で書かなくてはなりません。</p>
<p><a href="https://www.stackage.org/package/quickcheck-instances">quickcheck-instances</a> パッケージはそういった、よく使うパッケージのインスタンス定義をまとめたものです。</p>
<p>このパッケージの定義で満足いかない場合は自分でカスタマイズするというようにすれば、効率的に開発が進むと思いますよ！</p>
<h2 id="haskell-の入門書を読み終えたあとは">Haskell の入門書を読み終えたあとは・・・？</h2>
<p><code>Haskell</code> の入門書を読み終わった後のオススメの勉強法は以下の2つです。</p>
<ul>
<li>アカデミックコース: 論文を読む</li>
<li>エンジニアコース: ライブラリとアプリケーションのソースコードを読む</li>
</ul>
<p>論文の知識が無いと読めないライブラリもありますし、実装力がないと深い理解が得られない論文もあると思いますが、続けていると不思議とわかるようになります。</p>
<p>また、驚くべきことに <code>Haskell</code> 界隈ではカジュアルにドキュメントのリンクが論文だったりしますが、時間が経てばわかりやすい解説がいくつも出てくるものなので、その時はわからなくてもそのうちわかるようになるかもしれません。</p>
<p>ちなみに <code>QuickCheck</code> に関連する論文も (いくつか) ありますよ。</p>
<h2 id="まとめ">まとめ</h2>
<p><code>shrink</code> なんて使ったことなかったので、今まで良くわかんない関数でしたが、今後機会があれば定義してみようと思います。</p>
<p><code>QuickCheck</code> はランダムテストだと思えば、すぐに理解できますよ！性質テストって言われると難しい感じがしてしまいます・・・。(僕だけかも)</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Haskell Quiz No.3 QuickCheck の Arbitrary 型クラス</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-27-quiz-3.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-27-quiz-3.html</id>
    <published>2018-03-27T00:00:00Z</published>
    <updated>2018-03-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="haskell-quiz-no.3">Haskell Quiz No.3</h2>
<p>難易度: λ</p>
<p><code>propIsDigit</code> テストをパスするように <code>Digit</code> 型の <code>Arbitrary</code> インスタンスを定義してみましょう。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Quiz3</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Test.QuickCheck</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Data.Char</span> (isDigit)</a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">newtype</span> <span class="dt">Digit</span> <span class="fu">=</span> <span class="dt">Digit</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="ot">propIsDigit ::</span> <span class="dt">Digit</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">propIsDigit (<span class="dt">Digit</span> c) <span class="fu">=</span> isDigit c</a>
<a class="sourceLine" id="cb1-11" data-line-number="11"></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Digit</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  arbitrary <span class="fu">=</span> undefined</a></code></pre></div>
<p>テストは以下のように実行します。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1">$ <span class="ex">stack</span> repl --package QuickCheck -- Quiz3.hs</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ex">*Quiz3</span><span class="op">&gt;</span> quickCheck propIsDigit</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ex">+++</span> OK, passed 100 tests.</a></code></pre></div>
<p>上記のように <code>OK</code> になれば (たぶん) 正解です！</p>
<p>ヒント: 生成される値をデバッグしたい場合は <code>sample'</code> 関数が便利です。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ex">*Quiz3</span><span class="op">&gt;</span> sample<span class="st">&#39; (arbitrary :: Gen Digit)</span></a></code></pre></div>
<p>答えは<a href="03-28-quiz-4.html">次回</a>。</p>
<!--more-->
<h2 id="はじめに">はじめに</h2>
<p><a href="./03-25-quiz-2.html">前回</a>の問題と答えは以下の通りです。</p>
<h3 id="問題">問題</h3>
<p>難易度: λλ</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">foldr (<span class="fu">&amp;&amp;</span>) <span class="dt">True</span> <span class="fu">$</span> cycle [<span class="dt">True</span>, <span class="dt">False</span>]</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">foldl (<span class="fu">&amp;&amp;</span>) <span class="dt">True</span> <span class="fu">$</span> cycle [<span class="dt">True</span>, <span class="dt">False</span>]</a></code></pre></div>
<p>上記の2つの式の挙動の違いを説明してください。</p>
<p>また、なぜそうなるのか考えてみましょう！</p>
<h3 id="こたえ">こたえ</h3>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> foldr (<span class="fu">&amp;&amp;</span>) <span class="dt">True</span> <span class="fu">$</span> cycle [<span class="dt">True</span>, <span class="dt">False</span>]</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="dt">False</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="fu">&gt;&gt;&gt;</span> foldl (<span class="fu">&amp;&amp;</span>) <span class="dt">True</span> <span class="fu">$</span> cycle [<span class="dt">True</span>, <span class="dt">False</span>]</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="fu">^</span><span class="dt">CInterrupted</span><span class="fu">.</span></a></code></pre></div>
<p>ということで <code>foldr</code> は無限リストに対しても停止して値を返しますが、<code>foldl</code> は停止せず、値を返さない。</p>
<p>でした。</p>
<h2 id="haskell-quiz-no.2-の解説">Haskell Quiz No.2 の解説</h2>
<p><code>Haskell</code> は遅延評価なので <code>foldr</code> が無限リストを扱えるということは、知っておいて欲しいです。</p>
<p>また実際のアプリケーションではスペースリークの問題があるため <code>foldr</code> &lt; <code>foldl</code> &lt; <code>foldl'</code> の順で好まれるかもしません。(最適化されるから気にしなくても良いという話も聞いたことありますが、詳しくないので良くわかんないです。)</p>
<h3 id="cycle">cycle</h3>
<p><a href="https://www.stackage.org/haddock/lts-11.2/base-4.10.1.0/src/GHC-List.html#cycle">cycle</a> 関数は <code>base</code> パッケージの <a href="https://www.stackage.org/haddock/lts-11.2/base-4.10.1.0/src/GHC-List.html#cycle">GHC.List</a> で定義されています。また <a href="https://www.stackage.org/haddock/lts-11.2/base-4.10.1.0/Prelude.html#v:cycle">Prelude</a> モジュールにも含まれています。</p>
<p>以下は実際の定義です。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">cycle<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">cycle [] <span class="fu">=</span> errorEmptyList <span class="st">&quot;cycle&quot;</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">cycle xs <span class="fu">=</span> xs&#39;</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">  <span class="kw">where</span> xs&#39; <span class="fu">=</span> xs <span class="fu">++</span> xs&#39;</a></code></pre></div>
<p>この定義を見ればわかるように <code>cycle</code> 関数は空リストを与えると実行時エラーになります。</p>
<p>それ以外の場合では与えられたリストを繰り返して無限リストを作ります。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="op">&gt;&gt;&gt;</span> <span class="ex">cycle</span> <span class="st">&quot;Haskell&quot;</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="st">&quot;HaskellHaskellHaskell...</span></a></code></pre></div>
<h3 id="prelude-モジュールについて">Prelude モジュールについて</h3>
<p><code>Prelude</code> モジュールは良く使う基本的な関数や型の集まりです。とても良く使うので自動的に <code>import</code> されています。</p>
<p><code>Prelude</code> で定義されている関数の <code>型</code>・<code>定義</code>・<code>動作</code> は全部わかるようにしておきましょう。</p>
<p>これは本当に基礎知識です。(Haskell が苦手だなーと思う人はまずは <code>Prelude</code> で定義されている関数に慣れてください。それだけでも十分楽しめます。)</p>
<p>また、暗記して覚えることは非常に無駄なのでやめましょう。</p>
<p>何年か <code>Haskell</code> を使っていれば自然に覚えますし、感覚的には覚えている関数を書き下すのではなく、<code>関数名</code> と <code>型</code> または <code>関数の動作</code> から実装を導いている感じです。</p>
<h3 id="foldable">Foldable</h3>
<p><a href="https://www.stackage.org/haddock/lts-11.2/base-4.10.1.0/src/Data-Foldable.html#line-117">Foldable</a> 型クラスは <code>base</code> パッケージの <a href="https://www.stackage.org/haddock/lts-11.2/base-4.10.1.0/Data-Foldable.html">Data.Foldable</a> で定義されています。また <a href="https://www.stackage.org/haddock/lts-11.2/base-4.10.1.0/Prelude.html#t:Foldable">Prelude</a> モジュールにも含まれています。</p>
<p>昔の <code>foldr</code> はリストに対してのみ適用可能な関数でしたが、比較的最近 <code>Foldable</code> クラスのメソッドになりました。そのため、リスト以外でも利用できます。</p>
<p><code>Foldable</code> のクラス定義とリストのインスタンス定義はこんな感じです。(実際にはもっと多くのメソッドがあります)</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Foldable</span> t <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ot">  foldr ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  foldr f z t <span class="fu">=</span> appEndo (foldMap (<span class="dt">Endo</span> <span class="fu">#.</span> f) t) z</a>
<a class="sourceLine" id="cb8-4" data-line-number="4"></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Foldable</span> [] <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  foldr <span class="fu">=</span> List.foldr</a></code></pre></div>
<p>初学者に優しくない世界になりましたね・・・。なかなか定義にたどり着きません。</p>
<p><code>import</code> 宣言のあたりを見ると <code>import qualified GHC.List as List</code> とあるので <code>List.foldr</code> は <code>GHC.List.foldr</code> だとわかります。</p>
<p><code>GHC.List</code> を <code>base</code> パッケージの<a href="https://www.stackage.org/lts-11.2/package/base-4.10.1.0">一覧</a>から探しても見つかりません。これはわざと利用者に見えないようにしているためです。</p>
<p>実際に <a href="https://www.stackage.org/haddock/lts-11.2/base-4.10.1.0/src/GHC-List.html">GHC.List</a> は存在しますが <code>{-# OPTIONS_HADDOCK hide #-}</code> プラグマによって隠されているのです。</p>
<p><code>GHC.List</code> を探してもリストの <code>foldr</code> の定義は見つかりません。どうやら <a href="https://www.stackage.org/haddock/lts-11.2/base-4.10.1.0/src/GHC-Base.html">GHC.Base</a> で定義しているようです。</p>
<h3 id="foldr">foldr</h3>
<p><a href="https://www.stackage.org/haddock/lts-11.2/base-4.10.1.0/src/GHC-Base.html#line-850">foldr</a> の実際の定義は以下の通りです。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1">foldr<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">foldr k z <span class="fu">=</span> go</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">    go [] <span class="fu">=</span> z</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    go (y<span class="fu">:</span>ys) <span class="fu">=</span> y <span class="ot">`k`</span> go ys</a></code></pre></div>
<p>これではわかりずらいので少し変形してみましょう。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">foldr<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">foldr k z []     <span class="fu">=</span> z</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">foldr k z (y<span class="fu">:</span>ys) <span class="fu">=</span> y <span class="ot">`k`</span> foldr k z ys</a></code></pre></div>
<p>変数名もいつもの感じに変えちゃいましょう。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">foldr<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">foldr _  e []     <span class="fu">=</span> e</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">foldr f  e (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="ot">`f`</span> foldr f e xs <span class="co">-- f x (foldr f e xs) と同じ</span></a></code></pre></div>
<p>だいぶ見慣れた形に近づいてきました。</p>
<p><code>foldr</code> (<code>foldl</code>) はほどよく抽象化されているので、色々な理解があると思いますので、僕がいつも使っている説明をいくつかご紹介します。</p>
<p>ここからの <code>foldr</code>, <code>foldl</code> は全てリストについての話です。</p>
<h4 id="直感的な説明">直感的な説明</h4>
<p>例えば <code>foldr (+) 0 [1,2,3,4,5]</code> は以下のように考えることができます。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">[<span class="dv">1</span> , <span class="dv">2</span> , <span class="dv">3</span> , <span class="dv">4</span> , <span class="dv">5</span>]</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="co">-- リストの括弧 (`[`, `]`) を外します</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="dv">1</span> , <span class="dv">2</span> , <span class="dv">3</span> , <span class="dv">4</span> , <span class="dv">5</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="co">-- foldr(ight) なのでに 0 を追加します</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="dv">1</span> , <span class="dv">2</span> , <span class="dv">3</span> , <span class="dv">4</span> , <span class="dv">5</span> , <span class="dv">0</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="co">-- , を (+) に置き換えます</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7"><span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span> <span class="fu">+</span> <span class="dv">3</span> <span class="fu">+</span> <span class="dv">4</span> <span class="fu">+</span> <span class="dv">5</span> <span class="fu">+</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb12-8" data-line-number="8"><span class="co">-- foldr(ight) なので右結合で括弧をつけていきます</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9"><span class="dv">1</span> <span class="fu">+</span> (<span class="dv">2</span> <span class="fu">+</span> (<span class="dv">3</span> <span class="fu">+</span> (<span class="dv">4</span> <span class="fu">+</span> (<span class="dv">5</span> <span class="fu">+</span> <span class="dv">0</span>))))</a>
<a class="sourceLine" id="cb12-10" data-line-number="10"></a>
<a class="sourceLine" id="cb12-11" data-line-number="11"><span class="co">-- 一般化すると</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">x1 <span class="ot">`f`</span> (x2 <span class="ot">`f`</span> (x3 <span class="ot">`f`</span> (x4 <span class="ot">`f`</span> (x5 <span class="ot">`f`</span> e))))</a></code></pre></div>
<p>簡単ですね！この考え方をすれば <code>foldr</code> の型を暗記する必要はありません。</p>
<p><code>foldr f e xs</code> の型はこのように考えれば良いのです。</p>
<ul>
<li><code>f :: a -&gt; b -&gt; ?</code>。この時 <code>?</code> が <code>a</code> か <code>b</code> か迷いそうですが、上の図で考えれば <code>x5 `f` e</code> の結果は <code>x4 `f`</code> の第二引数に再び適用されます。そのため <code>f :: a -&gt; b -&gt; b</code> でなければ型が合いません。</li>
<li><code>f</code> の型がわかれば <code>e</code> の型は自然に <code>b</code> しか有りえません。</li>
<li>当然 <code>xs</code> は <code>x1, x2, x3, ・・・</code> とリストの形式なので <code>[a]</code> しかありえません。</li>
<li><code>foldr</code> の結果の型は最終的に <code>x1 `f` ...</code> となるので <code>f :: a -&gt; b -&gt; b</code> から <code>b</code> です。</li>
</ul>
<p>以上により <code>foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</code> が導かれました。</p>
<h4 id="universal-property-を使った説明">universal property を使った説明</h4>
<p>普遍性 (<code>universal property</code>) の詳しいことは有識者の方に任せるとして</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">myFunc []     <span class="fu">=</span> e</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">myFunc (x<span class="fu">:</span>xs) <span class="fu">=</span> f x (myFunc xs)</a></code></pre></div>
<p>上記のような再帰パターンの関数は全て <code>foldr f e</code> として書けるという性質です。この説明はどちらかと言うと、ベタに再帰で書いた関数を <code>foldr</code> を使った形式に書き直す際の理解の手助けとして有用かと思います。</p>
<p>具体例を見ればすぐにわかります。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">sum [] <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">sum (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="fu">+</span> sum xs</a></code></pre></div>
<p><code>sum</code> 関数は <code>foldr (+) 0</code> と同じです。(この時の <code>e</code> は <code>0</code>, <code>f</code> は <code>(+)</code> に対応します)</p>
<p>では先程の <code>cycle</code> は普遍性を使って <code>foldr</code> で書けるの？という疑問になりますよね。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">cycle [] <span class="fu">=</span> errorEmptyList <span class="st">&quot;cycle&quot;</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">cycle xs <span class="fu">=</span> xs&#39;</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  <span class="kw">where</span> xs&#39; <span class="fu">=</span> xs <span class="fu">++</span> xs&#39;</a></code></pre></div>
<p>先程のパターンと微妙に違うので合わせてみましょう。</p>
<p>また <code>xs' = cycle xs</code> なので以下のように変形できます。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">cycle [] <span class="fu">=</span> errorEmptyList <span class="st">&quot;cycle&quot;</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">cycle xs <span class="fu">=</span> xs <span class="fu">++</span> cycle xs</a></code></pre></div>
<p>さらに変形します。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">cycle []     <span class="fu">=</span> errorEmptyList <span class="st">&quot;cycle&quot;</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">cycle (x<span class="fu">:</span>xs) <span class="fu">=</span> (x<span class="fu">:</span>xs) <span class="fu">++</span> cycle (x<span class="fu">:</span>xs)</a></code></pre></div>
<p>ここで、最初のパターンと比較しやすいように <code>cycle</code> を <code>myFunc</code> という名前に変更します。</p>
<p>ついでに <code>++</code> の位置も変更しておきます。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="co">-- cycle</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">myFunc []     <span class="fu">=</span> errorEmptyList <span class="st">&quot;cycle&quot;</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">myFunc (x<span class="fu">:</span>xs) <span class="fu">=</span> (<span class="fu">++</span>) (x<span class="fu">:</span>xs) (myFunc (x<span class="fu">:</span>xs))</a>
<a class="sourceLine" id="cb18-4" data-line-number="4"></a>
<a class="sourceLine" id="cb18-5" data-line-number="5"><span class="co">-- foldr として書き直すことが出来る再帰パターン</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6">myFunc []     <span class="fu">=</span> e</a>
<a class="sourceLine" id="cb18-7" data-line-number="7">myFunc (x<span class="fu">:</span>xs) <span class="fu">=</span> f x (myFunc xs)</a></code></pre></div>
<p>どうですか、微妙に違いますよね。</p>
<p><code>x</code> と <code>xs</code> に分解しなければいけないのにどちらも <code>(x:xs)</code> になってしまっています。</p>
<p>ということで <code>foldr</code> を使った <code>cycle</code> の定義を普遍性を使って導出することはできません。</p>
<h3 id="cycle-関数を-foldr-を使って定義する">cycle 関数を foldr を使って定義する</h3>
<p>普遍性を使った方法では <code>cycle</code> を導出することができませんでした。</p>
<p>けど、本当に <code>foldr</code> を使って定義することはできないのでしょうか？ (参考: <a href="https://mail.haskell.org/pipermail/beginners/2009-March/001184.html">[Haskell-beginners] folds again – myCycle</a>)</p>
<p>僕はいつもこのような感じで <code>foldr</code> の定義を考えます。<code>acc</code> は蓄積変数 (<code>accumulate variable</code>) の略です。</p>
<p><code>go</code> の第二引数は常に <code>foldr</code> で畳み込んだ結果として考えることができます。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">cycle<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">cycle xs <span class="fu">=</span> foldr go e undefined</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4">    e        <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">    go x acc <span class="fu">=</span> undefined</a></code></pre></div>
<p>少し考えると <code>xs</code> を <code>xs ++ xs ++ xs ...</code> という形式にできれば良さそうです。</p>
<p>無限リストになるため初期値 <code>e</code> は絶対に評価されません。そのため <code>[]</code> でも <code>xs</code> でも <code>undefined</code> でも好きな値が使えそうです。ここでは何となく <code>xs</code> にしておきます。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1">cycle<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb20-2" data-line-number="2">cycle xs <span class="fu">=</span> foldr go e undefined</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4">    e        <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    go x acc <span class="fu">=</span> undefined</a></code></pre></div>
<p>次に <code>go</code> 関数ですが <code>xs ++ (xs ++ (xs ++ (...)))</code> となれば良いので、 <code>go x acc = xs ++ acc</code> です。</p>
<p><code>go</code> が <code>cycle</code> の引数 <code>xs</code> を参照している点が通常の使い方と異なる点です。</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1">cycle<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb21-2" data-line-number="2">cycle xs <span class="fu">=</span> foldr go e undefined</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">    e        <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">    go _ acc <span class="fu">=</span> xs <span class="fu">++</span> acc</a></code></pre></div>
<p>ここが一番のポイントですが <code>foldr</code> に与えるリストは <code>xs</code> ではありません。</p>
<p>無限リストを生成するために適当な無限リストを与えます。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1">cycle<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">cycle xs <span class="fu">=</span> foldr go e [<span class="dv">0</span><span class="fu">..</span>]</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4">    e        <span class="fu">=</span> xs</a>
<a class="sourceLine" id="cb22-5" data-line-number="5">    go _ acc <span class="fu">=</span> xs <span class="fu">++</span> acc</a></code></pre></div>
<p>つまりこのような感じです。</p>
<pre class="text"><code>0 `go` (1 `go` (2 `go` (3 `go` ...)))
xs ++ (1 `go` (2 `go` (3 `go` ...)))
xs ++ (xs ++ (2 `go` (3 `go` ...)))
xs ++ (xs ++ (xs ++ (3 `go` ...)))
xs ++ (xs ++ (xs ++ (xs ++ ...)))</code></pre>
<p>これは完全に <code>cycle</code> ですね！</p>
<p>こんな感じで頑張れば <code>foldr</code> を使って <code>cycle</code> を定義することができます。</p>
<p>ただ、本質的には <code>unfoldr</code> を使うべき問題だと思います！(そのうちクイズにします)</p>
<h3 id="遅延評価を追ってみよう">遅延評価を追ってみよう！</h3>
<p>やっと問題の本題です・・・。</p>
<p><code>foldr</code>, <code>cycle</code>, <a href="https://www.stackage.org/haddock/lts-11.2/ghc-prim-0.5.1.1/src/GHC-Classes.html#%26%26">(&amp;&amp;)</a> の定義は以下を使います。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1">foldr<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">foldr _  e []     <span class="fu">=</span> e</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">foldr f  e (x<span class="fu">:</span>xs) <span class="fu">=</span> x <span class="ot">`f`</span> foldr f e xs</a>
<a class="sourceLine" id="cb24-4" data-line-number="4"></a>
<a class="sourceLine" id="cb24-5" data-line-number="5">cycle<span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb24-6" data-line-number="6">cycle xs <span class="fu">=</span> xs <span class="fu">++</span> cycle xs</a>
<a class="sourceLine" id="cb24-7" data-line-number="7"></a>
<a class="sourceLine" id="cb24-8" data-line-number="8"><span class="ot">(&amp;&amp;) ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9"><span class="dt">True</span>  <span class="fu">&amp;&amp;</span> x  <span class="fu">=</span>  x</a>
<a class="sourceLine" id="cb24-10" data-line-number="10"><span class="dt">False</span> <span class="fu">&amp;&amp;</span> _ <span class="fu">=</span>  <span class="dt">False</span></a></code></pre></div>
<p>それでは実際に遅延評価で簡約していきましょう。</p>
<pre class="text"><code>foldr (&amp;&amp;) True (cycle [True, False])
  = { cycle を適用 }
foldr (&amp;&amp;) True ([True, False] ++ cycle [True, False])
  = { foldr を適用 }
True &amp;&amp; foldr (&amp;&amp;) True ([False] ++ cycle [True, False])
  = { (&amp;&amp;) を適用 }
foldr (&amp;&amp;) True ([False] ++ cycle [True, False])
  = { fodlr を適用 }
False &amp;&amp; foldr (&amp;&amp;) True (cycle [True, False])
  = { (&amp;&amp;) を適用 }
False</code></pre>
<p>つまり、<code>(&amp;&amp;)</code> の定義に秘密があったのです。</p>
<p><code>(&amp;&amp;)</code> 第一引数が <code>False</code> であれば第二引数を評価することなく <code>False</code> を返します。そのため <code>False &amp;&amp; _ =  False</code> のような定義になっています。(このような関数を非正格関数 (<code>non-strict function</code>) と言います。定義は <code>f undefined = undefined</code> であれば正格関数 (<code>strict function</code>) です。<code>(&amp;&amp;)</code> は第一引数に関しては正格ですが、第二引数に関しては非正格です)</p>
<p>これが <code>foldr</code> の場合に計算が停止する理由です。</p>
<p>ではなぜ <code>foldl</code> の場合は停止しないのでしょうか？</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1">foldl<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">foldl _ acc []     <span class="fu">=</span> acc</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">foldl f acc (x<span class="fu">:</span>xs) <span class="fu">=</span> foldl f (acc <span class="ot">`f`</span> x) xs</a></code></pre></div>
<p><code>foldl</code> の場合も同様に簡約してみましょう。</p>
<pre class="text"><code>foldl (&amp;&amp;) True (cycle [True, False])
  = { cycle を適用 }
foldl (&amp;&amp;) True ([True, False] ++ cycle [True, False])
  = { foldl を適用 }
foldl (&amp;&amp;) (True &amp;&amp; True) ([False] ++ cycle [True, False])
  = { foldl を適用 }
foldl (&amp;&amp;) ((True &amp;&amp; True) &amp;&amp; False) (cycle [True, False])
  = ...</code></pre>
<p>ということで <code>foldl</code> はリストの最後にたどり着くまで値を返せないのです。</p>
<p>そのため、無限リストを処理しようとすると停止しなくなります。</p>
<h2 id="まとめ">まとめ</h2>
<p>いつも解説が長くなってしまいます・・・。</p>
<p><code>fold</code> の融合則とかめちゃめちゃ好きなのでいつかまとめたいですね。</p>
<p>また、<code>fold</code> が好きな人には <a href="https://www.stackage.org/package/foldl">foldl</a> パッケージがオススメです。</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Haskell IDE Engine を Emacs で使う</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-26-hie-emacs.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-26-hie-emacs.html</id>
    <published>2018-03-26T00:00:00Z</published>
    <updated>2018-03-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p><a href="https://github.com/haskell/haskell-ide-engine">HIE (Haskell IDE Engine)</a> を <code>Emacs</code> に導入する方法が <code>HIE</code> の <a href="https://github.com/haskell/haskell-ide-engine/pull/502/files">README.md</a> に追記されたので、それに従いインストールしてみました。</p>
<p>本記事では、導入手順を紹介します。</p>
<!--more-->
<h2 id="導入手順">導入手順</h2>
<h3 id="hie-をインストールする">1. HIE をインストールする。</h3>
<pre class="bssh"><code>$ git clone https://github.com/haskell/haskell-ide-engine.git
$ cd haskell-ide-engine
$ make

...

* Missing C libraries: icuuc, icui18n, icudata</code></pre>
<p><code>make</code> 実行時、以下のようにライブラリが足りなかったので、必要なパッケージをインストールして、もう一度 <code>make</code> しました。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1">$ <span class="fu">sudo</span> apt install libicu-dev</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">$ <span class="fu">make</span></a></code></pre></div>
<p>普通に <code>stack install</code> で導入することもできますが、 <code>HIE</code> はビルド時の <code>GHC</code> バージョンでしか使えないという弱点があるため、<code>GHC</code> の バージョンが異なるプロジェクトでは利用できません。</p>
<p>そのため <code>make</code> を使って <code>hie-8.2.1</code> のように <code>GHC</code> のそれぞれのバージョンでビルドした <code>HIE</code> のバイナリを用意して解決しています。</p>
<h3 id="必要なパッケージを入手する">2. 必要なパッケージを入手する。</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1">$ <span class="fu">git</span> clone git@github.com:emacs-lsp/lsp-mode.git</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">$ <span class="fu">git</span> clone git@github.com:emacs-lsp/lsp-ui.git</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">$ <span class="fu">git</span> clone git@github.com:emacs-lsp/lsp-haskell.git</a></code></pre></div>
<h3 id="emacs-の設定ファイル-init.el-など-に以下を追加する">3. emacs の設定ファイル (init.el など) に以下を追加する。</h3>
<pre class="elisp"><code>(add-to-list &#39;load-path &quot;/path/to/lsp-mode&quot;)
(add-to-list &#39;load-path &quot;/path/to/lsp-ui&quot;)
(add-to-list &#39;load-path &quot;/path/to/lsp-haskell&quot;)

(require &#39;lsp-mode)
(require &#39;lsp-ui)
(require &#39;lsp-haskell)

(add-hook &#39;lsp-mode-hook &#39;lsp-ui-mode)
(add-hook &#39;haskell-mode-hook #&#39;lsp-haskell-enable)
(add-hook &#39;haskell-mode-hook &#39;flycheck-mode)</code></pre>
<p>上記内容を記述した後で Emacs を起動したときに、依存するパッケージのインストールを要求される場合があるので、<code>Cask</code> や <code>package-install</code> などでインストールしましょう。</p>
<p>インストールが成功すると、<code>Haskell</code> のファイルを読み込んだときに、カーソルを当てたところにある関数の型の表示、エラーの表示、補完、コマンド <code>M-.</code> で定義のところにジャンプなどができるようになります。</p>
<h2 id="おわりに">おわりに</h2>
<p><code>HIE</code> は <code>ghc-mod</code> の実行ファイルを使っているかのように見えますが、実際はライブラリを通しているだけでバイナリは使っていないそうです。</p>]]></summary>
</entry>
<entry>
    <title>Haskell Quiz No.2 foldl と foldr</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-25-quiz-2.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-25-quiz-2.html</id>
    <published>2018-03-25T00:00:00Z</published>
    <updated>2018-03-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="haskell-quiz-no.2">Haskell Quiz No.2</h2>
<p>難易度: λλ</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">foldr (<span class="fu">&amp;&amp;</span>) <span class="dt">True</span> <span class="fu">$</span> cycle [<span class="dt">True</span>, <span class="dt">False</span>]</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">foldl (<span class="fu">&amp;&amp;</span>) <span class="dt">True</span> <span class="fu">$</span> cycle [<span class="dt">True</span>, <span class="dt">False</span>]</a></code></pre></div>
<p>上記の2つの式の挙動の違いを説明してください。</p>
<p>また、なぜそうなるのか考えてみましょう！</p>
<p>答えは<a href="03-27-quiz-3.html">次回</a>。</p>
<!--more-->
<h2 id="はじめに">はじめに</h2>
<p><a href="./03-24-quiz-1.html">前回</a>の問題と答えは以下の通りです。</p>
<h3 id="問題">問題</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Foo</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Foo1</span> <span class="fu">=</span> <span class="dt">Foo1</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">data</span> <span class="dt">Foo2</span> <span class="fu">=</span> <span class="dt">Foo2</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="kw">newtype</span> <span class="dt">Foo3</span> <span class="fu">=</span> <span class="dt">Foo3</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">x1 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo1</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">     <span class="dt">Foo1</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">x2 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo2</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">     <span class="dt">Foo2</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12"></a>
<a class="sourceLine" id="cb2-13" data-line-number="13">x3 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo3</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-14" data-line-number="14">     <span class="dt">Foo3</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15"></a>
<a class="sourceLine" id="cb2-16" data-line-number="16">y1 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-17" data-line-number="17">     <span class="dt">Foo1</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-18" data-line-number="18"></a>
<a class="sourceLine" id="cb2-19" data-line-number="19">y2 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-20" data-line-number="20">     <span class="dt">Foo2</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-21" data-line-number="21"></a>
<a class="sourceLine" id="cb2-22" data-line-number="22">y3 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-23" data-line-number="23">     <span class="dt">Foo3</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb2-24" data-line-number="24"></a>
<a class="sourceLine" id="cb2-25" data-line-number="25"><span class="ot">int ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-26" data-line-number="26">int <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb2-27" data-line-number="27"></a>
<a class="sourceLine" id="cb2-28" data-line-number="28">yInt <span class="fu">=</span> <span class="kw">case</span> int <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-29" data-line-number="29">       _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>以下の値はそれぞれ何になるでしょう？</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">x1   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">x2   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">x3   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">y1   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5">y2   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6">y3   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">yInt <span class="fu">=</span> <span class="fu">???</span></a></code></pre></div>
<h3 id="答え">答え</h3>
<p><code>GHC</code> のバージョン <code>8.0.2</code>, <code>8.2.2</code>, <code>8.4.1</code> で確認しました。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">x1   <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">x2   <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">x3   <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">y1   <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">y2   <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">y3   <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">yInt <span class="fu">=</span> <span class="dv">1</span></a></code></pre></div>
<p>どうですか？自信を持って全部回答できた人は少ないのではないでしょうか。</p>
<p>ちなみに、この知識を披露するタイミングは・・・ほぼ無いでしょうね・・・。</p>
<p>よくある <code>Haskell</code> 雑学のうちの1つです。こういう内容はチームメンバーの誰かが理解していれば良いので、最初のうちはわからなくても大丈夫です。わかる人に解説してもらいましょう。</p>
<h3 id="どうでも良い話">どうでも良い話</h3>
<p>Haskell Quiz は <code>Haskell</code> と言いつつ <code>GHC</code> の話だったりする場合もありますが、実用上それが問題になることは無いので気にしないことにします。</p>
<p><code>Haskell</code> は言語仕様で <code>GHC</code> が処理系だというのは、ただの雑学です。このことを知ってると、割とHaskellに詳しそうだな思ってもらえますよ！(ついでに <code>G</code> が <code>Glasgow</code> の略でイギリスにある大学なんだよってことも伝えてあげると、バイトの学生とかは <code>へー</code> って顔をしてくれるのでオススメです！)</p>
<h2 id="haskell-quiz-no.1-の解説">Haskell Quiz No.1 の解説</h2>
<h3 id="x1">x1</h3>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Foo1</span> <span class="fu">=</span> <span class="dt">Foo1</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">x1 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo1</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  <span class="dt">Foo1</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p><code>Foo1</code> はよくあるデータ定義です。</p>
<p>気にしておくべき点は以下の2つです。</p>
<ul>
<li><code>Foo1 Int</code> の <code>Int</code> はまだ評価されていない<strong>サンク</strong>という状態です。</li>
<li><code>undefined</code> は実際に評価された時にエラーとなります。(逆に、最後まで評価されなければエラーにならない)</li>
</ul>
<p><code>Foo1</code> 型の値で、例えば <code>Foo1 (1+1)</code> の <code>1+1</code> はまだ必要になっていないので、評価されていないサンクです。(つまり <code>Foo1 2</code> ではありません)</p>
<p>本当かなぁ？と思う人は実際に以下のコードを実行すれば、何となくわかってもらえると思います。(<code>sum [1..100000000000000]</code> は評価された時にとても時間がかかる処理です)</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ex">ghci</span><span class="op">&gt;</span> Foo1 (sum [1..100000000000000])</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ex">Foo1</span> ^CInterrupted.</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="ex">ghci</span><span class="op">&gt;</span> case Foo1 (sum [1..100000000000000]) <span class="ex">of</span> Foo1 i -<span class="op">&gt;</span> i</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">^<span class="ex">CInterrupted.</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="ex">ghci</span><span class="op">&gt;</span> case Foo1 (sum [1..100000000000000]) <span class="ex">of</span> Foo1 _ -<span class="op">&gt;</span> 0</a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="ex">0</span></a></code></pre></div>
<p>ということで以下のコードは <code>case</code> で <code>Foo1</code> とのパターンマッチは行われますが、 <code>undefined</code> は評価されない (する必要がない) ため <code>1</code> が返ってくることになります。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Foo1</span> <span class="fu">=</span> <span class="dt">Foo1</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">x1 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo1</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">     <span class="dt">Foo1</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">x1 <span class="fu">=</span> <span class="dv">1</span></a></code></pre></div>
<p><code>Haskell</code> のアプリケーションがスペースリークしてしまう原因は、主にこのデータ構造のサンクが原因になっている場合が多いようです。</p>
<h3 id="x2">x2</h3>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Foo2</span> <span class="fu">=</span> <span class="dt">Foo2</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">x2 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo2</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">     <span class="dt">Foo2</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>このコードには見慣れない <code>!</code> という記号が出てきました。</p>
<p>ここで抑えておくポイントは1つだけです。</p>
<ul>
<li><code>!</code> はサンクを潰してくれる (評価する) マークです。つまり、値が使われない場合でも評価されるということです。(計算が無駄になる場合も当然ある)</li>
</ul>
<p>以下の結果から、<code>Foo2</code> の値を作る時には、必ず先に <code>sum [1..100000000000000]</code> が計算されていることがわかります。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ex">ghci</span><span class="op">&gt;</span> Foo2 (sum [1..100000000000000])</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">^<span class="ex">CInterrupted.</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="ex">ghci</span><span class="op">&gt;</span> case Foo2 (sum [1..100000000000000]) <span class="ex">of</span> Foo2 i -<span class="op">&gt;</span> i</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">^<span class="ex">CInterrupted.</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="ex">ghci</span><span class="op">&gt;</span> case Foo2 (sum [1..100000000000000]) <span class="ex">of</span> Foo2 _ -<span class="op">&gt;</span> 0</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">^<span class="ex">CInterrupted.</span></a></code></pre></div>
<p>そのため、今回の結果は <code>undefined</code> になります。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Foo2</span> <span class="fu">=</span> <span class="dt">Foo2</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">x2 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo2</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">     <span class="dt">Foo2</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<div class="sourceCode" id="cb12"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">x2 <span class="fu">=</span> undefined</a></code></pre></div>
<p>専門家は <code>undefined</code> のことを <code>bottom</code> (<code>⊥</code>) というテクニカルタームで呼ぶこともありますが、普通の人は <code>停止しない計算</code> や <code>エラー</code> という意味だと思えば十分です。(たぶん)</p>
<h3 id="x3">x3</h3>
<div class="sourceCode" id="cb13"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Foo3</span> <span class="fu">=</span> <span class="dt">Foo3</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">x3 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo3</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">     <span class="dt">Foo3</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>ここで抑えておくポイントは2つです。</p>
<ul>
<li><code>newtype</code> のデータコンストラクタは型チェックが終わったら剥がされる</li>
<li>そのため <code>newtype</code> は実行時に余分なコストが発生しない</li>
</ul>
<p>つまり、雰囲気はこんな感じです。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Nat</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2"></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="co">-- 型チェック前</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">x <span class="fu">=</span> <span class="dt">Nat</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5"></a>
<a class="sourceLine" id="cb14-6" data-line-number="6"><span class="co">-- 型チェック後</span></a>
<a class="sourceLine" id="cb14-7" data-line-number="7">x <span class="fu">=</span> <span class="dv">1</span></a></code></pre></div>
<p>Haskell の学習でわけわかんないポイントの1つに <code>type</code>, <code>newtype</code>, <code>data</code> の違いがあると思います。(少なくとも僕は最初全然わかりませんでした)</p>
<p>僕と同じように学習で困っている人は、以下の表で考えれば理解の手助けになるかもしれません。</p>
<div class="row">
<table class="col s8 offset-s2 centered">
<thead>
<tr>
<th>
</th>
<th>
型 (type)
</th>
<th>
値 (value)
</th>
<th>
具体例
</th>
</tr>
</thead>
<tbody>
<tr>
<td>
type
</td>
<td>
X
</td>
<td>
X
</td>
<td>
<code>type FilePath = String</code>
</td>
</tr>
<tr>
<td>
newtype
</td>
<td>
O
</td>
<td>
X
</td>
<td>
<code>newtype Nat = Nat Int</code>
</td>
</tr>
<tr>
<td>
data
</td>
<td>
O
</td>
<td>
O
</td>
<td>
<code>data Bool = True | False</code>
</td>
</tr>
</tbody>
</table>
</div>
<p><code>X</code> は既存の型や値を再利用する、<code>O</code> は型や値を新しく作るという意味です。</p>
<ul>
<li><code>type</code> は型も値も既存のものを再利用します。</li>
<li><code>newtype</code> は型は新しく作りますが、値は既存のものを再利用します。</li>
<li><code>data</code> は型も値も新しく作ります。</li>
</ul>
<p>ということで、このように変形できます。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Foo3</span> <span class="fu">=</span> <span class="dt">Foo3</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="co">-- 定義</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">x3 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo3</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">     <span class="dt">Foo3</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6"></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="co">-- newtype なので</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">x3 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb15-9" data-line-number="9"></a>
<a class="sourceLine" id="cb15-10" data-line-number="10"><span class="co">-- 1 を返すために undefined を評価する必要が無いため</span></a>
<a class="sourceLine" id="cb15-11" data-line-number="11">x3 <span class="fu">=</span> <span class="dv">1</span></a></code></pre></div>
<h3 id="y1">y1</h3>
<div class="sourceCode" id="cb16"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Foo1</span> <span class="fu">=</span> <span class="dt">Foo1</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">y1 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">     <span class="dt">Foo1</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>この場合は <code>case</code> 式で <code>Foo1 _</code> のパターンマッチを行う際に <code>undefined</code> の評価をしなければならないため <code>y1</code> は <code>undefined</code> になります。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">y1 <span class="fu">=</span> undefined</a></code></pre></div>
<h3 id="y2">y2</h3>
<div class="sourceCode" id="cb18"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Foo2</span> <span class="fu">=</span> <span class="dt">Foo2</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2"></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">y2 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4">     <span class="dt">Foo2</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>この場合も <code>y1</code> と同じケースです。やはり <code>Foo1</code> のパターンマッチが発生するため <code>undefined</code> です。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">y2 <span class="fu">=</span> undefined</a></code></pre></div>
<h3 id="y3">y3</h3>
<div class="sourceCode" id="cb20"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Foo3</span> <span class="fu">=</span> <span class="dt">Foo3</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">y3 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4">     <span class="dt">Foo3</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>この結果が一番おもしろい気がしますが、これは <code>1</code> を返します。</p>
<p>今までの話から <code>Foo3</code> は実行時には存在しないコンストラクタです。すなわち実行時にはこのような形式になります。</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1">y3 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">     _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>これは <code>x3</code> の場合と同じですね。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1">y3 <span class="fu">=</span> <span class="dv">1</span></a></code></pre></div>
<h3 id="yint">yInt</h3>
<div class="sourceCode" id="cb23"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="ot">int ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">int <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb23-3" data-line-number="3"></a>
<a class="sourceLine" id="cb23-4" data-line-number="4">yInt <span class="fu">=</span> <span class="kw">case</span> int <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">       _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>ここまで来たらこれはもう簡単ですよね！</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1">yInt <span class="fu">=</span> <span class="dv">1</span></a></code></pre></div>
<h2 id="まとめ">まとめ</h2>
<p>解説がとても長くなってしまいました・・・。間違ってたらご報告ください。</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Haskell Quiz はじめました。 No.1 type, newtype, data</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-24-quiz-1.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-24-quiz-1.html</id>
    <published>2018-03-24T00:00:00Z</published>
    <updated>2018-03-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>何となくクイズはじめました！(頑張って続けます・・・)</p>
<p>間違ってたら <code>twitter</code> や <a href="https://github.com/e-bigmoon/haskell-blog/issues">github の issue</a> で教えてください！</p>
<!--more-->
<h2 id="haskell-quiz-no.1-type-newtype-data">Haskell Quiz No.1 type, newtype, data</h2>
<p>難易度: λλλ</p>
<p>元ネタは <code>Haskell wiki</code> だったと思いますが、忘れてしまいました・・・。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Foo</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Foo1</span> <span class="fu">=</span> <span class="dt">Foo1</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">data</span> <span class="dt">Foo2</span> <span class="fu">=</span> <span class="dt">Foo2</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">newtype</span> <span class="dt">Foo3</span> <span class="fu">=</span> <span class="dt">Foo3</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">x1 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo1</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">     <span class="dt">Foo1</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">x2 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo2</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">     <span class="dt">Foo2</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12"></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">x3 <span class="fu">=</span> <span class="kw">case</span> <span class="dt">Foo3</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">     <span class="dt">Foo3</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15"></a>
<a class="sourceLine" id="cb1-16" data-line-number="16">y1 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-17" data-line-number="17">     <span class="dt">Foo1</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18"></a>
<a class="sourceLine" id="cb1-19" data-line-number="19">y2 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-20" data-line-number="20">     <span class="dt">Foo2</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-21" data-line-number="21"></a>
<a class="sourceLine" id="cb1-22" data-line-number="22">y3 <span class="fu">=</span> <span class="kw">case</span> undefined <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23">     <span class="dt">Foo3</span> _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-24" data-line-number="24"></a>
<a class="sourceLine" id="cb1-25" data-line-number="25"><span class="ot">int ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-26" data-line-number="26">int <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb1-27" data-line-number="27"></a>
<a class="sourceLine" id="cb1-28" data-line-number="28">yInt <span class="fu">=</span> <span class="kw">case</span> int <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-29" data-line-number="29">       _ <span class="ot">-&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>以下の値はそれぞれ何になるでしょう？</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">x1   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">x2   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">x3   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">y1   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">y2   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">y3   <span class="fu">=</span> <span class="fu">???</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">yInt <span class="fu">=</span> <span class="fu">???</span></a></code></pre></div>
<p>全部正解できたら普通にすごいです。</p>
<p>答えは<a href="./03-25-quiz-2.html">次回</a>！</p>
<p>以上です。</p>]]></summary>
</entry>

</feed>
