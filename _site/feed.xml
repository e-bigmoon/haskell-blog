<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>BIG MOON</title>
    <link href="https://haskell.e-bigmoon.com/feed.xml" rel="self" />
    <link href="https://haskell.e-bigmoon.com" />
    <id>https://haskell.e-bigmoon.com/feed.xml</id>
    <author>
        <name>BIG MOON</name>
        <email>it@e-bigmoon.com</email>
    </author>
    <updated>2018-06-26T00:00:00Z</updated>
    <entry>
    <title>ContT を使ってコードを綺麗にしよう！</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/06-26-cont-param.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/06-26-cont-param.html</id>
    <published>2018-06-26T00:00:00Z</published>
    <updated>2018-06-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>Continuation (継続) について全く勉強したことが無いので <a href="https://www.stackage.org/haddock/lts-11.15/mtl-2.2.2/Control-Monad-Cont.html">Control.Monad.Cont</a> で定義されている ContT とかいつ使うんだろうなーと思っていましたが、ついに利用機会がありました！！！</p>
<p>僕が考えたんじゃなくて fumieval さんに相談して、教えてもらったんですけどね。</p>
<!--more-->
<h2 id="問題のコード">問題のコード</h2>
<p><strong>Yesod</strong> の <strong>Handler</strong> ではパラメータの取得するために <a href="https://www.stackage.org/haddock/lts-11.15/yesod-core-1.6.5/Yesod-Core-Handler.html#v:lookupGetParam">lookupGetParam</a> や <a href="https://www.stackage.org/haddock/lts-11.15/yesod-core-1.6.5/Yesod-Core-Handler.html#v:lookupPostParam">lookupPostParam</a> を利用すると思います。</p>
<p>実際にはこんな感じでパラメータを取得していくつか処理を行います。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">deleteTestR ::</span> <span class="dt">Handler</span> <span class="dt">Html</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">deleteTestR <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  mParam <span class="ot">&lt;-</span> lookupPostParam <span class="st">&quot;key&quot;</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  <span class="kw">case</span> mParam <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> returnJson <span class="fu">$</span> <span class="dt">String</span> <span class="st">&quot;パラメータが不正です。&quot;</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    <span class="dt">Just</span> param <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">      <span class="kw">case</span> textToSqlKey param <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> returnJson <span class="fu">$</span> <span class="dt">String</span> <span class="st">&quot;キーが見つかりませんでした。&quot;</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">        <span class="dt">Just</span> key <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">          mRecord <span class="ot">&lt;-</span> runDB <span class="fu">$</span> get key</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">          <span class="kw">case</span> mRecord <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">            <span class="dt">Nothing</span> <span class="ot">-&gt;</span> returnJson <span class="fu">$</span> <span class="dt">String</span> <span class="st">&quot;削除対象のデータが見つかりませんでした。&quot;</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">            <span class="dt">Just</span> _  <span class="ot">-&gt;</span> returnJson <span class="fu">$</span> <span class="dt">String</span> <span class="st">&quot;success&quot;</span></a></code></pre></div>
<p>このコード、どう考えても嫌な感じですよね・・・。ネストやばいし。</p>
<p><strong>do</strong> で書くと <strong>Maybe</strong> 型なので値を返せないし、ベースに <strong>Handler</strong> モナドがあるので <strong>Either</strong> で置き換えるのも良くわかんないな・・・。と思って、結構放置してました。</p>
<h2 id="contt-を使ってリファクタリング">ContT を使ってリファクタリング！</h2>
<p>先程のプログラムを <a href="https://www.stackage.org/haddock/lts-11.15/mtl-2.2.2/Control-Monad-Cont.html#t:ContT">ContT</a> で置き換えるとこうなります。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">deleteTestR ::</span> <span class="dt">Handler</span> <span class="dt">Html</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">deleteTestR <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  mParam <span class="ot">&lt;-</span> lookupPostParam <span class="st">&quot;key&quot;</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  evalContT <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    param <span class="ot">&lt;-</span> mParam <span class="fu">!?</span> <span class="st">&quot;パラメータが不正です。&quot;</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">    key <span class="ot">&lt;-</span> textToSqlKey param <span class="fu">!?</span> <span class="st">&quot;キーが見つかりませんでした。&quot;</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">    mRecord <span class="ot">&lt;-</span> lift <span class="fu">$</span> runDB <span class="fu">$</span> get key</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">    deletedBrand <span class="ot">&lt;-</span> mRecord <span class="fu">!?</span> <span class="st">&quot;削除対象のデータが見つかりませんでした。&quot;</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">    lift <span class="fu">$</span> returnJson <span class="fu">$</span> <span class="dt">String</span> <span class="st">&quot;success&quot;</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">    <span class="dt">Nothing</span> <span class="fu">!?</span> e <span class="fu">=</span> <span class="dt">ContT</span> <span class="fu">$</span> const <span class="fu">$</span> returnJson <span class="fu">$</span> <span class="dt">String</span> e</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">    <span class="dt">Just</span> a  <span class="fu">!?</span> _ <span class="fu">=</span> <span class="dt">ContT</span> (<span class="fu">$</span> a)</a></code></pre></div>
<p>感動しましたね。継続すごいな！って。</p>
<h2 id="まとめ">まとめ</h2>
<p>継続勉強しよ。</p>]]></summary>
</entry>
<entry>
    <title>stack run コマンド</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/06-25-stack-run.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/06-25-stack-run.html</id>
    <published>2018-06-25T00:00:00Z</published>
    <updated>2018-06-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>先日 stack の master ブランチに <a href="https://github.com/commercialhaskell/stack/pull/3952">Introduce stack run command line option #3952</a> がマージされました。とても便利なので紹介したいと思います。</p>
<p><strong>stack run</strong> コマンドについて簡単に説明するとこんな感じです。</p>
<ul>
<li><strong>cabal run</strong> の <strong>stack</strong> バージョンです。</li>
<li><code>stack build &amp;&amp; stack exec foo</code> の短縮形です。</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1">$ <span class="ex">stack</span> --version</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ex">Version</span> 1.8.0, Git revision 466da22ce21cddc20323fc2611cd2a2d3cc56ec6 (dirty) <span class="kw">(</span><span class="ex">5998</span> commits<span class="kw">)</span> <span class="ex">x86_64</span> hpack-0.28.2</a></code></pre></div>
<p>現在の <strong>stack</strong> の最新バージョンは <strong>1.7.1</strong> です。</p>
<!--more-->
<h2 id="stack-run-コマンド">stack run コマンド</h2>
<p>実際にプロジェクトを作って試してみましょう。</p>
<pre class="shell"><code>$ stack new stack-run-test
$ cd stack-run-test</code></pre>
<p>初回は通常通りビルドが実行され、その後に someFunc が出力されます。</p>
<pre class="shell"><code>$ stack run
Building all executables for `stack-run-test&#39; once. After a successful build of all of them, only specified executables

...

Registering library for stack-run-test-0.1.0.0..
someFunc</code></pre>
<p>2回目以降はビルド結果がキャッシュされているので、ファイルを変更しなれければ再ビルドされることはありません。</p>
<pre class="shell"><code>$ stack run
someFunc</code></pre>
<h2 id="まとめ">まとめ</h2>
<p><code>stack run</code> コマンドは <a href="https://github.com/commercialhaskell/stack/issues/233">Wishlist: stack run #233</a> によって2015年6月に提案されているので3年越しの実装ということになります。この調子で色々と便利なコマンドが増えると良いですね。</p>
<p>実行ファイル名の指定を省略できるのは、非常に便利なので僕も使っていこうと思います。</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>正格性のすべて (翻訳)</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/06-25-All-About-Strictness.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/06-25-All-About-Strictness.html</id>
    <published>2018-06-25T00:00:00Z</published>
    <updated>2018-06-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Original post: <a href="https://www.fpcomplete.com/blog/2017/09/all-about-strictness">ALL ABOUT STRICTNESS</a></p>
<p>Haskell は (もしかすると、評判のよろしくない？) 遅延 (<em>lazy</em>) 言語です。遅延性の基本的なアイデアは「値は必要となったときにのみ計算される」という、たった一言で説明できるぐらい簡単なものです。しかし、この裏には様々なことが隠れています。特に、メモリと時間について効率的なコードを書こうとしたときに、必要不可欠なトピックがいくつもあります。</p>
<ul>
<li>弱頭部正規形 (WHNF) と 正規形 (NF)</li>
<li><code>seq</code> と <code>deepseq</code> の使い方 (と関連する概念)</li>
<li>データ型の正格性注釈</li>
<li>バンパターン</li>
<li>遅延、スパイン(spine)-正格、値-正格などのデータ構造の正格性</li>
<li>適切な補助関数の選択 (特に、fold 系)</li>
</ul>
<p>この記事は効率的な <a href="https://haskell-lang.org/library/conduit">conduit</a> コードを書くためのいくつかの質問にインスパイアされたものであり、記事の最後でそれらについて本気で取り組んでみようと思います。ここで紹介する概念は汎用的なものであり、ストリーミングライブラリに限定されるものではありません。</p>
<p><strong>ノート</strong> この記事は現実とは逆に、遅延性を解決すべき問題として取り扱います。遅延性は有利にも不利にもなります。私たちの目標は遅延性の問題の大枠とその回避策を理解することなので、悪い点にのみ焦点を当てることにします。遅延性にはとても大きなメリットが数多くありますが、ここで取り上げることはしません。なぜなら、私の読者はコメントで遅延性の素晴らしさについて紹介している記事へのリンクをいくつも追加してくれるでしょうから :)</p>
<!--more-->
<h2 id="遅延性入門">遅延性入門</h2>
<p>さて、私は先ほど</p>
<blockquote>
<p>値は必要となった時にのみ計算される</p>
</blockquote>
<p>と言いました。詳細を知るために正格言語であるC言語と比較してみましょう。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="dt">int</span> add(<span class="dt">int</span> x, <span class="dt">int</span> y) {</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  <span class="cf">return</span> x + y;</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">  <span class="dt">int</span> five = add(<span class="dv">1</span> + <span class="dv">1</span>, <span class="dv">1</span> + <span class="dv">2</span>);</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  <span class="dt">int</span> seven = add(<span class="dv">1</span> + <span class="dv">2</span>, <span class="dv">1</span> + <span class="dv">3</span>);</a>
<a class="sourceLine" id="cb1-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  printf(<span class="st">&quot;Five: %d</span><span class="sc">\n</span><span class="st">&quot;</span>, five);</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  <span class="cf">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">}</a></code></pre></div>
<p>私たちの関数 <code>add</code> は <code>x</code> と <code>y</code> の両方の引数で<em>正格</em>です。そして、結果もまた正格になります。つまり</p>
<ul>
<li>初めて <code>add</code> が呼ばれる前に <code>1 + 1</code> と <code>1 + 2</code> の両方の結果を計算します。</li>
<li><code>2</code> と <code>3</code> を引数として <code>add</code> 関数を呼び出した結果 <code>5</code> が得られます。それは変数 <code>five</code> によって指し示されるメモリの値となります。</li>
<li>同様に <code>1 + 2</code>, <code>1 + 3</code> を計算し <code>seven</code> に <code>7</code> が格納されます。</li>
<li>完全に計算された <code>five</code> の値で <code>printf</code> を呼び出します。</li>
</ul>
<p>さて、これと等価な Haskell コードと比較してみましょう。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">add x y <span class="fu">=</span> x <span class="fu">+</span> y</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  <span class="kw">let</span> five <span class="fu">=</span> add (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">1</span>) (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">      seven <span class="fu">=</span> add (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>) (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb2-8" data-line-number="8"></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  putStrLn <span class="fu">$</span> <span class="st">&quot;Five: &quot;</span> <span class="fu">++</span> show five</a></code></pre></div>
<p>正格性解析 (<em>strictness analysis</em>) と呼ばれる仕組みにより、説明よりも効率的な結果となることがありますが、意味的には以下の通りです。</p>
<ul>
<li><code>1 + 1</code> や <code>1 + 2</code> の計算をすぐに行うのではなく、コンパイラはこれらの計算のサンク (<em>thunk</em>) (プロミス (<em>promise</em>) として考えることができます) を生成し、<code>add</code> 関数にサンクを渡します。</li>
<li><code>add</code> 関数をすぐに呼び出すという例外を除けば、<code>five</code> は <code>add</code> 関数を <code>1 + 1</code> と <code>1 + 2</code> のサンクに適用するというサンクです。</li>
<li><code>seven</code> に関しても同様に、<code>add</code> 関数を異なる2つのサンクに適用するというサンクです。</li>
<li>最終的に <code>five</code> を表示しようとする際に実際の数を知る必要があります。このことを強制評価 (<em>forcing evaluation</em>) と言い、あとで詳しく、いつ・どのように強制評価が起こるか説明しますが、今のところは <code>putStrLn</code> が実行された時に起こると理解すれば十分です。<code>1 + 1</code> と <code>1 + 2</code> の強制評価を行う <code>five</code> の強制評価が行われ、サンクが実際の数 (<code>2</code>, <code>3</code>, 最終的に <code>5</code>) に変換されます。</li>
<li><code>seven</code> は一度も使われず、サンクとして残ったままとなりますが、このサンクを評価するための時間はかかっていません。</li>
</ul>
<p>C の (正格) 評価と比較すると、使われることのない <code>seven</code> の値を評価するという無意味な処理を行わないという恩恵があります。これにより、処理を3つスキップできます！現実的な場面では3つではなく、もっとひどいコストのかかる処理かもしれません。</p>
<p><em>だけども</em>、全てが素晴らしいものではありません。サンクはタダじゃないんです。我々はサンクのためにスペースを確保する必要があり、その確保と後にメモリ解放のために行われる GC を引き起こすコストの両方がかかります。たぶん一番大切なことは、式がサンク化されたものは、評価されたものよりもずっとコストがかかる可能性があるということです。(問題がより複雑になって) 混乱してしまわないように、データコストラクタのオーバーヘッドは一旦無視して、<code>five</code> の2つの表現方法を比較してみましょう。C において <code>five</code> は正確に1つのマシンワード*を消費します。それに対して Haskell の <code>five</code> サンクはだいたい以下のようになります。</p>
<p>* またはそれよりも少ないです。<code>int</code> は32ビットですが、たぶんあなたは64ビットのマシンを使っているでしょう。しかし、整列問題によりレジスタを1つのマシンワードと言っても良いでしょう。</p>
<ul>
<li>1つのマシンワードが “私はサンクです” と主張します</li>
<li>サンクの中は <code>add</code> 関数と <code>1 + 1</code> と <code>1 + 2</code> のサンク (それぞれ1つのマシンワード) へのポインタとなっています。そのため合計で3つのマシンワードです。</li>
<li><code>1 + 1</code> のサンクはサンクのための1つのマシンワードと <code>+</code> 演算子と <code>1</code> の値へのポインタです。(GHC は int 自身の余分なオーバーヘッドを避けるためにメモリの専用部分に小さな int の値を保持する最適化を行いますが、理論的にはそれぞれの余分なマシンワードが追加されます)。ここでもまた、少なくとも3つのマシンワードが必要となります。</li>
<li>同じことが <code>1 + 2</code> のサンクにも言えるので、3つのマシンワードとなります。</li>
<li>最終的な合計は<strong>10マシンワード</strong>となり、C のメモリ使用量と比較して10倍の差があります！</li>
</ul>
<p>実際のところ、こんなに上手くはいきません。なぜなら、正格性解析によって “やぁ、ちょっと待って、これは後で使うからサンクを確保するよりも2つの数字を加算する方が絶対良いって、じゃあまたね！” という感じで最適化が行われるためです。しかし、遅延性やサンクが発生する可能性のある全ての場所を理解しておくことは、Haskell を書く上で非常に重要なことです。</p>
<h3 id="バン">バン!</h3>
<p>さて、どうすれば Haskell の評価をより正格にできるのでしょうか。一番簡単なのはバンパターンを使う方法です。まずはコードを確認してみましょう。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">{-# LANGUAGE BangPatterns #-}</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">add <span class="fu">!</span>x <span class="fu">!</span>y <span class="fu">=</span> x <span class="fu">+</span> y</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  <span class="kw">let</span> <span class="fu">!</span>five <span class="fu">=</span> add (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">1</span>) (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">      <span class="fu">!</span>seven <span class="fu">=</span> add (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>) (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb3-9" data-line-number="9"></a>
<a class="sourceLine" id="cb3-10" data-line-number="10">  putStrLn <span class="fu">$</span> <span class="st">&quot;Five: &quot;</span> <span class="fu">++</span> show five</a></code></pre></div>
<p>このコードは正格な C のコードと全く同じように振る舞います。先ほどのコードとの違いは <code>add</code> 関数の <code>x</code> と <code>y</code> の前にバン (<code>!</code>) があることです。これによって GHC は <code>add</code> を評価する前に <code>x</code> と <code>y</code> の値を評価しなければならないと判断します。同様に <code>five</code> と <code>seven</code> の前にも <code>!</code> があるため、 GHC は <code>putStrLn</code> を評価する前にこれらの値を評価します。</p>
<p>Haskell には多くのものがありますが、バンパターンはただの <code>seq</code> 関数を使ったシンタックスシュガーです。<code>seq</code> 関数の型は以下の通りです。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">seq<span class="ot"> ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b</a></code></pre></div>
<p>この型シグネチャを見ると、<code>a</code> の値を無視するような以下の実装にしたくなるでしょう。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">badseq ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">badseq a b <span class="fu">=</span> b</a></code></pre></div>
<p>けれども、 <code>seq</code> は GHC が提供しているプリミティブな操作を使って<code>b</code> が評価されるときには、既に <code>a</code> が評価されていることを保証します。ここで先ほどの <code>add</code> 関数をバンパターンの代わりに <code>seq</code> を使って書き換えてみましょう。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">add x y <span class="fu">=</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="kw">let</span> part1 <span class="fu">=</span> seq x part2</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">      part2 <span class="fu">=</span> seq y answer</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">      answer <span class="fu">=</span> x <span class="fu">+</span> y</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">   <span class="kw">in</span> part1</a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="co">-- Or more idiomatically</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">add x y <span class="fu">=</span> x <span class="ot">`seq`</span> y <span class="ot">`seq`</span> x <span class="fu">+</span> y</a></code></pre></div>
<p>このコードは以下のような意味になります。</p>
<ul>
<li><code>part1</code> は <code>x</code> を評価した後に <code>part2</code> の値を評価します</li>
<li><code>part2</code> は <code>y</code> を評価した後に <code>answer</code> の値を評価します</li>
<li><code>answer</code> はそのまま <code>x + y</code> です</li>
</ul>
<p>もちろん、<code>let</code> と <code>in</code> を使ってこんなに長いコードを書くのは大変なので、多くのプログラマは最後の行のように <code>seq</code> を中置記法で使います。</p>
<p><strong>演習</strong> <code>in part1</code> の代わりに <code>in part2</code> とした場合どうなるでしょうか？また <code>in answer</code> ではどうでしょうか？</p>
<p>バンパターンから <code>let</code> を使う方法への変換はどんな場合でも可能です。先ほどの <code>main</code> 関数は次のように書き換えても同じことです。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">let</span> five <span class="fu">=</span> add (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">1</span>) (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">      seven <span class="fu">=</span> add (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>) (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5"></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  five <span class="ot">`seq`</span> seven <span class="ot">`seq`</span> putStrLn (<span class="st">&quot;Five: &quot;</span> <span class="fu">++</span> show five)</a></code></pre></div>
<p>上記のプログラムはバンパターンを使ったものと等しく、<code>seq</code> の動作を理解するために非常に重要な例です。ですが、バンパターンのコードよりも少し読みづらくなってしまったと感じる読者もいると思います。なので、自分が読みやすい好きな方を使ってください。たぶん、ほとんどの人はバンパターンを使うでしょうけども。</p>
<h3 id="評価を追ってみよう">評価を追ってみよう</h3>
<p>今まで、サンクの評価について私の説明が全てでした。これから、評価について、もっと直接的に観測するための方法について説明します。<code>Debug.Trace</code> モジュールで定義されている <code>trace</code> 関数は評価された時にメッセージを表示します。以下の2つのプログラムの出力を予想してみてください。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Debug.Trace</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">add x y <span class="fu">=</span> x <span class="fu">+</span> y</a>
<a class="sourceLine" id="cb8-7" data-line-number="7"></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  <span class="kw">let</span> five <span class="fu">=</span> trace <span class="st">&quot;five&quot;</span> (add (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">1</span>) (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>))</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">      seven <span class="fu">=</span> trace <span class="st">&quot;seven&quot;</span> (add (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>) (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">3</span>))</a>
<a class="sourceLine" id="cb8-12" data-line-number="12"></a>
<a class="sourceLine" id="cb8-13" data-line-number="13">  putStrLn <span class="fu">$</span> <span class="st">&quot;Five: &quot;</span> <span class="fu">++</span> show five</a></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="ot">{-# LANGUAGE BangPatterns #-}</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Debug.Trace</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"></a>
<a class="sourceLine" id="cb9-6" data-line-number="6"><span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">add x y <span class="fu">=</span> x <span class="fu">+</span> y</a>
<a class="sourceLine" id="cb9-8" data-line-number="8"></a>
<a class="sourceLine" id="cb9-9" data-line-number="9"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-11" data-line-number="11">  <span class="kw">let</span> <span class="fu">!</span>five <span class="fu">=</span> trace <span class="st">&quot;five&quot;</span> (add (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">1</span>) (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>))</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">      <span class="fu">!</span>seven <span class="fu">=</span> trace <span class="st">&quot;seven&quot;</span> (add (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>) (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">3</span>))</a>
<a class="sourceLine" id="cb9-13" data-line-number="13"></a>
<a class="sourceLine" id="cb9-14" data-line-number="14">  putStrLn <span class="fu">$</span> <span class="st">&quot;Five: &quot;</span> <span class="fu">++</span> show five</a></code></pre></div>
<p>それぞれのプログラムで表示される内容は・・・</p>
<p>もうわかりましたね。答えは以下の通りです。</p>
<ul>
<li>最初のプログラムは <code>five</code> と <code>Five: 5</code> の両方を表示します。<code>seven</code> は式が評価されないため、表示されません。(出力のバッファリングによっては、これらの値の表示順序が入れ替わるという奇妙な現象が起きることがあります。)</li>
<li>2つ目のプログラムは <code>five</code> と <code>seven</code> の両方を表示します。なぜなら、バンパターンによってこれらの評価が強制されるからです。しかし、この表示順についてはあなたが期待するものと異なっていたのではないでしょうか。現に、私のシステムでは <code>five</code> が表示される前に <code>seven</code> が表示されました。なぜなら、この場合において GHC は評価順を並び替えることができるからです。</li>
<li>逆に <code>five `seq` seven `seq` putStrLn (&quot;Five: &quot; ++ show five)</code> としていたら、表示される順序は <code>five</code>, <code>seven</code>, <code>&quot;Five: 5&quot;</code> となっていたでしょう。これはバンパターンが単に <code>seq</code> に変換されるという先ほどの説明でほんの少しだけ嘘をついたからです。しかし、 <code>x `seq` y</code> という式は実際のところ、GHC からすれば <code>x</code> と <code>y</code> のどちらを先に評価したとしても、式の評価が終わった時に <code>x</code> と <code>y</code> の両方が評価されていることが保証されていれば良いのです。</li>
</ul>
<p>とはいえ、あたなの式が本当に純粋であれば、<code>x</code> と <code>y</code> の評価がどちらから行われるかということは観測できなかったはずです。純粋では無い <code>trace</code> 関数を利用したからこそ、評価の順序を観測することができたんです。</p>
<p><strong>質問</strong> もし、全ての <code>add</code> 関数に <code>!</code> をつけたら結果はどう変わるでしょうか？ なぜ <code>!</code> を付けるだけで出力に影響したり (しなかったり) するのでしょうか？</p>
<h3 id="ボトムの値">ボトムの値</h3>
<p>今までの例もちゃんと動くので良いのですが、評価の順番を確認する方法として、よりスタンダードな方法があります。それはボトム、すなわち <code>undefined</code> を使うことです。<code>undefined</code> は、評価されたときに実行時例外を投げる点で特別です。 (他の特別な関数や値のように、<code>error</code> 関数も同じ動きをします。) バンが無い場合は <code>seven</code> が評価されないことを確認するために、以下の2つのプログラムを比較してみましょう:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="ot">{-# LANGUAGE BangPatterns #-}</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">add x y <span class="fu">=</span> x <span class="fu">+</span> y</a>
<a class="sourceLine" id="cb10-7" data-line-number="7"></a>
<a class="sourceLine" id="cb10-8" data-line-number="8"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-10" data-line-number="10">  <span class="kw">let</span> five <span class="fu">=</span> add (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">1</span>) (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb10-11" data-line-number="11">      seven <span class="fu">=</span> add (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>) undefined <span class="co">-- (1 + 3)</span></a>
<a class="sourceLine" id="cb10-12" data-line-number="12"></a>
<a class="sourceLine" id="cb10-13" data-line-number="13">  putStrLn <span class="fu">$</span> <span class="st">&quot;Five: &quot;</span> <span class="fu">++</span> show five</a></code></pre></div>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="ot">{-# LANGUAGE BangPatterns #-}</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"></a>
<a class="sourceLine" id="cb11-5" data-line-number="5"><span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">add x y <span class="fu">=</span> x <span class="fu">+</span> y</a>
<a class="sourceLine" id="cb11-7" data-line-number="7"></a>
<a class="sourceLine" id="cb11-8" data-line-number="8"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">  <span class="kw">let</span> five <span class="fu">=</span> add (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">1</span>) (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">      <span class="fu">!</span>seven <span class="fu">=</span> add (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>) undefined <span class="co">-- (1 + 3)</span></a>
<a class="sourceLine" id="cb11-12" data-line-number="12"></a>
<a class="sourceLine" id="cb11-13" data-line-number="13">  putStrLn <span class="fu">$</span> <span class="st">&quot;Five: &quot;</span> <span class="fu">++</span> show five</a></code></pre></div>
<p>最初の例は問題なく実行することができます。これは <code>seven</code> が評価されないからですね。しかし、2つ目の例では、<code>seven</code> にバンパターンが付いています。ここで、GHC はこんなことをしています:</p>
<ul>
<li><code>add (1 + 2) undefined</code> と言う式を評価します。</li>
<li>この式は <code>(1 + 2) + undefined</code> に簡約されます。</li>
<li>しかし、簡約した結果は値ではなく式なので、さらに評価が必要になります。</li>
<li><code>+</code> という演算子を評価するためには、2つの引数にサンクではなく実際の値が必要になります。このことは <code>+</code> の引数がバンパターンとなっているという見方をしても良いでしょう。より正確には、「<code>+</code> は2つの引数のどちらに対しても正格」と言います。</li>
<li>GHC は <code>1 + 2</code> と <code>undefined</code> の評価順を自由に選択できます。ここでは <code>1 + 2</code> を最初に評価することにしましょう。そうすると、2つの評価済みの値 (<code>1</code> と <code>2</code>) を <code>+</code> に渡すので、<code>3</code> が返ってきます。全て順調ですね。</li>
<li>しかし、次に <code>undefined</code> を評価しようとして、実行時例外が投げられます。</li>
</ul>
<p><strong>質問</strong> 上の質問に戻りますが: <code>add</code> 関数の内部にバンパターンを持たせたら、何か変わるでしょうか? 以下のプログラムの出力が何になるか考えてみてください:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="ot">{-# LANGUAGE BangPatterns #-}</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">add <span class="fu">!</span>x <span class="fu">!</span>y <span class="fu">=</span> x <span class="fu">+</span> y</a>
<a class="sourceLine" id="cb12-7" data-line-number="7"></a>
<a class="sourceLine" id="cb12-8" data-line-number="8"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">  <span class="kw">let</span> five <span class="fu">=</span> add (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">1</span>) (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb12-11" data-line-number="11">      seven <span class="fu">=</span> add (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">2</span>) undefined <span class="co">-- (1 + 3)</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12"></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">  putStrLn <span class="fu">$</span> <span class="st">&quot;Five: &quot;</span> <span class="fu">++</span> show five</a></code></pre></div>
<p>この動作を正格な言語と比較するためには、実行時例外のようなものを持つ言語が必要ですね。Rust の panic を使うことにしましょう:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">fn</span> add(x: <span class="dt">isize</span>, y: <span class="dt">isize</span>) -&gt; <span class="dt">isize</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">    <span class="pp">println!</span>(<span class="st">&quot;adding: {} and {}&quot;</span>, x, y);</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    x + y</a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="op">}</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5"></a>
<a class="sourceLine" id="cb13-6" data-line-number="6"><span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    <span class="kw">let</span> five = add(<span class="dv">1</span> + <span class="dv">1</span>, <span class="dv">1</span> + <span class="dv">2</span>);</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">    <span class="kw">let</span> seven = add(<span class="dv">1</span> + <span class="dv">2</span>, <span class="pp">panic!</span>());</a>
<a class="sourceLine" id="cb13-9" data-line-number="9"></a>
<a class="sourceLine" id="cb13-10" data-line-number="10">    <span class="pp">println!</span>(<span class="st">&quot;Five: {}&quot;</span>, five);</a>
<a class="sourceLine" id="cb13-11" data-line-number="11"><span class="op">}</span></a></code></pre></div>
<p>まず、Rust の名誉のために一言断っておくと、Rust は、このプログラムがどんなにバカげたことをしているのか、多くの警告を出してくれます。確かにそれはそうなんですが、これらの警告は無視して突っ走りましょう。このプログラムは、まず最初に <code>add(1 + 1, 1 + 2)</code> という式を評価します (<code>adding: 2 and 3</code> という出力で確認できます)。そして、2回目の <code>add</code> 関数に入る前に、<code>1 + 2</code> と <code>panic!()</code> のどちらも評価する必要があります。前者はいいですが、後者ではパニックが発生し、そこでショートします。</p>
<p>Haskell の遅延性を獲得したいのなら、簡単な方法があります。クロージャを使いましょう。クロージャは本質的にはサンクです。Rust の構文でクロージャを書くと、<code>|args| body</code> のようになります。引数なしのクロージャを作ると、サンクのような振る舞いをします。こんな感じです:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">fn</span> add&lt;X, Y&gt;(x: X, y: Y) -&gt; <span class="dt">isize</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">    <span class="kw">where</span> X: <span class="bu">FnOnce</span>() -&gt; <span class="dt">isize</span>,</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">          Y: <span class="bu">FnOnce</span>() -&gt; <span class="dt">isize</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    <span class="kw">let</span> x = x();</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    <span class="kw">let</span> y = y();</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    <span class="pp">println!</span>(<span class="st">&quot;adding: {} and {}&quot;</span>, x, y);</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    x + y</a>
<a class="sourceLine" id="cb14-8" data-line-number="8"><span class="op">}</span></a>
<a class="sourceLine" id="cb14-9" data-line-number="9"></a>
<a class="sourceLine" id="cb14-10" data-line-number="10"><span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb14-11" data-line-number="11">    <span class="kw">let</span> five = || add(|| <span class="dv">1</span> + <span class="dv">1</span>, || <span class="dv">1</span> + <span class="dv">2</span>);</a>
<a class="sourceLine" id="cb14-12" data-line-number="12">    <span class="kw">let</span> seven = || add(|| <span class="dv">1</span> + <span class="dv">2</span>, || <span class="pp">panic!</span>());</a>
<a class="sourceLine" id="cb14-13" data-line-number="13"></a>
<a class="sourceLine" id="cb14-14" data-line-number="14">    <span class="pp">println!</span>(<span class="st">&quot;Five: {}&quot;</span>, five());</a>
<a class="sourceLine" id="cb14-15" data-line-number="15"><span class="op">}</span></a></code></pre></div>
<p>繰り返しますが、Rust のコンパイラは使われていない <code>seven</code> について文句を言ってきます。が、<code>seven</code> のクロージャを使うことはないので、このプログラムを実行することはできます。</p>
<p>まだ Rust についてあまり知らない? それなら、みんな大好き Javascript を使ってみましょう:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">function</span> <span class="at">add</span>(x<span class="op">,</span> y) <span class="op">{</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">    <span class="cf">return</span> <span class="at">x</span>() <span class="op">+</span> <span class="at">y</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="op">}</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"></a>
<a class="sourceLine" id="cb15-5" data-line-number="5"><span class="kw">function</span> <span class="at">panic</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6">    <span class="cf">throw</span> <span class="st">&quot;Panic!&quot;</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="op">}</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8"></a>
<a class="sourceLine" id="cb15-9" data-line-number="9"><span class="kw">var</span> five <span class="op">=</span> ignored <span class="op">=&gt;</span> <span class="at">add</span>(ignored <span class="op">=&gt;</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> ignored <span class="op">=&gt;</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb15-10" data-line-number="10"><span class="kw">var</span> seven <span class="op">=</span> ignored <span class="op">=&gt;</span> <span class="at">add</span>(ignored <span class="op">=&gt;</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span><span class="op">,</span> panic)<span class="op">;</span></a>
<a class="sourceLine" id="cb15-11" data-line-number="11"><span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;Five: &quot;</span> <span class="op">+</span> <span class="at">five</span>())<span class="op">;</span></a></code></pre></div>
<p>よし、今までの話をまとめてみます:</p>
<ul>
<li>Haskell の評価戦略はデフォルトで遅延評価です。</li>
<li>バンパターンと <code>seq</code> を使うことで、正格評価にすることができます。</li>
<li>一方、正格な言語ではクロージャを使うことで遅延評価にすることができます。</li>
<li>ボトム (<code>undefined</code>) を関数の引数に渡して、目の前で爆発すれば、関数の引数が正格だとわかります。</li>
<li><code>trace</code> 関数を使っても同じことを確認できます。</li>
</ul>
<p>ここまでは全て順調ですね。先に進む前に、これらの概念を確実に理解しておいてください。前の章を読み直すのもいいかもしれません。</p>
<h2 id="平均">平均</h2>
<p>まだ言及してないことがありました。「評価する」とか「値であることを強要する」というのは具体的にどういうことなのでしょう? この問題を考えるために、average 関数を実装してみましょう。<code>RunningTotal</code> というデータ型を使って、平均値の合計と要素数を取得することにします。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">data</span> <span class="dt">RunningTotal</span> <span class="fu">=</span> <span class="dt">RunningTotal</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  {<span class="ot"> sum ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  ,<span class="ot"> count ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb16-5" data-line-number="5"></a>
<a class="sourceLine" id="cb16-6" data-line-number="6"><span class="ot">printAverage ::</span> <span class="dt">RunningTotal</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb16-7" data-line-number="7">printAverage (<span class="dt">RunningTotal</span> sum count)</a>
<a class="sourceLine" id="cb16-8" data-line-number="8">  <span class="fu">|</span> count <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> error <span class="st">&quot;Need at least one value!&quot;</span></a>
<a class="sourceLine" id="cb16-9" data-line-number="9">  <span class="fu">|</span> otherwise <span class="fu">=</span> print (fromIntegral sum <span class="fu">/</span> fromIntegral<span class="ot"> count ::</span> <span class="dt">Double</span>)</a>
<a class="sourceLine" id="cb16-10" data-line-number="10"></a>
<a class="sourceLine" id="cb16-11" data-line-number="11"><span class="co">-- | A fold would be nicer... we&#39;ll see that later</span></a>
<a class="sourceLine" id="cb16-12" data-line-number="12"><span class="ot">printListAverage ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb16-13" data-line-number="13">printListAverage <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-14" data-line-number="14">  go (<span class="dt">RunningTotal</span> <span class="dv">0</span> <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb16-15" data-line-number="15">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-16" data-line-number="16">    go rt [] <span class="fu">=</span> printAverage rt</a>
<a class="sourceLine" id="cb16-17" data-line-number="17">    go (<span class="dt">RunningTotal</span> sum count) (x<span class="fu">:</span>xs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-18" data-line-number="18">      <span class="kw">let</span> rt <span class="fu">=</span> <span class="dt">RunningTotal</span> (sum <span class="fu">+</span> x) (count <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb16-19" data-line-number="19">       <span class="kw">in</span> go rt xs</a>
<a class="sourceLine" id="cb16-20" data-line-number="20"></a>
<a class="sourceLine" id="cb16-21" data-line-number="21"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb16-22" data-line-number="22">main <span class="fu">=</span> printListAverage [<span class="dv">1</span><span class="fu">..</span><span class="dv">1000000</span>]</a></code></pre></div>
<p>実行時に統計を取って、メモリ使用量を見てみます:</p>
<pre class="shell"><code>$ stack ghc average.hs &amp;&amp; ./average +RTS -s</code></pre>
<p>なんということでしょう。メモリ使用量がぶっ飛んだことになっています!</p>
<pre class="shell"><code>[1 of 1] Compiling Main             ( average.hs, average.o )
Linking average ...
500000.5
     258,654,528 bytes allocated in the heap
     339,889,944 bytes copied during GC
      95,096,512 bytes maximum residency (9 sample(s))
       1,148,312 bytes maximum slop
             164 MB total memory in use (0 MB lost due to fragmentation)</code></pre>
<p>トータルで 258MB も確保していて、一度に 95MB も確保しています。ただの局所関数の再帰にしては、ばかみたいに多いですね。</p>
<h3 id="バン-1">バン!</h3>
<p>あなたは今、「<code>seq</code> とかバンパターンのようなものを使うべきじゃないの?」と考えていると思います。確かに、それも良いでしょう。実際、1つバンパターンを加えて <code>go</code> の再帰に入る前に新しい <code>rt</code> を強制評価すれば、この問題は簡単に解決できそうです。例えば、<code>{-# LANGUAGE BangPatterns #-}</code> をファイルの先頭に追加して、<code>go</code> をこんな風に定義したらどうでしょう:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">go <span class="fu">!</span>rt [] <span class="fu">=</span> printAverage rt</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">go (<span class="dt">RunningTotal</span> sum count) (x<span class="fu">:</span>xs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  <span class="kw">let</span> rt <span class="fu">=</span> <span class="dt">RunningTotal</span> (sum <span class="fu">+</span> x) (count <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">   <span class="kw">in</span> go rt xs</a></code></pre></div>
<p>しかし、こうしてもメモリ使用量は<em>全く</em>変わりません。なぜこんなことになってしまうのでしょう。これを理解するためには、weak head normal form (弱頭部正規形) というものを理解する必要があります。</p>
<h3 id="弱頭部正規形">弱頭部正規形</h3>
<p>まず最初に、このトピックに関して <a href="https://stackoverflow.com/questions/6872898/haskell-what-is-weak-head-normal-form/6889335#6889335">Stack Overflow に素晴らしい回答があることを</a>示しておきます。</p>
<p>私たちは値であることを強制し、式を評価することについて話し合ってきましたが、それが実際に何を意味しているのかは全く明らかにしませんでした。まず簡単な例から始めましょう。このプログラムの出力はどうなるでしょうか?</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1">main <span class="fu">=</span> putStrLn <span class="fu">$</span> undefined <span class="ot">`seq`</span> <span class="st">&quot;Hello World&quot;</span></a></code></pre></div>
<p>文字列を表示しようとしたときに <code>undefined</code> が原因でエラーになるだろうと予測した方は正解です。このエラーは <code>putStrLn</code> が引数に対して正格であり、また <code>&quot;Hello World&quot;</code> を評価する前に <code>undefined</code> を評価しようとするために起こります。では、少し違う例を試してみましょう:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1">main <span class="fu">=</span> putStrLn <span class="fu">$</span> <span class="dt">Just</span> undefined <span class="ot">`seq`</span> <span class="st">&quot;Hello World&quot;</span></a></code></pre></div>
<p>「評価する」という言葉を、「サンクがない状態の何かになるまで完全に評価する」という意味で取っている人は、今回も <code>undefined</code> についてエラーを吐く、と答えるでしょう。しかし実際は、例外を吐かずにうまく “Hello World” と表示してくれます。一体どうなっているんでしょう?</p>
<p>実は、<code>seq</code> で強制評価について話しているときは、<em>弱頭部正規形 (weak head normal form) (WHNF)</em> へ評価するという意味で話しています。ほとんどのデータ型において、これは 1つコンストラクタの層を引き剥がす、という意味になります。<code>Just undefined</code> の場合、<code>Just</code> というデータコンストラクタを引き剥がすだけで、その中の <code>undefined</code> に触れることはありません。(すぐ下でこれに対処する別々の方法をお見せします。)</p>
<p>標準データコンストラクタ*を扱う場合、<code>seq</code> を利用するということは一番外側のコンストラクタでパターンマッチさせるようなものです。単相化させたいのなら、例えば、<code>seqMaybe :: Maybe a -&gt; b -&gt; b</code> という関数を実装して、上の <code>main</code> で使うことができます。やってみてください。答えは下にあります。</p>
<ul>
<li>説明はお待ちください。後で <code>newtype</code> の話を読めば、この変なネーミングの意味を理解できるでしょう。</li>
</ul>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="ot">seqMaybe ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb22-2" data-line-number="2">seqMaybe <span class="dt">Nothing</span> b <span class="fu">=</span> b</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">seqMaybe (<span class="dt">Just</span> _) b <span class="fu">=</span> b</a>
<a class="sourceLine" id="cb22-4" data-line-number="4"></a>
<a class="sourceLine" id="cb22-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb22-6" data-line-number="6">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb22-7" data-line-number="7">  putStrLn <span class="fu">$</span> <span class="dt">Just</span> undefined <span class="ot">`seqMaybe`</span> <span class="st">&quot;Hello World&quot;</span></a>
<a class="sourceLine" id="cb22-8" data-line-number="8">  putStrLn <span class="fu">$</span> undefined <span class="ot">`seqMaybe`</span> <span class="st">&quot;Goodbye!&quot;</span></a></code></pre></div>
<p>では、続けましょう。このプログラムは何を表示すると思いますか?</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">  putStrLn <span class="fu">$</span> error <span class="ot">`seq`</span> <span class="st">&quot;Hello&quot;</span></a>
<a class="sourceLine" id="cb23-3" data-line-number="3">  putStrLn <span class="fu">$</span> (\x <span class="ot">-&gt;</span> undefined) <span class="ot">`seq`</span> <span class="st">&quot;World&quot;</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4">  putStrLn <span class="fu">$</span> error <span class="st">&quot;foo&quot;</span> <span class="ot">`seq`</span> <span class="st">&quot;Goodbye!&quot;</span></a></code></pre></div>
<p><code>error `seq` ...</code> が問題になると思うかもしれません。最終的に <code>error</code> が例外を吐くんじゃないの? ってね。しかし、<code>error</code> は関数です。<code>error</code> が <code>String</code> の値を引数に与えられるまで、例外が吐かれることも、ボトムの値が返されることもないのです。よって、これを評価してもエラーを生成することはありません。ルールとしては、引数よりも少ない値に適用された関数は、自動的に弱頭部正規形になります。</p>
<p>同じようなロジックは、<code>(\x -&gt; undefined)</code> にも適用できます。これはラムダ式ですが、型としては全ての引数に値が適用されていない関数です。したがって、このラムダ式が評価されても例外を吐くことはありません。言い換えると、この式はすでに弱頭部正規形になっています。</p>
<p>しかし、<code>error &quot;foo&quot;</code> は引数が完全に適用された関数です。これはもう関数ではなく、値です。そして弱頭部正規形に評価しようとするときに、例外が爆発して顔面に飛んできます。</p>
<p><strong>演習</strong> 次の式は、評価されたときに例外を投げるでしょうか?</p>
<ul>
<li><code>(+) undefined</code></li>
<li><code>Just undefined</code></li>
<li><code>undefined 5</code></li>
<li><code>(error &quot;foo&quot; :: Int -&gt; Double)</code></li>
</ul>
<h3 id="average-関数を修正する">average 関数を修正する</h3>
<p>弱頭部正規形を理解したところで、例に戻って最初のバンパターンが、なぜ何もしてくれなかったのか見てみましょう:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1">go <span class="fu">!</span>rt [] <span class="fu">=</span> printAverage rt</a>
<a class="sourceLine" id="cb24-2" data-line-number="2">go (<span class="dt">RunningTotal</span> sum count) (x<span class="fu">:</span>xs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb24-3" data-line-number="3">  <span class="kw">let</span> rt <span class="fu">=</span> <span class="dt">RunningTotal</span> (sum <span class="fu">+</span> x) (count <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">   <span class="kw">in</span> go rt xs</a></code></pre></div>
<p>弱頭部正規形では、強制評価はコンストラクタを剥がすことと同じです。これはさっきの節でもうやりましたね! 問題は、<code>RunningTotal</code> データコンストラクタの中に含まれる値が評価されていないこと、それが原因でサンクが蓄積されていることです。これを解決する方法は2つあります。</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1">go rt [] <span class="fu">=</span> printAverage rt</a>
<a class="sourceLine" id="cb25-2" data-line-number="2">go (<span class="dt">RunningTotal</span> <span class="fu">!</span>sum <span class="fu">!</span>count) (x<span class="fu">:</span>xs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3">  <span class="kw">let</span> rt <span class="fu">=</span> <span class="dt">RunningTotal</span> (sum <span class="fu">+</span> x) (count <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">   <span class="kw">in</span> go rt xs</a></code></pre></div>
<p>バンを <code>RunningTotal</code> に置くのはやめて、コンストラクタの<em>中</em>の値に置いて、ループの度に強制的に評価させるようにしています。巨大なサンクの連鎖は無くなり、最大メモリ常駐量は 44kb にまで減少しています。(全体としては、まだ約 192mb 使用しています。これをどうにかするためには、今回の例とは異なる別の最適化を行う必要があります。なので、この値はこの例では全て無視することにします。) もう1つのアプローチは:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1">go rt [] <span class="fu">=</span> printAverage rt</a>
<a class="sourceLine" id="cb26-2" data-line-number="2">go (<span class="dt">RunningTotal</span> sum count) (x<span class="fu">:</span>xs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3">  <span class="kw">let</span> <span class="fu">!</span>sum&#39; <span class="fu">=</span> sum <span class="fu">+</span> x</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">      <span class="fu">!</span>count&#39; <span class="fu">=</span> count <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb26-5" data-line-number="5">      rt <span class="fu">=</span> <span class="dt">RunningTotal</span> sum&#39; count&#39;</a>
<a class="sourceLine" id="cb26-6" data-line-number="6">   <span class="kw">in</span> go rt xs</a></code></pre></div>
<p>このアプローチでは新しい <code>RunningTotal</code> の値を作る<em>前</em>に、新しい sum と count を強制評価します。私はこのバージョンの方がちょっと好きです。というのも、次の繰り返しで値を分解した時ではなく、正しい場所、つまり値を構築するときに評価を強制しているからです。</p>
<p>この話のポイント: コンテナではなく、実際に評価する必要があるものを評価していることを確認すべし</p>
<h4 id="翻訳者追記">翻訳者追記</h4>
<p>実行結果を比較してみました。</p>
<h5 id="section">1</h5>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1">go rt [] <span class="fu">=</span> printAverage rt</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">go (<span class="dt">RunningTotal</span> sum count) (x<span class="fu">:</span>xs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">  <span class="kw">let</span> rt <span class="fu">=</span> <span class="dt">RunningTotal</span> (sum <span class="fu">+</span> x) (count <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">   <span class="kw">in</span> go rt xs</a></code></pre></div>
<h5 id="section-1">2</h5>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">go <span class="fu">!</span>rt [] <span class="fu">=</span> printAverage rt</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">go (<span class="dt">RunningTotal</span> sum count) (x<span class="fu">:</span>xs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb28-3" data-line-number="3">  <span class="kw">let</span> rt <span class="fu">=</span> <span class="dt">RunningTotal</span> (sum <span class="fu">+</span> x) (count <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">   <span class="kw">in</span> go rt xs</a></code></pre></div>
<h5 id="section-2">3</h5>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1">go rt [] <span class="fu">=</span> printAverage rt</a>
<a class="sourceLine" id="cb29-2" data-line-number="2">go (<span class="dt">RunningTotal</span> <span class="fu">!</span>sum <span class="fu">!</span>count) (x<span class="fu">:</span>xs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3">  <span class="kw">let</span> rt <span class="fu">=</span> <span class="dt">RunningTotal</span> (sum <span class="fu">+</span> x) (count <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">   <span class="kw">in</span> go rt xs</a></code></pre></div>
<h5 id="section-3">4</h5>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1">go rt [] <span class="fu">=</span> printAverage rt</a>
<a class="sourceLine" id="cb30-2" data-line-number="2">go (<span class="dt">RunningTotal</span> sum count) (x<span class="fu">:</span>xs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb30-3" data-line-number="3">  <span class="kw">let</span> <span class="fu">!</span>sum&#39; <span class="fu">=</span> sum <span class="fu">+</span> x</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">      <span class="fu">!</span>count&#39; <span class="fu">=</span> count <span class="fu">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb30-5" data-line-number="5">      rt <span class="fu">=</span> <span class="dt">RunningTotal</span> sum&#39; count&#39;</a>
<a class="sourceLine" id="cb30-6" data-line-number="6">   <span class="kw">in</span> go rt xs</a></code></pre></div>
<h5 id="原文にはありませんがrunningtotal-の定義で正格性注釈をつけています">5 原文にはありませんが、<code>RunningTotal</code> の定義で正格性注釈をつけています。</h5>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="kw">data</span> <span class="dt">RunningTotal</span> <span class="fu">=</span> <span class="dt">RunningTotal</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2">  {<span class="ot"> sum ::</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb31-3" data-line-number="3">  ,<span class="ot"> count ::</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb31-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb31-5" data-line-number="5"></a>
<a class="sourceLine" id="cb31-6" data-line-number="6">go rt [] <span class="fu">=</span> printAverage rt</a>
<a class="sourceLine" id="cb31-7" data-line-number="7">go (<span class="dt">RunningTotal</span> sum count) (x<span class="fu">:</span>xs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb31-8" data-line-number="8">  <span class="kw">let</span> rt <span class="fu">=</span> <span class="dt">RunningTotal</span> (sum <span class="fu">+</span> x) (count <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb31-9" data-line-number="9">   <span class="kw">in</span> go rt xs</a></code></pre></div>
<h5 id="これも原文にはありませんがstrictdata-拡張を使っています">6 これも原文にはありませんが、<code>StrictData</code> 拡張を使っています。</h5>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="ot">{-# LANGUAGE StrictData #-}</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2"></a>
<a class="sourceLine" id="cb32-3" data-line-number="3">go rt [] <span class="fu">=</span> printAverage rt</a>
<a class="sourceLine" id="cb32-4" data-line-number="4">go (<span class="dt">RunningTotal</span> sum count) (x<span class="fu">:</span>xs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb32-5" data-line-number="5">  <span class="kw">let</span> rt <span class="fu">=</span> <span class="dt">RunningTotal</span> (sum <span class="fu">+</span> x) (count <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb32-6" data-line-number="6">   <span class="kw">in</span> go rt xs</a></code></pre></div>
<h5 id="deepseq-のセクションのものです">7 deepseq のセクションのものです</h5>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="kw">data</span> <span class="dt">RunningTotal</span> <span class="fu">=</span> <span class="dt">RunningTotal</span></a>
<a class="sourceLine" id="cb33-2" data-line-number="2">  {<span class="ot"> sum ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb33-3" data-line-number="3">  ,<span class="ot"> count ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb33-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb33-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">NFData</span> <span class="dt">RunningTotal</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-6" data-line-number="6">  rnf (<span class="dt">RunningTotal</span> sum count) <span class="fu">=</span> sum <span class="ot">`deepseq`</span> count <span class="ot">`deepseq`</span> ()</a></code></pre></div>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>allocated in the heap</td>
<td>258,654,520 bytes</td>
<td>258,654,520 bytes</td>
<td>192,102,712 bytes</td>
<td>216,102,712 bytes</td>
<td>176,102,712 bytes</td>
<td>176,102,712 bytes</td>
<td>256,135,480 bytes</td>
</tr>
<tr class="even">
<td>copied during GC</td>
<td>339,889,944 bytes</td>
<td>339,889,944 bytes</td>
<td>173,080 bytes</td>
<td>142,896 bytes</td>
<td>164,400 bytes</td>
<td>164,400 bytes</td>
<td>168,640 bytes</td>
</tr>
<tr class="odd">
<td>maximum residency</td>
<td>95,096,512 bytes</td>
<td>95,096,512 bytes</td>
<td>44,384 bytes</td>
<td>44,384 bytes</td>
<td>44,384 bytes</td>
<td>44,384 bytes</td>
<td>44,384 bytes</td>
</tr>
<tr class="even">
<td>maximum slop</td>
<td>1,148,312 byte</td>
<td>1,148,312 bytes</td>
<td>25,248 bytes</td>
<td>25,248 bytes</td>
<td>25,248 bytes</td>
<td>25,248 bytes</td>
<td>25,248 bytes</td>
</tr>
<tr class="odd">
<td>total memory in use</td>
<td>164 MB</td>
<td>164 MB</td>
<td>1 MB</td>
<td>1 MB</td>
<td>1 MB</td>
<td>1 MB</td>
<td>1 MB</td>
</tr>
</tbody>
</table>
<h3 id="deepseq">deepseq</h3>
<p><code>seq</code> が弱頭部正規形にしか評価してくれないのはイライラしますよね。<em>正規形</em> (NF) にまで完全に評価したいという状況はいくらでもあります。つまり、値の中の全てのサンクを評価したいということですね。言語レベルでこれを制御する方法はありませんが、半分標準の (GHC についてくるということ) ライブラリに <code>deepseq</code> 関数があります。<code>deepseq</code> は <code>NFData</code> 型クラスの <code>rnf</code> (<strong>r</strong>educe a value to <strong>n</strong>ormal <strong>f</strong>orm) メソッドを使って定義されています。<code>rnf</code> メソッドは値を正規形に簡約する方法を提供します。</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Control.DeepSeq</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2"></a>
<a class="sourceLine" id="cb34-3" data-line-number="3"><span class="kw">data</span> <span class="dt">RunningTotal</span> <span class="fu">=</span> <span class="dt">RunningTotal</span></a>
<a class="sourceLine" id="cb34-4" data-line-number="4">  {<span class="ot"> sum ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb34-5" data-line-number="5">  ,<span class="ot"> count ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb34-6" data-line-number="6">  }</a>
<a class="sourceLine" id="cb34-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">NFData</span> <span class="dt">RunningTotal</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-8" data-line-number="8">  rnf (<span class="dt">RunningTotal</span> sum count) <span class="fu">=</span> sum <span class="ot">`deepseq`</span> count <span class="ot">`deepseq`</span> ()</a>
<a class="sourceLine" id="cb34-9" data-line-number="9"></a>
<a class="sourceLine" id="cb34-10" data-line-number="10"><span class="ot">printAverage ::</span> <span class="dt">RunningTotal</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb34-11" data-line-number="11">printAverage (<span class="dt">RunningTotal</span> sum count)</a>
<a class="sourceLine" id="cb34-12" data-line-number="12">  <span class="fu">|</span> count <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> error <span class="st">&quot;Need at least one value!&quot;</span></a>
<a class="sourceLine" id="cb34-13" data-line-number="13">  <span class="fu">|</span> otherwise <span class="fu">=</span> print (fromIntegral sum <span class="fu">/</span> fromIntegral<span class="ot"> count ::</span> <span class="dt">Double</span>)</a>
<a class="sourceLine" id="cb34-14" data-line-number="14"></a>
<a class="sourceLine" id="cb34-15" data-line-number="15"><span class="co">-- | A fold would be nicer... we&#39;ll see that later</span></a>
<a class="sourceLine" id="cb34-16" data-line-number="16"><span class="ot">printListAverage ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb34-17" data-line-number="17">printListAverage <span class="fu">=</span></a>
<a class="sourceLine" id="cb34-18" data-line-number="18">  go (<span class="dt">RunningTotal</span> <span class="dv">0</span> <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb34-19" data-line-number="19">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-20" data-line-number="20">    go rt [] <span class="fu">=</span> printAverage rt</a>
<a class="sourceLine" id="cb34-21" data-line-number="21">    go (<span class="dt">RunningTotal</span> sum count) (x<span class="fu">:</span>xs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb34-22" data-line-number="22">      <span class="kw">let</span> rt <span class="fu">=</span> <span class="dt">RunningTotal</span> (sum <span class="fu">+</span> x) (count <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb34-23" data-line-number="23">       <span class="kw">in</span> rt <span class="ot">`deepseq`</span> go rt xs</a>
<a class="sourceLine" id="cb34-24" data-line-number="24"></a>
<a class="sourceLine" id="cb34-25" data-line-number="25"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb34-26" data-line-number="26">main <span class="fu">=</span> printListAverage [<span class="dv">1</span><span class="fu">..</span><span class="dv">1000000</span>]</a></code></pre></div>
<p>もう一度言いますが、このプログラムの最大メモリ常駐量は 44kb です。ここでは <code>rnf</code> を含む　<code>NFData</code> 型クラスのインスタンスを定義します。単純にデータコンストラクタ中の全ての値を <code>deepseq</code> するという方法は、<code>NFData</code> インスタンスを定義するときに良く用いられます。これは常套手段なので、実は <code>Generic</code> 導出を使うだけで GHC は自動的にインスタンスを定義します。</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2"><span class="kw">import</span> <span class="dt">GHC.Generics</span> (<span class="dt">Generic</span>)</a>
<a class="sourceLine" id="cb35-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Control.DeepSeq</span></a>
<a class="sourceLine" id="cb35-4" data-line-number="4"></a>
<a class="sourceLine" id="cb35-5" data-line-number="5"><span class="kw">data</span> <span class="dt">RunningTotal</span> <span class="fu">=</span> <span class="dt">RunningTotal</span></a>
<a class="sourceLine" id="cb35-6" data-line-number="6">  {<span class="ot"> sum ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb35-7" data-line-number="7">  ,<span class="ot"> count ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb35-8" data-line-number="8">  }</a>
<a class="sourceLine" id="cb35-9" data-line-number="9">  <span class="kw">deriving</span> <span class="dt">Generic</span></a>
<a class="sourceLine" id="cb35-10" data-line-number="10"><span class="kw">instance</span> <span class="dt">NFData</span> <span class="dt">RunningTotal</span></a></code></pre></div>
<p><code>NFData</code> 型クラスのインスタンスにすることの一番の魅力は、多くのデータ型に対する抽象化の能力です。(ここでやっているように) スペースリークを避けるだけではなく、値の中のサンクに例外が誤って含まれてしまうというようなことも防げます。例として、<a href="https://haskell-lang.org/library/safe-exceptions">safe-exceptions library</a> の <a href="https://www.stackage.org/haddock/lts-9.3/safe-exceptions-0.1.6.0/Control-Exception-Safe.html#v:tryAnyDeep">tryAnyDeep</a> 関数を見てみてください。</p>
<p><strong>演習</strong> <code>rnf</code> と <code>seq</code> を使って <code>deepseq</code> を自分で定義してみてください。</p>
<h4 id="翻訳者追記-1">翻訳者追記</h4>
<p>演習の解答例</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="ot">deepseq ::</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb36-2" data-line-number="2">deepseq x y <span class="fu">=</span> rnf x <span class="ot">`seq`</span> y</a></code></pre></div>
<h3 id="正格なデータ">正格なデータ</h3>
<p>これらのアプローチはうまくいきましたが、最適解ではありません。問題は <code>RunningTotal</code> の定義に存在します。ここで私たちが考えているのは、<code>RunningTotal</code> 型の値があるとき、実は2つの <code>Int</code> が存在しているということです。しかし遅延性のせいで <code>RunningTotal</code> の値には、2つの <code>Int</code>、<code>Int</code> に評価することができるサンク、もしくは例外を投げるサンクを持つことができる、という値を含むことができてしまいます。</p>
<p>そのため、<code>RunningTotal</code> の値に遅延性が入りこむ余地を無くしたいものですね。これは、データ型の定義に<em>正格性注釈</em> (<em>strictness annotations</em>) をつけることで実現できます。</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="kw">data</span> <span class="dt">RunningTotal</span> <span class="fu">=</span> <span class="dt">RunningTotal</span></a>
<a class="sourceLine" id="cb37-2" data-line-number="2">  {<span class="ot"> sum ::</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb37-3" data-line-number="3">  ,<span class="ot"> count ::</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb37-4" data-line-number="4">  }</a>
<a class="sourceLine" id="cb37-5" data-line-number="5">  <span class="kw">deriving</span> <span class="dt">Generic</span></a>
<a class="sourceLine" id="cb37-6" data-line-number="6"></a>
<a class="sourceLine" id="cb37-7" data-line-number="7"><span class="ot">printAverage ::</span> <span class="dt">RunningTotal</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb37-8" data-line-number="8">printAverage (<span class="dt">RunningTotal</span> sum count)</a>
<a class="sourceLine" id="cb37-9" data-line-number="9">  <span class="fu">|</span> count <span class="fu">==</span> <span class="dv">0</span> <span class="fu">=</span> error <span class="st">&quot;Need at least one value!&quot;</span></a>
<a class="sourceLine" id="cb37-10" data-line-number="10">  <span class="fu">|</span> otherwise <span class="fu">=</span> print (fromIntegral sum <span class="fu">/</span> fromIntegral<span class="ot"> count ::</span> <span class="dt">Double</span>)</a>
<a class="sourceLine" id="cb37-11" data-line-number="11"></a>
<a class="sourceLine" id="cb37-12" data-line-number="12"><span class="co">-- | A fold would be nicer... we&#39;ll see that later</span></a>
<a class="sourceLine" id="cb37-13" data-line-number="13"><span class="ot">printListAverage ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb37-14" data-line-number="14">printListAverage <span class="fu">=</span></a>
<a class="sourceLine" id="cb37-15" data-line-number="15">  go (<span class="dt">RunningTotal</span> <span class="dv">0</span> <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb37-16" data-line-number="16">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb37-17" data-line-number="17">    go rt [] <span class="fu">=</span> printAverage rt</a>
<a class="sourceLine" id="cb37-18" data-line-number="18">    go (<span class="dt">RunningTotal</span> sum count) (x<span class="fu">:</span>xs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb37-19" data-line-number="19">      <span class="kw">let</span> rt <span class="fu">=</span> <span class="dt">RunningTotal</span> (sum <span class="fu">+</span> x) (count <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb37-20" data-line-number="20">       <span class="kw">in</span> go rt xs</a>
<a class="sourceLine" id="cb37-21" data-line-number="21"></a>
<a class="sourceLine" id="cb37-22" data-line-number="22"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb37-23" data-line-number="23">main <span class="fu">=</span> printListAverage [<span class="dv">1</span><span class="fu">..</span><span class="dv">1000000</span>]</a></code></pre></div>
<p><code>RunningTotal</code> の定義で <code>Int</code> の前にバンを置いただけです。他に正格性や評価を指定するようなものはありません。しかし、これらのフィールドに正格性注釈を置くことで、簡単ですが重要なことを言うことができます:</p>
<p><strong><code>RunningTotal</code> 型の値を評価するときは、必ずその中に含まれる2つの <code>Int</code> も評価しなければならない</strong></p>
<p>さきほど説明したように、2つ目の <code>go</code> は コンストラクタを剥ぎ取ることで、<code>RunningTotal</code> の値が強制評価されます。前回まではバンパターンを使う必要があった <code>sum</code> と <code>count</code> の強制評価が、ここでは自動化されています。</p>
<p>これ以外のアドバンテージも1つあります。少し話からは脱線しますが、それでも言及しておく価値はあります。 <code>Int</code> のような小さな値を扱うとき、GHC は自動的に正格なフィールドを<em>アンボックス化</em> (<em>unbox</em>) します。これは、<code>RunningTotal</code> の中で <code>Int</code> へのポインタを持ち続けるよりも、<code>Int</code> そのものを持つようになるという意味です。こうすることで、もっとメモリ使用量を減らすことができます。</p>
<p>こういうすごく良い質問をしてくれるかもしれません: 「自分のデータのフィールドで正格性注釈を使うかべきどうか、どうやったらわかるの?」この回答は少し議論の余地があるかもしれませんが、私のアドバイスとして、ベストプラクティスはフィールドに対して遅延性を持たせたいとき以外は、正格にすることです。フィールドを正格にすることで、以下のようなメリットが得られます:</p>
<ul>
<li>ここで私たちがやっているように、うっかりスペースリークを起こしてしまうのを避ける</li>
<li>うっかりボトムの値を含んでしまうのを避ける</li>
<li>レコード構文で値を生成するとき、正格なフィールドを忘れた時に GHC がエラーを出してくれる。正格ではないフィールドに対しては警告しか出してくれない。</li>
</ul>
<h3 id="newtype-の興味深いケース">newtype の興味深いケース</h3>
<p>よく似たデータ型を3つ定義してみましょう。</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Foo</span> <span class="fu">=</span> <span class="dt">Foo</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb38-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Bar</span> <span class="fu">=</span> <span class="dt">Bar</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb38-3" data-line-number="3"><span class="kw">newtype</span> <span class="dt">Baz</span> <span class="fu">=</span> <span class="dt">Baz</span> <span class="dt">Int</span></a></code></pre></div>
<p>ゲームをしましょう。以下のコードを <code>main</code> 関数に置いたときの出力を推測してみてください。以下の説明を読む前に、それぞれのケースを頭の中で考えてくださいね。</p>
<ol type="1">
<li><code>case undefined of { Foo _ -&gt; putStrLn &quot;Still alive!&quot; }</code></li>
<li><code>case Foo undefined of { Foo _ -&gt; putStrLn &quot;Still alive!&quot; }</code></li>
<li><code>case undefined of { Bar _ -&gt; putStrLn &quot;Still alive!&quot; }</code></li>
<li><code>case Bar undefined of { Bar _ -&gt; putStrLn &quot;Still alive!&quot; }</code></li>
<li><code>case undefined of { Baz _ -&gt; putStrLn &quot;Still alive!&quot; }</code></li>
<li><code>case Baz undefined of { Baz _ -&gt; putStrLn &quot;Still alive!&quot; }</code></li>
</ol>
<p>ケース (1) は比較的単純ですね。データコンストラクタ (<code>Foo</code>) を1層剥いで、ボトムの値を見つけます。なので、これは例外を投げます。これは (3) にも当てはまります。</p>
<p>(2) は例外を投げません。<code>Foo</code> データコンストラクタがあって、それはボトムの値を含んでいます。しかし、<code>Foo</code> の中の <code>Int</code> に正格性注釈がないので、<code>Foo</code> を剥いでも <code>Int</code> の強制評価は起こらず、例外が投げられることはありません。これとは対照的に、(4) では正格性注釈があるので、<code>Bar</code> のケースでは例外が投げられます。</p>
<p><code>newtype</code> はどうでしょう? <code>newtype</code> について知っていることといえば、実行時表現が無いということでしょうか。ということは、<code>Baz</code> データコンストラクタがボトムの余分な層を隠すことは不可能です。つまり、<code>Baz undefined</code> と <code>undefined</code> を区別することはできません。こう考えると、ぱっと見 <code>Bar</code> のようになりそうですが、おもしろいことに、そうではないんです。</p>
<p><code>Baz</code> コンストラクタを剥がすことが実行時の動作になんら影響がないことはわかりますよね? そもそもそこには存在していないんだから。よって、(5) の中のパターンマッチは何の意味もありません。これは <code>case undefined of { _ -&gt; putStrLn &quot;Still alive!&quot; }</code> と等しくなります。そして <code>undefined</code> について調べることはない (データコンストラクタではなく、ワイルドカードパターンを使っている) ので、例外が投げられることはありません。</p>
<p>同様に、ケース (6) でも <code>Baz</code> コンストラクタを <code>undefined</code> に適用していますが、実行時表現はないので、これもまた存在しません。なので、ここでも例外が投げられることはありません。</p>
<p><strong>演習</strong> <code>main = Baz undefined `seq` putStrLn &quot;Still alive!&quot;</code> の出力はどうなるでしょうか? そうなるのはなぜでしょう?</p>
<h4 id="翻訳者追記-2">翻訳者追記</h4>
<p>演習の解答例: エラーを吐く。<code>seq</code> によって <code>Baz undefined</code> 、つまり <code>undefined</code> が評価されるため。</p>
<h3 id="便利な演算子と関数">便利な演算子と関数</h3>
<p>すでにお気づきかもしれませんが、<code>seq</code> と <code>deepseq</code> をあらゆるところで使うのは不都合なことがあります。バンパターンも助けにはなりますが、強制評価を行う方法は他にもあります。おそらく、最も良くに使われているのは <code>$!</code> 演算子でしょう。例えば、以下のように利用します。</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="ot">mysum ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb39-2" data-line-number="2">mysum list0 <span class="fu">=</span></a>
<a class="sourceLine" id="cb39-3" data-line-number="3">  go list0 <span class="dv">0</span></a>
<a class="sourceLine" id="cb39-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb39-5" data-line-number="5">    go [] total <span class="fu">=</span> total</a>
<a class="sourceLine" id="cb39-6" data-line-number="6">    go (x<span class="fu">:</span>xs) total <span class="fu">=</span> go xs <span class="fu">$!</span> total <span class="fu">+</span> x</a>
<a class="sourceLine" id="cb39-7" data-line-number="7"></a>
<a class="sourceLine" id="cb39-8" data-line-number="8">main <span class="fu">=</span> print <span class="fu">$</span> mysum [<span class="dv">1</span><span class="fu">..</span><span class="dv">1000000</span>]</a></code></pre></div>
<p>上の例では、<code>go</code> 関数の再帰に入る前に <code>total + x</code> を強制評価しています。結果、スペースリークを防ぐことができます。(演習: 同じことを、バンパターンと <code>seq</code> 関数を使ってやってみてください。)</p>
<p><code>$!!</code> 演算子も同様ですが、<code>seq</code> ではなく <code>deepseq</code> を利用しています。そのため、この演算子を使うと正規形に評価されます。</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Control.DeepSeq</span></a>
<a class="sourceLine" id="cb40-2" data-line-number="2"></a>
<a class="sourceLine" id="cb40-3" data-line-number="3"><span class="ot">average ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb40-4" data-line-number="4">average list0 <span class="fu">=</span></a>
<a class="sourceLine" id="cb40-5" data-line-number="5">  go list0 (<span class="dv">0</span>, <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb40-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb40-7" data-line-number="7">    go [] (total, count) <span class="fu">=</span> fromIntegral total <span class="fu">/</span> count</a>
<a class="sourceLine" id="cb40-8" data-line-number="8">    go (x<span class="fu">:</span>xs) (total, count) <span class="fu">=</span> go xs <span class="fu">$!!</span> (total <span class="fu">+</span> x, count <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb40-9" data-line-number="9"></a>
<a class="sourceLine" id="cb40-10" data-line-number="10">main <span class="fu">=</span> print <span class="fu">$</span> average [<span class="dv">1</span><span class="fu">..</span><span class="dv">1000000</span>]</a></code></pre></div>
<p>他にも、いい感じの補助関数に <code>force</code> というものがあります。これは、対象の式が弱頭部正規形に評価されるとき、実際には正規形に評価します。例えば、上記の <code>go</code> 関数はこのように書き換えることができます。</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1">go [] (total, count) <span class="fu">=</span> fromIntegral total <span class="fu">/</span> count</a>
<a class="sourceLine" id="cb41-2" data-line-number="2">go (x<span class="fu">:</span>xs) (total, count) <span class="fu">=</span> go xs <span class="fu">$!</span> force (total <span class="fu">+</span> x, count <span class="fu">+</span> <span class="dv">1</span>)</a></code></pre></div>
<p><strong>演習</strong> これらの便利な関数と演算子を、<code>seq</code> と <code>deepseq</code> を使って自分で定義してみましょう。</p>
<h4 id="翻訳者追記-3">翻訳者追記</h4>
<p>演習の解答例</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="ot">force ::</span> (<span class="dt">NFData</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb42-2" data-line-number="2">force x <span class="fu">=</span> x <span class="ot">`deepseq`</span> x</a></code></pre></div>
<h2 id="データ構造">データ構造</h2>
<p>はい、以上が一番複雑な部分でした。もしもそれら全てを理解していたら、残りは自然に理解できて、より深く理解するための用語を少し導入するだけになります。</p>
<p>このプログラムの出力はどうなるでしょうか:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a) <span class="fu">|</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb43-2" data-line-number="2"></a>
<a class="sourceLine" id="cb43-3" data-line-number="3">main <span class="fu">=</span> <span class="dt">Cons</span> undefined undefined <span class="ot">`seq`</span> putStrLn <span class="st">&quot;Hello World&quot;</span></a></code></pre></div>
<p>えー、これまでに紹介した原理を使うと、一番外側のコンストラクタがあるので、<code>Cons undefined undefined</code> は既に弱頭部正規形になっています。なので、このプログラムは例外を吐くことなく “Hello World” と表示します。いいですね。さて、<code>Cons</code> は <code>:</code> データコンストラクタと等しいことを思い出してください。そうすると、上記の例はこうなります。</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1">main <span class="fu">=</span> (undefined<span class="fu">:</span>undefined) <span class="ot">`seq`</span> putStrLn <span class="st">&quot;Hello World&quot;</span></a></code></pre></div>
<p>ということは、リストは遅延データ構造だということですね。最初の要素はボトムで、残りの要素もボトムです。しかし全体としてはボトムではありません。少し違う例を試してみましょう。</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Cons</span> a <span class="fu">!</span>(<span class="dt">List</span> a) <span class="fu">|</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb45-2" data-line-number="2"></a>
<a class="sourceLine" id="cb45-3" data-line-number="3">main <span class="fu">=</span> <span class="dt">Cons</span> undefined undefined <span class="ot">`seq`</span> putStrLn <span class="st">&quot;Hello World&quot;</span></a></code></pre></div>
<p>これは顔面で爆発します! 後続のリストが正格だからです。しかし、以下の例は大丈夫です。</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Cons</span> a <span class="fu">!</span>(<span class="dt">List</span> a) <span class="fu">|</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb46-2" data-line-number="2"></a>
<a class="sourceLine" id="cb46-3" data-line-number="3">main <span class="fu">=</span> <span class="dt">Cons</span> undefined (<span class="dt">Cons</span> undefined <span class="dt">Nil</span>) <span class="ot">`seq`</span> putStrLn <span class="st">&quot;Hello World&quot;</span></a></code></pre></div>
<p>このリストの定義では、リストそのものについては詳細の全てを知る必要があります。しかし、値は undefined のままでもいいのです。これは<em>スパイン正格</em> (<em>spine strict</em>) と呼ばれています。対照的に、値に対して正格な<em>値正格</em> (<em>value strict}</em>) にすることも可能です。やってみましょう。</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" data-line-number="1"><span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Cons</span> <span class="fu">!</span>a <span class="fu">!</span>(<span class="dt">List</span> a) <span class="fu">|</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb47-2" data-line-number="2"></a>
<a class="sourceLine" id="cb47-3" data-line-number="3">main <span class="fu">=</span> <span class="dt">Cons</span> undefined (<span class="dt">Cons</span> undefined <span class="dt">Nil</span>) <span class="ot">`seq`</span> putStrLn <span class="st">&quot;Hello World&quot;</span></a></code></pre></div>
<p>これは期待通り、顔面で爆発するでしょう。</p>
<p>お分かりかもしれませんが、もう1つリストの定義が残っています。値に対して正格で、残りはそうではないものです。</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Cons</span> <span class="fu">!</span>a (<span class="dt">List</span> a) <span class="fu">|</span> <span class="dt">Nil</span></a></code></pre></div>
<p>実際のところ、Haskell このパターンのデータ構造を知りません。よって名前もありません。(もしもこんなデータ構造があって名前があるのなら、教えてください。どんな使われ方をしているのか気になります。)</p>
<p>なので、通常のリストは遅延リストです。他にもいくつかデータ型を見てみましょう。</p>
<h3 id="ベクター">ベクター</h3>
<p><code>Data.Vector</code> の中のベクター (<em>ボックスベクター</em> (<em>boxed vectors</em>)とも) は、スパイン正格です。<code>import qualified Data.Vector as V</code> でインポートしたとして、以下のプログラムの結果はどうなるでしょうか?</p>
<ol type="1">
<li><code>main = V.fromList [undefined] `seq` putStrLn &quot;Hello World&quot;</code></li>
<li><code>main = V.fromList (undefined:undefined) `seq` putStrLn &quot;Hello World&quot;</code></li>
<li><code>main = V.fromList undefined `seq` putStrLn &quot;Hello World&quot;</code></li>
</ol>
<p>最初は成功します。ベクターは完全なスパインとして定義されるからです。そのため、ボトムを含んでいるかどうかは無関係です。2番目は失敗します。後続のリストのスパインが undefined だからです。最後の例も (当然) 失敗します。リスト全体が undefined だからです。</p>
<p>さて、<em>アンボックスベクター</em> (<em>unboxed vectors</em>) についても見てみましょう。推論の都合上、GHC を少し手助けしてやる必要があります。なので、プログラムの先頭に以下のような <code>fromList</code> が定義されているとしましょう。</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb49-1" data-line-number="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector.Unboxed</span> <span class="kw">as</span> <span class="dt">V</span></a>
<a class="sourceLine" id="cb49-2" data-line-number="2"></a>
<a class="sourceLine" id="cb49-3" data-line-number="3"><span class="ot">fromList ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">V.Vector</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb49-4" data-line-number="4">fromList <span class="fu">=</span> V.fromList</a></code></pre></div>
<p>この場合はどうなるでしょうか？</p>
<ol type="1">
<li><code>main = fromList [undefined] `seq` putStrLn &quot;Hello World&quot;</code></li>
<li><code>main = fromList (undefined:undefined) `seq` putStrLn &quot;Hello World&quot;</code></li>
<li><code>main = fromList undefined `seq` putStrLn &quot;Hello World&quot;</code></li>
</ol>
<p>ご想像の通り、(2) と (3) はボックスベクターのときと同じ動きをします。しかし、(1) も例外を投げるようになります。これは、アンボックスベクターがスパイン正格なだけではなく、値に対しても正格だからです。storable vector と primitive vector も同じ振る舞いをします。</p>
<p>残念ながら、私の知る限り、公開されているライブラリに正格なボックスベクターは存在しません。そのようなデータ型はスペースリーク対策に役立つと思うんですが (この記事を書くきっかけになった質問のように)。</p>
<h3 id="set-と-map">Set と Map</h3>
<p>containers, unordered-containers パッケージの、Map から始まるモジュールには <code>Strict</code> と <code>Lazy</code> (例えば、<code>Data.HashMap.Strict</code> と <code>Data.HashMap.Lazy</code>) が用意されているのに対して、Set から始まるモジュールには存在しないことに (<code>Data.IntSet</code> など) 気がつくと思います 。これは、これら全てのコンテナがスパイン正格で、キーに対して正格でなければならないからです。集合は分離された値を持たず、キーだけ持っているので、値に対して正格でなければいけません。</p>
<p>それに対してマップはキーと値の両方を持っています。Map.HashMap.Lazy のようなモジュールはスパイン正格ですが、値は遅延です。対して、Map.HashMap.Strict のようなモジュールはスパインと値の両方について正格です。</p>
<p><strong>演習</strong> <code>Data.Sequence.Seq</code> データ型を調べて、遅延、スパイン正格、値正格のいずれかに分類してみましょう。</p>
<h4 id="翻訳者追記-4">翻訳者追記</h4>
<p>演習の解答例:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb50-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb50-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.2 --package containers</span></a>
<a class="sourceLine" id="cb50-3" data-line-number="3"></a>
<a class="sourceLine" id="cb50-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Data.Sequence</span> (fromList)</a>
<a class="sourceLine" id="cb50-5" data-line-number="5"></a>
<a class="sourceLine" id="cb50-6" data-line-number="6">main <span class="fu">=</span> fromList [<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,undefined,<span class="dv">0</span>,<span class="dv">0</span>] <span class="ot">`seq`</span> putStrLn <span class="st">&quot;Alive!&quot;</span></a></code></pre></div>
<p>これを実行すると <code>Alive!</code> と表示されるのでスパイン正格。</p>
<h2 id="関数の引数">関数の引数</h2>
<p>関数の引数にボトムの値が適用されたとき、結果がボトムになれば、関数はボトムが与えられた引数に対して正格であると言います。上の例で見たように、<code>Int</code> に対して <code>+</code> を適用する場合、 <code>undefined + x</code> と <code>x + undefined</code> の結果は両方ともボトムとなるため、<code>+</code> はどちらの引数に対しても正格です。</p>
<p>それに対して <code>const a b = a</code> と定義される <code>const</code> 関数は、最初の引数に対して正格で、2番目の引数に対しては非正格です。</p>
<p>リストの <code>:</code> データコンストラクタは、第1引数と第2引数に対して、どちらも非正格です。しかし、<code>data List a = Cons !a !(List a) | Nil</code> という定義では、<code>Cons</code> はどちらの引数に対しても正格になります。</p>
<h2 id="fold">Fold</h2>
<p>遅延性を扱う上でつまづきやすいポイントは、fold です。もっとも悪名高い例は <code>foldl</code> 関数でしょう。こいつは偽りの安心感をいざない、夢と希望をぶち壊してくれます。</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb51-1" data-line-number="1"><span class="ot">mysum ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb51-2" data-line-number="2">mysum <span class="fu">=</span> foldl (<span class="fu">+</span>) <span class="dv">0</span></a>
<a class="sourceLine" id="cb51-3" data-line-number="3"></a>
<a class="sourceLine" id="cb51-4" data-line-number="4"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb51-5" data-line-number="5">main <span class="fu">=</span> print <span class="fu">$</span> mysum [<span class="dv">1</span><span class="fu">..</span><span class="dv">1000000</span>]</a></code></pre></div>
<p>翻訳者追記 (上記プログラムの結果)</p>
<pre class="plain"><code>     169,311,296 bytes allocated in the heap
     230,806,408 bytes copied during GC
      53,397,048 bytes maximum residency (8 sample(s))
         903,624 bytes maximum slop
             106 MB total memory in use (0 MB lost due to fragmentation)</code></pre>
<p>これは限りなく正解に近いですが、最大メモリ常駐量は 53mb にもなっています! 答えはチョンっとつけて正格な左畳み込み <code>foldl</code> 関数を使うことです。</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb53-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.List</span> (foldl&#39;)</a>
<a class="sourceLine" id="cb53-2" data-line-number="2"></a>
<a class="sourceLine" id="cb53-3" data-line-number="3"><span class="ot">mysum ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb53-4" data-line-number="4">mysum <span class="fu">=</span> foldl&#39; (<span class="fu">+</span>) <span class="dv">0</span></a>
<a class="sourceLine" id="cb53-5" data-line-number="5"></a>
<a class="sourceLine" id="cb53-6" data-line-number="6"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb53-7" data-line-number="7">main <span class="fu">=</span> print <span class="fu">$</span> mysum [<span class="dv">1</span><span class="fu">..</span><span class="dv">1000000</span>]</a></code></pre></div>
<p><code>Prelude</code> はなんでこんな絶対におかしい関数 (<code>foldl</code>) を提供しているのでしょうか?</p>
<figure>
<img src="https://www.fpcomplete.com/static/hysterical-raisins.jpg" alt="Hysterical Raisins" /><figcaption>Hysterical Raisins</figcaption>
</figure>
<p>ただ、ほとんど全ての正格であると称している関数は、実際のところ弱頭部正規形に対してのみ正格であることに留意しなければいけません。前の <code>average</code> 関数の例を見てみると、まだスペースリークがあります:</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb54-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.List</span> (foldl&#39;)</a>
<a class="sourceLine" id="cb54-2" data-line-number="2"></a>
<a class="sourceLine" id="cb54-3" data-line-number="3"><span class="ot">average ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb54-4" data-line-number="4">average <span class="fu">=</span></a>
<a class="sourceLine" id="cb54-5" data-line-number="5">  divide <span class="fu">.</span> foldl&#39; add (<span class="dv">0</span>, <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb54-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb54-7" data-line-number="7">    divide (total, count) <span class="fu">=</span> fromIntegral total <span class="fu">/</span> count</a>
<a class="sourceLine" id="cb54-8" data-line-number="8">    add (total, count) x <span class="fu">=</span> (total <span class="fu">+</span> x, count <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb54-9" data-line-number="9"></a>
<a class="sourceLine" id="cb54-10" data-line-number="10"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb54-11" data-line-number="11">main <span class="fu">=</span> print <span class="fu">$</span> average [<span class="dv">1</span><span class="fu">..</span><span class="dv">1000000</span>]</a></code></pre></div>
<p>翻訳者追記 (上記プログラムの結果)</p>
<pre class="plain"><code>     306,654,600 bytes allocated in the heap
     390,431,392 bytes copied during GC
      88,082,496 bytes maximum residency (10 sample(s))
       1,160,496 bytes maximum slop
             181 MB total memory in use (0 MB lost due to fragmentation)</code></pre>
<p>私のアドバイスは、正格なフィールドを持つ補助的なデータ型を使うことです。しかしあなたはそうしたくないかもしれませんし、正規形に評価するような <code>foldl'</code> がないことにイライラしているかもしれません。そんなあなたに朗報です。<code>force</code> を使うだけで、簡単に弱頭部正規形へ評価する fold を正規形へ評価する fold にアップグレードすることができます。</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb56-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.List</span> (foldl&#39;)</a>
<a class="sourceLine" id="cb56-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Control.DeepSeq</span> (force)</a>
<a class="sourceLine" id="cb56-3" data-line-number="3"></a>
<a class="sourceLine" id="cb56-4" data-line-number="4"><span class="ot">average ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Double</span></a>
<a class="sourceLine" id="cb56-5" data-line-number="5">average <span class="fu">=</span></a>
<a class="sourceLine" id="cb56-6" data-line-number="6">  divide <span class="fu">.</span> foldl&#39; add (<span class="dv">0</span>, <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb56-7" data-line-number="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb56-8" data-line-number="8">    divide (total, count) <span class="fu">=</span> fromIntegral total <span class="fu">/</span> count</a>
<a class="sourceLine" id="cb56-9" data-line-number="9">    add (total, count) x <span class="fu">=</span> force (total <span class="fu">+</span> x, count <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb56-10" data-line-number="10"></a>
<a class="sourceLine" id="cb56-11" data-line-number="11"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb56-12" data-line-number="12">main <span class="fu">=</span> print <span class="fu">$</span> average [<span class="dv">1</span><span class="fu">..</span><span class="dv">1000000</span>]</a></code></pre></div>
<p>翻訳者追記 (上記プログラムの結果)</p>
<pre class="plain"><code>     240,102,848 bytes allocated in the heap
          54,552 bytes copied during GC
          44,384 bytes maximum residency (2 sample(s))
          21,152 bytes maximum slop
               1 MB total memory in use (0 MB lost due to fragmentation)</code></pre>
<p>腕のいい水道工事業者のように、<code>force</code> はすぐにリークを止めてくれます!</p>
<h3 id="ストリーミングデータ">ストリーミングデータ</h3>
<p>conduit のようなストリーミングデータライブラリの主張の1つに、メモリ使用量が定数オーダーになる、というものがあります。この主張を聞くと、スペースリークについて心配することなく、こいつとおさらばできるという印象を受けます。しかし、弱頭部正規形 vs 正規形の問題はここでも当てはまります。私の言い分を証明するために、conduit で average をひどいやり方で計算してみましょう。</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb58-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb58-2" data-line-number="2"></a>
<a class="sourceLine" id="cb58-3" data-line-number="3"><span class="ot">average ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ConduitM</span> <span class="dt">Int</span> o m <span class="dt">Double</span></a>
<a class="sourceLine" id="cb58-4" data-line-number="4">average <span class="fu">=</span></a>
<a class="sourceLine" id="cb58-5" data-line-number="5">  divide <span class="fu">&lt;$&gt;</span> foldlC add (<span class="dv">0</span>, <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb58-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb58-7" data-line-number="7">    divide (total, count) <span class="fu">=</span> fromIntegral total <span class="fu">/</span> count</a>
<a class="sourceLine" id="cb58-8" data-line-number="8">    add (total, count) x <span class="fu">=</span> (total <span class="fu">+</span> x, count <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb58-9" data-line-number="9"></a>
<a class="sourceLine" id="cb58-10" data-line-number="10"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb58-11" data-line-number="11">main <span class="fu">=</span> print <span class="fu">$</span> runConduitPure <span class="fu">$</span> enumFromToC <span class="dv">1</span> <span class="dv">1000000</span> <span class="fu">.|</span> average</a></code></pre></div>
<p>以下のコマンドでメモリ使用量を確かめることができます。</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb59-1" data-line-number="1"><span class="fu">$</span> stack <span class="co">--resolver lts-9.3 ghc --package conduit-combinators -- Main.hs -O2</span></a>
<a class="sourceLine" id="cb59-2" data-line-number="2"><span class="fu">$</span> <span class="fu">./</span><span class="dt">Main</span> <span class="fu">+</span><span class="dt">RTS</span> <span class="fu">-</span>s</a></code></pre></div>
<p>翻訳者追記 (上記プログラムの結果)</p>
<pre class="plain"><code>     265,361,840 bytes allocated in the heap
     205,193,384 bytes copied during GC
      50,201,912 bytes maximum residency (8 sample(s))
         686,792 bytes maximum slop
              98 MB total memory in use (0 MB lost due to fragmentation)</code></pre>
<p><strong>演習</strong> 以下のものを使って、このプログラムを定数メモリ使用量で実行してみましょう。</p>
<ol type="1">
<li><code>force</code> 関数</li>
<li>バンパターン</li>
<li>正格なフィールドを持つカスタムデータ型</li>
</ol>
<h2 id="連鎖反応">連鎖反応</h2>
<p>この超正格なプログラムをご覧ください。特別な値正格リストデータ型です。私はふんだんにバンパターンを散りばめ、至るところで <code>seq</code> を呼び出しています。<code>$!</code> も使ってます。メモリ使用量はどうなるでしょうか?</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb61-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb61-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb61-3" data-line-number="3"><span class="ot">{-# LANGUAGE BangPatterns #-}</span></a>
<a class="sourceLine" id="cb61-4" data-line-number="4"></a>
<a class="sourceLine" id="cb61-5" data-line-number="5"><span class="kw">data</span> <span class="dt">StrictList</span> a <span class="fu">=</span> <span class="dt">Cons</span> <span class="fu">!</span>a <span class="fu">!</span>(<span class="dt">StrictList</span> a) <span class="fu">|</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb61-6" data-line-number="6"></a>
<a class="sourceLine" id="cb61-7" data-line-number="7"><span class="ot">strictMap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">StrictList</span> a <span class="ot">-&gt;</span> <span class="dt">StrictList</span> b</a>
<a class="sourceLine" id="cb61-8" data-line-number="8">strictMap _ <span class="dt">Nil</span> <span class="fu">=</span> <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb61-9" data-line-number="9">strictMap f (<span class="dt">Cons</span> a list) <span class="fu">=</span></a>
<a class="sourceLine" id="cb61-10" data-line-number="10">  <span class="kw">let</span> <span class="fu">!</span>b <span class="fu">=</span> f a</a>
<a class="sourceLine" id="cb61-11" data-line-number="11">      <span class="fu">!</span>list&#39; <span class="fu">=</span> strictMap f list</a>
<a class="sourceLine" id="cb61-12" data-line-number="12">   <span class="kw">in</span> b <span class="ot">`seq`</span> list&#39; <span class="ot">`seq`</span> <span class="dt">Cons</span> b list&#39;</a>
<a class="sourceLine" id="cb61-13" data-line-number="13"></a>
<a class="sourceLine" id="cb61-14" data-line-number="14"><span class="ot">strictEnum ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StrictList</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb61-15" data-line-number="15">strictEnum low high <span class="fu">=</span></a>
<a class="sourceLine" id="cb61-16" data-line-number="16">  go low</a>
<a class="sourceLine" id="cb61-17" data-line-number="17">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb61-18" data-line-number="18">    go <span class="fu">!</span>x</a>
<a class="sourceLine" id="cb61-19" data-line-number="19">      <span class="fu">|</span> x <span class="fu">==</span> high <span class="fu">=</span> <span class="dt">Cons</span> x <span class="dt">Nil</span></a>
<a class="sourceLine" id="cb61-20" data-line-number="20">      <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Cons</span> x (go <span class="fu">$!</span> x <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb61-21" data-line-number="21"></a>
<a class="sourceLine" id="cb61-22" data-line-number="22"><span class="ot">double ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb61-23" data-line-number="23">double <span class="fu">!</span>x <span class="fu">=</span> x <span class="fu">*</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb61-24" data-line-number="24"></a>
<a class="sourceLine" id="cb61-25" data-line-number="25"><span class="ot">evens ::</span> <span class="dt">StrictList</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb61-26" data-line-number="26">evens <span class="fu">=</span> strictMap double <span class="fu">$!</span> strictEnum <span class="dv">1</span> <span class="dv">1000000</span></a>
<a class="sourceLine" id="cb61-27" data-line-number="27"></a>
<a class="sourceLine" id="cb61-28" data-line-number="28"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb61-29" data-line-number="29">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb61-30" data-line-number="30">  <span class="kw">let</span> string <span class="fu">=</span> <span class="st">&quot;Hello World&quot;</span></a>
<a class="sourceLine" id="cb61-31" data-line-number="31">      string&#39; <span class="fu">=</span> evens <span class="ot">`seq`</span> string</a>
<a class="sourceLine" id="cb61-32" data-line-number="32">  putStrLn string</a></code></pre></div>
<p>よーく見て、コードをよく読んで、予想してみてください。準備はいいですか? いきましょう。</p>
<p>翻訳者追記 (上記プログラムの結果)</p>
<pre class="plain"><code>          51,912 bytes allocated in the heap
           3,408 bytes copied during GC
          44,504 bytes maximum residency (1 sample(s))
          25,128 bytes maximum slop
               2 MB total memory in use (0 MB lost due to fragmentation)</code></pre>
<p>メモリ利用量は 44kb です。「なんで!?」と叫びたくなるかもしれません。「100万回正格な <code>Int</code> のリンクトリストを回しているじゃないか!」ってね。惜しい。このプログラムは <code>evens</code> の値の評価を強制した直後に、死ぬほど評価を繰り返すでしょう。これは正しい。そして、<code>main</code> の中の <code>string'</code> という値の評価を強制した直後に <code>evens</code> は評価されます。</p>
<p>しかし、このプログラムはどちらも強制評価が起こることはありません! 注意深く見てみれば、プログラムの最後の行は <code>string</code> という値を使っています。<code>string'</code> も <code>evens</code> も使うことはないんですね。プログラムを実行するとき、GHC は <code>main</code> 関数によって指定された <code>IO</code> アクションを実行することにのみ関心を持ちます。そして、その <code>main</code> は <code>putStrLn string</code> ということしか言っていないわけです。</p>
<p>このことの理解は極めて重要です。プログラム中で <code>seq</code> や <code>deepseq</code> を使い、好きなだけ評価の連鎖を組み立てることができます。しかし結局は、<code>IO</code> アクション経由で連鎖の最初に値を評価してやらないと、評価されないサンクが残ったままなのです。</p>
<p><strong>演習</strong></p>
<ol type="1">
<li><code>putStrLn string</code> を <code>putStrLn string'</code> にして、メモリ使用量がどうなるか観察してください (終わったら戻してください)</li>
<li><code>main</code> のどこかにバンパターンを置くと、メモリ利用量がはね上がります。それはどこでしょう?</li>
<li><code>putStrLn string</code> の行のどこかに <code>seq</code> を置くと、メモリ利用率が大きくなります。それはどこでしょう?</li>
</ol>
<h4 id="翻訳者追記-5">翻訳者追記</h4>
<p>演習の解答例</p>
<ol type="1">
<li>略</li>
<li><code>string'</code> の前</li>
<li>略</li>
</ol>
<h2 id="もっと先に">もっと先に</h2>
<p>Sebastian Graf は<a href="http://fixpt.de/blog/2017-12-04-strictness-analysis-part-1.html">このブログ記事を分析する</a>というタイトルで、素晴らしいブログ記事を書いています。このブログ記事は、正格性のケース毎に GHC がどのように解析、最適化をしているのかというところまでもっと踏み込んだ解説をしています。作者である彼の言葉を引用します。</p>
<p>「このブログ記事では、スペースリークを防ぐための、コンパイラと連携できるようなより局所的なアプローチを解説したいと思います」</p>
<p>もしも興味が湧いたのなら、一読してみることをおすすめします。</p>]]></summary>
</entry>
<entry>
    <title>Prelude を カスタムPrelude で置き換える</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/05-23-extended-prelude.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/05-23-extended-prelude.html</id>
    <published>2018-05-23T00:00:00Z</published>
    <updated>2018-05-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>つい最近 haskell-jp で <strong>皆さんPreludeは何を使っていますか？</strong> という話がありました。</p>
<p>まとめるとだいたこんな感じです。</p>
<table>
<thead>
<tr class="header">
<th>カスタム Prelude パッケージ</th>
<th>利用しているプロジェクト</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://github.com/nikita-volkov/base-prelude">base-prelude</a></td>
<td>???</td>
</tr>
<tr class="even">
<td><a href="https://github.com/snoyberg/mono-traversable/tree/master/classy-prelude">classy-prelude</a></td>
<td><a href="https://github.com/yesodweb/yesod">Yesod</a></td>
</tr>
<tr class="odd">
<td><a href="https://github.com/sdiehl/protolude">protolude</a></td>
<td><a href="https://github.com/purescript/purescript">purescript</a></td>
</tr>
<tr class="even">
<td><a href="https://github.com/serokell/universum">universum</a></td>
<td><a href="https://github.com/input-output-hk/cardano-sl">cardano-sl</a></td>
</tr>
<tr class="odd">
<td><a href="https://github.com/commercialhaskell/rio">rio</a></td>
<td><a href="https://github.com/commercialhaskell/stack">stack</a></td>
</tr>
</tbody>
</table>
<p>カスタム Prelude を使うモチベーションは、自分のよく使う関数を Prelude に入れたいとか、<strong>fromJust</strong> みたいな部分関数を排除したいなど、色々あります。</p>
<p>実際にカスタム Prelude を使うためにはファイルの先頭に <strong>NoImplicitPrelude</strong> 言語拡張とカスタムPreludeの <strong>import</strong> 宣言を追加する必要があります。(具体例として <strong>rio</strong> パッケージを利用します)</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">import</span> <span class="dt">RIO</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="fu">...</span></a></code></pre></div>
<p>新しいファイルを作るたびに、ファイルの先頭に上記の宣言を書いても良いのですが、今回はこの作業なしにカスタム Prelude を使う方法をご紹介したいと思います。</p>
<!--more-->
<h2 id="default-extensions-を利用する">default-extensions を利用する</h2>
<p><code>{-# LANGUAGE NoImplicitPrelude #-}</code> を自動的に有効化させることは意外と簡単です。</p>
<p><strong>package.yaml</strong> や <strong>cabal</strong> ファイルの <strong>default-extensions</strong> に追加するだけです。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co"># package.yaml</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="fu">default-extensions:</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">-</span> NoImplicitPrelude</a></code></pre></div>
<pre><code># project.cabal
default-extensions: NoImplicitPrelude</code></pre>
<p>この場合、全てのファイルで自動的に <strong>NoImplicitPrelude</strong> が有効になるため、カスタム Prelude の import 宣言のみが必要となります。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">import</span> <span class="dt">RIO</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="fu">...</span></a></code></pre></div>
<p>まだ <code>import RIO</code> が残っているので、こいつをなんとかしましょう。</p>
<h2 id="base-noprelude-パッケージ">base-noprelude パッケージ</h2>
<p><a href="https://ghc.haskell.org/trac/ghc/ticket/9499?cversion=0&amp;cnum_hist=8">Add -prelude-is flag</a> というチケットで紹介されている方法を使えば、<code>import RIO</code> を記述することなく、<strong>Prelude</strong> のように利用できるようになります。</p>
<p>このチケットによれば <strong>-prelude-is</strong> というオプションを導入しようとしていたようですが、そんなことしなくても <strong>Prelude</strong> を置き換えれるよ！という話です。</p>
<p>具体的には <a href="https://github.com/haskell-hvr/base-noprelude">base-noprelude</a> パッケージを利用します。</p>
<h3 id="最小構成">最小構成</h3>
<p>この方法もかなり簡単で、<strong>stack.yaml</strong>, <strong>package.yaml</strong>, <strong>src/Prelude.hs</strong> をちょこっと書くだけで完成です。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co"># stack.yaml</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="fu">resolver:</span><span class="at"> nightly-2018-05-23</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="fu">packages:</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="kw">-</span> .</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="fu">extra-deps:</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="kw">-</span> base-noprelude-4.11.1.0</a></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co"># package.yaml</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="fu">name:</span><span class="at"> extended-prelude</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="fu">dependencies:</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="kw">-</span> base-noprelude</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="kw">-</span> rio</a>
<a class="sourceLine" id="cb6-7" data-line-number="7"></a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="fu">library:</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  <span class="fu">source-dirs:</span><span class="at"> src</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">  <span class="fu">other-modules:</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">  <span class="kw">-</span> Prelude</a></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="co">-- src/Prelude.hs</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Prelude</span> (<span class="kw">module</span> <span class="dt">RIO</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="kw">import</span> <span class="dt">RIO</span></a></code></pre></div>
<h3 id="確認">確認</h3>
<p>ファイルに <code>import RIO</code> を書かなくても本当に良いのか確かめてみます。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">-- src/Sample.hs</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Sample</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="ot">f ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">f <span class="fu">=</span> tshow <span class="st">&quot;a&quot;</span></a></code></pre></div>
<p>当然、通常の <strong>Prelude</strong> には <strong>Text</strong> も <strong>tshow</strong> も無いので、<code>import RIO</code> が有効になっていなければ、ビルドエラーになるはずです。</p>
<p><strong>ghci</strong> で確認してみましょう。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="fu">$</span> stack repl</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">ghci<span class="fu">&gt;</span> f</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="st">&quot;\&quot;a\&quot;&quot;</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t fromJust</a>
<a class="sourceLine" id="cb9-6" data-line-number="6"></a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span> error<span class="fu">:</span> <span class="dt">Variable</span> not <span class="kw">in</span> scope<span class="fu">:</span> fromJust</a>
<a class="sourceLine" id="cb9-8" data-line-number="8"></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t view</a>
<a class="sourceLine" id="cb9-10" data-line-number="10"><span class="ot">view ::</span> <span class="dt">MonadReader</span> s m <span class="ot">=&gt;</span> <span class="dt">Getting</span> a s a <span class="ot">-&gt;</span> m a</a></code></pre></div>
<p>ちゃんと動いてそうですね。</p>
<h2 id="まとめ">まとめ</h2>
<p>実際にこの手法で開発を進めているわけではないので、もしかすると落とし穴があるかもしれませんが、思ったより使いやすくてびっくりしました。</p>
<p>元の Prelude に戻すことも簡単だと思うので、興味があれば試してみて下さい。(結構前のチケットなので、周知の事実だったらすみません・・・。)</p>]]></summary>
</entry>
<entry>
    <title>extensible-0.4.9 がリリースされました。</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/05-14-release-extensible-049.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/05-14-release-extensible-049.html</id>
    <published>2018-05-14T00:00:00Z</published>
    <updated>2018-05-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>BIG MOON では、業務に必要なツールを自社開発しており、プログラミング言語に <strong>Haskell</strong> を採用しています。実用的に利用し始めて3年ぐらい？です。</p>
<p>僕らが <strong>Haskell</strong> を利用していて一番困った点はレコードの取り扱いです。</p>
<ul>
<li>異なる型のフィールドラベルに同じ名前を付けたい</li>
<li>フィールド全体対して関数を適用したい</li>
<li>フィールド多相な関数を定義したい</li>
</ul>
<p>このような問題に対して <a href="https://github.com/fumieval/extensible">extensible</a> という、(当初は謎に包まれていた) パッケージの利用を検討し、実際に既存のシステムを <strong>extensible</strong> で置き換えました。(当時アルバイトしていた <a href="https://github.com/matsubara0507">matsubara0507</a> さんが居なければ実現不可能だったと思います)</p>
<p>今回、縁あって作者の <a href="https://twitter.com/fumieval">fumieval</a> さんと一緒に仕事できる機会に恵まれました。fumieval さんは簡単な質問でも、とても気さくに答えてくれます。</p>
<p>僕達のノウハウはまだまだとても少ないですが、この素晴らしいパッケージを広く知って欲しいと思い、まだまだ作成途中ではありますが <a href="https://wiki.hask.moe/">extensible 攻略Wiki</a> という親しみやすい雰囲気で情報を発信していくことになりました。</p>
<p>この wiki もまた <strong>Haskell</strong> で作られており <a href="https://github.com/fumieval/apus">apus</a> という名前で公開されています。</p>
<p>今回の extensible-0.4.9 の<a href="https://github.com/fumieval/extensible/blob/master/CHANGELOG.md">アップデート</a>は、攻略wiki のコンテンツを拡充していく中で出てきたアイデアや、関数などがいくつか追加されました。(matsubara0507 さんと弊社も色々と貢献できているはずです！)</p>
<p>今回はその内容について簡単な例とともに解説を行いたいと思います。</p>
<ul>
<li><a href="https://hackage.haskell.org/package/extensible">Hackage extensible-0.4.9</a></li>
</ul>
<!--more-->
<h2 id="アップデート内容">アップデート内容</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="ch">&#39;[ &quot;name&quot; :&gt; String</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">   , <span class="st">&quot;age&quot;</span>  <span class="fu">:&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">   ]</a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="ot">person ::</span> <span class="dt">Person</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">person <span class="fu">=</span> <span class="fu">#</span>name <span class="fu">@=</span> <span class="st">&quot;bigmoon&quot;</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">      <span class="fu">&lt;:</span> <span class="fu">#</span>age  <span class="fu">@=</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">      <span class="fu">&lt;:</span> nil</a></code></pre></div>
<p>以降の例では、上記の <code>Person</code> 型と <code>person</code> 変数が宣言されているものとします。</p>
<hr />
<ul>
<li>MonadIO のインスタンスを一般化しました。</li>
</ul>
<p>ベースモナドとして <strong>ResourceT IO</strong> などが使えるようになりました。</p>
<p>今までは <code>Associate &quot;IO&quot; (ResourceT IO)</code> のように書けませんでしたが、こんな感じのコードが書けるようになりました。また、<a href="https://www.stackage.org/haddock/lts-11.9/resourcet-1.2.1/Control-Monad-Trans-Resource.html#t:ResourceT">ResourceT IO</a> 以外にも <a href="https://www.stackage.org/haddock/lts-11.9/base-4.10.1.0/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> のインスタンスであれば何でも指定可能です。</p>
<p>ここでは <a href="https://www.stackage.org/haddock/lts-11.9/resourcet-1.2.1/Control-Monad-Trans-Resource.html#t:MonadResource">MonadResource</a> のインスタンスを自分で定義しましたが、次回リリース (0.4.10) でライブラリに追加される予定？です。(たぶん)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">type</span> <span class="dt">ExampleM</span> <span class="fu">=</span> <span class="dt">Eff</span> <span class="ch">&#39;[ &quot;IO&quot; &gt;: ResourceT IO ]</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">main <span class="fu">=</span> runResourceT <span class="fu">.</span> retractEff <span class="fu">.</span> runConduit <span class="fu">$</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  bracketP (openFile <span class="st">&quot;data.csv&quot;</span> <span class="dt">ReadMode</span>) hClose <span class="fu">$</span> \handle <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    (sourceHandle<span class="ot"> handle ::</span> <span class="dt">ConduitT</span> i <span class="dt">ByteString</span> <span class="dt">ExampleM</span> ()) <span class="fu">.|</span> stdoutC</a>
<a class="sourceLine" id="cb2-7" data-line-number="7"></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="kw">instance</span> (<span class="dt">Associate</span> <span class="st">&quot;IO&quot;</span> (<span class="dt">ResourceT</span> <span class="dt">IO</span>) xs) <span class="ot">=&gt;</span> <span class="dt">MonadResource</span> (<span class="dt">Eff</span> xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  liftResourceT <span class="fu">=</span> liftEff (<span class="dt">Proxy</span> <span class="fu">@</span> <span class="st">&quot;IO&quot;</span>)</a></code></pre></div>
<p>ただ単に <code>csv</code> ファイルを読み込んで表示するだけの例です。</p>
<pre class="csv"><code>-- data.csv
&quot;bigmoon&quot;, 10, &quot;watch&quot;
&quot;wado&quot;, 100, art
</code></pre>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> main</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="st">&quot;bigmoon&quot;</span>, <span class="dv">10</span>, <span class="st">&quot;watch&quot;</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="st">&quot;wado&quot;</span>, <span class="dv">100</span>, art</a></code></pre></div>
<p><a href="https://github.com/waddlaw/extensible-example/blob/master/release-article/0.4.9/MonadIO.hs">完全なコード</a></p>
<hr />
<ul>
<li>新しい制約コンビネータ <a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Dictionary.html#t:And">And</a> を追加しました。</li>
</ul>
<p>このコンビネータを利用することで <a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Product.html#t:Forall">Forall</a> の制約を二つ以上指定することができます。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="dt">And</span><span class="ot"> ::</span> (k <span class="ot">-&gt;</span> <span class="dt">Constraint</span>) <span class="ot">-&gt;</span> (k <span class="ot">-&gt;</span> <span class="dt">Constraint</span>) <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Constraint</span></a></code></pre></div>
<p>以下は拡張可能レコードの値が <strong>Show</strong> かつ <a href="https://www.stackage.org/haddock/lts-11.9/base-4.10.1.0/Data-Typeable.html">Typeable</a> の両方を満たすという制約で <a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Product.html#v:hfoldMapFor">hfoldMapFor</a> 関数を使う例です。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">debug ::</span> <span class="dt">Forall</span> (<span class="dt">ValueIs</span> (<span class="dt">And</span> <span class="dt">Show</span> <span class="dt">Typeable</span>)) xs <span class="ot">=&gt;</span> <span class="dt">Record</span> xs <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">debug <span class="fu">=</span> hfoldMapFor c (print <span class="fu">.</span> fork id typeOf <span class="fu">.</span> view _Wrapper)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    c <span class="fu">=</span> <span class="dt">Proxy</span> <span class="fu">@</span> (<span class="dt">ValueIs</span> (<span class="dt">And</span> <span class="dt">Show</span> <span class="dt">Typeable</span>))</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    fork f g x <span class="fu">=</span> (f x, g x)</a></code></pre></div>
<p>例として定義した <strong>debug</strong> 関数は与えられた拡張可能レコードの <strong>値</strong> と <strong>型</strong> を表示することができます。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> debug person</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">(<span class="st">&quot;bigmoon&quot;</span>,[<span class="dt">Char</span>])</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">(<span class="dv">10</span>,<span class="dt">Int</span>)</a></code></pre></div>
<p><a href="https://github.com/waddlaw/extensible-example/blob/master/release-article/0.4.9/And.hs">完全なコード</a></p>
<hr />
<ul>
<li><a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Field.html#v:stringAssocKey">stringAssocKey</a> 関数を追加しました。</li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">stringAssocKey ::</span> (<span class="dt">IsString</span> a, <span class="dt">KnownSymbol</span> (<span class="dt">AssocKey</span> kv)) <span class="ot">=&gt;</span> proxy kv <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>この関数を使えば、拡張可能レコードのキーを文字列として取得することができます。</p>
<p>例えば、拡張可能レコードのキーを全て集めてリストにして返す関数は以下のように作ることができます。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">keys ::</span> (<span class="dt">IsString</span> key, <span class="dt">Forall</span> (<span class="dt">KeyIs</span> <span class="dt">KnownSymbol</span>) xs) <span class="ot">=&gt;</span> proxy xs <span class="ot">-&gt;</span> [key]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">keys xs <span class="fu">=</span> henumerateFor (<span class="dt">Proxy</span> <span class="fu">@</span> (<span class="dt">KeyIs</span> <span class="dt">KnownSymbol</span>)) xs ((<span class="fu">:</span>) <span class="fu">.</span> stringAssocKey) []</a></code></pre></div>
<p><a href="https://www.stackage.org/haddock/lts-11.9/base-4.10.1.0/Data-String.html#t:IsString">IsString</a> のインスタンスであれば何でも良いので、<strong>String</strong> に限らず <strong>Text</strong>, <strong>ByteString</strong> などを返すことができます。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> mapM_ putStrLn <span class="fu">$</span> keys person</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">name</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">age</a>
<a class="sourceLine" id="cb10-4" data-line-number="4"></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> mapM_ Data.Text.IO.putStrLn <span class="fu">$</span> keys person</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">name</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">age</a></code></pre></div>
<p><a href="https://github.com/waddlaw/extensible-example/blob/master/release-article/0.4.9/StringAssocKey.hs">完全なコード</a></p>
<hr />
<ul>
<li><a href="https://hackage.haskell.org/package/prettyprinter">prettyprinter</a> パッケージの <strong>Pretty</strong> のインスタンスを追加しました。</li>
</ul>
<p>prettyprinter パッケージについては<a href="https://haskell.e-bigmoon.com/posts/2018/03-30-prettyprinter.html">過去のブログ記事</a>で少し紹介しているので、興味ある方はそちらをご確認ください。</p>
<p>以下のような出力になるそうです。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">[ name<span class="fu">:</span> <span class="dt">DA</span><span class="fu">-</span>192H</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  weight<span class="fu">:</span> <span class="fl">260.0</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  price<span class="fu">:</span> <span class="dv">120</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  featured<span class="fu">:</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  description<span class="fu">:</span> <span class="dt">High</span><span class="fu">-</span>quality (24bit 192kHz), lightweight portable <span class="dt">DAC</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">  quantity<span class="fu">:</span> <span class="dv">20</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">, name<span class="fu">:</span> <span class="dt">HHP</span><span class="fu">-</span><span class="dv">150</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">  weight<span class="fu">:</span> <span class="fl">200.0</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9">  price<span class="fu">:</span> <span class="dv">330</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">  featured<span class="fu">:</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb11-11" data-line-number="11">  description<span class="fu">:</span> <span class="dt">Premium</span> wooden headphone</a>
<a class="sourceLine" id="cb11-12" data-line-number="12">  quantity<span class="fu">:</span> <span class="dv">55</span> ]</a></code></pre></div>
<p>現状は <code>prettyprinter</code> 側のバグ？で上手く表示されていないようですが、そのうち直ると思います。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> pretty person</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">{ name<span class="fu">:</span> bigmoon; age<span class="fu">:</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> pretty [person, person]</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">[{ name<span class="fu">:</span> bigmoon; age<span class="fu">:</span> <span class="dv">10</span> }, { name<span class="fu">:</span> bigmoon; age<span class="fu">:</span> <span class="dv">10</span> }]</a></code></pre></div>
<p><a href="https://github.com/waddlaw/extensible-example/blob/master/release-article/0.4.9/Pretty.hs">完全なコード</a></p>
<hr />
<ul>
<li><a href="https://hackage.haskell.org/package/th-lift">th-lift</a> の <strong>Lift</strong> のインスタンスを追加しました。</li>
</ul>
<p><strong>Lift</strong> のインスタンスになったので例えば、<strong>Data.Yaml.TH</strong> モジュールの <a href="https://www.stackage.org/haddock/lts-11.9/yaml-0.8.30/Data-Yaml-TH.html#v:decodeFile">decodeFile</a> 関数を使ってコンパイル時に <strong>yaml</strong> ファイルから一気に拡張可能レコードを作り上げることができます。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">config ::</span> <span class="dt">Config</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">config <span class="fu">=</span> <span class="fu">$$</span>(Yaml.TH.decodeFile <span class="st">&quot;config.yaml&quot;</span>)</a></code></pre></div>
<p>実行例:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="co"># config.yaml</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="fu">name:</span><span class="at"> </span><span class="st">&quot;bigmoon&quot;</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="fu">age:</span><span class="at"> 10</span></a></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> config</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">name <span class="fu">@=</span> <span class="st">&quot;bigmoon&quot;</span> <span class="fu">&lt;:</span> age <span class="fu">@=</span> <span class="dv">10</span> <span class="fu">&lt;:</span> nil</a></code></pre></div>
<p><a href="https://github.com/waddlaw/extensible-example/blob/master/release-article/0.4.9/Lift.hs">完全なコード</a></p>
<hr />
<ul>
<li><a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Product.html#v:hmapWithIndexFor">hmapWithIndexFor</a> を追加しました。</li>
</ul>
<p><a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Product.html#v:hmapWithIndex">hmapWithIndex</a> の制約付きバージョンです。</p>
<p>例えば以下のようにして拡張可能レコードから <strong>aeson</strong> パッケージの <a href="https://www.stackage.org/haddock/lts-11.9/aeson-1.2.4.0/Data-Aeson.html#t:Value">Value</a> をフィールドとして持つ拡張可能レコードに変換できます。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">toJSONRecord ::</span> <span class="dt">Forall</span> (<span class="dt">ValueIs</span> <span class="dt">ToJSON</span>) xs <span class="ot">=&gt;</span> <span class="dt">Record</span> xs <span class="ot">-&gt;</span> <span class="dt">RecordOf</span> (<span class="dt">Const&#39;</span> <span class="dt">Value</span>) xs</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">toJSONRecord <span class="fu">=</span> hmapWithIndexFor c <span class="fu">$</span> \m <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">    <span class="dt">Field</span> <span class="fu">.</span> <span class="dt">Const&#39;</span> <span class="fu">.</span> toJSON <span class="fu">.</span> view _Wrapper</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  <span class="kw">where</span> c <span class="fu">=</span> <span class="dt">Proxy</span> <span class="fu">@</span> (<span class="dt">ValueIs</span> <span class="dt">ToJSON</span>)</a></code></pre></div>
<p>実行例:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> person</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">name <span class="fu">@=</span> <span class="st">&quot;bigmoon&quot;</span> <span class="fu">&lt;:</span> age <span class="fu">@=</span> <span class="dv">10</span> <span class="fu">&lt;:</span> nil</a>
<a class="sourceLine" id="cb17-3" data-line-number="3"></a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> toJSONRecord person</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">name <span class="fu">@=</span> <span class="dt">String</span> <span class="st">&quot;bigmoon&quot;</span> <span class="fu">&lt;:</span> age <span class="fu">@=</span> <span class="dt">Number</span> <span class="fl">10.0</span> <span class="fu">&lt;:</span> nil</a></code></pre></div>
<p><a href="https://github.com/waddlaw/extensible-example/blob/master/release-article/0.4.9/HmapWithIndexFor.hs">完全なコード</a></p>
<hr />
<ul>
<li><a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Wrapper.html#t:Const-39-">Const’</a> に Monoid のインスタンスを追加しました。</li>
</ul>
<hr />
<ul>
<li><a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Wrapper.html#t:Wrapper">Wrapper</a> に Either e のインスタンスを追加しました。</li>
</ul>
<h2 id="まとめ">まとめ</h2>
<p><strong>extensible</strong> パッケージは初見では全く使い方がわからないレベルで難しいですが、実際に使ってみると、今までリアルワールド Haskell っぽいコードだね。仕方ないね。と妥協していた部分がとても綺麗に書けるようになります。</p>
<p><a href="https://wiki.hask.moe/">extensible 攻略Wiki</a> の内容はこれからもっと充実して行くので、気になる人はチェックしてみてください！</p>]]></summary>
</entry>
<entry>
    <title>Stack 1.7.1 がリリースされました。</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/05-04-stack171.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/05-04-stack171.html</id>
    <published>2018-05-04T00:00:00Z</published>
    <updated>2018-05-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>4月28日に Stack version 1.7.1 が<a href="https://github.com/commercialhaskell/stack/blob/v1.7.1/ChangeLog.md#v171">リリース</a>されました。</p>
<p>更新は以下のコマンドですぐに終わります。</p>
<pre class="shell"><code>$ stack upgrade
...

$ stack --version
Version 1.7.1, Git revision 681c800873816c022739ca7ed14755e85a579565 (5807 commits) x86_64 hpack-0.28.2</code></pre>
<!--more-->
<h2 id="リリースノート">リリースノート</h2>
<ul>
<li><strong>aarch64 (64ビットARM) で初めて stack が利用できるようになりました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/commit/9a23b91bd1ba4d120a77c9982e85079f825ebf06#diff-e705c8fadf1193ab59443a5e6c8cbe8b">9a23b91bd1ba4d120a77c9982e85079f825ebf06</a>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>stack のダウンロードリンクが <code>https://www.stackage.org/stack/</code> から <code>https://get.haskellstack.org/stable/</code> に変わりました。</p>
<p>各種バイナリへのリンクは <code>https://get.haskellstack.org/stable/&lt;PLATFORM&gt;.&lt;EXTENSION&gt;</code> という形式になるようです。</p>
<ul>
<li><strong>GHC 8.2.2 への対応が困難なため、静的にリンクされた Alpile Linux 向け stack は利用できなくなりました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/2387">Official support for Alpine Linux #2387</a>
</li>
<li>
<a href="https://ghc.haskell.org/trac/ghc/ticket/14739">Cannot compile ghc 8.2.1 or 8.2.2 on armv7l architectures</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/commit/9a23b91bd1ba4d120a77c9982e85079f825ebf06#diff-e705c8fadf1193ab59443a5e6c8cbe8b">9a23b91bd1ba4d120a77c9982e85079f825ebf06</a>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>GHC 8.2.2 から CentOS 6 の 32-bit Linux GMP4 はサポートされなくなりました。そのため stack も利用できなくなりました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3613">linux64-gmp4 variant for GHC 8.2.2 #3613</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/commit/9a23b91bd1ba4d120a77c9982e85079f825ebf06#diff-e705c8fadf1193ab59443a5e6c8cbe8b">9a23b91bd1ba4d120a77c9982e85079f825ebf06</a>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>実際の<a href="https://github.com/commercialhaskell/stack/blob/9a23b91bd1ba4d120a77c9982e85079f825ebf06/etc/scripts/get-stack.sh#L224">コード</a>を見てみるとまだ使えそうな気がしますが、stack 1.7.1 からは<a href="https://github.com/commercialhaskell/stack/releases/download/v1.7.1/stack-1.7.1-linux-i386-gmp4.tar.gz">リンク切れ</a>になります。(stack v1.6.5 とかであれば<a href="https://github.com/commercialhaskell/stack/releases/download/v1.6.5/stack-1.6.5-linux-i386-gmp4.tar.gz">ダウンロード可能</a>です。)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1">  <span class="kw">else</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    <span class="ex">install_dependencies</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="kw">case</span> <span class="st">&quot;</span><span class="va">$1</span><span class="st">&quot;</span><span class="kw"> in</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">      <span class="st">&quot;6&quot;</span><span class="kw">)</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">        <span class="ex">print_bindist_notice</span> <span class="st">&quot;libgmp4&quot;</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">        <span class="ex">install_32bit_gmp4_linked_binary</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">        <span class="kw">;;</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">      *<span class="kw">)</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">        <span class="ex">print_bindist_notice</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">        <span class="ex">install_32bit_standard_binary</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">        <span class="kw">;;</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">    <span class="kw">esac</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13">  <span class="kw">fi</span></a></code></pre></div>
<h3 id="大きな変更">大きな変更</h3>
<ul>
<li><strong>Cabal のバージョンを 2.0 から 2.2 にアップグレードしました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3878">Switch to Cabal 2.2 (prerelease) #3878</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="変更点">変更点</h3>
<ul>
<li><strong>GCC を利用する Linux ディストリビューションで、デフォルトで PIE が有効になっている場合、<code>stack setup</code> コマンドは異なる GHC 設定オプションを利用しなくなりました。ghc-8.0.2 から GHC は自分自身で検出できるようになり、Stack’s attempted workaround for older versions caused more problems than it solved.</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3636">Setup fails with ‘No information found for ghc-8.2.2’ for OS key ‘linux64-ncurses6-nopie’ #3636</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3715">setup: improvements to selecting bindists on Linux #3715</a>
</li>
<li>
<a href="https://github.com/fpco/stackage-content/pull/34">stack-setup-2: nopie fixes for Arch, Gentoo, and Void Linux #34</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p>いまいち良くわかってないですが、<a href="https://github.com/commercialhaskell/stack/pull/3715/files#diff-4968f87e674615592e572f2ec593e5b0L558">コードの差分</a>を見ると <code>noPie</code> に関する部分が全部削除されてるので、その辺りを GHC が上手く処理するようになったんでしょう・・・。</p>
<ul>
<li><strong><code>stack new</code> コマンドは、プロジェクトテンプレートに stack.yaml ファイルが含まれる場合に、初期化処理を行わないようになりました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3888">Initialize a new project only when no stack.yaml #3888</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p>今まで通り <code>stack.yaml</code> が含まれている場合でも初期化させたい場合は<code>forceOverwrite initOpts</code> が <code>True</code> になれば良いので、<code>--force</code> フラグをつければ良さそうですね。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode diff"><code class="sourceCode diff"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="st">-        initProject IsNewCmd dir initOpts globalResolver</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="va">+        exists &lt;- doesFileExist $ dir &lt;/&gt; stackDotYaml</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="va">+        when (forceOverwrite initOpts || not exists) $</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="va">+            initProject IsNewCmd dir initOpts globalResolver</span></a></code></pre></div>
<h3 id="その他の改良点">その他の改良点</h3>
<ul>
<li><strong>stack に新たなサブコマンド <code>ls</code> が導入されました。このコマンドによってローカル及びリモートのスナップショットを確認することができます。詳細は <code>stack ls snapshots --help</code> コマンドでご確認ください。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/1614">A new stack show command and missing informative commands #1614</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3252">Introduce new sub command ls #3252</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p>過去の<a href="../2017/12-20-stack-ls-command.html">ブログ記事</a>で紹介しているので気になる方はご参照ください。</p>
<ul>
<li><strong><code>list-dependencies</code> コマンドが廃止されます。同等の機能は <code>ls dependencies</code> コマンドで引き続き提供されます。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3669">Stack list-dependencies : Bring it under the new ls umbrella command #3669</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3706">Port <code>list-dependencies</code> under the new ls sub command #3706</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p>v1.7.1 ではまだ利用できますが、以下のように <code>DEPRECATED</code> メッセージが表示されます。一応 v1.8 で削除される予定です。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1">$ <span class="ex">stack</span> list-dependencies</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ex">DEPRECATED</span>: Use ls dependencies instead. Will be removed in next major version.</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="ex">...</span></a></code></pre></div>
<ul>
<li><strong>全ての HTTP リクエストヘッダに User-Agent が追加されるようになりました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3628">Specify User-Agent to get over my company’s firewall #3628</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3682/">Specify User-Agent on every HTTP request (#3628) #3682</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p>今までは <code>User-Agent</code> が付いていなかったみたいですが、<code>The Haskell Stack</code> が全てのHTTPリクエストに対して付与されるようになったみたいです。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode diff"><code class="sourceCode diff"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="va">+setUserAgent :: Request -&gt; Request</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="va">+setUserAgent = setRequestHeader &quot;User-Agent&quot; [&quot;The Haskell Stack&quot;]</span></a></code></pre></div>
<ul>
<li><strong><code>stack setup</code> コマンドは互換性のある GHC をインストールするために、任意の OS キーによるインストールを試すようになりました (これは OS キーをどれか1つだけチェックするよりも良い方法です)。この変更は Linux の各ディストリビューションで libinfo 5/6, ncurses 5/6, gmp 4/5 の異なった組み合わせに起因するものです。今後の GHC リリースを見据えて、セットアップに関する YAML メタデータをシンプルに保つことができます。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3521">Check for ncurses6 before checking for tinfo6 #3521</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3715">setup: improvements to selecting bindists on Linux #3715</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>ビルドプログレスバーが現在ビルドしているパッケージ名を表示するようになりました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3763">Report currently building packages along with “Progress:” label #3763</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tbody>
</table>
<p>変更前の表示結果</p>
<pre><code>Progress: 3/74</code></pre>
<p>変更後の表示結果</p>
<pre><code>Progress: 3/74; [Cabal-2.0.1.1|basement-0.0.4|old-time-1.1.0.3|simple-sendfile-0.2.26|stm-2.4.4.1|stringsearch-0.3.6.6]</code></pre>
<ul>
<li><strong><code>stack setup --verbose</code> の出力に GHC 設定処理のログを含めるようにしました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3716">“stack setup –verbose” should also cause verbose output of GHC configure process if possible #3716</a>
</li>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3712">Never ending “Configuring GHC…” #3712</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3740">Log GHC configure output on <code>stack -v setup</code> #3740</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p>変更前は以下のように <code>Configuring GHC ...</code> で何も表示されていなかったようです。</p>
<pre class="shell"><code>$ stack build --verbose
...

2017-12-27 00:30:23.869257: [debug] Run process: /home/gleb/.stack/programs/x86_64-linux/ghc-tinfo6-nopie-8.0.2.temp/ghc-8.0.2/configure --prefix=/home/gleb/.stack/programs/x86_64-linux/ghc-tinfo6-nopie-8.0.2/
@(System/Process/Log.hs:37:3)
Configuring GHC ...</code></pre>
<p>変更後は、こんな感じのログが続いて表示されるようになったようです。</p>
<pre class="shell"><code>...
018-01-03 10:49:29.280793: [debug] Run process within /home/kp/.stack/programs/x86_64-linux/ghc-7.10.3.temp/ghc-7.10.3/: /usr/bin/make install
@(subs/rio/src/RIO/Process.hs:191:3)
2018-01-03 10:49:29.304283: [info] /usr/bin/make -r --no-print-directory -f ghc.mk install BINDIST=YES NO_INCLUDE_DEPS=YES
@(Stack/Setup.hs:1096:54)
2018-01-03 10:49:29.737966: [info] &quot;rm&quot; -f utils/ghc-pkg/dist-install/build/Version.hs
@(Stack/Setup.hs:1096:54)
2018-01-03 10:49:29.739872: [info] echo &quot;module Version where&quot;                    &gt;&gt; utils/ghc-pkg/dist-install/build/Version.hs
@(Stack/Setup.hs:1096:54)
2018-01-03 10:49:29.741026: [info] echo &quot;version, targetOS, targetARCH :: String&quot; &gt;&gt; utils/ghc-pkg/dist-install/build/Version.hs
@(Stack/Setup.hs:1096:54)
2018-01-03 10:49:29.742170: [info] echo &quot;version    = \&quot;7.10.3\&quot;&quot;      &gt;&gt; utils/ghc-pkg/dist-install/build/Version.hs</code></pre>
<ul>
<li><strong>ファイルパスまたは git 参照から <code>extra-dep</code> が見つからなかった時のエラーメッセージが改善されました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3806">Confusing error message when a cabal file for an extra-dep can’t be found #3806</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3808">When a cabal file can’t be found, warn that extra-deps could be the problem too #3808</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p>こんな感じでエラーメッセージが改善されたようです。</p>
<p><a href="https://user-images.githubusercontent.com/1274145/35401090-6f853812-01ad-11e8-8c02-622f9ea9c2da.png" target="_blank"><img src="https://user-images.githubusercontent.com/1274145/35401090-6f853812-01ad-11e8-8c02-622f9ea9c2da.png"></a></p>
<ul>
<li><strong>Windows 環境では Nix インテグレーションがサポートされていないため、明示的にフラグを有効にした場合でも常に無効になるように変更しました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3600">Nix doesn’t work on Windows #3600</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3833">Disable nix on windows (#3600) #3833</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<ul>
<li><strong><code>stack build</code> に <code>--keep-tmp-files</code> フラグを追加しました。デバッグ目的のため一時的に作成したファイルやディレクトリを削除せずに残しておくことができます。このフラグは同等の機能を持つ ghc オプションと同時に使うと良いでしょう。例: <code>stack build --keep-tmp-files --ghc-options=-keep-tmp-files</code></strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3857">How to keep temporary files on build failures? #3857</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3858">stack build: Add –keep-tmp-files flag. Fixes #3857 #3858</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p><code>stack.yaml</code> の <code>build</code> セクションに指定することもできるようです。(デフォルト値は <code>False</code>)</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="fu">build:</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="fu">library-profiling:</span><span class="at"> false</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="fu">executable-profiling:</span><span class="at"> false</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  <span class="fu">copy-bins:</span><span class="at"> false</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  <span class="fu">prefetch:</span><span class="at"> false</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">  <span class="fu">keep-going:</span><span class="at"> false</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  <span class="fu">keep-tmp-files:</span><span class="at"> false</span></a></code></pre></div>
<ul>
<li><strong>スナップショットのパーズ例外時のエラーメッセージを改善しました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3879">Improved error messages for snapshot parse exceptions #3879</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<ul>
<li><strong><code>stack unpack</code> コマンドに <code>--to /target/directory</code> オプションが追加されました。パッケージの展開先を指定できるようになります。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3904">Possibility to specify a base path to unpack a package #3904</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3947">Add –to option to the unpack command to specify destination #3947</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<ul>
<li><strong><code>stack hoogle</code> コマンドに <code>--server</code> オプションが追加されました。ローカルのポート8080番で Hoogle サーバーが起動します。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/2310">Add <code>stack hoogle --server</code> command #2310</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3941">Introduce Hoogle server command line option #3941</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p><code>stack hoogle --server</code> は <code>stack hoogle -- server --local --port 8080</code> の省略形です。</p>
<h3 id="リリースノートに載ってない変更">リリースノートに載ってない変更</h3>
<ul>
<li><code>extra-deps</code> で <code>github</code> という短縮形が使えるようになりました。</li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3873">Allow github shorthand for extra-deps #3873</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3890">Allow ‘github’ shorthand for extra-deps (fixes #3873) #3890</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p>以下のように書くことができます。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">-</span> <span class="fu">github:</span><span class="at"> commercialhaskell/rio</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="fu">commit:</span><span class="at"> 09654f9fcbdcd96d0f5102796b32fdac5da7260e</span></a></code></pre></div>
<p><code>commit</code> は短縮して記述することもできます。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">-</span> <span class="fu">github:</span><span class="at"> commercialhaskell/rio</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="fu">commit:</span><span class="at"> </span><span class="st">&quot;09654&quot;</span></a></code></pre></div>
<p><a href="https://github.com/mitchellwrosen/stack/blob/9489cf7d12c54ea40ab043e199d7850d2502e140/src/test/Stack/Types/BuildPlanSpec.hs">BuildPlanSpec.hs</a> にテストがいくつか載っていいるので、そこを見れば利用可能な形式がわかります。</p>
<h3 id="バグフィックス">バグフィックス</h3>
<ul>
<li><strong>スクリプトインタプリタ形式で暗黙的に渡されるファイル引数を他の引数より先に処理するようにしました。この修正により、スクリプト実行時に – +RTS … -RTS を渡せるようになりました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3658">Error when using RTS options with the Stack script interpreter #3658</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3668">Put file arguments first when stack is run as script interpreter #3658 #3668</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p><a href="./02-21-stack165.html">v.1.6.5</a> の時に紹介したので、そちらをご確認ください。</p>
<ul>
<li><strong>stack 設定ファイルで year パラメータが設定できるようになりました。それに伴い、ドキュメントもわかりやすくしました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/2275">stack new – AesonException #2275</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3701">Fix use of and document year template parameter #3701</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p><a href="./02-21-stack165.html">v.1.6.5</a> の時に紹介したので、そちらをご確認ください。</p>
<ul>
<li><strong>ベンチーマークが別のベンチマークやビルドステップと並行して実行されてしまう問題を修正しました。これは別のプロセスのCPU利用がベンチマークに悪影響を及ぼすと思われるので理想的ではありません。また、デフォルトでベンチマークの出力が表示されないようになっていた件も同様に修正しました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3663">Benchmarks are run in parallel #3663</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3666">Never run benchmarks concurrently, always output to console #3663 #3666</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p><a href="./02-21-stack165.html">v.1.6.5</a> の時に紹介したので、そちらをご確認ください。</p>
<ul>
<li><strong>stack ghci で複数のパッケージで定義されている同名のモジュールを読み込めるようになりました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3776">Add rio package as a dep of stack #3776</a>
</li>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3779">With ghci, allow multiple packages to use the same module #3776 #3779</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p><a href="./02-21-stack165.html">v.1.6.5</a> の時に紹介したので、そちらをご確認ください。</p>
<ul>
<li><strong>stack ghci で base の依存関係を追加する必要が無くなりました。これはローカルターゲットが存在しない場合に自動的に追加されるためです。これにより、base を置き換えているコードも同様に読み込めるようになります。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3589">stack ghci at global level missing base #3589</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/commit/196bdbae986ddf887f92999b26129085a8ed0be5">196bdbae986ddf887f92999b26129085a8ed0be5</a>
</li>
<li>
<a href="https://github.com/commercialhaskell/stack/commit/99950cfae2e014f76abbebd51869e5cae5f00a6a">99950cfae2e014f76abbebd51869e5cae5f00a6a</a>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><a href="./02-21-stack165.html">v.1.6.5</a> の時に紹介したので、そちらをご確認ください。</p>
<ul>
<li><strong><code>stack ghci</code> コマンドで autogen ファイルのパスを適切に扱えるようになりました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3791">Adjust <code>-i</code> paths used by ghci to point to autogen / etc files generated by newer Cabal #3791</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3795">Use per-component build directories for ghci with Cabal&gt;=2.0 #3791 #3795</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>stack はサブディレクトリを含むパッケージを常に再コンパイルしていました。現在は修正され、サブディレクトリを再コンパイルする必要がある時だけ行うようになりました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3899">hakyll dependency on nightly is not cached #3899</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3955">Don’t recompile in presence of sublibraries #3955</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p>特に <code>Hakyll</code> や <code>Pandoc</code> (依存しているライブラリも同様に影響を受ける) を使う場合に踏み抜く可能性があるため、影響を受けている人はアップグレード推奨です。</p>
<ul>
<li><code>get-stack.sh</code> インストールスクリプトにおいて Debian/Fedora/CentOS の依存関係のインストールをドキュメントの手動で行う場合と一致するように修正しました。</li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/commit/9dfff2760b659c84605028002cd6500cdb52c823#diff-e705c8fadf1193ab59443a5e6c8cbe8b">9dfff2760b659c84605028002cd6500cdb52c823</a>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><a href="https://docs.haskellstack.org/en/stable/install_and_upgrade/#manual-download_2">Manual Download</a> の内容と同様の処理になりました。(<code>git</code> と <code>gnupg</code> が追加されました)</p>
<ul>
<li><strong>Nix を利用する場合に gmp で Cabal-simple をコンパイルするように修正しました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/2944">Nix: stack should compile setup-Simple-Cabal with libgmp #2944</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3971">#2944: Compile Cabal-simple with gmp when using Nix #3971</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<ul>
<li><strong><code>stack ghci</code> コマンドの stack 処理は ghci で置き換えられました。これによりシグナルハンドリングの動作が改善されます。特に Ctrl-C のハンドリングが改善されます。そのため、生成されたファイルは終了後に残ります。このパスはファイルコンテンツのハッシュにより決まり、システムの一時的なディレクトリに保存されます。そのため、必要に応じて綺麗にしましょう。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3821">stack repl exits on ctrl+c with error <stdin>: hGetChar: hardware fault (Input/output error) #3821</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3869">Fix stack ghci ctrl c 3821 #3869</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p><code>stack repl</code> を実行すると、実際にはこんな感じでディレクトリとファイルが作られます。<code>ba125cb0</code> や <code>e4ed4429</code> というファイル名はファイルのコンテンツハッシュによって決まるそうです。(<code>tmp</code> というディレクトリ名は環境によって異なります)</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb13-1" data-line-number="1">$ <span class="ex">tree</span> /tmp/haskell-stack-ghci/</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="ex">/tmp/haskell-stack-ghci/</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">├── <span class="ex">ba125cb0</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">│   └── <span class="ex">cabal_macros.h</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">└── <span class="ex">e4ed4429</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    └── <span class="ex">ghci-script</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7"></a>
<a class="sourceLine" id="cb13-8" data-line-number="8"><span class="ex">2</span> directories, 2 files</a></code></pre></div>
<h2 id="changelog-オリジナル">Changelog (オリジナル)</h2>
<h3 id="release-notes">Release notes</h3>
<ul>
<li>aarch64 (64-bit ARM) bindists are now available for the first time.</li>
<li>Statically linked Linux bindists are no longer available, due to difficulty with GHC 8.2.2 on Alpine Linux.</li>
<li>32-bit Linux GMP4 bindists for CentOS 6 are no longer available, since GHC 8.2.2 is no longer being built for that platform.</li>
</ul>
<h3 id="major-changes">Major changes</h3>
<ul>
<li>Upgrade from Cabal 2.0 to Cabal 2.2</li>
</ul>
<h3 id="behavior-changes">Behavior changes</h3>
<ul>
<li><code>stack setup</code> no longer uses different GHC configure options on Linux distributions that use GCC with PIE enabled by default. GHC detects this itself since ghc-8.0.2, and Stack’s attempted workaround for older versions caused more problems than it solved.</li>
<li><code>stack new</code> no longer initializes a project if the project template contains a stack.yaml file.</li>
</ul>
<h3 id="other-enhancements">Other enhancements</h3>
<ul>
<li>A new sub command <code>ls</code> has been introduced to stack to view local and remote snapshots present in the system. Use <code>stack ls snapshots --help</code> to get more details about it.</li>
<li><code>list-dependencies</code> has been deprecated. The functionality has to accessed through the new <code>ls dependencies</code> interface. See <a href="https://github.com/commercialhaskell/stack/issues/3669">#3669</a> for details.</li>
<li>Specify User-Agent HTTP request header on every HTTP request. See <a href="https://github.com/commercialhaskell/stack/issues/3628">#3628</a> for details.</li>
<li><code>stack setup</code> looks for GHC bindists and installations by any OS key that is compatible (rather than only checking a single one). This is relevant on Linux where different distributions may have different combinations of libtinfo 5/6, ncurses 5/6, and gmp 4/5, and will allow simpifying the setup-info metadata YAML for future GHC releases.</li>
<li>The build progress bar reports names of packages currently building.</li>
<li><code>stack setup --verbose</code> causes verbose output of GHC configure process. See <a href="https://github.com/commercialhaskell/stack/issues/3716">#3716</a></li>
<li>Improve the error message when an <code>extra-dep</code> from a path or git reference can’t be found See <a href="https://github.com/commercialhaskell/stack/pull/3808">#3808</a></li>
<li>Nix integration is now disabled on windows even if explicitly enabled, since it isn’t supported. See <a href="https://github.com/commercialhaskell/stack/issues/3600">#3600</a></li>
<li><code>stack build</code> now supports a new flag <code>--keep-tmp-files</code> to retain intermediate files and directories for the purpose of debugging. It is best used with ghc’s equivalent flag, i.e. <code>stack build --keep-tmp-files --ghc-options=-keep-tmp-files</code>. See <a href="https://github.com/commercialhaskell/stack/issues/3857">#3857</a></li>
<li>Improved error messages for snapshot parse exceptions</li>
<li><code>stack unpack</code> now supports a <code>--to /target/directory</code> option to specify where to unpack the package into</li>
<li><code>stack hoogle</code> now supports a new flag <code>--server</code> that launches local Hoogle server on port 8080. See <a href="https://github.com/commercialhaskell/stack/issues/2310">#2310</a></li>
</ul>
<h3 id="bug-fixes">Bug fixes</h3>
<ul>
<li>The script interpreter’s implicit file arguments are now passed before other arguments. See <a href="https://github.com/commercialhaskell/stack/issues/3658">#3658</a>. In particular, this makes it possible to pass <code>-- +RTS ... -RTS</code> to specify RTS arguments used when running the script.</li>
<li>Don’t ignore the template <code>year</code> parameter in config files, and clarify the surrounding documentation. See <a href="https://github.com/commercialhaskell/stack/issues/2275">#2275</a>.</li>
<li>Benchmarks used to be run concurrently with other benchmarks and build steps. This is non-ideal because CPU usage of other processes may interfere with benchmarks. It also prevented benchmark output from being displayed by default. This is now fixed. See <a href="https://github.com/commercialhaskell/stack/issues/3663">#3663</a>.</li>
<li><code>stack ghci</code> now allows loading multiple packages with the same module name, as long as they have the same filepath. See <a href="https://github.com/commercialhaskell/stack/pull/3776">#3776</a>.</li>
<li><code>stack ghci</code> no longer always adds a dependency on <code>base</code>. It is now only added when there are no local targets. This allows it to be to load code that uses replacements for <code>base</code>. See <a href="https://github.com/commercialhaskell/stack/issues/3589#issuecomment">#3589</a></li>
<li><code>stack ghci</code> now uses correct paths for autogen files with <a href="https://github.com/commercialhaskell/stack/issues/3791">#3791</a></li>
<li>When a package contained sublibraries, stack was always recompiling the package. This has been fixed now, no recompilation is being done because of sublibraries. See <a href="https://github.com/commercialhaskell/stack/issues/3899">#3899</a>.</li>
<li>The <code>get-stack.sh</code> install script now matches manual instructions when it comes to Debian/Fedora/CentOS install dependencies.</li>
<li>Compile Cabal-simple with gmp when using Nix. See <a href="https://github.com/commercialhaskell/stack/issues/2944">#2944</a></li>
<li><code>stack ghci</code> now replaces the stack process with ghci. This improves signal handling behavior. In particular, handling of Ctrl-C. To make this possible, the generated files are now left behind after exit. The paths are based on hashing file contents, and it’s stored in the system temporary directory, so this shouldn’t result in too much garbage. See <a href="https://github.com/commercialhaskell/stack/issues/3821">#3821</a>.</li>
</ul>]]></summary>
</entry>
<entry>
    <title>HIE でコード整形時に改行が追加されてしまうバグが直りました</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/04-18-hie.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/04-18-hie.html</id>
    <published>2018-04-18T00:00:00Z</published>
    <updated>2018-04-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p><strong>vscode</strong> + <strong>Haskell IDE Engine</strong> の組み合わせで <code>Haskell</code> を書き続けて半年ぐらいになります。</p>
<p><code>hie</code> が採用している整形ツールは <a href="https://github.com/lspitzner/brittany">brittany</a> なのですが、個人的には <a href="https://github.com/commercialhaskell/hindent">hindent</a> よりも気に入っています。(最近 <a href="https://github.com/lspitzner/brittany/pull/124">Add import and module support #124</a> が実装されたんですけど、この部分は正直気に入っていない・・・。<code>stylish-haskell</code> の結果の方が好きです。)</p>
<p>今回のバグはコード整形時にファイルの最後に空行が追加されてしまうというものでした・・・。(100回実行すると100行追加されます・・・)</p>
<ul>
<li><a href="https://github.com/haskell/haskell-ide-engine/issues/289">Newline added on every save #289</a></li>
<li><a href="https://github.com/haskell/haskell-ide-engine/issues/521">Formatting code adds newline at the end of the file #521</a></li>
</ul>
<p>上記の <code>issue</code> が <a href="https://github.com/haskell/haskell-ide-engine/pull/525">Fix extra newline being added when formatting document #525</a> で修正されました。</p>
<p>手作業で毎回削除してて、絶対何かおかしいと思ってましたが、ちゃんと直りました！！！やったね！</p>
<p>以上です。</p>
<!--more-->]]></summary>
</entry>
<entry>
    <title>LiquidHaskell の --prune-unsorted フラグ</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/04-14-lh-unsorted-flag.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/04-14-lh-unsorted-flag.html</id>
    <published>2018-04-14T00:00:00Z</published>
    <updated>2018-04-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p><code>LiquidHaskell</code> では <code>measure</code> という仕組みを使って <code>Haskell</code> の関数を <code>LH</code> の述語に持ち上げることができます。</p>
<p>しかし、以下の <code>nLen</code> 関数は <code>measure</code> によって持ち上げることができません。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co">{-@ measure nLen @-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">nLen ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">nLen [] <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">nLen (n<span class="fu">:</span>ns) <span class="fu">=</span> n <span class="fu">+</span> nLen ns</a></code></pre></div>
<p>結論から言えば、これを解決するためには <code>--prune-unsorted</code> フラグを利用します。</p>
<p>以下は <code>measure</code> の基本的な使い方等についての説明です。</p>
<!--more-->
<h2 id="measure-の基本的な使い方">measure の基本的な使い方</h2>
<p>例えばリストの長さを求める <code>lLen</code> という関数を述語に持ち上げるにはこのようにします。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">{-@ measure lLen @-}</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ot">lLen ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">lLen [] <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">lLen (_<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> lLen xs</a></code></pre></div>
<pre class="shell"><code>$ liquid LH.hs
LiquidHaskell Version 0.8.2.4, Git revision 5b68dc72f628a4c16a77616fb32d8c685580ed2d (dirty)
Copyright 2013-18 Regents of the University of California. All Rights Reserved.

**** DONE:  A-Normalization ****************************************************
**** DONE:  Extracted Core using GHC *******************************************
**** DONE:  Transformed Core ***************************************************
Working 150% [=================================================================]
**** DONE:  annotate ***********************************************************
**** RESULT: SAFE **************************************************************</code></pre>
<p>実際にはこんな感じで長さ付きリストのリファインメント型をつけます。先程から<strong>述語</strong>と言っているのはリファインメント型 <code>{ | }</code> の <code>|</code> の右側のことです。<code>measure</code> によってこの部分で <code>Haskell</code> で定義した <code>lLen</code> 関数が使えるようになります。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co">{-@ type ListN a N = {v:[a] | lLen v = N} @-}</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="co">{-@ goodList :: ListN Int 2 @-}</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="ot">goodList ::</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">goodList <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">2</span>]</a></code></pre></div>
<p>当然ですが、仕様を満たしていない場合は <code>UNSAFE</code> になります。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">{-@ badList :: ListN Int 1 @-}</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="ot">badList ::</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">badList <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">2</span>]</a></code></pre></div>
<pre class="shell"><code>**** RESULT: UNSAFE ************************************************************
Error: Liquid Type Mismatch

 14 | badList = [1,2]
      ^^^^^^^
   Inferred type
     VV : {v : [Int] | Main.lLen v == 1 + Main.lLen ?d
                       &amp;&amp; len v == 1 + len ?d
                       &amp;&amp; tail v == ?d
                       &amp;&amp; head v == (1 : int)
                       &amp;&amp; len v &gt;= 0}

   not a subtype of Required type
     VV : {VV : [Int] | Main.lLen VV == 1}

   In Context
     ?b : {?b : [Int] | Main.lLen ?b == 0
                        &amp;&amp; len ?b == 0
                        &amp;&amp; len ?b &gt;= 0}

     ?d : {?d : [Int] | Main.lLen ?d == 1 + Main.lLen ?b
                        &amp;&amp; len ?d == 1 + len ?b
                        &amp;&amp; tail ?d == ?b
                        &amp;&amp; head ?d == (2 : int)
                        &amp;&amp; len ?d &gt;= 0}</code></pre>
<p>エラーメッセージがつらいですが、とりあえずは以下の部分に着目すれば良いでしょう。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">not a subtype <span class="kw">of</span> <span class="dt">Required</span> <span class="kw">type</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">     <span class="dt">VV</span> <span class="fu">:</span> {<span class="dt">VV</span> <span class="fu">:</span> [<span class="dt">Int</span>] <span class="fu">|</span> Main.lLen <span class="dt">VV</span> <span class="fu">==</span> <span class="dv">1</span>}</a></code></pre></div>
<p><code>lLen VV == 1</code> の制約が満たされていない。つまり、<code>lLen</code> の結果が <code>1</code> になってないよ。ということです。</p>
<h2 id="measure-でエラーが出る場合">measure でエラーが出る場合</h2>
<p><code>measure</code> はどんな関数にも使えるわけではありません。</p>
<p>例えば、以下のような数値のリストに対して、リストの値の合計を返す関数 <code>nLen</code> を考えましょう。(<code>sum</code> と同じですが <code>Preude</code> とかぶるので名前を変更しています)</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">{-@ measure nLen @-}</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ot">nLen ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">nLen [] <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">nLen (n<span class="fu">:</span>ns) <span class="fu">=</span> n <span class="fu">+</span> nLen ns</a></code></pre></div>
<p><code>LiquidHaskell</code> はこの定義に対してエラーを表示します。これは <code>nLen</code> 関数がリストの型変数 <code>a</code> を <code>Int</code> に特殊化しているためです。(<a href="https://github.com/ucsd-progsys/liquidhaskell#prune-unsorted-predicates">Prune Unsorted Predicates</a>)</p>
<p>こういう関数に対しては <code>--prune-unsorted</code> フラグを用いれば良いです。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="co">{-@ LIQUID &quot;--prune-unsorted&quot; @-}</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="co">{-@ measure nLen @-}</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="ot">nLen ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">nLen [] <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">nLen (n<span class="fu">:</span>ns) <span class="fu">=</span> n <span class="fu">+</span> nLen ns</a></code></pre></div>
<p><code>nLen</code> を使った型は、先ほどの <code>lLen</code> とほとんど同じです。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="co">{-@ type ListSum a N = {v:[a] | nLen v = N} @-}</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="co">{-@ goodListSum :: ListSum Int 111 @-}</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="ot">goodListSum ::</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">goodListSum <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">10</span>,<span class="dv">100</span>]</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="co">{-@ badListSum :: ListSum Int 111 @-}</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8"><span class="ot">badListSum ::</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">badListSum <span class="fu">=</span> [<span class="dv">1</span>]</a></code></pre></div>
<h2 id="まとめ">まとめ</h2>
<ul>
<li>型パラメータが特殊化された関数を <code>measure</code> で述語に持ち上げる際には <code>--prune-unsorted</code> を使う</li>
</ul>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Haskell Quiz No.8 Conduit Part.4</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/04-08-quiz-8.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/04-08-quiz-8.html</id>
    <published>2018-04-08T00:00:00Z</published>
    <updated>2018-04-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="haskell-quiz-no.8">Haskell Quiz No.8</h2>
<p>難易度: λλλ</p>
<p>以下の <code>Conduit</code> を使ったコードの実行結果を予想してみてください！</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.3</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">main <span class="fu">=</span> print <span class="fu">$</span> runConduitPure <span class="fu">$</span> return () <span class="fu">.|</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    mapM_ leftover [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    sinkList</a></code></pre></div>
<p>答えは次回。</p>
<!--more-->
<h2 id="はじめに">はじめに</h2>
<p><a href="./04-07-quiz-7.html">前回</a>の問題と答えは以下の通りです。</p>
<h3 id="問題">問題</h3>
<p>難易度: λλ</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.3</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">myTakeWhileC ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (i <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">ConduitM</span> i i m ()</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">myTakeWhileC f <span class="fu">=</span> loop</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">    loop <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">      mx <span class="ot">&lt;-</span> await</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">      <span class="kw">case</span> mx <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> return ()</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">        <span class="dt">Just</span> x</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">          <span class="fu">|</span> f x       <span class="ot">-&gt;</span> yield x <span class="fu">&gt;&gt;</span> loop</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">          <span class="fu">|</span> otherwise <span class="ot">-&gt;</span> return ()</a>
<a class="sourceLine" id="cb2-15" data-line-number="15"></a>
<a class="sourceLine" id="cb2-16" data-line-number="16"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-17" data-line-number="17">main <span class="fu">=</span> print <span class="fu">$</span> runConduitPure <span class="fu">$</span> yieldMany [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">.|</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-18" data-line-number="18">  x <span class="ot">&lt;-</span> myTakeWhileC (<span class="fu">&lt;=</span> <span class="dv">5</span>) <span class="fu">.|</span> sinkList</a>
<a class="sourceLine" id="cb2-19" data-line-number="19">  y <span class="ot">&lt;-</span> sinkList</a>
<a class="sourceLine" id="cb2-20" data-line-number="20">  return (x, y)</a></code></pre></div>
<h3 id="こたえ">こたえ</h3>
<p>実際に実行してみましょう！</p>
<pre class="shell"><code>$ ./Quiz7.hs
([1,2,3,4,5],[7,8,9,10])</code></pre>
<p><strong>6</strong> が抜けていることに注意してくださいね！</p>
<h3 id="解説の補足">解説の補足</h3>
<blockquote class="twitter-tweet" data-conversation="none" data-lang="ja">
<p lang="ja" dir="ltr">
面白いシリーズありがとうございます(いまさらながら読んでます)。ところで細かい点なんですが、conduitは内部ではチャンクサイズ自体は管理していません。sourceFile等でByteStringが32KBになるのはそのソースがByteStringのdefaultChunkSizeで分割して流してるだけですね
</p>
— 水無麻那 (<span class="citation" data-cites="Mizunashi_Mana">@Mizunashi_Mana</span>) <a href="https://twitter.com/Mizunashi_Mana/status/996221192208969728?ref_src=twsrc%5Etfw">2018年5月15日</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<blockquote class="twitter-tweet" data-conversation="none" data-lang="ja">
<p lang="ja" dir="ltr">
なので、型毎に決まるというよりはソース毎に決まるが正しい気がします(例えば、yieldMany [“aa”, “bb” :: ByteString]をawaitすると、そのまま“aa”、“bb”が流れてきます)
</p>
— 水無麻那 (<span class="citation" data-cites="Mizunashi_Mana">@Mizunashi_Mana</span>) <a href="https://twitter.com/Mizunashi_Mana/status/996221636838735873?ref_src=twsrc%5Etfw">2018年5月15日</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>確かに指摘通りで、<strong>型によって</strong>チャンクサイズが決まるのではなく、<strong>利用する Source</strong> によって決まるの方が正確ですね！ご指摘ありがとうございます。</p>
<p>ソースコードを読むとすぐにわかるのですが、せっかくなので少し解説します。</p>
<p>まず <a href="https://www.stackage.org/haddock/lts-11.9/conduit-1.3.0.2/src/Data.Conduit.Combinators.html#sourceFile">sourceFile</a> 関数の内部で readChunk 関数の呼び出しがあります。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">sourceFile ::</span> <span class="dt">MonadResource</span> m</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">           <span class="ot">=&gt;</span> FilePath</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">           <span class="ot">-&gt;</span> <span class="dt">ConduitT</span> i <span class="dt">S.ByteString</span> m ()</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">sourceFile fp <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    bracketP</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">        (FR.openFile fp)</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">         FR.closeFile</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">         loop</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">    loop h <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11">        bs <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> FR.readChunk h</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">        unless (S.null bs) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-13" data-line-number="13">            yield bs</a>
<a class="sourceLine" id="cb4-14" data-line-number="14">            loop h</a></code></pre></div>
<p>この <a href="https://www.stackage.org/haddock/lts-11.9/streaming-commons-0.1.19/src/Data.Streaming.FileRead.html#readChunk">readChunk</a> 関数の defaultChunkSize が実際のチャンクサイズです。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">readChunk ::</span> <span class="dt">ReadHandle</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">S.ByteString</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">readChunk (<span class="dt">ReadHandle</span> h) <span class="fu">=</span> S.hGetSome h defaultChunkSize</a></code></pre></div>
<p><a href="https://github.com/haskell/bytestring/blob/master/Data/ByteString/Lazy/Internal.hs#L198">defaultChunkSize</a> の定義は以下のとおりです。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co">-- | The chunk size used for I\/O. Currently set to 32k, less the memory management overhead</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ot">defaultChunkSize ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">defaultChunkSize <span class="fu">=</span> <span class="dv">32</span> <span class="fu">*</span> k <span class="fu">-</span> chunkOverhead</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">   <span class="kw">where</span> k <span class="fu">=</span> <span class="dv">1024</span></a></code></pre></div>
<p>このため、<strong>sourceFile</strong> を利用した場合は <strong>32kbyte</strong> のチャンクサイズでデータが流れるということになります。</p>
<h3 id="解説">解説</h3>
<p>今回の問題は <code>[1,2,3,4,5],[7,8,9,10]</code> ではなく <code>[1,2,3,4,5],[6,7,8,9,10]</code> と思った人もいるのではないでしょうか？</p>
<p>では何故このような動作になってしまうのか、それは <code>myTakeWhileC</code> 関数に秘密があります。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">myTakeWhileC ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (i <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">ConduitM</span> i i m ()</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">myTakeWhileC f <span class="fu">=</span> loop</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    loop <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">      mx <span class="ot">&lt;-</span> await</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">      <span class="kw">case</span> mx <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> return ()</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">        <span class="dt">Just</span> x</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">          <span class="fu">|</span> f x       <span class="ot">-&gt;</span> yield x <span class="fu">&gt;&gt;</span> loop</a>
<a class="sourceLine" id="cb7-10" data-line-number="10">          <span class="fu">|</span> otherwise <span class="ot">-&gt;</span> return ()</a></code></pre></div>
<p>この関数を理解するためには、以下の2点を抑えておけば十分です。</p>
<ul>
<li><code>await</code> は上流のパイプに対して、値をチャンクサイズで1つ要求する関数です。(チャンクサイズは型 (より正確に言えば <strong>Source</strong>) によって違います。リストであれば要素1つですが、<code>ByteString</code> (<strong>sourceFile</strong> を利用した場合) であれば <strong>1byte</strong> や <strong>1文字</strong> ではなく！ <strong>32kbyte</strong>になります。)</li>
<li><code>yield</code> は下流のパイプに値を流す関数です</li>
</ul>
<p>つまり、この関数は上流からデータを取得し、<code>f x</code> が <code>True</code> であれば下流にデータを流す準備を行い、同じ処理を繰り返します。(また、上流のデータが無くなれば <code>await</code> の結果は <code>Nothing</code> となるため、そこで処理が止まります)</p>
<p>今回の <code>f</code> は <code>(&lt;= 5)</code> なので流れてくる値が <code>5</code> 以下の間は、上流から流れてきた値をそのまま下流に流す準備をします。</p>
<p>図で書くとこんな感じでしょうか。<code>yield</code> の準備完了と <code>await</code> の要求を青と赤の実線で表現しています。(破線はそうでない場合)</p>
<p>下記の図は一番最初の <code>await</code> です。<code>sinkList</code> も <code>await</code> していますが、先に <code>myTakeWhileC</code> 関数によって消費されてしまうため、データは届きません。</p>
<p><code>myTakeWhileC</code> に適用した <strong>1</strong> は条件を満たすため、さらに下流の <code>sinkList</code> にデータを流す準備を行い、<code>sinkList</code> が <code>await</code> したタイミングでデータが流れます。</p>
<p><img class="no-border" src="/images/2018/04-08/quiz8-1.png"></p>
<p><strong>2 〜 5</strong> の場合も同様に処理されます。そのため、<code>main</code> 関数の <code>x &lt;- myTakeWhileC (&lt;= 5) .| sinkList</code> の <code>x</code> は <code>[1,2,3,5,]</code> という値になります。</p>
<p>次に条件を満たさない <strong>6</strong> の場合を考えましょう。</p>
<p>この場合は <code>myTakeWhileC</code> 関数は <code>return ()</code> を返します。そのため下流の <code>sinkList</code> にはデータを流しません。</p>
<p><img class="no-border" src="/images/2018/04-08/quiz8-2.png"></p>
<p>ここで <strong>6</strong> のデータが消え去ります。通常、一度消費してしまった値については再利用できません。(ここでは解説しませんが、<code>Conduit</code> では <code>leftover</code> という関数を使って一度消費してしまった値を上流に返すための関数が定義されています)</p>
<p><img class="no-border" src="/images/2018/04-08/quiz8-3.png"></p>
<p>そのため、次は <strong>7</strong> が2つ目の <code>sinkList</code> に流れます。</p>
<p><strong>8 〜 10</strong> についても同様に処理されるため、結果として <code>y &lt;- sinkList</code> の <code>y</code> は <code>[7,8,9,10]</code> となります。</p>
<h2 id="まとめ">まとめ</h2>
<ul>
<li>パイプを流れるデータは<strong>チャンクサイズ</strong>ということを意識する。</li>
<li>消費してしまったデータは <code>leftover</code> を使わない限り取り戻せない</li>
</ul>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Haskell Quiz No.7 Conduit Part.3</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/04-07-quiz-7.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/04-07-quiz-7.html</id>
    <published>2018-04-07T00:00:00Z</published>
    <updated>2018-04-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="haskell-quiz-no.7">Haskell Quiz No.7</h2>
<p>難易度: λλ</p>
<p>以下の <code>Conduit</code> を使ったコードの実行結果を予想してみてください！</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.3</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">myTakeWhileC ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (i <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">ConduitM</span> i i m ()</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">myTakeWhileC f <span class="fu">=</span> loop</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    loop <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">      mx <span class="ot">&lt;-</span> await</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">      <span class="kw">case</span> mx <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> return ()</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">        <span class="dt">Just</span> x</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">          <span class="fu">|</span> f x       <span class="ot">-&gt;</span> yield x <span class="fu">&gt;&gt;</span> loop</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">          <span class="fu">|</span> otherwise <span class="ot">-&gt;</span> return ()</a>
<a class="sourceLine" id="cb1-15" data-line-number="15"></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-17" data-line-number="17">main <span class="fu">=</span> print <span class="fu">$</span> runConduitPure <span class="fu">$</span> yieldMany [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">.|</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">  x <span class="ot">&lt;-</span> myTakeWhileC (<span class="fu">&lt;=</span> <span class="dv">5</span>) <span class="fu">.|</span> sinkList</a>
<a class="sourceLine" id="cb1-19" data-line-number="19">  y <span class="ot">&lt;-</span> sinkList</a>
<a class="sourceLine" id="cb1-20" data-line-number="20">  return (x, y)</a></code></pre></div>
<p>答えは<a href="04-08-quiz-8.html">次回</a>。</p>
<!--more-->
<h2 id="はじめに">はじめに</h2>
<p><a href="./04-06-quiz-6.html">前回</a>の問題と答えは以下の通りです。</p>
<h3 id="問題">問題</h3>
<p>難易度: λλ</p>
<p>以下の <code>Conduit</code> を使ったコードの実行結果を予想してみてください！</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.2</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">trans ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ConduitM</span> <span class="dt">Int</span> <span class="dt">Int</span> m ()</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">trans <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  takeC <span class="dv">5</span> <span class="fu">.|</span> mapC (<span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  mapC (<span class="fu">*</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb2-9" data-line-number="9"></a>
<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">main <span class="fu">=</span> runConduit <span class="fu">$</span> yieldMany [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">.|</span> trans <span class="fu">.|</span> mapM_C print</a></code></pre></div>
<h3 id="こたえ">こたえ</h3>
<p>実際に実行してみましょう！</p>
<pre class="shell"><code>$ ./Quiz6.hs
2
3
4
5
6
12
14
16
18
20</code></pre>
<h2 id="haskell-quiz-no.6-の解説">Haskell Quiz No.6 の解説</h2>
<p>この問題で重要なのは <code>trans</code> 関数です。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">trans ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ConduitM</span> <span class="dt">Int</span> <span class="dt">Int</span> m ()</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">trans <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  takeC <span class="dv">5</span> <span class="fu">.|</span> mapC (<span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  mapC (<span class="fu">*</span> <span class="dv">2</span>)</a></code></pre></div>
<ul>
<li>1つめのパイプ <code>takeC 5 .| mapC (+ 1)</code> によって <code>[1..10]</code> のうち <code>[1..5]</code> が <code>mapC (+ 1)</code> によって処理されます。</li>
<li>2つめのパイプ <code>mapC (* 2)</code> によって残りの <code>[6..10]</code> が <code>mapC (* 2)</code> によって処理されます。</li>
</ul>
<p>そのため、結果として以下のような出力となりました。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="dv">2</span>  <span class="co">-- 1+1</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="dv">3</span>  <span class="co">-- 2+1</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="dv">4</span>  <span class="co">-- 3+1</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="dv">5</span>  <span class="co">-- 4+1</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="dv">6</span>  <span class="co">-- 5+1</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="dv">12</span> <span class="co">-- 6*2</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="dv">14</span> <span class="co">-- 7*2</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="dv">16</span> <span class="co">-- 8*2</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="dv">18</span> <span class="co">-- 9*2</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10"><span class="dv">20</span> <span class="co">-- 10*2</span></a></code></pre></div>
<p>大前提として、このパイプにデータが流れるのは <code>mapM_C print</code> によって上流のデータが無くなるまでデータを要求するという操作があるためです。</p>
<p>そのため、 <code>mapM_C print</code> を <code>sinkNull</code> にすると何も表示されなくなります。</p>
<h2 id="まとめ">まとめ</h2>
<p><code>Conduit</code> は何も知らずにいつも通りの感覚で利用すると、直感と違う動きをすることがあるので、簡単な例を通して慣れていくと良いと思います。</p>
<p>以上です。</p>]]></summary>
</entry>

</feed>
