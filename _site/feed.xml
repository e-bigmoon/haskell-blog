<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>BIG MOON</title>
    <link href="https://haskell.e-bigmoon.com/feed.xml" rel="self" />
    <link href="https://haskell.e-bigmoon.com" />
    <id>https://haskell.e-bigmoon.com/feed.xml</id>
    <author>
        <name>BIG MOON</name>
        <email>it@e-bigmoon.com</email>
    </author>
    <updated>2018-05-23T00:00:00Z</updated>
    <entry>
    <title>Prelude を カスタムPrelude で置き換える</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/05-23-extended-prelude.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/05-23-extended-prelude.html</id>
    <published>2018-05-23T00:00:00Z</published>
    <updated>2018-05-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>つい最近 haskell-jp で <strong>皆さんPreludeは何を使っていますか？</strong> という話がありました。</p>
<p>まとめるとだいたこんな感じです。</p>
<table>
<thead>
<tr class="header">
<th>カスタム Prelude パッケージ</th>
<th>利用しているプロジェクト</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://github.com/nikita-volkov/base-prelude">base-prelude</a></td>
<td>???</td>
</tr>
<tr class="even">
<td><a href="https://github.com/snoyberg/mono-traversable/tree/master/classy-prelude">classy-prelude</a></td>
<td><a href="https://github.com/yesodweb/yesod">Yesod</a></td>
</tr>
<tr class="odd">
<td><a href="https://github.com/sdiehl/protolude">protolude</a></td>
<td><a href="https://github.com/purescript/purescript">purescript</a></td>
</tr>
<tr class="even">
<td><a href="https://github.com/serokell/universum">universum</a></td>
<td><a href="https://github.com/input-output-hk/cardano-sl">cardano-sl</a></td>
</tr>
<tr class="odd">
<td><a href="https://github.com/commercialhaskell/rio">rio</a></td>
<td><a href="https://github.com/commercialhaskell/stack">stack</a></td>
</tr>
</tbody>
</table>
<p>カスタム Prelude を使うモチベーションは、自分のよく使う関数を Prelude に入れたいとか、<strong>fromJust</strong> みたいな部分関数を排除したいなど、色々あります。</p>
<p>実際にカスタム Prelude を使うためにはファイルの先頭に <strong>NoImplicitPrelude</strong> 言語拡張とカスタムPreludeの <strong>import</strong> 宣言を追加する必要があります。(具体例として <strong>rio</strong> パッケージを利用します)</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">import</span> <span class="dt">RIO</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="fu">...</span></a></code></pre></div>
<p>新しいファイルを作るたびに、ファイルの先頭に上記の宣言を書いても良いのですが、今回はこの作業なしにカスタム Prelude を使う方法をご紹介したいと思います。</p>
<!--more-->
<h2 id="default-extensions-を利用する">default-extensions を利用する</h2>
<p><code>{-# LANGUAGE NoImplicitPrelude #-}</code> を自動的に有効化させることは意外と簡単です。</p>
<p><strong>package.yaml</strong> や <strong>cabal</strong> ファイルの <strong>default-extensions</strong> に追加するだけです。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co"># package.yaml</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="fu">default-extensions:</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">-</span> NoImplicitPrelude</a></code></pre></div>
<pre><code># project.cabal
default-extensions: NoImplicitPrelude</code></pre>
<p>この場合、全てのファイルで自動的に <strong>NoImplicitPrelude</strong> が有効になるため、カスタム Prelude の import 宣言のみが必要となります。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">import</span> <span class="dt">RIO</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="fu">...</span></a></code></pre></div>
<p>まだ <code>import RIO</code> が残っているので、こいつをなんとかしましょう。</p>
<h2 id="base-noprelude-パッケージ">base-noprelude パッケージ</h2>
<p><a href="https://ghc.haskell.org/trac/ghc/ticket/9499?cversion=0&amp;cnum_hist=8">Add -prelude-is flag</a> というチケットで紹介されている方法を使えば、<code>import RIO</code> を記述することなく、<strong>Prelude</strong> のように利用できるようになります。</p>
<p>このチケットによれば <strong>-prelude-is</strong> というオプションを導入しようとしていたようですが、そんなことしなくても <strong>Prelude</strong> を置き換えれるよ！という話です。</p>
<p>具体的には <a href="https://github.com/haskell-hvr/base-noprelude">base-noprelude</a> パッケージを利用します。</p>
<h3 id="最小構成">最小構成</h3>
<p>この方法もかなり簡単で、<strong>stack.yaml</strong>, <strong>package.yaml</strong>, <strong>src/Prelude.hs</strong> をちょこっと書くだけで完成です。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co"># stack.yaml</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="fu">resolver:</span><span class="at"> nightly-2018-05-23</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="fu">packages:</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="kw">-</span> .</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="fu">extra-deps:</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="kw">-</span> base-noprelude-4.11.1.0</a></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co"># package.yaml</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="fu">name:</span><span class="at"> extended-prelude</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="fu">dependencies:</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="kw">-</span> base-noprelude</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="kw">-</span> rio</a>
<a class="sourceLine" id="cb6-7" data-line-number="7"></a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="fu">library:</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  <span class="fu">source-dirs:</span><span class="at"> src</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">  <span class="fu">other-modules:</span></a>
<a class="sourceLine" id="cb6-11" data-line-number="11">  <span class="kw">-</span> Prelude</a></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="co">-- src/Prelude.hs</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Prelude</span> (<span class="kw">module</span> <span class="dt">RIO</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="kw">import</span> <span class="dt">RIO</span></a></code></pre></div>
<h3 id="確認">確認</h3>
<p>ファイルに <code>import RIO</code> を書かなくても本当に良いのか確かめてみます。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">-- src/Sample.hs</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Sample</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="ot">f ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">f <span class="fu">=</span> tshow <span class="st">&quot;a&quot;</span></a></code></pre></div>
<p>当然、通常の <strong>Prelude</strong> には <strong>Text</strong> も <strong>tshow</strong> も無いので、<code>import RIO</code> が有効になっていなければ、ビルドエラーになるはずです。</p>
<p><strong>ghci</strong> で確認してみましょう。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="fu">$</span> stack repl</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">ghci<span class="fu">&gt;</span> f</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="st">&quot;\&quot;a\&quot;&quot;</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t fromJust</a>
<a class="sourceLine" id="cb9-6" data-line-number="6"></a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="fu">&lt;</span>interactive<span class="fu">&gt;:</span><span class="dv">1</span><span class="fu">:</span><span class="dv">1</span><span class="fu">:</span> error<span class="fu">:</span> <span class="dt">Variable</span> not <span class="kw">in</span> scope<span class="fu">:</span> fromJust</a>
<a class="sourceLine" id="cb9-8" data-line-number="8"></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t view</a>
<a class="sourceLine" id="cb9-10" data-line-number="10"><span class="ot">view ::</span> <span class="dt">MonadReader</span> s m <span class="ot">=&gt;</span> <span class="dt">Getting</span> a s a <span class="ot">-&gt;</span> m a</a></code></pre></div>
<p>ちゃんと動いてそうですね。</p>
<h2 id="まとめ">まとめ</h2>
<p>実際にこの手法で開発を進めているわけではないので、もしかすると落とし穴があるかもしれませんが、思ったより使いやすくてびっくりしました。</p>
<p>元の Prelude に戻すことも簡単だと思うので、興味があれば試してみて下さい。(結構前のチケットなので、周知の事実だったらすみません・・・。)</p>]]></summary>
</entry>
<entry>
    <title>extensible-0.4.9 がリリースされました。</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/05-14-release-extensible-049.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/05-14-release-extensible-049.html</id>
    <published>2018-05-14T00:00:00Z</published>
    <updated>2018-05-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>BIG MOON では、業務に必要なツールを自社開発しており、プログラミング言語に <strong>Haskell</strong> を採用しています。実用的に利用し始めて3年ぐらい？です。</p>
<p>僕らが <strong>Haskell</strong> を利用していて一番困った点はレコードの取り扱いです。</p>
<ul>
<li>異なる型のフィールドラベルに同じ名前を付けたい</li>
<li>フィールド全体対して関数を適用したい</li>
<li>フィールド多相な関数を定義したい</li>
</ul>
<p>このような問題に対して <a href="https://github.com/fumieval/extensible">extensible</a> という、(当初は謎に包まれていた) パッケージの利用を検討し、実際に既存のシステムを <strong>extensible</strong> で置き換えました。(当時アルバイトしていた <a href="https://github.com/matsubara0507">matsubara0507</a> さんが居なければ実現不可能だったと思います)</p>
<p>今回、縁あって作者の <a href="https://twitter.com/fumieval">fumieval</a> さんと一緒に仕事できる機会に恵まれました。fumieval さんは簡単な質問でも、とても気さくに答えてくれます。</p>
<p>僕達のノウハウはまだまだとても少ないですが、この素晴らしいパッケージを広く知って欲しいと思い、まだまだ作成途中ではありますが <a href="https://wiki.hask.moe/">extensible 攻略Wiki</a> という親しみやすい雰囲気で情報を発信していくことになりました。</p>
<p>この wiki もまた <strong>Haskell</strong> で作られており <a href="https://github.com/fumieval/apus">apus</a> という名前で公開されています。</p>
<p>今回の extensible-0.4.9 の<a href="https://github.com/fumieval/extensible/blob/master/CHANGELOG.md">アップデート</a>は、攻略wiki のコンテンツを拡充していく中で出てきたアイデアや、関数などがいくつか追加されました。(matsubara0507 さんと弊社も色々と貢献できているはずです！)</p>
<p>今回はその内容について簡単な例とともに解説を行いたいと思います。</p>
<ul>
<li><a href="https://hackage.haskell.org/package/extensible">Hackage extensible-0.4.9</a></li>
</ul>
<!--more-->
<h2 id="アップデート内容">アップデート内容</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">type</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Record</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  <span class="ch">&#39;[ &quot;name&quot; :&gt; String</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">   , <span class="st">&quot;age&quot;</span>  <span class="fu">:&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">   ]</a>
<a class="sourceLine" id="cb1-5" data-line-number="5"></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="ot">person ::</span> <span class="dt">Person</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">person <span class="fu">=</span> <span class="fu">#</span>name <span class="fu">@=</span> <span class="st">&quot;bigmoon&quot;</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">      <span class="fu">&lt;:</span> <span class="fu">#</span>age  <span class="fu">@=</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">      <span class="fu">&lt;:</span> nil</a></code></pre></div>
<p>以降の例では、上記の <code>Person</code> 型と <code>person</code> 変数が宣言されているものとします。</p>
<hr />
<ul>
<li>MonadIO のインスタンスを一般化しました。</li>
</ul>
<p>ベースモナドとして <strong>ResourceT IO</strong> などが使えるようになりました。</p>
<p>今までは <code>Associate &quot;IO&quot; (ResourceT IO)</code> のように書けませんでしたが、こんな感じのコードが書けるようになりました。また、<a href="https://www.stackage.org/haddock/lts-11.9/resourcet-1.2.1/Control-Monad-Trans-Resource.html#t:ResourceT">ResourceT IO</a> 以外にも <a href="https://www.stackage.org/haddock/lts-11.9/base-4.10.1.0/Control-Monad-IO-Class.html#t:MonadIO">MonadIO</a> のインスタンスであれば何でも指定可能です。</p>
<p>ここでは <a href="https://www.stackage.org/haddock/lts-11.9/resourcet-1.2.1/Control-Monad-Trans-Resource.html#t:MonadResource">MonadResource</a> のインスタンスを自分で定義しましたが、次回リリース (0.4.10) でライブラリに追加される予定？です。(たぶん)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">type</span> <span class="dt">ExampleM</span> <span class="fu">=</span> <span class="dt">Eff</span> <span class="ch">&#39;[ &quot;IO&quot; &gt;: ResourceT IO ]</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">main <span class="fu">=</span> runResourceT <span class="fu">.</span> retractEff <span class="fu">.</span> runConduit <span class="fu">$</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  bracketP (openFile <span class="st">&quot;data.csv&quot;</span> <span class="dt">ReadMode</span>) hClose <span class="fu">$</span> \handle <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    (sourceHandle<span class="ot"> handle ::</span> <span class="dt">ConduitT</span> i <span class="dt">ByteString</span> <span class="dt">ExampleM</span> ()) <span class="fu">.|</span> stdoutC</a>
<a class="sourceLine" id="cb2-7" data-line-number="7"></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="kw">instance</span> (<span class="dt">Associate</span> <span class="st">&quot;IO&quot;</span> (<span class="dt">ResourceT</span> <span class="dt">IO</span>) xs) <span class="ot">=&gt;</span> <span class="dt">MonadResource</span> (<span class="dt">Eff</span> xs) <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  liftResourceT <span class="fu">=</span> liftEff (<span class="dt">Proxy</span> <span class="fu">@</span> <span class="st">&quot;IO&quot;</span>)</a></code></pre></div>
<p>ただ単に <code>csv</code> ファイルを読み込んで表示するだけの例です。</p>
<pre class="csv"><code>-- data.csv
&quot;bigmoon&quot;, 10, &quot;watch&quot;
&quot;wado&quot;, 100, art
</code></pre>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> main</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="st">&quot;bigmoon&quot;</span>, <span class="dv">10</span>, <span class="st">&quot;watch&quot;</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="st">&quot;wado&quot;</span>, <span class="dv">100</span>, art</a></code></pre></div>
<p><a href="https://github.com/waddlaw/extensible-example/blob/master/release-article/0.4.9/MonadIO.hs">完全なコード</a></p>
<hr />
<ul>
<li>新しい制約コンビネータ <a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Dictionary.html#t:And">And</a> を追加しました。</li>
</ul>
<p>このコンビネータを利用することで <a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Product.html#t:Forall">Forall</a> の制約を二つ以上指定することができます。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="dt">And</span><span class="ot"> ::</span> (k <span class="ot">-&gt;</span> <span class="dt">Constraint</span>) <span class="ot">-&gt;</span> (k <span class="ot">-&gt;</span> <span class="dt">Constraint</span>) <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Constraint</span></a></code></pre></div>
<p>以下は拡張可能レコードの値が <strong>Show</strong> かつ <a href="https://www.stackage.org/haddock/lts-11.9/base-4.10.1.0/Data-Typeable.html">Typeable</a> の両方を満たすという制約で <a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Product.html#v:hfoldMapFor">hfoldMapFor</a> 関数を使う例です。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">debug ::</span> <span class="dt">Forall</span> (<span class="dt">ValueIs</span> (<span class="dt">And</span> <span class="dt">Show</span> <span class="dt">Typeable</span>)) xs <span class="ot">=&gt;</span> <span class="dt">Record</span> xs <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">debug <span class="fu">=</span> hfoldMapFor c (print <span class="fu">.</span> fork id typeOf <span class="fu">.</span> view _Wrapper)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    c <span class="fu">=</span> <span class="dt">Proxy</span> <span class="fu">@</span> (<span class="dt">ValueIs</span> (<span class="dt">And</span> <span class="dt">Show</span> <span class="dt">Typeable</span>))</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    fork f g x <span class="fu">=</span> (f x, g x)</a></code></pre></div>
<p>例として定義した <strong>debug</strong> 関数は与えられた拡張可能レコードの <strong>値</strong> と <strong>型</strong> を表示することができます。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> debug person</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">(<span class="st">&quot;bigmoon&quot;</span>,[<span class="dt">Char</span>])</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">(<span class="dv">10</span>,<span class="dt">Int</span>)</a></code></pre></div>
<p><a href="https://github.com/waddlaw/extensible-example/blob/master/release-article/0.4.9/And.hs">完全なコード</a></p>
<hr />
<ul>
<li><a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Field.html#v:stringAssocKey">stringAssocKey</a> 関数を追加しました。</li>
</ul>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">stringAssocKey ::</span> (<span class="dt">IsString</span> a, <span class="dt">KnownSymbol</span> (<span class="dt">AssocKey</span> kv)) <span class="ot">=&gt;</span> proxy kv <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>この関数を使えば、拡張可能レコードのキーを文字列として取得することができます。</p>
<p>例えば、拡張可能レコードのキーを全て集めてリストにして返す関数は以下のように作ることができます。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">keys ::</span> (<span class="dt">IsString</span> key, <span class="dt">Forall</span> (<span class="dt">KeyIs</span> <span class="dt">KnownSymbol</span>) xs) <span class="ot">=&gt;</span> proxy xs <span class="ot">-&gt;</span> [key]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">keys xs <span class="fu">=</span> henumerateFor (<span class="dt">Proxy</span> <span class="fu">@</span> (<span class="dt">KeyIs</span> <span class="dt">KnownSymbol</span>)) xs ((<span class="fu">:</span>) <span class="fu">.</span> stringAssocKey) []</a></code></pre></div>
<p><a href="https://www.stackage.org/haddock/lts-11.9/base-4.10.1.0/Data-String.html#t:IsString">IsString</a> のインスタンスであれば何でも良いので、<strong>String</strong> に限らず <strong>Text</strong>, <strong>ByteString</strong> などを返すことができます。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> mapM_ putStrLn <span class="fu">$</span> keys person</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">name</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">age</a>
<a class="sourceLine" id="cb10-4" data-line-number="4"></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> mapM_ Data.Text.IO.putStrLn <span class="fu">$</span> keys person</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">name</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">age</a></code></pre></div>
<p><a href="https://github.com/waddlaw/extensible-example/blob/master/release-article/0.4.9/StringAssocKey.hs">完全なコード</a></p>
<hr />
<ul>
<li><a href="https://hackage.haskell.org/package/prettyprinter">prettyprinter</a> パッケージの <strong>Pretty</strong> のインスタンスを追加しました。</li>
</ul>
<p>prettyprinter パッケージについては<a href="https://haskell.e-bigmoon.com/posts/2018/03-30-prettyprinter.html">過去のブログ記事</a>で少し紹介しているので、興味ある方はそちらをご確認ください。</p>
<p>以下のような出力になるそうです。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">[ name<span class="fu">:</span> <span class="dt">DA</span><span class="fu">-</span>192H</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  weight<span class="fu">:</span> <span class="fl">260.0</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  price<span class="fu">:</span> <span class="dv">120</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  featured<span class="fu">:</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">  description<span class="fu">:</span> <span class="dt">High</span><span class="fu">-</span>quality (24bit 192kHz), lightweight portable <span class="dt">DAC</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">  quantity<span class="fu">:</span> <span class="dv">20</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">, name<span class="fu">:</span> <span class="dt">HHP</span><span class="fu">-</span><span class="dv">150</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8">  weight<span class="fu">:</span> <span class="fl">200.0</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9">  price<span class="fu">:</span> <span class="dv">330</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">  featured<span class="fu">:</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb11-11" data-line-number="11">  description<span class="fu">:</span> <span class="dt">Premium</span> wooden headphone</a>
<a class="sourceLine" id="cb11-12" data-line-number="12">  quantity<span class="fu">:</span> <span class="dv">55</span> ]</a></code></pre></div>
<p>現状は <code>prettyprinter</code> 側のバグ？で上手く表示されていないようですが、そのうち直ると思います。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> pretty person</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">{ name<span class="fu">:</span> bigmoon; age<span class="fu">:</span> <span class="dv">10</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> pretty [person, person]</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">[{ name<span class="fu">:</span> bigmoon; age<span class="fu">:</span> <span class="dv">10</span> }, { name<span class="fu">:</span> bigmoon; age<span class="fu">:</span> <span class="dv">10</span> }]</a></code></pre></div>
<p><a href="https://github.com/waddlaw/extensible-example/blob/master/release-article/0.4.9/Pretty.hs">完全なコード</a></p>
<hr />
<ul>
<li><a href="https://hackage.haskell.org/package/th-lift">th-lift</a> の <strong>Lift</strong> のインスタンスを追加しました。</li>
</ul>
<p><strong>Lift</strong> のインスタンスになったので例えば、<strong>Data.Yaml.TH</strong> モジュールの <a href="https://www.stackage.org/haddock/lts-11.9/yaml-0.8.30/Data-Yaml-TH.html#v:decodeFile">decodeFile</a> 関数を使ってコンパイル時に <strong>yaml</strong> ファイルから一気に拡張可能レコードを作り上げることができます。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">config ::</span> <span class="dt">Config</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">config <span class="fu">=</span> <span class="fu">$$</span>(Yaml.TH.decodeFile <span class="st">&quot;config.yaml&quot;</span>)</a></code></pre></div>
<p>実行例:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="co"># config.yaml</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="fu">name:</span><span class="at"> </span><span class="st">&quot;bigmoon&quot;</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"><span class="fu">age:</span><span class="at"> 10</span></a></code></pre></div>
<div class="sourceCode" id="cb15"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> config</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">name <span class="fu">@=</span> <span class="st">&quot;bigmoon&quot;</span> <span class="fu">&lt;:</span> age <span class="fu">@=</span> <span class="dv">10</span> <span class="fu">&lt;:</span> nil</a></code></pre></div>
<p><a href="https://github.com/waddlaw/extensible-example/blob/master/release-article/0.4.9/Lift.hs">完全なコード</a></p>
<hr />
<ul>
<li><a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Product.html#v:hmapWithIndexFor">hmapWithIndexFor</a> を追加しました。</li>
</ul>
<p><a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Product.html#v:hmapWithIndex">hmapWithIndex</a> の制約付きバージョンです。</p>
<p>例えば以下のようにして拡張可能レコードから <strong>aeson</strong> パッケージの <a href="https://www.stackage.org/haddock/lts-11.9/aeson-1.2.4.0/Data-Aeson.html#t:Value">Value</a> をフィールドとして持つ拡張可能レコードに変換できます。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">toJSONRecord ::</span> <span class="dt">Forall</span> (<span class="dt">ValueIs</span> <span class="dt">ToJSON</span>) xs <span class="ot">=&gt;</span> <span class="dt">Record</span> xs <span class="ot">-&gt;</span> <span class="dt">RecordOf</span> (<span class="dt">Const&#39;</span> <span class="dt">Value</span>) xs</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">toJSONRecord <span class="fu">=</span> hmapWithIndexFor c <span class="fu">$</span> \m <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3">    <span class="dt">Field</span> <span class="fu">.</span> <span class="dt">Const&#39;</span> <span class="fu">.</span> toJSON <span class="fu">.</span> view _Wrapper</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  <span class="kw">where</span> c <span class="fu">=</span> <span class="dt">Proxy</span> <span class="fu">@</span> (<span class="dt">ValueIs</span> <span class="dt">ToJSON</span>)</a></code></pre></div>
<p>実行例:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> person</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">name <span class="fu">@=</span> <span class="st">&quot;bigmoon&quot;</span> <span class="fu">&lt;:</span> age <span class="fu">@=</span> <span class="dv">10</span> <span class="fu">&lt;:</span> nil</a>
<a class="sourceLine" id="cb17-3" data-line-number="3"></a>
<a class="sourceLine" id="cb17-4" data-line-number="4"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> toJSONRecord person</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">name <span class="fu">@=</span> <span class="dt">String</span> <span class="st">&quot;bigmoon&quot;</span> <span class="fu">&lt;:</span> age <span class="fu">@=</span> <span class="dt">Number</span> <span class="fl">10.0</span> <span class="fu">&lt;:</span> nil</a></code></pre></div>
<p><a href="https://github.com/waddlaw/extensible-example/blob/master/release-article/0.4.9/HmapWithIndexFor.hs">完全なコード</a></p>
<hr />
<ul>
<li><a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Wrapper.html#t:Const-39-">Const’</a> に Monoid のインスタンスを追加しました。</li>
</ul>
<hr />
<ul>
<li><a href="https://hackage.haskell.org/package/extensible-0.4.9/docs/Data-Extensible-Wrapper.html#t:Wrapper">Wrapper</a> に Either e のインスタンスを追加しました。</li>
</ul>
<h2 id="まとめ">まとめ</h2>
<p><strong>extensible</strong> パッケージは初見では全く使い方がわからないレベルで難しいですが、実際に使ってみると、今までリアルワールド Haskell っぽいコードだね。仕方ないね。と妥協していた部分がとても綺麗に書けるようになります。</p>
<p><a href="https://wiki.hask.moe/">extensible 攻略Wiki</a> の内容はこれからもっと充実して行くので、気になる人はチェックしてみてください！</p>]]></summary>
</entry>
<entry>
    <title>Stack 1.7.1 がリリースされました。</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/05-04-stack171.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/05-04-stack171.html</id>
    <published>2018-05-04T00:00:00Z</published>
    <updated>2018-05-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>4月28日に Stack version 1.7.1 が<a href="https://github.com/commercialhaskell/stack/blob/v1.7.1/ChangeLog.md#v171">リリース</a>されました。</p>
<p>更新は以下のコマンドですぐに終わります。</p>
<pre class="shell"><code>$ stack upgrade
...

$ stack --version
Version 1.7.1, Git revision 681c800873816c022739ca7ed14755e85a579565 (5807 commits) x86_64 hpack-0.28.2</code></pre>
<!--more-->
<h2 id="リリースノート">リリースノート</h2>
<ul>
<li><strong>aarch64 (64ビットARM) で初めて stack が利用できるようになりました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/commit/9a23b91bd1ba4d120a77c9982e85079f825ebf06#diff-e705c8fadf1193ab59443a5e6c8cbe8b">9a23b91bd1ba4d120a77c9982e85079f825ebf06</a>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>stack のダウンロードリンクが <code>https://www.stackage.org/stack/</code> から <code>https://get.haskellstack.org/stable/</code> に変わりました。</p>
<p>各種バイナリへのリンクは <code>https://get.haskellstack.org/stable/&lt;PLATFORM&gt;.&lt;EXTENSION&gt;</code> という形式になるようです。</p>
<ul>
<li><strong>GHC 8.2.2 への対応が困難なため、静的にリンクされた Alpile Linux 向け stack は利用できなくなりました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/2387">Official support for Alpine Linux #2387</a>
</li>
<li>
<a href="https://ghc.haskell.org/trac/ghc/ticket/14739">Cannot compile ghc 8.2.1 or 8.2.2 on armv7l architectures</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/commit/9a23b91bd1ba4d120a77c9982e85079f825ebf06#diff-e705c8fadf1193ab59443a5e6c8cbe8b">9a23b91bd1ba4d120a77c9982e85079f825ebf06</a>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>GHC 8.2.2 から CentOS 6 の 32-bit Linux GMP4 はサポートされなくなりました。そのため stack も利用できなくなりました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3613">linux64-gmp4 variant for GHC 8.2.2 #3613</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/commit/9a23b91bd1ba4d120a77c9982e85079f825ebf06#diff-e705c8fadf1193ab59443a5e6c8cbe8b">9a23b91bd1ba4d120a77c9982e85079f825ebf06</a>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>実際の<a href="https://github.com/commercialhaskell/stack/blob/9a23b91bd1ba4d120a77c9982e85079f825ebf06/etc/scripts/get-stack.sh#L224">コード</a>を見てみるとまだ使えそうな気がしますが、stack 1.7.1 からは<a href="https://github.com/commercialhaskell/stack/releases/download/v1.7.1/stack-1.7.1-linux-i386-gmp4.tar.gz">リンク切れ</a>になります。(stack v1.6.5 とかであれば<a href="https://github.com/commercialhaskell/stack/releases/download/v1.6.5/stack-1.6.5-linux-i386-gmp4.tar.gz">ダウンロード可能</a>です。)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1">  <span class="kw">else</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    <span class="ex">install_dependencies</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="kw">case</span> <span class="st">&quot;</span><span class="va">$1</span><span class="st">&quot;</span><span class="kw"> in</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">      <span class="st">&quot;6&quot;</span><span class="kw">)</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">        <span class="ex">print_bindist_notice</span> <span class="st">&quot;libgmp4&quot;</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">        <span class="ex">install_32bit_gmp4_linked_binary</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">        <span class="kw">;;</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">      *<span class="kw">)</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">        <span class="ex">print_bindist_notice</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">        <span class="ex">install_32bit_standard_binary</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">        <span class="kw">;;</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">    <span class="kw">esac</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13">  <span class="kw">fi</span></a></code></pre></div>
<h3 id="大きな変更">大きな変更</h3>
<ul>
<li><strong>Cabal のバージョンを 2.0 から 2.2 にアップグレードしました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3878">Switch to Cabal 2.2 (prerelease) #3878</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="変更点">変更点</h3>
<ul>
<li><strong>GCC を利用する Linux ディストリビューションで、デフォルトで PIE が有効になっている場合、<code>stack setup</code> コマンドは異なる GHC 設定オプションを利用しなくなりました。ghc-8.0.2 から GHC は自分自身で検出できるようになり、Stack’s attempted workaround for older versions caused more problems than it solved.</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3636">Setup fails with ‘No information found for ghc-8.2.2’ for OS key ‘linux64-ncurses6-nopie’ #3636</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3715">setup: improvements to selecting bindists on Linux #3715</a>
</li>
<li>
<a href="https://github.com/fpco/stackage-content/pull/34">stack-setup-2: nopie fixes for Arch, Gentoo, and Void Linux #34</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p>いまいち良くわかってないですが、<a href="https://github.com/commercialhaskell/stack/pull/3715/files#diff-4968f87e674615592e572f2ec593e5b0L558">コードの差分</a>を見ると <code>noPie</code> に関する部分が全部削除されてるので、その辺りを GHC が上手く処理するようになったんでしょう・・・。</p>
<ul>
<li><strong><code>stack new</code> コマンドは、プロジェクトテンプレートに stack.yaml ファイルが含まれる場合に、初期化処理を行わないようになりました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3888">Initialize a new project only when no stack.yaml #3888</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p>今まで通り <code>stack.yaml</code> が含まれている場合でも初期化させたい場合は<code>forceOverwrite initOpts</code> が <code>True</code> になれば良いので、<code>--force</code> フラグをつければ良さそうですね。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode diff"><code class="sourceCode diff"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="st">-        initProject IsNewCmd dir initOpts globalResolver</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="va">+        exists &lt;- doesFileExist $ dir &lt;/&gt; stackDotYaml</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="va">+        when (forceOverwrite initOpts || not exists) $</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="va">+            initProject IsNewCmd dir initOpts globalResolver</span></a></code></pre></div>
<h3 id="その他の改良点">その他の改良点</h3>
<ul>
<li><strong>stack に新たなサブコマンド <code>ls</code> が導入されました。このコマンドによってローカル及びリモートのスナップショットを確認することができます。詳細は <code>stack ls snapshots --help</code> コマンドでご確認ください。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/1614">A new stack show command and missing informative commands #1614</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3252">Introduce new sub command ls #3252</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p>過去の<a href="../2017/12-20-stack-ls-command.html">ブログ記事</a>で紹介しているので気になる方はご参照ください。</p>
<ul>
<li><strong><code>list-dependencies</code> コマンドが廃止されます。同等の機能は <code>ls dependencies</code> コマンドで引き続き提供されます。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3669">Stack list-dependencies : Bring it under the new ls umbrella command #3669</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3706">Port <code>list-dependencies</code> under the new ls sub command #3706</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p>v1.7.1 ではまだ利用できますが、以下のように <code>DEPRECATED</code> メッセージが表示されます。一応 v1.8 で削除される予定です。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1">$ <span class="ex">stack</span> list-dependencies</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ex">DEPRECATED</span>: Use ls dependencies instead. Will be removed in next major version.</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="ex">...</span></a></code></pre></div>
<ul>
<li><strong>全ての HTTP リクエストヘッダに User-Agent が追加されるようになりました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3628">Specify User-Agent to get over my company’s firewall #3628</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3682/">Specify User-Agent on every HTTP request (#3628) #3682</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p>今までは <code>User-Agent</code> が付いていなかったみたいですが、<code>The Haskell Stack</code> が全てのHTTPリクエストに対して付与されるようになったみたいです。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode diff"><code class="sourceCode diff"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="va">+setUserAgent :: Request -&gt; Request</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="va">+setUserAgent = setRequestHeader &quot;User-Agent&quot; [&quot;The Haskell Stack&quot;]</span></a></code></pre></div>
<ul>
<li><strong><code>stack setup</code> コマンドは互換性のある GHC をインストールするために、任意の OS キーによるインストールを試すようになりました (これは OS キーをどれか1つだけチェックするよりも良い方法です)。この変更は Linux の各ディストリビューションで libinfo 5/6, ncurses 5/6, gmp 4/5 の異なった組み合わせに起因するものです。今後の GHC リリースを見据えて、セットアップに関する YAML メタデータをシンプルに保つことができます。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3521">Check for ncurses6 before checking for tinfo6 #3521</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3715">setup: improvements to selecting bindists on Linux #3715</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>ビルドプログレスバーが現在ビルドしているパッケージ名を表示するようになりました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3763">Report currently building packages along with “Progress:” label #3763</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tbody>
</table>
<p>変更前の表示結果</p>
<pre><code>Progress: 3/74</code></pre>
<p>変更後の表示結果</p>
<pre><code>Progress: 3/74; [Cabal-2.0.1.1|basement-0.0.4|old-time-1.1.0.3|simple-sendfile-0.2.26|stm-2.4.4.1|stringsearch-0.3.6.6]</code></pre>
<ul>
<li><strong><code>stack setup --verbose</code> の出力に GHC 設定処理のログを含めるようにしました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3716">“stack setup –verbose” should also cause verbose output of GHC configure process if possible #3716</a>
</li>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3712">Never ending “Configuring GHC…” #3712</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3740">Log GHC configure output on <code>stack -v setup</code> #3740</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p>変更前は以下のように <code>Configuring GHC ...</code> で何も表示されていなかったようです。</p>
<pre class="shell"><code>$ stack build --verbose
...

2017-12-27 00:30:23.869257: [debug] Run process: /home/gleb/.stack/programs/x86_64-linux/ghc-tinfo6-nopie-8.0.2.temp/ghc-8.0.2/configure --prefix=/home/gleb/.stack/programs/x86_64-linux/ghc-tinfo6-nopie-8.0.2/
@(System/Process/Log.hs:37:3)
Configuring GHC ...</code></pre>
<p>変更後は、こんな感じのログが続いて表示されるようになったようです。</p>
<pre class="shell"><code>...
018-01-03 10:49:29.280793: [debug] Run process within /home/kp/.stack/programs/x86_64-linux/ghc-7.10.3.temp/ghc-7.10.3/: /usr/bin/make install
@(subs/rio/src/RIO/Process.hs:191:3)
2018-01-03 10:49:29.304283: [info] /usr/bin/make -r --no-print-directory -f ghc.mk install BINDIST=YES NO_INCLUDE_DEPS=YES
@(Stack/Setup.hs:1096:54)
2018-01-03 10:49:29.737966: [info] &quot;rm&quot; -f utils/ghc-pkg/dist-install/build/Version.hs
@(Stack/Setup.hs:1096:54)
2018-01-03 10:49:29.739872: [info] echo &quot;module Version where&quot;                    &gt;&gt; utils/ghc-pkg/dist-install/build/Version.hs
@(Stack/Setup.hs:1096:54)
2018-01-03 10:49:29.741026: [info] echo &quot;version, targetOS, targetARCH :: String&quot; &gt;&gt; utils/ghc-pkg/dist-install/build/Version.hs
@(Stack/Setup.hs:1096:54)
2018-01-03 10:49:29.742170: [info] echo &quot;version    = \&quot;7.10.3\&quot;&quot;      &gt;&gt; utils/ghc-pkg/dist-install/build/Version.hs</code></pre>
<ul>
<li><strong>ファイルパスまたは git 参照から <code>extra-dep</code> が見つからなかった時のエラーメッセージが改善されました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3806">Confusing error message when a cabal file for an extra-dep can’t be found #3806</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3808">When a cabal file can’t be found, warn that extra-deps could be the problem too #3808</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p>こんな感じでエラーメッセージが改善されたようです。</p>
<p><a href="https://user-images.githubusercontent.com/1274145/35401090-6f853812-01ad-11e8-8c02-622f9ea9c2da.png" target="_blank"><img src="https://user-images.githubusercontent.com/1274145/35401090-6f853812-01ad-11e8-8c02-622f9ea9c2da.png"></a></p>
<ul>
<li><strong>Windows 環境では Nix インテグレーションがサポートされていないため、明示的にフラグを有効にした場合でも常に無効になるように変更しました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3600">Nix doesn’t work on Windows #3600</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3833">Disable nix on windows (#3600) #3833</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<ul>
<li><strong><code>stack build</code> に <code>--keep-tmp-files</code> フラグを追加しました。デバッグ目的のため一時的に作成したファイルやディレクトリを削除せずに残しておくことができます。このフラグは同等の機能を持つ ghc オプションと同時に使うと良いでしょう。例: <code>stack build --keep-tmp-files --ghc-options=-keep-tmp-files</code></strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3857">How to keep temporary files on build failures? #3857</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3858">stack build: Add –keep-tmp-files flag. Fixes #3857 #3858</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p><code>stack.yaml</code> の <code>build</code> セクションに指定することもできるようです。(デフォルト値は <code>False</code>)</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="fu">build:</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">  <span class="fu">library-profiling:</span><span class="at"> false</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="fu">executable-profiling:</span><span class="at"> false</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">  <span class="fu">copy-bins:</span><span class="at"> false</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  <span class="fu">prefetch:</span><span class="at"> false</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">  <span class="fu">keep-going:</span><span class="at"> false</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  <span class="fu">keep-tmp-files:</span><span class="at"> false</span></a></code></pre></div>
<ul>
<li><strong>スナップショットのパーズ例外時のエラーメッセージを改善しました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3879">Improved error messages for snapshot parse exceptions #3879</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<ul>
<li><strong><code>stack unpack</code> コマンドに <code>--to /target/directory</code> オプションが追加されました。パッケージの展開先を指定できるようになります。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3904">Possibility to specify a base path to unpack a package #3904</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3947">Add –to option to the unpack command to specify destination #3947</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<ul>
<li><strong><code>stack hoogle</code> コマンドに <code>--server</code> オプションが追加されました。ローカルのポート8080番で Hoogle サーバーが起動します。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/2310">Add <code>stack hoogle --server</code> command #2310</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3941">Introduce Hoogle server command line option #3941</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p><code>stack hoogle --server</code> は <code>stack hoogle -- server --local --port 8080</code> の省略形です。</p>
<h3 id="リリースノートに載ってない変更">リリースノートに載ってない変更</h3>
<ul>
<li><code>extra-deps</code> で <code>github</code> という短縮形が使えるようになりました。</li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3873">Allow github shorthand for extra-deps #3873</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3890">Allow ‘github’ shorthand for extra-deps (fixes #3873) #3890</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p>以下のように書くことができます。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">-</span> <span class="fu">github:</span><span class="at"> commercialhaskell/rio</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="fu">commit:</span><span class="at"> 09654f9fcbdcd96d0f5102796b32fdac5da7260e</span></a></code></pre></div>
<p><code>commit</code> は短縮して記述することもできます。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">-</span> <span class="fu">github:</span><span class="at"> commercialhaskell/rio</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="fu">commit:</span><span class="at"> </span><span class="st">&quot;09654&quot;</span></a></code></pre></div>
<p><a href="https://github.com/mitchellwrosen/stack/blob/9489cf7d12c54ea40ab043e199d7850d2502e140/src/test/Stack/Types/BuildPlanSpec.hs">BuildPlanSpec.hs</a> にテストがいくつか載っていいるので、そこを見れば利用可能な形式がわかります。</p>
<h3 id="バグフィックス">バグフィックス</h3>
<ul>
<li><strong>スクリプトインタプリタ形式で暗黙的に渡されるファイル引数を他の引数より先に処理するようにしました。この修正により、スクリプト実行時に – +RTS … -RTS を渡せるようになりました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3658">Error when using RTS options with the Stack script interpreter #3658</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3668">Put file arguments first when stack is run as script interpreter #3658 #3668</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p><a href="./02-21-stack165.html">v.1.6.5</a> の時に紹介したので、そちらをご確認ください。</p>
<ul>
<li><strong>stack 設定ファイルで year パラメータが設定できるようになりました。それに伴い、ドキュメントもわかりやすくしました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/2275">stack new – AesonException #2275</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3701">Fix use of and document year template parameter #3701</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p><a href="./02-21-stack165.html">v.1.6.5</a> の時に紹介したので、そちらをご確認ください。</p>
<ul>
<li><strong>ベンチーマークが別のベンチマークやビルドステップと並行して実行されてしまう問題を修正しました。これは別のプロセスのCPU利用がベンチマークに悪影響を及ぼすと思われるので理想的ではありません。また、デフォルトでベンチマークの出力が表示されないようになっていた件も同様に修正しました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3663">Benchmarks are run in parallel #3663</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3666">Never run benchmarks concurrently, always output to console #3663 #3666</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p><a href="./02-21-stack165.html">v.1.6.5</a> の時に紹介したので、そちらをご確認ください。</p>
<ul>
<li><strong>stack ghci で複数のパッケージで定義されている同名のモジュールを読み込めるようになりました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3776">Add rio package as a dep of stack #3776</a>
</li>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3779">With ghci, allow multiple packages to use the same module #3776 #3779</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p><a href="./02-21-stack165.html">v.1.6.5</a> の時に紹介したので、そちらをご確認ください。</p>
<ul>
<li><strong>stack ghci で base の依存関係を追加する必要が無くなりました。これはローカルターゲットが存在しない場合に自動的に追加されるためです。これにより、base を置き換えているコードも同様に読み込めるようになります。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3589">stack ghci at global level missing base #3589</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/commit/196bdbae986ddf887f92999b26129085a8ed0be5">196bdbae986ddf887f92999b26129085a8ed0be5</a>
</li>
<li>
<a href="https://github.com/commercialhaskell/stack/commit/99950cfae2e014f76abbebd51869e5cae5f00a6a">99950cfae2e014f76abbebd51869e5cae5f00a6a</a>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><a href="./02-21-stack165.html">v.1.6.5</a> の時に紹介したので、そちらをご確認ください。</p>
<ul>
<li><strong><code>stack ghci</code> コマンドで autogen ファイルのパスを適切に扱えるようになりました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3791">Adjust <code>-i</code> paths used by ghci to point to autogen / etc files generated by newer Cabal #3791</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3795">Use per-component build directories for ghci with Cabal&gt;=2.0 #3791 #3795</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>stack はサブディレクトリを含むパッケージを常に再コンパイルしていました。現在は修正され、サブディレクトリを再コンパイルする必要がある時だけ行うようになりました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3899">hakyll dependency on nightly is not cached #3899</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3955">Don’t recompile in presence of sublibraries #3955</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p>特に <code>Hakyll</code> や <code>Pandoc</code> (依存しているライブラリも同様に影響を受ける) を使う場合に踏み抜く可能性があるため、影響を受けている人はアップグレード推奨です。</p>
<ul>
<li><code>get-stack.sh</code> インストールスクリプトにおいて Debian/Fedora/CentOS の依存関係のインストールをドキュメントの手動で行う場合と一致するように修正しました。</li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/commit/9dfff2760b659c84605028002cd6500cdb52c823#diff-e705c8fadf1193ab59443a5e6c8cbe8b">9dfff2760b659c84605028002cd6500cdb52c823</a>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><a href="https://docs.haskellstack.org/en/stable/install_and_upgrade/#manual-download_2">Manual Download</a> の内容と同様の処理になりました。(<code>git</code> と <code>gnupg</code> が追加されました)</p>
<ul>
<li><strong>Nix を利用する場合に gmp で Cabal-simple をコンパイルするように修正しました。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/2944">Nix: stack should compile setup-Simple-Cabal with libgmp #2944</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3971">#2944: Compile Cabal-simple with gmp when using Nix #3971</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<ul>
<li><strong><code>stack ghci</code> コマンドの stack 処理は ghci で置き換えられました。これによりシグナルハンドリングの動作が改善されます。特に Ctrl-C のハンドリングが改善されます。そのため、生成されたファイルは終了後に残ります。このパスはファイルコンテンツのハッシュにより決まり、システムの一時的なディレクトリに保存されます。そのため、必要に応じて綺麗にしましょう。</strong></li>
</ul>
<table class="border narrow">
<tbody>
<tr>
<th>
issue
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/issues/3821">stack repl exits on ctrl+c with error <stdin>: hGetChar: hardware fault (Input/output error) #3821</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
PR
</th>
<td>
<ul>
<li>
<a href="https://github.com/commercialhaskell/stack/pull/3869">Fix stack ghci ctrl c 3821 #3869</a>
</li>
</ul>
</td>
</tr>
<tr>
<th>
commit
</th>
<td>
</td>
</tr>
</tbody>
</table>
<p><code>stack repl</code> を実行すると、実際にはこんな感じでディレクトリとファイルが作られます。<code>ba125cb0</code> や <code>e4ed4429</code> というファイル名はファイルのコンテンツハッシュによって決まるそうです。(<code>tmp</code> というディレクトリ名は環境によって異なります)</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb13-1" data-line-number="1">$ <span class="ex">tree</span> /tmp/haskell-stack-ghci/</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="ex">/tmp/haskell-stack-ghci/</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">├── <span class="ex">ba125cb0</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">│   └── <span class="ex">cabal_macros.h</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">└── <span class="ex">e4ed4429</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    └── <span class="ex">ghci-script</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7"></a>
<a class="sourceLine" id="cb13-8" data-line-number="8"><span class="ex">2</span> directories, 2 files</a></code></pre></div>
<h2 id="changelog-オリジナル">Changelog (オリジナル)</h2>
<h3 id="release-notes">Release notes</h3>
<ul>
<li>aarch64 (64-bit ARM) bindists are now available for the first time.</li>
<li>Statically linked Linux bindists are no longer available, due to difficulty with GHC 8.2.2 on Alpine Linux.</li>
<li>32-bit Linux GMP4 bindists for CentOS 6 are no longer available, since GHC 8.2.2 is no longer being built for that platform.</li>
</ul>
<h3 id="major-changes">Major changes</h3>
<ul>
<li>Upgrade from Cabal 2.0 to Cabal 2.2</li>
</ul>
<h3 id="behavior-changes">Behavior changes</h3>
<ul>
<li><code>stack setup</code> no longer uses different GHC configure options on Linux distributions that use GCC with PIE enabled by default. GHC detects this itself since ghc-8.0.2, and Stack’s attempted workaround for older versions caused more problems than it solved.</li>
<li><code>stack new</code> no longer initializes a project if the project template contains a stack.yaml file.</li>
</ul>
<h3 id="other-enhancements">Other enhancements</h3>
<ul>
<li>A new sub command <code>ls</code> has been introduced to stack to view local and remote snapshots present in the system. Use <code>stack ls snapshots --help</code> to get more details about it.</li>
<li><code>list-dependencies</code> has been deprecated. The functionality has to accessed through the new <code>ls dependencies</code> interface. See <a href="https://github.com/commercialhaskell/stack/issues/3669">#3669</a> for details.</li>
<li>Specify User-Agent HTTP request header on every HTTP request. See <a href="https://github.com/commercialhaskell/stack/issues/3628">#3628</a> for details.</li>
<li><code>stack setup</code> looks for GHC bindists and installations by any OS key that is compatible (rather than only checking a single one). This is relevant on Linux where different distributions may have different combinations of libtinfo 5/6, ncurses 5/6, and gmp 4/5, and will allow simpifying the setup-info metadata YAML for future GHC releases.</li>
<li>The build progress bar reports names of packages currently building.</li>
<li><code>stack setup --verbose</code> causes verbose output of GHC configure process. See <a href="https://github.com/commercialhaskell/stack/issues/3716">#3716</a></li>
<li>Improve the error message when an <code>extra-dep</code> from a path or git reference can’t be found See <a href="https://github.com/commercialhaskell/stack/pull/3808">#3808</a></li>
<li>Nix integration is now disabled on windows even if explicitly enabled, since it isn’t supported. See <a href="https://github.com/commercialhaskell/stack/issues/3600">#3600</a></li>
<li><code>stack build</code> now supports a new flag <code>--keep-tmp-files</code> to retain intermediate files and directories for the purpose of debugging. It is best used with ghc’s equivalent flag, i.e. <code>stack build --keep-tmp-files --ghc-options=-keep-tmp-files</code>. See <a href="https://github.com/commercialhaskell/stack/issues/3857">#3857</a></li>
<li>Improved error messages for snapshot parse exceptions</li>
<li><code>stack unpack</code> now supports a <code>--to /target/directory</code> option to specify where to unpack the package into</li>
<li><code>stack hoogle</code> now supports a new flag <code>--server</code> that launches local Hoogle server on port 8080. See <a href="https://github.com/commercialhaskell/stack/issues/2310">#2310</a></li>
</ul>
<h3 id="bug-fixes">Bug fixes</h3>
<ul>
<li>The script interpreter’s implicit file arguments are now passed before other arguments. See <a href="https://github.com/commercialhaskell/stack/issues/3658">#3658</a>. In particular, this makes it possible to pass <code>-- +RTS ... -RTS</code> to specify RTS arguments used when running the script.</li>
<li>Don’t ignore the template <code>year</code> parameter in config files, and clarify the surrounding documentation. See <a href="https://github.com/commercialhaskell/stack/issues/2275">#2275</a>.</li>
<li>Benchmarks used to be run concurrently with other benchmarks and build steps. This is non-ideal because CPU usage of other processes may interfere with benchmarks. It also prevented benchmark output from being displayed by default. This is now fixed. See <a href="https://github.com/commercialhaskell/stack/issues/3663">#3663</a>.</li>
<li><code>stack ghci</code> now allows loading multiple packages with the same module name, as long as they have the same filepath. See <a href="https://github.com/commercialhaskell/stack/pull/3776">#3776</a>.</li>
<li><code>stack ghci</code> no longer always adds a dependency on <code>base</code>. It is now only added when there are no local targets. This allows it to be to load code that uses replacements for <code>base</code>. See <a href="https://github.com/commercialhaskell/stack/issues/3589#issuecomment">#3589</a></li>
<li><code>stack ghci</code> now uses correct paths for autogen files with <a href="https://github.com/commercialhaskell/stack/issues/3791">#3791</a></li>
<li>When a package contained sublibraries, stack was always recompiling the package. This has been fixed now, no recompilation is being done because of sublibraries. See <a href="https://github.com/commercialhaskell/stack/issues/3899">#3899</a>.</li>
<li>The <code>get-stack.sh</code> install script now matches manual instructions when it comes to Debian/Fedora/CentOS install dependencies.</li>
<li>Compile Cabal-simple with gmp when using Nix. See <a href="https://github.com/commercialhaskell/stack/issues/2944">#2944</a></li>
<li><code>stack ghci</code> now replaces the stack process with ghci. This improves signal handling behavior. In particular, handling of Ctrl-C. To make this possible, the generated files are now left behind after exit. The paths are based on hashing file contents, and it’s stored in the system temporary directory, so this shouldn’t result in too much garbage. See <a href="https://github.com/commercialhaskell/stack/issues/3821">#3821</a>.</li>
</ul>]]></summary>
</entry>
<entry>
    <title>HIE でコード整形時に改行が追加されてしまうバグが直りました</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/04-18-hie.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/04-18-hie.html</id>
    <published>2018-04-18T00:00:00Z</published>
    <updated>2018-04-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p><strong>vscode</strong> + <strong>Haskell IDE Engine</strong> の組み合わせで <code>Haskell</code> を書き続けて半年ぐらいになります。</p>
<p><code>hie</code> が採用している整形ツールは <a href="https://github.com/lspitzner/brittany">brittany</a> なのですが、個人的には <a href="https://github.com/commercialhaskell/hindent">hindent</a> よりも気に入っています。(最近 <a href="https://github.com/lspitzner/brittany/pull/124">Add import and module support #124</a> が実装されたんですけど、この部分は正直気に入っていない・・・。<code>stylish-haskell</code> の結果の方が好きです。)</p>
<p>今回のバグはコード整形時にファイルの最後に空行が追加されてしまうというものでした・・・。(100回実行すると100行追加されます・・・)</p>
<ul>
<li><a href="https://github.com/haskell/haskell-ide-engine/issues/289">Newline added on every save #289</a></li>
<li><a href="https://github.com/haskell/haskell-ide-engine/issues/521">Formatting code adds newline at the end of the file #521</a></li>
</ul>
<p>上記の <code>issue</code> が <a href="https://github.com/haskell/haskell-ide-engine/pull/525">Fix extra newline being added when formatting document #525</a> で修正されました。</p>
<p>手作業で毎回削除してて、絶対何かおかしいと思ってましたが、ちゃんと直りました！！！やったね！</p>
<p>以上です。</p>
<!--more-->]]></summary>
</entry>
<entry>
    <title>LiquidHaskell の --prune-unsorted フラグ</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/04-14-lh-unsorted-flag.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/04-14-lh-unsorted-flag.html</id>
    <published>2018-04-14T00:00:00Z</published>
    <updated>2018-04-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p><code>LiquidHaskell</code> では <code>measure</code> という仕組みを使って <code>Haskell</code> の関数を <code>LH</code> の述語に持ち上げることができます。</p>
<p>しかし、以下の <code>nLen</code> 関数は <code>measure</code> によって持ち上げることができません。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co">{-@ measure nLen @-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">nLen ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">nLen [] <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">nLen (n<span class="fu">:</span>ns) <span class="fu">=</span> n <span class="fu">+</span> nLen ns</a></code></pre></div>
<p>結論から言えば、これを解決するためには <code>--prune-unsorted</code> フラグを利用します。</p>
<p>以下は <code>measure</code> の基本的な使い方等についての説明です。</p>
<!--more-->
<h2 id="measure-の基本的な使い方">measure の基本的な使い方</h2>
<p>例えばリストの長さを求める <code>lLen</code> という関数を述語に持ち上げるにはこのようにします。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">{-@ measure lLen @-}</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ot">lLen ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">lLen [] <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">lLen (_<span class="fu">:</span>xs) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> lLen xs</a></code></pre></div>
<pre class="shell"><code>$ liquid LH.hs
LiquidHaskell Version 0.8.2.4, Git revision 5b68dc72f628a4c16a77616fb32d8c685580ed2d (dirty)
Copyright 2013-18 Regents of the University of California. All Rights Reserved.

**** DONE:  A-Normalization ****************************************************
**** DONE:  Extracted Core using GHC *******************************************
**** DONE:  Transformed Core ***************************************************
Working 150% [=================================================================]
**** DONE:  annotate ***********************************************************
**** RESULT: SAFE **************************************************************</code></pre>
<p>実際にはこんな感じで長さ付きリストのリファインメント型をつけます。先程から<strong>述語</strong>と言っているのはリファインメント型 <code>{ | }</code> の <code>|</code> の右側のことです。<code>measure</code> によってこの部分で <code>Haskell</code> で定義した <code>lLen</code> 関数が使えるようになります。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co">{-@ type ListN a N = {v:[a] | lLen v = N} @-}</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="co">{-@ goodList :: ListN Int 2 @-}</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="ot">goodList ::</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">goodList <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">2</span>]</a></code></pre></div>
<p>当然ですが、仕様を満たしていない場合は <code>UNSAFE</code> になります。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="co">{-@ badList :: ListN Int 1 @-}</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="ot">badList ::</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">badList <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">2</span>]</a></code></pre></div>
<pre class="shell"><code>**** RESULT: UNSAFE ************************************************************
Error: Liquid Type Mismatch

 14 | badList = [1,2]
      ^^^^^^^
   Inferred type
     VV : {v : [Int] | Main.lLen v == 1 + Main.lLen ?d
                       &amp;&amp; len v == 1 + len ?d
                       &amp;&amp; tail v == ?d
                       &amp;&amp; head v == (1 : int)
                       &amp;&amp; len v &gt;= 0}

   not a subtype of Required type
     VV : {VV : [Int] | Main.lLen VV == 1}

   In Context
     ?b : {?b : [Int] | Main.lLen ?b == 0
                        &amp;&amp; len ?b == 0
                        &amp;&amp; len ?b &gt;= 0}

     ?d : {?d : [Int] | Main.lLen ?d == 1 + Main.lLen ?b
                        &amp;&amp; len ?d == 1 + len ?b
                        &amp;&amp; tail ?d == ?b
                        &amp;&amp; head ?d == (2 : int)
                        &amp;&amp; len ?d &gt;= 0}</code></pre>
<p>エラーメッセージがつらいですが、とりあえずは以下の部分に着目すれば良いでしょう。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">not a subtype <span class="kw">of</span> <span class="dt">Required</span> <span class="kw">type</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">     <span class="dt">VV</span> <span class="fu">:</span> {<span class="dt">VV</span> <span class="fu">:</span> [<span class="dt">Int</span>] <span class="fu">|</span> Main.lLen <span class="dt">VV</span> <span class="fu">==</span> <span class="dv">1</span>}</a></code></pre></div>
<p><code>lLen VV == 1</code> の制約が満たされていない。つまり、<code>lLen</code> の結果が <code>1</code> になってないよ。ということです。</p>
<h2 id="measure-でエラーが出る場合">measure でエラーが出る場合</h2>
<p><code>measure</code> はどんな関数にも使えるわけではありません。</p>
<p>例えば、以下のような数値のリストに対して、リストの値の合計を返す関数 <code>nLen</code> を考えましょう。(<code>sum</code> と同じですが <code>Preude</code> とかぶるので名前を変更しています)</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">{-@ measure nLen @-}</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ot">nLen ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">nLen [] <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">nLen (n<span class="fu">:</span>ns) <span class="fu">=</span> n <span class="fu">+</span> nLen ns</a></code></pre></div>
<p><code>LiquidHaskell</code> はこの定義に対してエラーを表示します。これは <code>nLen</code> 関数がリストの型変数 <code>a</code> を <code>Int</code> に特殊化しているためです。(<a href="https://github.com/ucsd-progsys/liquidhaskell#prune-unsorted-predicates">Prune Unsorted Predicates</a>)</p>
<p>こういう関数に対しては <code>--prune-unsorted</code> フラグを用いれば良いです。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="co">{-@ LIQUID &quot;--prune-unsorted&quot; @-}</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="co">{-@ measure nLen @-}</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="ot">nLen ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">nLen [] <span class="fu">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">nLen (n<span class="fu">:</span>ns) <span class="fu">=</span> n <span class="fu">+</span> nLen ns</a></code></pre></div>
<p><code>nLen</code> を使った型は、先ほどの <code>lLen</code> とほとんど同じです。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="co">{-@ type ListSum a N = {v:[a] | nLen v = N} @-}</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="co">{-@ goodListSum :: ListSum Int 111 @-}</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="ot">goodListSum ::</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">goodListSum <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">10</span>,<span class="dv">100</span>]</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="co">{-@ badListSum :: ListSum Int 111 @-}</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8"><span class="ot">badListSum ::</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">badListSum <span class="fu">=</span> [<span class="dv">1</span>]</a></code></pre></div>
<h2 id="まとめ">まとめ</h2>
<ul>
<li>型パラメータが特殊化された関数を <code>measure</code> で述語に持ち上げる際には <code>--prune-unsorted</code> を使う</li>
</ul>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Haskell Quiz No.8 Conduit Part.4</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/04-08-quiz-8.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/04-08-quiz-8.html</id>
    <published>2018-04-08T00:00:00Z</published>
    <updated>2018-04-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="haskell-quiz-no.8">Haskell Quiz No.8</h2>
<p>難易度: λλλ</p>
<p>以下の <code>Conduit</code> を使ったコードの実行結果を予想してみてください！</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.3</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">main <span class="fu">=</span> print <span class="fu">$</span> runConduitPure <span class="fu">$</span> return () <span class="fu">.|</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    mapM_ leftover [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    sinkList</a></code></pre></div>
<p>答えは次回。</p>
<!--more-->
<h2 id="はじめに">はじめに</h2>
<p><a href="./04-07-quiz-7.html">前回</a>の問題と答えは以下の通りです。</p>
<h3 id="問題">問題</h3>
<p>難易度: λλ</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.3</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">myTakeWhileC ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (i <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">ConduitM</span> i i m ()</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">myTakeWhileC f <span class="fu">=</span> loop</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">    loop <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">      mx <span class="ot">&lt;-</span> await</a>
<a class="sourceLine" id="cb2-10" data-line-number="10">      <span class="kw">case</span> mx <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> return ()</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">        <span class="dt">Just</span> x</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">          <span class="fu">|</span> f x       <span class="ot">-&gt;</span> yield x <span class="fu">&gt;&gt;</span> loop</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">          <span class="fu">|</span> otherwise <span class="ot">-&gt;</span> return ()</a>
<a class="sourceLine" id="cb2-15" data-line-number="15"></a>
<a class="sourceLine" id="cb2-16" data-line-number="16"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-17" data-line-number="17">main <span class="fu">=</span> print <span class="fu">$</span> runConduitPure <span class="fu">$</span> yieldMany [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">.|</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-18" data-line-number="18">  x <span class="ot">&lt;-</span> myTakeWhileC (<span class="fu">&lt;=</span> <span class="dv">5</span>) <span class="fu">.|</span> sinkList</a>
<a class="sourceLine" id="cb2-19" data-line-number="19">  y <span class="ot">&lt;-</span> sinkList</a>
<a class="sourceLine" id="cb2-20" data-line-number="20">  return (x, y)</a></code></pre></div>
<h3 id="こたえ">こたえ</h3>
<p>実際に実行してみましょう！</p>
<pre class="shell"><code>$ ./Quiz7.hs
([1,2,3,4,5],[7,8,9,10])</code></pre>
<p><strong>6</strong> が抜けていることに注意してくださいね！</p>
<h3 id="解説の補足">解説の補足</h3>
<blockquote class="twitter-tweet" data-conversation="none" data-lang="ja">
<p lang="ja" dir="ltr">
面白いシリーズありがとうございます(いまさらながら読んでます)。ところで細かい点なんですが、conduitは内部ではチャンクサイズ自体は管理していません。sourceFile等でByteStringが32KBになるのはそのソースがByteStringのdefaultChunkSizeで分割して流してるだけですね
</p>
— 水無麻那 (<span class="citation" data-cites="Mizunashi_Mana">@Mizunashi_Mana</span>) <a href="https://twitter.com/Mizunashi_Mana/status/996221192208969728?ref_src=twsrc%5Etfw">2018年5月15日</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<blockquote class="twitter-tweet" data-conversation="none" data-lang="ja">
<p lang="ja" dir="ltr">
なので、型毎に決まるというよりはソース毎に決まるが正しい気がします(例えば、yieldMany [“aa”, “bb” :: ByteString]をawaitすると、そのまま“aa”、“bb”が流れてきます)
</p>
— 水無麻那 (<span class="citation" data-cites="Mizunashi_Mana">@Mizunashi_Mana</span>) <a href="https://twitter.com/Mizunashi_Mana/status/996221636838735873?ref_src=twsrc%5Etfw">2018年5月15日</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>確かに指摘通りで、<strong>型によって</strong>チャンクサイズが決まるのではなく、<strong>利用する Source</strong> によって決まるの方が正確ですね！ご指摘ありがとうございます。</p>
<p>ソースコードを読むとすぐにわかるのですが、せっかくなので少し解説します。</p>
<p>まず <a href="https://www.stackage.org/haddock/lts-11.9/conduit-1.3.0.2/src/Data.Conduit.Combinators.html#sourceFile">sourceFile</a> 関数の内部で readChunk 関数の呼び出しがあります。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">sourceFile ::</span> <span class="dt">MonadResource</span> m</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">           <span class="ot">=&gt;</span> FilePath</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">           <span class="ot">-&gt;</span> <span class="dt">ConduitT</span> i <span class="dt">S.ByteString</span> m ()</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">sourceFile fp <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    bracketP</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">        (FR.openFile fp)</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">         FR.closeFile</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">         loop</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">    loop h <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11">        bs <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> FR.readChunk h</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">        unless (S.null bs) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-13" data-line-number="13">            yield bs</a>
<a class="sourceLine" id="cb4-14" data-line-number="14">            loop h</a></code></pre></div>
<p>この <a href="https://www.stackage.org/haddock/lts-11.9/streaming-commons-0.1.19/src/Data.Streaming.FileRead.html#readChunk">readChunk</a> 関数の defaultChunkSize が実際のチャンクサイズです。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">readChunk ::</span> <span class="dt">ReadHandle</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">S.ByteString</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">readChunk (<span class="dt">ReadHandle</span> h) <span class="fu">=</span> S.hGetSome h defaultChunkSize</a></code></pre></div>
<p><a href="https://github.com/haskell/bytestring/blob/master/Data/ByteString/Lazy/Internal.hs#L198">defaultChunkSize</a> の定義は以下のとおりです。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co">-- | The chunk size used for I\/O. Currently set to 32k, less the memory management overhead</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ot">defaultChunkSize ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">defaultChunkSize <span class="fu">=</span> <span class="dv">32</span> <span class="fu">*</span> k <span class="fu">-</span> chunkOverhead</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">   <span class="kw">where</span> k <span class="fu">=</span> <span class="dv">1024</span></a></code></pre></div>
<p>このため、<strong>sourceFile</strong> を利用した場合は <strong>32kbyte</strong> のチャンクサイズでデータが流れるということになります。</p>
<h3 id="解説">解説</h3>
<p>今回の問題は <code>[1,2,3,4,5],[7,8,9,10]</code> ではなく <code>[1,2,3,4,5],[6,7,8,9,10]</code> と思った人もいるのではないでしょうか？</p>
<p>では何故このような動作になってしまうのか、それは <code>myTakeWhileC</code> 関数に秘密があります。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">myTakeWhileC ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (i <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">ConduitM</span> i i m ()</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">myTakeWhileC f <span class="fu">=</span> loop</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    loop <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">      mx <span class="ot">&lt;-</span> await</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">      <span class="kw">case</span> mx <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> return ()</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">        <span class="dt">Just</span> x</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">          <span class="fu">|</span> f x       <span class="ot">-&gt;</span> yield x <span class="fu">&gt;&gt;</span> loop</a>
<a class="sourceLine" id="cb7-10" data-line-number="10">          <span class="fu">|</span> otherwise <span class="ot">-&gt;</span> return ()</a></code></pre></div>
<p>この関数を理解するためには、以下の2点を抑えておけば十分です。</p>
<ul>
<li><code>await</code> は上流のパイプに対して、値をチャンクサイズで1つ要求する関数です。(チャンクサイズは型 (より正確に言えば <strong>Source</strong>) によって違います。リストであれば要素1つですが、<code>ByteString</code> (<strong>sourceFile</strong> を利用した場合) であれば <strong>1byte</strong> や <strong>1文字</strong> ではなく！ <strong>32kbyte</strong>になります。)</li>
<li><code>yield</code> は下流のパイプに値を流す関数です</li>
</ul>
<p>つまり、この関数は上流からデータを取得し、<code>f x</code> が <code>True</code> であれば下流にデータを流す準備を行い、同じ処理を繰り返します。(また、上流のデータが無くなれば <code>await</code> の結果は <code>Nothing</code> となるため、そこで処理が止まります)</p>
<p>今回の <code>f</code> は <code>(&lt;= 5)</code> なので流れてくる値が <code>5</code> 以下の間は、上流から流れてきた値をそのまま下流に流す準備をします。</p>
<p>図で書くとこんな感じでしょうか。<code>yield</code> の準備完了と <code>await</code> の要求を青と赤の実線で表現しています。(破線はそうでない場合)</p>
<p>下記の図は一番最初の <code>await</code> です。<code>sinkList</code> も <code>await</code> していますが、先に <code>myTakeWhileC</code> 関数によって消費されてしまうため、データは届きません。</p>
<p><code>myTakeWhileC</code> に適用した <strong>1</strong> は条件を満たすため、さらに下流の <code>sinkList</code> にデータを流す準備を行い、<code>sinkList</code> が <code>await</code> したタイミングでデータが流れます。</p>
<p><img class="no-border" src="/images/2018/04-08/quiz8-1.png"></p>
<p><strong>2 〜 5</strong> の場合も同様に処理されます。そのため、<code>main</code> 関数の <code>x &lt;- myTakeWhileC (&lt;= 5) .| sinkList</code> の <code>x</code> は <code>[1,2,3,5,]</code> という値になります。</p>
<p>次に条件を満たさない <strong>6</strong> の場合を考えましょう。</p>
<p>この場合は <code>myTakeWhileC</code> 関数は <code>return ()</code> を返します。そのため下流の <code>sinkList</code> にはデータを流しません。</p>
<p><img class="no-border" src="/images/2018/04-08/quiz8-2.png"></p>
<p>ここで <strong>6</strong> のデータが消え去ります。通常、一度消費してしまった値については再利用できません。(ここでは解説しませんが、<code>Conduit</code> では <code>leftover</code> という関数を使って一度消費してしまった値を上流に返すための関数が定義されています)</p>
<p><img class="no-border" src="/images/2018/04-08/quiz8-3.png"></p>
<p>そのため、次は <strong>7</strong> が2つ目の <code>sinkList</code> に流れます。</p>
<p><strong>8 〜 10</strong> についても同様に処理されるため、結果として <code>y &lt;- sinkList</code> の <code>y</code> は <code>[7,8,9,10]</code> となります。</p>
<h2 id="まとめ">まとめ</h2>
<ul>
<li>パイプを流れるデータは<strong>チャンクサイズ</strong>ということを意識する。</li>
<li>消費してしまったデータは <code>leftover</code> を使わない限り取り戻せない</li>
</ul>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Haskell Quiz No.7 Conduit Part.3</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/04-07-quiz-7.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/04-07-quiz-7.html</id>
    <published>2018-04-07T00:00:00Z</published>
    <updated>2018-04-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="haskell-quiz-no.7">Haskell Quiz No.7</h2>
<p>難易度: λλ</p>
<p>以下の <code>Conduit</code> を使ったコードの実行結果を予想してみてください！</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.3</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">myTakeWhileC ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (i <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">ConduitM</span> i i m ()</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">myTakeWhileC f <span class="fu">=</span> loop</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">    loop <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">      mx <span class="ot">&lt;-</span> await</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">      <span class="kw">case</span> mx <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> return ()</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">        <span class="dt">Just</span> x</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">          <span class="fu">|</span> f x       <span class="ot">-&gt;</span> yield x <span class="fu">&gt;&gt;</span> loop</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">          <span class="fu">|</span> otherwise <span class="ot">-&gt;</span> return ()</a>
<a class="sourceLine" id="cb1-15" data-line-number="15"></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-17" data-line-number="17">main <span class="fu">=</span> print <span class="fu">$</span> runConduitPure <span class="fu">$</span> yieldMany [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">.|</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">  x <span class="ot">&lt;-</span> myTakeWhileC (<span class="fu">&lt;=</span> <span class="dv">5</span>) <span class="fu">.|</span> sinkList</a>
<a class="sourceLine" id="cb1-19" data-line-number="19">  y <span class="ot">&lt;-</span> sinkList</a>
<a class="sourceLine" id="cb1-20" data-line-number="20">  return (x, y)</a></code></pre></div>
<p>答えは<a href="04-08-quiz-8.html">次回</a>。</p>
<!--more-->
<h2 id="はじめに">はじめに</h2>
<p><a href="./04-06-quiz-6.html">前回</a>の問題と答えは以下の通りです。</p>
<h3 id="問題">問題</h3>
<p>難易度: λλ</p>
<p>以下の <code>Conduit</code> を使ったコードの実行結果を予想してみてください！</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.2</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">trans ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ConduitM</span> <span class="dt">Int</span> <span class="dt">Int</span> m ()</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">trans <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  takeC <span class="dv">5</span> <span class="fu">.|</span> mapC (<span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  mapC (<span class="fu">*</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb2-9" data-line-number="9"></a>
<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">main <span class="fu">=</span> runConduit <span class="fu">$</span> yieldMany [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">.|</span> trans <span class="fu">.|</span> mapM_C print</a></code></pre></div>
<h3 id="こたえ">こたえ</h3>
<p>実際に実行してみましょう！</p>
<pre class="shell"><code>$ ./Quiz6.hs
2
3
4
5
6
12
14
16
18
20</code></pre>
<h2 id="haskell-quiz-no.6-の解説">Haskell Quiz No.6 の解説</h2>
<p>この問題で重要なのは <code>trans</code> 関数です。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">trans ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ConduitM</span> <span class="dt">Int</span> <span class="dt">Int</span> m ()</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">trans <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  takeC <span class="dv">5</span> <span class="fu">.|</span> mapC (<span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  mapC (<span class="fu">*</span> <span class="dv">2</span>)</a></code></pre></div>
<ul>
<li>1つめのパイプ <code>takeC 5 .| mapC (+ 1)</code> によって <code>[1..10]</code> のうち <code>[1..5]</code> が <code>mapC (+ 1)</code> によって処理されます。</li>
<li>2つめのパイプ <code>mapC (* 2)</code> によって残りの <code>[6..10]</code> が <code>mapC (* 2)</code> によって処理されます。</li>
</ul>
<p>そのため、結果として以下のような出力となりました。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="dv">2</span>  <span class="co">-- 1+1</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="dv">3</span>  <span class="co">-- 2+1</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="dv">4</span>  <span class="co">-- 3+1</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="dv">5</span>  <span class="co">-- 4+1</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="dv">6</span>  <span class="co">-- 5+1</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="dv">12</span> <span class="co">-- 6*2</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="dv">14</span> <span class="co">-- 7*2</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="dv">16</span> <span class="co">-- 8*2</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="dv">18</span> <span class="co">-- 9*2</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10"><span class="dv">20</span> <span class="co">-- 10*2</span></a></code></pre></div>
<p>大前提として、このパイプにデータが流れるのは <code>mapM_C print</code> によって上流のデータが無くなるまでデータを要求するという操作があるためです。</p>
<p>そのため、 <code>mapM_C print</code> を <code>sinkNull</code> にすると何も表示されなくなります。</p>
<h2 id="まとめ">まとめ</h2>
<p><code>Conduit</code> は何も知らずにいつも通りの感覚で利用すると、直感と違う動きをすることがあるので、簡単な例を通して慣れていくと良いと思います。</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Haskell Quiz No.6 Conduit Part.2</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/04-06-quiz-6.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/04-06-quiz-6.html</id>
    <published>2018-04-06T00:00:00Z</published>
    <updated>2018-04-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="haskell-quiz-no.6">Haskell Quiz No.6</h2>
<p>難易度: λλ</p>
<p>以下の <code>Conduit</code> を使ったコードの実行結果を予想してみてください！</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.2</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">trans ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ConduitM</span> <span class="dt">Int</span> <span class="dt">Int</span> m ()</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">trans <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  takeC <span class="dv">5</span> <span class="fu">.|</span> mapC (<span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">  mapC (<span class="fu">*</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb1-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">main <span class="fu">=</span> runConduit <span class="fu">$</span> yieldMany [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">.|</span> trans <span class="fu">.|</span> mapM_C print</a></code></pre></div>
<p>答えは<a href="04-07-quiz-7.html">次回</a>。</p>
<p>最近は <code>Conduit</code> にはまっているので、クイズも <code>Conduit</code> が続きます。</p>
<!--more-->
<h2 id="はじめに">はじめに</h2>
<p><a href="./03-31-quiz-5.html">前回</a>の問題と答えは以下の通りです。</p>
<h3 id="問題">問題</h3>
<p>難易度: λλ</p>
<p>以下の <code>Conduit</code> を使ったコードの実行結果を予想してみてください！</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.0</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">sink ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ConduitM</span> <span class="dt">Int</span> o m (<span class="dt">String</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">sink <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  x <span class="ot">&lt;-</span> takeC <span class="dv">5</span> <span class="fu">.|</span> mapC show <span class="fu">.|</span> foldC</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  y <span class="ot">&lt;-</span> sumC</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  return (x, y)</a>
<a class="sourceLine" id="cb2-10" data-line-number="10"></a>
<a class="sourceLine" id="cb2-11" data-line-number="11"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13">  <span class="kw">let</span> res <span class="fu">=</span> runConduitPure <span class="fu">$</span> yieldMany [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">.|</span> sink</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">  print res</a></code></pre></div>
<h3 id="こたえ">こたえ</h3>
<p>実際に実行してみましょう！</p>
<pre class="shell"><code>$ ./Quiz5.hs
(&quot;12345&quot;,40)</code></pre>
<p>どうですか？予想通りでしたか？？</p>
<h2 id="haskell-quiz-no.5-の解説">Haskell Quiz No.5 の解説</h2>
<p>この問題を解くためには <a href="https://www.stackage.org/lts-11.3/package/conduit-1.3.0.2">conduit</a> というストリーム処理ライブラリの知識が必要になります。</p>
<h3 id="conduit-を使うモチベーション">Conduit を使うモチベーション</h3>
<p>具体例として指定したディレクトリ以下の<strong>ファイル数</strong>と<strong>容量の合計</strong>を出力するようなプログラムを作ってみましょう。</p>
<p>ディレクトリ操作については <a href="https://www.stackage.org/lts-11.3/package/directory-1.3.0.2">directory</a> パッケージに便利な関数が色々と定義されているので、このパッケージを利用します。</p>
<p>必要な操作と、対応する関数は以下の通りです。</p>
<ul>
<li>ファイルの列挙: <a href="https://www.stackage.org/haddock/lts-11.3/directory-1.3.0.2/System-Directory.html#v:listDirectory">listDirectory</a></li>
<li>ファイルサイズの取得: <a href="https://www.stackage.org/haddock/lts-11.3/directory-1.3.0.2/System-Directory.html#v:getFileSize">getFileSize</a></li>
<li>ファイル・ディレクトリの判定: <a href="https://www.stackage.org/haddock/lts-11.3/directory-1.3.0.2/System-Directory.html#v:doesFileExist">doesFileExist</a></li>
</ul>
<p>これらの関数を使って、こんな感じでプログラムを作ることができます。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="co">{-</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="co">stack script --resolver lts-11.3</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="co">  --package extra</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="co">  --package filepath</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="co">  --package directory</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="co">-}</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8"></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="kw">import</span> <span class="dt">System.Environment</span> (getArgs)</a>
<a class="sourceLine" id="cb4-10" data-line-number="10"><span class="kw">import</span> <span class="dt">System.Directory</span> (listDirectory, doesFileExist, getFileSize)</a>
<a class="sourceLine" id="cb4-11" data-line-number="11"><span class="kw">import</span> <span class="dt">System.FilePath</span> ((&lt;/&gt;))</a>
<a class="sourceLine" id="cb4-12" data-line-number="12"><span class="kw">import</span> <span class="dt">Control.Monad.Extra</span> (partitionM, ifM)</a>
<a class="sourceLine" id="cb4-13" data-line-number="13"><span class="kw">import</span> <span class="dt">Control.Monad</span> (when)</a>
<a class="sourceLine" id="cb4-14" data-line-number="14"></a>
<a class="sourceLine" id="cb4-15" data-line-number="15"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-16" data-line-number="16">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-17" data-line-number="17">  arg <span class="ot">&lt;-</span> getArgs</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">  when (length arg <span class="fu">==</span> <span class="dv">1</span>) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-19" data-line-number="19">    (cnt, size) <span class="ot">&lt;-</span> recListDir <span class="fu">$</span> head arg</a>
<a class="sourceLine" id="cb4-20" data-line-number="20">    putStrLn <span class="fu">$</span> <span class="st">&quot;総ファイル数: &quot;</span> <span class="fu">++</span> show cnt</a>
<a class="sourceLine" id="cb4-21" data-line-number="21">    putStrLn <span class="fu">$</span> <span class="st">&quot;総ファイルサイズ: &quot;</span> <span class="fu">++</span> show size</a>
<a class="sourceLine" id="cb4-22" data-line-number="22"></a>
<a class="sourceLine" id="cb4-23" data-line-number="23"><span class="ot">recListDir ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Int</span>, <span class="dt">Integer</span>)</a>
<a class="sourceLine" id="cb4-24" data-line-number="24">recListDir fp <span class="fu">=</span> loop (<span class="dv">0</span>, <span class="dv">0</span>) [fp]</a>
<a class="sourceLine" id="cb4-25" data-line-number="25">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-26" data-line-number="26">    loop summary [] <span class="fu">=</span> return summary</a>
<a class="sourceLine" id="cb4-27" data-line-number="27">    loop (accCnt, accSize) (fp<span class="fu">:</span>fps) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-28" data-line-number="28">      dirs <span class="ot">&lt;-</span> listDirectory fp</a>
<a class="sourceLine" id="cb4-29" data-line-number="29">      (files, childDirs) <span class="ot">&lt;-</span> partitionM doesFileExist <span class="fu">$</span> map (fp <span class="fu">&lt;/&gt;</span>) dirs</a>
<a class="sourceLine" id="cb4-30" data-line-number="30">      size <span class="ot">&lt;-</span> sum <span class="fu">&lt;$&gt;</span> mapM getFileSize files</a>
<a class="sourceLine" id="cb4-31" data-line-number="31">      <span class="kw">let</span> summary <span class="fu">=</span> (accCnt <span class="fu">+</span> length files, accSize <span class="fu">+</span> size)</a>
<a class="sourceLine" id="cb4-32" data-line-number="32">      loop summary <span class="fu">$</span> fps <span class="fu">++</span> childDirs</a></code></pre></div>
<p>実際に、プロファイリングを取得しつつ動かしてみます。</p>
<pre class="shell"><code>$ stack ghc Ex &amp;&amp; sudo ./Ex /home/bm12/Desktop/ +RTS -s
総ファイル数: 338866
総ファイルサイズ: 37870090712</code></pre>
<p>とりあえず、上手く動いているような気がします。</p>
<p>しかし、メモリ使用量は・・・</p>
<pre class="shell"><code>  13,440,124,048 bytes allocated in the heap
   8,760,418,592 bytes copied during GC
   1,225,650,008 bytes maximum residency (23 sample(s))
      19,423,400 bytes maximum slop
            2599 MB total memory in use (0 MB lost due to fragmentation)

                                     Tot time (elapsed)  Avg pause  Max pause
  Gen  0      9869 colls,     0 par    7.821s   9.831s     0.0010s    1.1223s
  Gen  1        23 colls,     0 par    0.011s   0.013s     0.0006s    0.0009s

  INIT    time    0.000s  (  0.000s elapsed)
  MUT     time    5.255s  (  6.347s elapsed)
  GC      time    7.832s  (  9.845s elapsed)
  EXIT    time    0.032s  (  0.123s elapsed)
  Total   time   13.118s  ( 16.315s elapsed)

  %GC     time      59.7%  (60.3% elapsed)

  Alloc rate    2,557,607,298 bytes per MUT second

  Productivity  40.3% of total user, 39.7% of total elapsed</code></pre>
<ul>
<li><strong>2599 MB total memory in use</strong></li>
<li><strong>%GC time 59.7% (60.3% elapsed)</strong></li>
</ul>
<p>ということで、非常にやばいですね。</p>
<h3 id="conduit-で書き直そう">Conduit で書き直そう！</h3>
<p>先程作ったプログラムは、どうやらスペースリークしているようです。指定したディレクトリ以下のファイルの数とファイルサイズの合計を取得するだけなのに、メモリを使いすぎですね。</p>
<p>解決方法は色々ありますが、今回はストリームライブラリの <code>Conduit</code> を使って解決していきましょう。</p>
<p><code>Conduit</code> には <a href="https://www.stackage.org/haddock/lts-11.3/conduit-1.3.0.2/Conduit.html#v:sourceDirectoryDeep">sourceDirectoryDeep</a> という、関数が用意されています。</p>
<p>だいたいこんな感じで書き直すことができます。先程の定義と比べると <strong>sourceDirectoryDeep</strong> 関数のおかげでスッキリした印象です。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="co">{-</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="co">stack script --resolver lts-11.3</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="co">  --package conduit</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5"><span class="co">  --package extra</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6"><span class="co">  --package directory</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7"><span class="co">-}</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8"></a>
<a class="sourceLine" id="cb7-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10"></a>
<a class="sourceLine" id="cb7-11" data-line-number="11"><span class="kw">import</span> <span class="dt">System.Environment</span> (getArgs)</a>
<a class="sourceLine" id="cb7-12" data-line-number="12"><span class="kw">import</span> <span class="dt">System.Directory</span> (doesFileExist, getFileSize)</a>
<a class="sourceLine" id="cb7-13" data-line-number="13"><span class="kw">import</span> <span class="dt">Control.Monad.Extra</span> (whenM)</a>
<a class="sourceLine" id="cb7-14" data-line-number="14"><span class="kw">import</span> <span class="dt">Control.Monad</span> (when)</a>
<a class="sourceLine" id="cb7-15" data-line-number="15"></a>
<a class="sourceLine" id="cb7-16" data-line-number="16"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-17" data-line-number="17">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-18" data-line-number="18">  arg <span class="ot">&lt;-</span> getArgs</a>
<a class="sourceLine" id="cb7-19" data-line-number="19">  when (length arg <span class="fu">==</span> <span class="dv">1</span>) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-20" data-line-number="20">    (cnt, size) <span class="ot">&lt;-</span></a>
<a class="sourceLine" id="cb7-21" data-line-number="21">      runConduitRes <span class="fu">$</span> sourceDirectoryDeep <span class="dt">True</span> (head arg)</a>
<a class="sourceLine" id="cb7-22" data-line-number="22">                   <span class="fu">.|</span> awaitForever getInfo</a>
<a class="sourceLine" id="cb7-23" data-line-number="23">                   <span class="fu">.|</span> getZipSink ((,) <span class="fu">&lt;$&gt;</span> <span class="dt">ZipSink</span> lengthC <span class="fu">&lt;*&gt;</span> <span class="dt">ZipSink</span> sumC)</a>
<a class="sourceLine" id="cb7-24" data-line-number="24">    putStrLn <span class="fu">$</span> <span class="st">&quot;総ファイル数: &quot;</span> <span class="fu">++</span> show cnt</a>
<a class="sourceLine" id="cb7-25" data-line-number="25">    putStrLn <span class="fu">$</span> <span class="st">&quot;総ファイルサイズ: &quot;</span> <span class="fu">++</span> show size</a>
<a class="sourceLine" id="cb7-26" data-line-number="26"></a>
<a class="sourceLine" id="cb7-27" data-line-number="27"><span class="ot">getInfo ::</span> <span class="dt">MonadResource</span> m <span class="ot">=&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">ConduitM</span> FilePath <span class="dt">Integer</span> m ()</a>
<a class="sourceLine" id="cb7-28" data-line-number="28">getInfo path <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-29" data-line-number="29">  whenM (liftIO <span class="fu">$</span> doesFileExist path) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-30" data-line-number="30">    size <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> getFileSize path</a>
<a class="sourceLine" id="cb7-31" data-line-number="31">    yield size</a></code></pre></div>
<p>では、同様にプロファイルを取得しつつ、実行してみましょう。</p>
<pre class="shell"><code>$ stack ghc Ex2 &amp;&amp; sudo ./Ex2 /home/bm12/Desktop/ +RTS -s
総ファイル数: 338866
総ファイルサイズ: 37870092264</code></pre>
<p>肝心のメモリ使用量はと言うと・・・</p>
<pre class="shell"><code>  10,742,224,392 bytes allocated in the heap
      86,720,088 bytes copied during GC
          87,576 bytes maximum residency (19 sample(s))
          33,320 bytes maximum slop
               3 MB total memory in use (0 MB lost due to fragmentation)

                                     Tot time (elapsed)  Avg pause  Max pause
  Gen  0     10347 colls,     0 par    0.146s   0.198s     0.0000s    0.0008s
  Gen  1        19 colls,     0 par    0.000s   0.001s     0.0000s    0.0001s

  INIT    time    0.000s  (  0.000s elapsed)
  MUT     time    5.252s  (  7.444s elapsed)
  GC      time    0.146s  (  0.198s elapsed)
  EXIT    time    0.000s  (  0.000s elapsed)
  Total   time    5.398s  (  7.642s elapsed)

  %GC     time       2.7%  (2.6% elapsed)

  Alloc rate    2,045,428,118 bytes per MUT second

  Productivity  97.3% of total user, 97.4% of total elapsed</code></pre>
<ul>
<li><strong>3 MB total memory in use</strong></li>
<li><strong>%GC time 2.7% (2.6% elapsed)</strong></li>
</ul>
<p>どうですか？ストリーム処理って凄いですよね。</p>
<h3 id="解説">解説</h3>
<p>この問題の重要なポイントは、実行すると <code>(&quot;12345&quot;, 6+7+8+9+10)</code> という結果のように、<code>[1..10]</code> のリストの前半と後半で異なる処理になっているという点です。</p>
<pre class="shell"><code>$ ./Quiz5.hs
(&quot;12345&quot;,40)</code></pre>
<p>ここで理解しておきたい知識は以下の3点です。</p>
<ul>
<li>データは<strong>パイプ</strong> (ストリーム) を流れて処理されます</li>
<li><code>yieldMany</code> 関数は受け取ったデータをパイプに流す<strong>準備</strong>をします (<code>yieldMany</code> は自分から積極的にデータを流すことはしません。準備だけしておき <code>await</code> 関数などで、実際に必要になった際にだけデータを流します)</li>
<li><code>.|</code> はパイプを<strong>合成</strong>します</li>
</ul>
<div class="sourceCode" id="cb11"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="kw">let</span> res <span class="fu">=</span> runConduitPure <span class="fu">$</span> yieldMany [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">.|</span> sink</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  print res</a></code></pre></div>
<p><code>sink</code> 関数は <code>takeC 5 .| mapC show .| foldC</code> というパイプと <code>sumC</code> というパイプからなる、大きなパイプです。</p>
<p><code>takeC 5 .| mapC show .| foldC</code> 関数は <code>takeC 5</code> の部分でデータを <strong>5つだけ</strong> 上流のパイプに要求します。そのため、残りの5つのデータは次の <code>sumC</code> に流れることになります。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">sink ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ConduitM</span> <span class="dt">Int</span> o m (<span class="dt">String</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">sink <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  x <span class="ot">&lt;-</span> takeC <span class="dv">5</span> <span class="fu">.|</span> mapC show <span class="fu">.|</span> foldC <span class="co">-- 1,2,3,4,5  のデータが処理される</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  y <span class="ot">&lt;-</span> sumC                          <span class="co">-- 6,7,8,9,10 のデータが処理される</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  return (x, y)</a></code></pre></div>
<p>そのため、最終的には <code>(&quot;12345&quot;,40)</code> となりました。</p>
<p><code>&quot;12345&quot;</code> はそれぞれの <strong>Int</strong> 型が <code>mapC show</code> によって <strong>String</strong> 型に変換され、<code>foldC</code> の <code>mappend</code> による畳込みによって文字列連結されます。</p>
<h2 id="まとめ">まとめ</h2>
<p>実用的なアプリケーションを作ろうと考えている方は <code>Conduit</code> などのストリームライブラリを理解していると、色々と面倒なことを考えなくて済むのでとても良いですよ。</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Haskell Quiz No.5 Conduit Part.1</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-31-quiz-5.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-31-quiz-5.html</id>
    <published>2018-03-31T00:00:00Z</published>
    <updated>2018-03-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="haskell-quiz-no.5">Haskell Quiz No.5</h2>
<p>難易度: λλ</p>
<p>以下の <code>Conduit</code> を使ったコードの実行結果を予想してみてください！</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.0</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">sink ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ConduitM</span> <span class="dt">Int</span> o m (<span class="dt">String</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">sink <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  x <span class="ot">&lt;-</span> takeC <span class="dv">5</span> <span class="fu">.|</span> mapC show <span class="fu">.|</span> foldC</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">  y <span class="ot">&lt;-</span> sumC</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  return (x, y)</a>
<a class="sourceLine" id="cb1-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  <span class="kw">let</span> res <span class="fu">=</span> runConduitPure <span class="fu">$</span> yieldMany [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">.|</span> sink</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">  print res</a></code></pre></div>
<p>答えは<a href="04-06-quiz-6.html">次回</a>。</p>
<!--more-->
<h2 id="はじめに">はじめに</h2>
<p><a href="./03-28-quiz-4.html">前回</a>の問題と答えは以下の通りです。</p>
<h3 id="問題">問題</h3>
<p>難易度: λ</p>
<p>今回は、与えられた値がリストのリストに含まれているかどうかを判定する問題です。</p>
<p>幅優先で探索する関数 <code>bfs</code> と深さ優先で探索する関数 <code>dfs</code> をそれぞれ定義してみましょう。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">bfs ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [[<span class="dt">Int</span>]] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">bfs <span class="fu">=</span> undefined</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ot">dfs ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [[<span class="dt">Int</span>]] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">dfs <span class="fu">=</span> undefined</a></code></pre></div>
<p>実行結果はだいたいこんな感じです。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb3-1" data-line-number="1">$ <span class="ex">stack</span> repl -- Quiz4.hs</a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="ex">*Quiz4</span><span class="op">&gt;</span> xs = [[10..],[4,5,6],[7,8,9]]</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="ex">*Quiz4</span><span class="op">&gt;</span> bfs 9 xs</a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ex">True</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ex">*Quiz4</span><span class="op">&gt;</span> dfs 9 xs</a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="ex">.....</span></a></code></pre></div>
<h3 id="こたえ">こたえ</h3>
<p>素晴らしい回答が <strong>Haskeller</strong> から届きました。(一部修正)</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">dfs x <span class="fu">=</span> elem x <span class="fu">.</span> concat</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">bfs x <span class="fu">=</span> elem x <span class="fu">.</span> concat <span class="fu">.</span> transpose</a></code></pre></div>
<p>まさに <code>Haskell</code> ！！！って感じのコードですよね。</p>
<h2 id="haskell-quiz-no.4-の解説">Haskell Quiz No.4 の解説</h2>
<p>完全なコードはこちら</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Quiz4</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Data.List</span> (transpose)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="ot">dfs ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [[a]] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">dfs x <span class="fu">=</span> elem x <span class="fu">.</span> concat</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="ot">bfs ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [[a]] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">bfs x <span class="fu">=</span> elem x <span class="fu">.</span> concat <span class="fu">.</span> transpose</a></code></pre></div>
<ul>
<li><strong>dfs</strong> は <code>depth farst search</code> なので、<strong>深さ優先探索</strong>を行うように実装しています。</li>
<li><strong>bfs</strong> は <code>breadth first search</code> なので、<strong>幅優先探索</strong>を行うように実装しています。</li>
</ul>
<h3 id="data.list-モジュール">Data.List モジュール</h3>
<p>リスト操作系の関数は基本的に <a href="http://hackage.haskell.org/package/base-4.11.0.0/docs/Data-List.html">Data.List</a> を探せば見つかります。</p>
<p><code>Prelude</code> に含まれている関数と重複するものもありますが、それ以外にも有用な関数がいくつも定義されているため、 <code>Data.List</code> モジュールにどんな関数があるか把握しておくと良いと思います。</p>
<p>ここで定義されている関数の命名規則は別のパッケージでも慣習的に利用されていることが多いため、関数がどんな操作なのか<strong>理解</strong> (暗記ではない) しておくと、全く知らないパッケージでも何となく読める時があります。</p>
<p>例えば今回の <code>transpose</code> 関数は <code>Data.List</code> 以外にも色々なモジュールで同様に定義されています。</p>
<ul>
<li><a href="http://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString-Char8.html#v:transpose">ByteString</a></li>
<li><a href="http://hackage.haskell.org/package/text-1.2.3.0/docs/Data-Text-Lazy.html#v:transpose">Text</a></li>
</ul>
<p>つまり、データ構造はリストとは違うけども、操作としては同じと言うことです。</p>
<h3 id="transpose">transpose</h3>
<p><a href="http://hackage.haskell.org/package/base-4.11.0.0/docs/Data-List.html#v:transpose">transpose</a> は <code>base</code> パッケージの <code>Data.List</code> で定義されています。<code>Prelude</code> には含まれていないため、明示的に <code>import</code> する必要があります。</p>
<p><code>haddock</code> の説明通り、リストを転置させる関数です。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="fu">&gt;&gt;&gt;</span> transpose [[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>]]</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">[[<span class="dv">1</span>,<span class="dv">4</span>],[<span class="dv">2</span>,<span class="dv">5</span>],[<span class="dv">3</span>,<span class="dv">6</span>]]</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="fu">&gt;&gt;&gt;</span> transpose [[<span class="dv">10</span>,<span class="dv">11</span>],[<span class="dv">20</span>],[],[<span class="dv">30</span>,<span class="dv">31</span>,<span class="dv">32</span>]]</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">[[<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">30</span>],[<span class="dv">11</span>,<span class="dv">31</span>],[<span class="dv">32</span>]]</a></code></pre></div>
<p>その際、空リストは取り除かれるようですね。</p>
<p><code>transpose</code> 関数の実装は <a href="http://hackage.haskell.org/package/base-4.11.0.0/docs/src/Data.OldList.html#transpose">Data.OldList</a> で以下のように定義されています。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">transpose ::</span> [[a]] <span class="ot">-&gt;</span> [[a]]</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">transpose []           <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">transpose ([]<span class="fu">:</span>xss)     <span class="fu">=</span> transpose xss</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">transpose ((x<span class="fu">:</span>xs)<span class="fu">:</span>xss) <span class="fu">=</span> (x <span class="fu">:</span> [h <span class="fu">|</span> (h<span class="fu">:</span>_) <span class="ot">&lt;-</span> xss]) <span class="fu">:</span> transpose (xs <span class="fu">:</span> [ t <span class="fu">|</span> (_<span class="fu">:</span>t) <span class="ot">&lt;-</span> xss])</a></code></pre></div>
<p>たしかに2つ目の等式で空白が除去されていることがわかりますね。</p>
<p>3つ目の等式は少し複雑ですが、面白いので見てみましょう。</p>
<p>それぞれのリストの <code>head</code> を取りたいので <code>map head xss</code> がすぐに思いつきそうですが <code>[h | (h:_) &lt;- xss]</code> となっています。うまいやりかたですね。</p>
<p>普通に <code>head</code> をかけてしまうと空リストで実行時エラーとなってしまいます。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="fu">*</span><span class="dt">Quiz4</span><span class="fu">&gt;</span> xss <span class="fu">=</span> [[<span class="dv">1</span>,<span class="dv">2</span>],[],[<span class="dv">3</span>,<span class="dv">4</span>]]</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="fu">*</span><span class="dt">Quiz4</span><span class="fu">&gt;</span> map head xss</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">[<span class="dv">1</span>,<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> Prelude.head<span class="fu">:</span> empty list</a></code></pre></div>
<p>しかし <code>[h | (h:_) &lt;- xss]</code> ではどうでしょうか？</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="fu">*</span><span class="dt">Quiz4</span><span class="fu">&gt;</span> xss <span class="fu">=</span> [[<span class="dv">1</span>,<span class="dv">2</span>],[],[<span class="dv">3</span>,<span class="dv">4</span>]]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="fu">*</span><span class="dt">Quiz4</span><span class="fu">&gt;</span> [h <span class="fu">|</span> (h<span class="fu">:</span>_) <span class="ot">&lt;-</span> xss]</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">[<span class="dv">1</span>,<span class="dv">3</span>]</a></code></pre></div>
<p>はい。空リストを含んでいたとしてもエラーにならずに、良い感じに先頭の要素から成るリストが生成できました。</p>
<p>では、なぜこのような動作になるのでしょうか？</p>
<p>それを理解するためには <strong>Haskell 2010 Language Report</strong> の <a href="https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11">3.11 List Comprehensions</a> を参照する必要があります。</p>
<p>ここにリスト内包表記がどのように変換されるか、変換規則が載っています。(ここでは一部のみ掲載)</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="co">-- ルール1</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">[ e <span class="fu">|</span> <span class="dt">True</span> ] <span class="fu">=</span> [e]</a>
<a class="sourceLine" id="cb10-3" data-line-number="3"></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="co">-- ルール2</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">[ e <span class="fu">|</span> q ] <span class="fu">=</span> [ e <span class="fu">|</span> q, <span class="dt">True</span> ]</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="co">-- ルール3</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">[ e <span class="fu">|</span> p <span class="ot">&lt;-</span> l, <span class="dt">Q</span> ] <span class="fu">=</span> <span class="kw">let</span> ok p <span class="fu">=</span> [ e <span class="fu">|</span> <span class="dt">Q</span> ]</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">                        ok _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">                    <span class="kw">in</span> concatMap ok l</a></code></pre></div>
<p>上記の規則により、先程の <code>[h | (h:_) &lt;- xss]</code> は以下のように変換できます。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">[ h <span class="fu">|</span> (h<span class="fu">:</span>_) <span class="ot">&lt;-</span> xss ]</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="fu">=</span> { ルール2 より }</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">[ h <span class="fu">|</span> (h<span class="fu">:</span>_) <span class="ot">&lt;-</span> xss, <span class="dt">True</span> ]</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  <span class="fu">=</span> { ルール3 より }</a>
<a class="sourceLine" id="cb11-5" data-line-number="5"><span class="kw">let</span> ok (h<span class="fu">:</span>_) <span class="fu">=</span> [ h <span class="fu">|</span> <span class="dt">True</span> ]</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">    ok _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb11-7" data-line-number="7"><span class="kw">in</span> concatMap ok xss</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">  <span class="fu">=</span> { ルール1 より }</a>
<a class="sourceLine" id="cb11-9" data-line-number="9"><span class="kw">let</span> ok (h<span class="fu">:</span>_) <span class="fu">=</span> [h]</a>
<a class="sourceLine" id="cb11-10" data-line-number="10">    ok _ <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb11-11" data-line-number="11"><span class="kw">in</span> concatMap ok xss</a></code></pre></div>
<p>最終的には <code>f = [h | (h:_) &lt;- xss]</code> とすると</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">f <span class="fu">=</span> concatMap ok xss</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">    ok (h<span class="fu">:</span>_) <span class="fu">=</span> [h]</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">    ok _     <span class="fu">=</span> []</a></code></pre></div>
<p>になります。</p>
<p>パターンマッチに失敗した場合は <code>ok _ = []</code> ということで自動的に空リストになるという部分が実行時エラーにならない秘密のようですね。</p>
<p>最終的に <code>concatMap</code> によって、空リストが自然に除去されていることがわかります。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="fu">*</span><span class="dt">Quiz4</span><span class="fu">&gt;</span> concatMap ok [[<span class="dv">1</span>,<span class="dv">2</span>], [], [<span class="dv">3</span>,<span class="dv">4</span>]]</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</a></code></pre></div>
<p>ということで、もとの式に戻ると <code>transpose</code> 関数の主張はこういうことです。</p>
<figure>
<img src="/images/2018/03-31/transpose.png" alt="transpose 関数の処理" /><figcaption>transpose 関数の処理</figcaption>
</figure>
<div class="sourceCode" id="cb14"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">transpose []           <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">transpose ([]<span class="fu">:</span>xss)     <span class="fu">=</span> transpose xss</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">transpose ((x<span class="fu">:</span>xs)<span class="fu">:</span>xss) <span class="fu">=</span> (x <span class="fu">:</span> [h <span class="fu">|</span> (h<span class="fu">:</span>_) <span class="ot">&lt;-</span> xss]) <span class="fu">:</span> transpose (xs <span class="fu">:</span> [ t <span class="fu">|</span> (_<span class="fu">:</span>t) <span class="ot">&lt;-</span> xss])</a></code></pre></div>
<h3 id="幅優先探索と深さ優先探索">幅優先探索と深さ優先探索</h3>
<p>アルゴリズムの本などを読むと、必ずこの <strong>幅優先探索</strong> と <strong>深さ優先探索</strong> というキーワードを目にすると思います。(また、同時に説明に利用されるのは木構造のデータでしょう)</p>
<p>幅優先探索と深さ優先探索の概念を理解するために木構造に触れる必要は無く、リストだけで十分です。</p>
<p>本質は以下のように凄く簡単なことです。</p>
<figure>
<img src="/images/2018/03-31/search.png" alt="リストを使った幅優先探索と深さ優先探索" /><figcaption>リストを使った幅優先探索と深さ優先探索</figcaption>
</figure>
<p>そのため <code>[10..]</code> のような無限リストが与えられた場合に <strong>深さ優先探索</strong> では結果を返すことができないのです。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb15-1" data-line-number="1">$ <span class="ex">stack</span> repl -- Quiz4.hs</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="ex">*Quiz4</span><span class="op">&gt;</span> xs = [[10..],[4,5,6],[7,8,9]]</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="ex">*Quiz4</span><span class="op">&gt;</span> bfs 9 xs</a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="ex">True</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5"><span class="ex">*Quiz4</span><span class="op">&gt;</span> dfs 9 xs</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"><span class="ex">.....</span></a></code></pre></div>
<h3 id="コードの解説">コードの解説</h3>
<p><code>dfs</code> は <code>concat</code> によってリストのリストを直列につないだ結果に対して <code>elem x</code> で要素を検索すれば良いということになります。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">dfs ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [[a]] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">dfs x <span class="fu">=</span> elem x <span class="fu">.</span> concat</a></code></pre></div>
<p>それに対して <code>bfs</code> は各リストの先頭要素だけを先に処理していく必要があります。自分でその辺りの処理を書いても良いのですが <code>transpose</code> で一発です。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="ot">bfs ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [[a]] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">bfs x <span class="fu">=</span> elem x <span class="fu">.</span> concat <span class="fu">.</span> transpose</a></code></pre></div>
<p><code>bfs</code> はこのように書くこともできます。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">bfs ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [[a]] <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">bfs x <span class="fu">=</span> dfs x <span class="fu">.</span> transpose</a></code></pre></div>
<p>つまり、リストのリストのようなデータ構造に対して幅優先探索を行うということは、リストを転置した結果に対して深さ優先探索を行うことと等しいということです。</p>
<figure>
<img src="/images/2018/03-31/bfs.png" alt="bfs と dfs の関係" /><figcaption>bfs と dfs の関係</figcaption>
</figure>
<h2 id="まとめ">まとめ</h2>
<p>Haskell 2010 Language Report ってどういう時に利用するんだろう？って思っている人もいるとは思いますが、こういう場合に参照すると便利です。</p>
<p>今回は幅優先探索と深さ優先探索を <strong>リストのリスト</strong> で説明しましたが、一般的に説明される木構造では、これが少し複雑になっただけです。</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>prettyprinter パッケージ</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/03-30-prettyprinter.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/03-30-prettyprinter.html</id>
    <published>2018-03-30T00:00:00Z</published>
    <updated>2018-03-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>今回は <a href="https://www.stackage.org/package/prettyprinter">prettyprinter</a> を使ってみました。</p>
<p>使おうと思ったモチベーションとしては、以下のようなデータ型をデバッグ表示させる際に <code>prettyprinter</code> 系パッケージを使って良い感じに表示してみようかな？という感じです。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span> <span class="dt">Text</span> <span class="dt">String</span></a></code></pre></div>
<p>表示をカスタマイズするために <code>Show</code> クラスのインスタンスを書き換えることは、経験上嫌なことしか起きないです・・。</p>
<p>自分でそれっぽい型クラスを作っても良いのですが、普通は素直に <code>prettyprinter</code> 系のパッケージを使った方が良いと思います！</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" data-line-number="1">$ <span class="ex">stack</span> repl --package text</a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ex">Prelude</span><span class="op">&gt;</span> import Data.Text</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ex">Prelude</span> Data.Text<span class="op">&gt;</span> data Person = Person Text String deriving Show</a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ex">Prelude</span> Data.Text<span class="op">&gt;</span> :set -XOverloadedStrings</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ex">Prelude</span> Data.Text<span class="op">&gt;</span> Person <span class="st">&quot;はすける&quot;</span> <span class="st">&quot;らむだ&quot;</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="ex">Person</span> <span class="st">&quot;\12399\12377\12369\12427&quot;</span> <span class="st">&quot;\12425\12416\12384&quot;</span></a></code></pre></div>
<!--more-->
<h2 id="パッケージの選定理由">パッケージの選定理由</h2>
<p>ぐぐって一番始めに出てきたのは <a href="https://github.com/haskell/pretty">pretty</a> というパッケージだったんですが <code>String</code> にしか対応してない感じだったので見送りました。</p>
<p><code>prettyprinter</code> は <strong>A modern, easy to use, well-documented, extensible prettyprinter.</strong> というコメント通り、とても使いやすいです。</p>
<h2 id="使ってみました">使ってみました</h2>
<div class="sourceCode" id="cb3"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="co">-- stack --resolver lts-11.2 script</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Data.Text.Prettyprint.Doc</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="kw">import</span> <span class="dt">Data.Text.Prettyprint.Doc.Render.Text</span> (putDoc)</a>
<a class="sourceLine" id="cb3-9" data-line-number="9"><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb3-10" data-line-number="10"></a>
<a class="sourceLine" id="cb3-11" data-line-number="11"><span class="kw">data</span> <span class="dt">A</span> <span class="fu">=</span> <span class="dt">A</span> <span class="dt">Text</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12">  <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13"></a>
<a class="sourceLine" id="cb3-14" data-line-number="14"><span class="kw">data</span> <span class="dt">B</span> <span class="fu">=</span> <span class="dt">B</span> <span class="dt">Text</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb3-15" data-line-number="15"></a>
<a class="sourceLine" id="cb3-16" data-line-number="16"><span class="kw">instance</span> <span class="dt">Pretty</span> <span class="dt">B</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-17" data-line-number="17">  pretty (<span class="dt">B</span> l r) <span class="fu">=</span> <span class="st">&quot;B&quot;</span> <span class="fu">&lt;+&gt;</span> pretty l <span class="fu">&lt;+&gt;</span> pretty r</a>
<a class="sourceLine" id="cb3-18" data-line-number="18"></a>
<a class="sourceLine" id="cb3-19" data-line-number="19"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-20" data-line-number="20">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-21" data-line-number="21">  print <span class="fu">$</span> <span class="dt">A</span> <span class="st">&quot;あ&quot;</span> <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb3-22" data-line-number="22">  putDoc <span class="fu">$</span> pretty <span class="fu">$</span> <span class="dt">B</span> <span class="st">&quot;あ&quot;</span> <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb3-23" data-line-number="23">  putStrLn <span class="st">&quot;&quot;</span></a></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb4-1" data-line-number="1">$ <span class="fu">chmod</span> u+x Pretty.hs</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">$ <span class="ex">./Pretty.hs</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="ex">A</span> <span class="st">&quot;\12354&quot;</span> <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="ex">B</span> あ a</a></code></pre></div>
<p><a href="https://www.stackage.org/haddock/lts-11.2/prettyprinter-1.2.0.1/Data-Text-Prettyprint-Doc.html#t:Pretty">Pretty</a> 型クラスのインスタンスを普通に定義するだけです。</p>
<p>適当に改行したい場合は <a href="https://www.stackage.org/haddock/lts-11.2/prettyprinter-1.2.0.1/Data-Text-Prettyprint-Doc.html#v:line">line</a> を追加するだけです。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Pretty</span> <span class="dt">B</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  pretty (<span class="dt">B</span> l r) <span class="fu">=</span> <span class="st">&quot;B&quot;</span> <span class="fu">&lt;&gt;</span> line</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">                <span class="fu">&lt;+&gt;</span> pretty l <span class="fu">&lt;&gt;</span> line</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">                <span class="fu">&lt;+&gt;</span> pretty r</a></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" data-line-number="1">$ <span class="ex">./test.hs</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ex">A</span> <span class="st">&quot;\12354&quot;</span> <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="ex">B</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"> あ</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"> <span class="ex">a</span></a></code></pre></div>
<p>区切りの空白が不要な場合は <a href="https://www.stackage.org/haddock/lts-11.2/prettyprinter-1.2.0.1/Data-Text-Prettyprint-Doc.html#v:-60--43--62-">&lt;+&gt;</a> を <a href="https://www.stackage.org/haddock/lts-11.2/prettyprinter-1.2.0.1/Data-Text-Prettyprint-Doc.html#v:-60--62-">&lt;&gt;</a> にするだけです。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Pretty</span> <span class="dt">B</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  pretty (<span class="dt">B</span> l r) <span class="fu">=</span> <span class="st">&quot;B&quot;</span> <span class="fu">&lt;&gt;</span> line</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">                <span class="fu">&lt;&gt;</span> pretty l <span class="fu">&lt;&gt;</span> line</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">                <span class="fu">&lt;&gt;</span> pretty r</a></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" data-line-number="1">$ <span class="ex">./test.hs</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ex">A</span> <span class="st">&quot;\12354&quot;</span> <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="ex">B</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">あ</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="ex">a</span></a></code></pre></div>
<p>適当にネストさせたい場合も簡単です。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Pretty</span> <span class="dt">B</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  pretty (<span class="dt">B</span> l r) <span class="fu">=</span> nest <span class="dv">4</span> (<span class="st">&quot;B&quot;</span> <span class="fu">&lt;&gt;</span> line</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">                <span class="fu">&lt;&gt;</span> pretty l <span class="fu">&lt;&gt;</span> line</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">                <span class="fu">&lt;&gt;</span> pretty r)</a></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb10-1" data-line-number="1">$ <span class="ex">./test.hs</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ex">A</span> <span class="st">&quot;\12354&quot;</span> <span class="st">&quot;a&quot;</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="ex">B</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">    あ</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">    <span class="ex">a</span></a></code></pre></div>
<h2 id="まとめ">まとめ</h2>
<p>めちゃめちゃ簡単だったので、使ってみると楽しいですよー。ドキュメントが充実しているのが良いですね。</p>
<p>今回は短めでした。</p>
<p>以上です。</p>]]></summary>
</entry>

</feed>
