<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>BIG MOON</title>
    <link href="https://haskell.e-bigmoon.com/feed.xml" rel="self" />
    <link href="https://haskell.e-bigmoon.com" />
    <id>https://haskell.e-bigmoon.com/feed.xml</id>
    <author>
        <name>BIG MOON</name>
        <email>it@e-bigmoon.com</email>
    </author>
    <updated>2017-12-24T00:00:00Z</updated>
    <entry>
    <title>stack v1.6.3 がリリースされました。</title>
    <link href="https://haskell.e-bigmoon.com/posts/2017-12-24-stack163.html" />
    <id>https://haskell.e-bigmoon.com/posts/2017-12-24-stack163.html</id>
    <published>2017-12-24T00:00:00Z</published>
    <updated>2017-12-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>以下のコマンドで <code>stack v1.6.3</code> のバイナリが落ちてきます。</p>
<pre class="shell"><code>$ stack upgrade</code></pre>
<h2 id="リリースノート">リリースノート</h2>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/blob/master/ChangeLog.md#v163">Changelog.md</a></li>
</ul>
<p>機能追加は無く、改良とバグフィックスのみです。</p>
<p><code>stack ls</code> コマンドは今回に含まれていないので <code>v1.7.0</code> で追加されそうな感じですね。</p>
<!--more-->
<h3 id="enhancements">Enhancements</h3>
<ul>
<li>In addition to supporting <code>.tar.gz</code> and <code>.zip</code> files as remote archives, plain <code>.tar</code> files are now accepted too. This will additionally help with cases where HTTP servers mistakenly set the transfer encoding to <code>gzip</code>. See <a href="https://github.com/commercialhaskell/stack/issues/3647">#3647</a>.</li>
</ul>
<p>ということで <code>.tar</code> に加えて <code>extra-deps</code> に <code>.tar.gz</code>, <code>.zip</code> 形式が指定できるようになったみたいです。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="fu">extra-deps:</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">-</span> <span class="fu">http:</span><span class="at">//www.mathstat.dal.ca/~selinger/quipper/downloads/quipper-0.8.tgz</span></a></code></pre></div>
<p>僕は使ったこと無いですが、役立ちそう。</p>
<ul>
<li>Links to docs.haskellstack.org ignore Stack version patchlevel.</li>
<li>Downloading Docker-compatible stack binary ignores Stack version patchlevel.</li>
</ul>
<p>たぶん <code>stack v1.6.1.1</code> のようなバージョンは無視されるということでしょうか。</p>
<h2 id="bug-fixes">Bug fixes</h2>
<ul>
<li>For versions of Cabal before 1.24, ensure that the dependencies of non-buildable components are part of the build plan to work around an old Cabal bug. See <a href="https://github.com/commercialhaskell/stack/issues/3631">#3631</a>.</li>
</ul>
<p>古めの <code>LTS</code> (issue は lts-6.35 で報告されてる) 使ってる人はこの問題が解決されますのでアップデート推奨と思われます。</p>
<ul>
<li>Run the Cabal file checking in the <code>sdist</code> command more reliably by allowing the Cabal library to flatten the <code>GenericPackageDescription</code> itself.</li>
</ul>
<p>よくわかりません。</p>
<ul>
<li>The script interpreter’s implicit file arguments are now passed before other arguments. See <a href="Error%20when%20using%20RTS%20options%20with%20the%20Stack%20script%20interpreter%20#3658">#3658</a>. In particular, this makes it possible to pass <code>-- +RTS ... -RTS</code> to specify RTS arguments used when running the script.</li>
</ul>
<p>スクリプトインタプリタの暗黙的なファイル引数を他の引数より先に渡すように修正されたようです。 その結果、以下のような <code>RTS</code> オプションの指定が適切に処理できるようになりました。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="co">{- stack</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="co">  script</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="co">  --resolver lts-6.25</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="co">  --package turtle</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="co">  --</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="co">  +RTS -s -RTS</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="co">-}</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9"></a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="ot">main ::</span> <span class="dt">IO</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">main <span class="fu">=</span> putStrLn <span class="st">&quot;Hello, world!&quot;</span></a></code></pre></div>
<ul>
<li>Don’t ignore the template year parameter in config files, and clarify the surrounding documentation. See <a href="stack%20new%20--%20AesonException%20#2275">#2275</a>.</li>
</ul>
<p><code>config.yaml</code> に <code>year</code> パラメータを指定できるようになったそうです。こんな感じです。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">templates:</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="fu">params:</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    <span class="fu">author-email:</span><span class="at"> 415fox@gmail.com</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    <span class="fu">author-name:</span><span class="at"> michael fox</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    <span class="fu">category:</span><span class="at"> Application</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">    <span class="fu">copyright:</span><span class="at"> copytright michael fox 2016</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    <span class="fu">github-username:</span><span class="at"> gitfoxi</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8">    <span class="fu">year:</span><span class="at"> 2016</span></a></code></pre></div>
<p>ドキュメントを見る限り <code>copyright</code> は指定されていない場合に <code>author-name</code> と <code>year</code> を使って <code>copyright</code> が生成されるようです。 また <code>year</code> を省略した場合は現在の年が設定されるとのことなので、設定しなくても良さそうですね。</p>
<blockquote>
<p>year - if copyright is not specified, year and author-name are used to generate the copyright property in cabal. If year is not specified, it defaults to the current year.</p>
</blockquote>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>カスタムスナップショットの紹介</title>
    <link href="https://haskell.e-bigmoon.com/posts/2017-12-23-stack161.html" />
    <id>https://haskell.e-bigmoon.com/posts/2017-12-23-stack161.html</id>
    <published>2017-12-23T00:00:00Z</published>
    <updated>2017-12-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>ちょっと前に <a href="https://github.com/commercialhaskell/stack/blob/master/ChangeLog.md#v161">version 1.6.1</a> がリリースされたので、その中の目玉機能でもある <code>カスタムスナップショット</code> を紹介したいと思います。</p>
<!--more-->
<h2 id="news">NEWS</h2>
<p>すでに多くの方がご存知かと思いますが、<code>stack</code> 界隈で大きな出来事が3つありました。</p>
<ul>
<li><code>stack 1.6.1</code> のリリース</li>
<li><code>lts-10.0</code> のリリース</li>
<li><code>stack new</code> で生成されるテンプレートのデフォルトが <code>hpack</code> になった</li>
</ul>
<p>以下の記事は <code>hpack</code> についての記述があるため、stack 初心者におすすめです！</p>
<ul>
<li><a href="https://myuon.github.io/posts/haskell-project-setup/">Haskellプロジェクトを始めるにあたって</a></li>
<li><a href="https://qiita.com/ogata-k/items/2b21326b2b7351bfc28c">Haskellのstackによるプロジェクトについて</a></li>
<li><a href="https://qiita.com/waddlaw/items/49874f4cf9b680e4b015">本気で Haskell したい人向けの Stack チュートリアル</a>
<ul>
<li>僕が作成して、時々加筆修正していますが、量が多くなりすぎたのでどうにかしようと思っています・・・。</li>
<li>タイトルは煽っている感じが少々ありますが、結構真面目です。</li>
</ul></li>
</ul>
<p>ただ、古い記事が全部だめかというとそうでもありません。</p>
<p>細部を自分で補完できれば有用な記事も多くあります。</p>
<ul>
<li><a href="https://qiita.com/tanakh/items/6866d0f570d0547df026">Haskellのビルドツール“stack”の紹介</a></li>
<li><a href="https://qiita.com/igrep/items/da1d8df6d40eb001a561">Stackでやる最速Haskell Hello world! (GHCのインストール付き！)</a></li>
</ul>
<h2 id="custom-snapshots-カスタムスナップショット-について">Custom Snapshots (カスタムスナップショット) について</h2>
<ul>
<li><a href="https://docs.haskellstack.org/en/stable/custom_snapshot/">Custom Snapshots</a></li>
<li><a href="https://www.fpcomplete.com/blog/2017/07/stacks-new-extensible-snapshots">STACK’S NEW EXTENSIBLE SNAPSHOTS.</a></li>
<li><a href="https://github.com/commercialhaskell/stack/pull/3249">Extensible snapshots #3249</a></li>
</ul>
<p>カスタムスナップショットは名前から想像できるように、スナップショットを好きにカスタマイズできる新機能です！</p>
<p>公式のスナップショットは <code>resolver</code> に指定する <code>lts</code> や <code>nightly</code> で始まるものです。</p>
<p>カスタムスナップショットとは関係ないですが、<code>lts</code>, <code>nightly</code> とバージョンを省略すると最新版のスナップショットを指定できるという小技もあります。(<a href="https://github.com/commercialhaskell/stack/issues/3641">Feature request: stack init –latest-nightly #3641</a>)</p>
<pre class="shell"><code>$ stack new sample --resolver=nightly
$ stack new sample --resolver=lts</code></pre>
<h2 id="カスタムスナップショットを作ってみよう">カスタムスナップショットを作ってみよう！</h2>
<p>通常であれば <code>stack new</code> で生成されるプロジェクトの <code>stack.yaml</code> と <code>package.yaml</code> を使いますが、今回は全部ゼロから作って行こうと思います。</p>
<h3 id="カスタムスナップショットの作成">カスタムスナップショットの作成</h3>
<p>まずは <code>my-snapshot.yaml</code> という名前で空のファイルを作ります。</p>
<pre class="shell"><code>$ touch my-snapshot.yaml
$ tree
.
└── my-snapshot.yaml</code></pre>
<p>カスタムスナップショットを定義するためには、まずはベースとなるスナップショットを決める必要があります。</p>
<p>そのため、 <code>my-snapshot.yaml</code> に <code>resolver</code> を追記しましょう。今回は新しくリリースされた <code>lts-10.0</code> を指定します。</p>
<p>また <code>name</code> フィールドで自分のスナップショットに名前をつけます。</p>
<p>この2つが必須のフィールドになります。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">resolver:</span><span class="at"> lts-10.0</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="fu">name:</span><span class="at"> waddlaw-1.0</span></a></code></pre></div>
<p>これで <code>lts-10.0</code> と全く同じカスタムスナップショットを定義することができました。</p>
<p><code>name</code> フィールドは <code>~/.stack/snapshots/</code> 以下に保存されるスナップショットのディレクトリ名の一部として利用されたりします。</p>
<h3 id="stack.yaml-の作成">stack.yaml の作成</h3>
<p>実際に使ってみましょう。まずは <code>stack.yaml</code> を用意します。</p>
<pre class="shell"><code>$ touch stack.yaml

$ tree
.
├── my-snapshot.yaml
└── stack.yaml</code></pre>
<p><code>stack.yaml</code> の <code>resolver</code> に先に作ったカスタムスナップショットを指定します。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="fu">resolver:</span><span class="at"> my-snapshot.yaml</span></a></code></pre></div>
<p>このままでは <code>cabal</code> ファイルが無いため、まだビルドできません。</p>
<h3 id="package.yaml-の作成">package.yaml の作成</h3>
<p><code>package.yaml</code> もゼロから作っていきましょう。</p>
<pre class="shell"><code>$ touch package.yaml

$ tree
.
├── my-snapshot.yaml
├── package.yaml
└── stack.yaml</code></pre>
<p>最小の <code>package.yaml</code> はこんな感じです。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="fu">name:</span><span class="at"> test-custom-snapshot</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="fu">dependencies:</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">-</span> base</a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="fu">library:</span><span class="at"> </span><span class="kw">{}</span></a></code></pre></div>
<p>ではビルドしてみましょう。</p>
<pre class="shell"><code>$ stack build
...

$ tree
.
├── my-snapshot.yaml
├── package.yaml
├── stack.yaml
└── test-custom-snapshot.cabal</code></pre>
<p>無事に <code>cabal</code> ファイルが生成されていますね。</p>
<h2 id="パッケージの追加">パッケージの追加</h2>
<p>現時点の依存関係を確認してみます。</p>
<pre class="shell"><code>$ stack list-dependencies
base 4.10.1.0
ghc-prim 0.5.1.1
integer-gmp 1.0.1.0
rts 1.0
test-custom-snapshot 0.0.0</code></pre>
<p>まずは、いつも通り何かパッケージを追加してみましょう。</p>
<p>今回は <a href="https://www.stackage.org/package/hakyll-shakespeare">hakyll-shakespeare</a> を追加することにします。<code>hamlet</code> 記法が好きなので <code>hakyll</code> でサイト作る時は個人的にお世話になっているパッケージです。</p>
<p>現時点で <code>lts-10.0</code> に <code>hakyll-shakespeare</code> は含まれていません。</p>
<pre><code>$ cat my-snapshot.yaml
resolver: lts-10.0
name: waddlaw-1.0

packages:
  - hakyll-shakespeare-0.1.0.0.2</code></pre>
<p>こんな感じでカスタムスナップショットに <code>hakyll-shakespeare</code> を指定します。</p>
<p><code>packages</code> フィールドには <code>extra-deps</code> と同じ構文が利用できます。そのため <code>hackage</code> などにアップロードしていないパッケージでも同様に指定可能です。</p>
<p>それでは、ちゃんと追加されるか確認してみます。</p>
<pre class="shell"><code>$ stack build
$ stack list-dependencies | grep hakyll-shakespeare
hakyll-shakespeare 0.1.0.0.2</code></pre>
<p>大丈夫そうですね！</p>
<h2 id="カスタムスナップショットを共有する">カスタムスナップショットを共有する</h2>
<p>ここまでで基本的なカスタムスナップショットの作り方はマスターできたと思います。</p>
<p>しかし、複数のプロジェクトでカスタムスナップショットが利用できなければ、うれしさ半減です。なので、カスタムスナップショットには、そういった仕組みも用意されています。</p>
<p>どこかにカスタムスナップショットをアップロードし、単純に <code>resolver</code> に <code>URL</code> を指定するだけです。</p>
<pre class="shell"><code>$ cat stack.yaml
resolver: https://raw.githubusercontent.com/waddlaw/example-custom-snapshot/master/my-snapshot.yaml</code></pre>
<h3 id="注意点">注意点</h3>
<p>1つ注意しなければならない点として、ローカルに用意するカスタムスナップショットファイルと違い、リモートのファイルについてはイミュータブル (変更されないもの) として処理されるという点です。つまり、 <code>URL</code> にアクセスするのは一度だけということです。</p>
<p>そのため、リモートのファイルを上書き更新したとしても、その内容は既存のプロジェクトには反映されません。</p>
<pre class="shell"><code>$ tree ~/.stack/custom-plan/
/home/bm12/.stack/custom-plan/
└── yaml
    └── tCj-vP1QL-9k.yaml

$ cat ~/.stack/custom-plan/yaml/tCj-vP1QL-9k.yaml
resolver: lts-10.0
name: waddlaw-1.0

packages:
  - hakyll-shakespeare-0.1.0.0.2</code></pre>
<p>なので <code>Stackage</code> 同様にカスタムスナップショットの内容を変更する場合は、その都度新しいスナップショットを作る必要があります。</p>
<h2 id="カスタマイズ可能な設定">カスタマイズ可能な設定</h2>
<p>スナップショットをカスタマイズできる項目は以下の4つです。</p>
<ul>
<li>コンパイラの上書き</li>
<li>除外パッケージの指定</li>
<li>ghc-options の指定</li>
<li>flags の指定</li>
</ul>
<p>具体的な使い方についてはドキュメントをご確認ください。</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/blob/master/doc/custom_snapshot.md#using-a-url-instead-of-a-filepath">Custom Snapshots</a></li>
</ul>
<h2 id="まとめ">まとめ</h2>
<p>この機能は <code>Hakyll</code> などの静的サイトジェネレータを良く使う人にとっては、便利なのではないでしょうか。</p>
<p>個人的には、<code>lts-9</code> 系で最新の <code>pandoc</code> と <code>hakyll</code> を使おうとしたとき、数多くの <code>extra-deps</code> を追加する必要があり、そういう場面で便利かなと少し感じました。</p>]]></summary>
</entry>
<entry>
    <title>将来も使えるテストスイート</title>
    <link href="https://haskell.e-bigmoon.com/posts/2017-12-22-future-proofing-test-suites.html" />
    <id>https://haskell.e-bigmoon.com/posts/2017-12-22-future-proofing-test-suites.html</id>
    <published>2017-12-22T00:00:00Z</published>
    <updated>2017-12-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Great original post: <a href="https://www.snoyman.com/blog/2017/11/future-proofing-test-suites">Future proofing test suites</a>.</p>
<p>2017年 11月 12日 Michael Snoyman</p>
<p>まず、最近何回か見た具体的なケースから話を始めましょう。そしてそれを元に一般的な話をします。もしもあなたがパッケージの作者で、この問題に直面してきたのなら、ちょっと聞いてくださいよ。私がこの情報をブログの記事にしているのは、いくつものバグトラッカーで同じ説明を何回もするよりも、ここに一回だけ書いて、そのリンクを貼ればいいと考えたからです。</p>
<p><a href="https://www.stackage.org/package/hlint">hlint</a> は Haskell のコードをより良くするためのアドバイスをくれる、素晴らしいツールです (Neil Mitchell のもう一つの素晴らしいプロダクト)。その別のプロダクトのように、hlint もまた新しいバージョンで、より良いアドバイスをくれるような進化を遂げています。まぁこれは、昔の hlint では出なかった警告が、新しいバージョンで突然出るようになるかもしれない、という意味でもあります。</p>
<!--more-->
<p>最近、Stackage のキュレーション中に 2回、コードを全く変えていないのに、何個もテストが失敗するのを見ています。この、以前通っていたテストが失敗するようになる現象は、hlint のバージョンを新しくしたのが原因でした。これは明らかに、hlint のバージョンを新しくしたからコードがいきなりぶっ壊れたのではありません。テストの失敗の診断が関係しているので、hlint の警告のせいでしょうね (意訳)。</p>
<h2 id="推奨するやり方">推奨するやり方</h2>
<p>hlint を使ってプロジェクトのコードを改善するのは、すごくおすすめです。Stack などの CI のプロセスでこいつを使って、素晴らしい結果を返してくれるのを何回か見ています。(ちなみにこれは私のアイディアではなくて、実際に使ったりもしていませんでした。ただスタイルエラーがある PR を投げてしまって、それが失敗するのに気づいて、嬉しい驚きだった、というだけです)。でも、hlint のバージョンを新しくしたせいで、パッケージ全体としてのテストが失敗する現象。これは起こりすぎです。なので、</p>
<ul>
<li>警告が出る PR をブロックしたいのなら、CI から hlint を呼び出すように<strong>してください</strong>。私が思いつく方法は 2つあります:
<ul>
<li>Stack のやり方をまねる。Stack にはスタイルエラー専用の、<a href="https://github.com/commercialhaskell/stack/blob/46121be1b96465f1164e3f84cafa19c7369da9cc/.travis.yml#L39">Travis CI のビルドマトリックス</a>があります。プロジェクトの cabal ファイルは、hlint について何も知りません。</li>
<li>cabalファイルのテストを使うが、デフォルトで無効にしておく。CI の設定から、フラグを使ってそのテストを有効にします。 </li>
</ul></li>
<li>Hackage にアップロードされ、Stackage でビルドされた際に、スタイルに関連するエラーによってテストが失敗するようなパッケージのセットアップはやめましょう。</li>
</ul>
<h2 id="一般的に推奨するやり方">一般的に推奨するやり方</h2>
<p>ここから考察される一般論は、CI でコードをビルドするときは、やりたいだけ厳密にやる、ということです。標準を高く保ち、PR をブロックし、master がぶっ壊れた! と叫んでください。ささいな問題でもそうでなくても、重要だと思う問題全てに対してです。<code>-Wall -Werror</code> をオンにし、タブや文末のスペースに対してエラーを吐くようにしてください。これらは全て良いものです (タブかスペースかなどの、必要な議論はしてください)。</p>
<p>しかし、他の場所でコードをリリースするときは、メインではない機能に対しては、テストを緩くしましょう。コードがビルドに失敗するのなら、それは問題です。ビルドに成功しても、実行時に正しくない結果を返すようなら、それは問題です。これらの問題が存在すると、Stackage などのビルドシステムは、そのようなパッケージを受け入れてくれません。でも、スタイルの問題や新しく追加されたコンパイラの警告のようなものなら、あなたのパッケージを使うより下流の利用者に対して、失敗させるべきではないでしょうね。</p>]]></summary>
</entry>
<entry>
    <title>stack ls コマンドが追加されます</title>
    <link href="https://haskell.e-bigmoon.com/posts/2017-12-20-stack-ls-command.html" />
    <id>https://haskell.e-bigmoon.com/posts/2017-12-20-stack-ls-command.html</id>
    <published>2017-12-20T00:00:00Z</published>
    <updated>2017-12-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><code>Stack</code> の <code>master</code> に <code>stack ls</code> コマンドがマージされました。</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/3672">Add stack ls snapshots documentation to the user guide #3672</a></li>
</ul>
<p>今後、このコマンドのサブコマンドに <code>list-dependencies</code> などを順次追加していく方針?のようです。</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/issues/3669">Stack list-dependencies : Bring it under the new ls umbrella command #3669</a></li>
</ul>
<!--more-->
<h2 id="使ってみよう">使ってみよう！</h2>
<p>このコマンドを使うためには <code>stack</code> の <code>master</code> ブランチの最新版をインストールする必要があります。</p>
<pre class="shell"><code>$ stack upgrade --git
# ソースからコンパイルするので時間がかかります

$ stack --version
Version 1.7.0, Git revision 7d68bd695c4de8f231a95e66d0c882031f8255de (5468 commits) x86_64 hpack-0.20.0</code></pre>
<p>現状、実装されているコマンドとしては <code>stack ls snapshots</code> があります。</p>
<pre class="shell"><code># ローカルのスナップショット一覧を表示
$ stack ls snapshots

# lts のみ表示 (lts の略)
$ stack ls snapshots -l

# nightly のみ表示 (nightly の略)
$ stack ls snapshots -n

# リモートのスナップショット一覧を表示
$ stack ls snapshots remote

$ stack ls snapshots -l remote

$ stack ls snapshots -n remote</code></pre>
<p>実行すると <code>less</code> が立ち上がり、結果を確認することができます。</p>
<p>もとの <code>stack</code> のバージョンに戻すためには以下のコマンドを実行しましょう。</p>
<pre class="shell"><code>$ stack upgrade --binary-version 1.6.1
# バイナリが落ちてくるのですぐに元通りです。

$ stack --version
Version 1.6.1, Git revision f25811329bbc40b0c21053a8160c56f923e1201b (5435 commits) x86_64 hpack-0.20.0</code></pre>
<h2 id="まとめ">まとめ</h2>
<p>これで <a href="https://www.stackage.org/">Stackage</a> を見なくても、どんなスナップショットが利用できるか、すぐに確認できるようになりますね。</p>]]></summary>
</entry>
<entry>
    <title>Haskell で暗号学的ハッシュを扱う</title>
    <link href="https://haskell.e-bigmoon.com/posts/2017-09-18-cryptographic-hashing-haskell.html" />
    <id>https://haskell.e-bigmoon.com/posts/2017-09-18-cryptographic-hashing-haskell.html</id>
    <published>2017-09-18T00:00:00Z</published>
    <updated>2017-09-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Great original post: <a href="https://www.fpcomplete.com/blog/2017/09/cryptographic-hashing-haskell">CRYPTOGRAPHIC HASHING IN HASKELL.</a>.</p>
<p>2017年 9月 18日 Michael Snoyman</p>
<p><a href="https://www.stackage.org/package/cryptonite">cryptonite</a> は現在、Haskell で暗号を扱う際のデファクトスタンダードです。 一般的に安全な乱数、共通鍵・公開鍵暗号、MAC (メッセージ認証符号)等をサポートしていて、その中には今日の話題、暗号学的ハッシュも含まれています。</p>
<p>まず、ハッシュ関数について軽く説明しましょう。ハッシュ関数とは、任意長のデータを固定長のデータに変換するものです。暗号学的ハッシュ関数は、暗号を扱う上で望ましい性質をそなえたハッシュ関数です (詳しくは <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">Wikipedia</a> を参照)。 一般的な暗号学的ハッシュ関数の使われ方の一例として、ダウンロードされたファイルが改ざんされていないことを保証するための、チェックサムを提供する、というものがあります。 今日使われている暗号学的ハッシュ関数には、SHA256、Skein512、そしてまぁ、ちょっと古いですが MD5 などがあります。</p>
<p><code>cryptonite</code> は <a href="https://www.stackage.org/package/memory">memory</a> というライブラリの一番上の階層にあります。この <code>memory</code> ライブラリは、Byte 配列を扱うための型クラスと便利な関数を提供しています。 「全て <code>ByteString</code> でいいのでは?」と思うかもしれませんが、後ほどこの型クラスの便利さを示します。</p>
<!--more-->
<p>一旦これら 2つのライブラリに慣れれば、簡単に使いこなすことができます。 ですが、API のドキュメントを見るだけでは、部分部分がどう組み合わさるのか理解するのは至難の技です。特に、どこで明示的な型シグネチャが必要になるのかの理解が難しい。 この記事では、理解に必要な部分について1つ1つの簡単な例を、実行可能なコードで紹介します。 読み進める中で、API のドキュメントについてざっくりと理解していってください。</p>
<p>この記事のコードの例は、全て <code>Stack</code> のスクリプトインタプリタ機能を使っています。 まず <code>Stack</code> を<a href="https://haskell-lang.org/get-started">インストール</a>して、次の手順で実行してください。</p>
<ul>
<li><code>Main.hs</code> にコードをコピペする</li>
<li><code>stack Main.hs</code> を実行</li>
</ul>
<h2 id="基本的な型クラス">基本的な型クラス</h2>
<p>文字列っぽい型を扱うのは慣れているでしょう? 正格・遅延評価される <code>ByteString</code> や <code>Text</code> や普通の <code>String</code> などです。 正格なバイトシーケンスを表現する際、<code>Data.ByteString.ByteString</code> を思い浮かべるのではないでしょうか。 しかし、これから見るように、バイトシーケンスとして扱いたい型はいろいろ見つかります。</p>
<p><code>memory</code> はこの要望に答えるべく、以下の 2つの型クラスを定義しています。</p>
<ul>
<li><code>ByteArrayAccess</code> ある型のバイトへ、読み取り専用のアクセスを提供</li>
<li><code>ByteArray</code> 読み / 書きのアクセスを提供する。<code>ByteArrayAccess</code> の子クラス</li>
</ul>
<p>例えば、以下に示すコードは、意味もなく <code>ByteString</code> と <code>Byte</code> の変換をしています。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteArray</span> <span class="kw">as</span> <span class="dt">BA</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">import</span> <span class="dt">Data.ByteString</span> (<span class="dt">ByteString</span>)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString</span> <span class="kw">as</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  B.writeFile <span class="st">&quot;test.txt&quot;</span> <span class="st">&quot;This is a test&quot;</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  byteString <span class="ot">&lt;-</span> B.readFile <span class="st">&quot;test.txt&quot;</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  <span class="kw">let</span><span class="ot"> bytes ::</span> <span class="dt">BA.Bytes</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">      bytes <span class="fu">=</span> BA.convert byteString</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">  print bytes</a></code></pre></div>
<p><code>bytestring</code> ライブラリを使ってファイルの入出力から話を始めたのは、<a href="http://www.snoyman.com/blog/2016/12/beware-of-readfile">入出力は bytestring でやるべき</a> だからです。 <code>convert</code>関数を使うと、<code>ByteString</code> を <code>Bytes</code> に変換することができます。</p>
<p><strong>練習問題</strong> 上の2つの型クラスの説明を踏まえて <code>convert</code> の型シグネチャは何だと思いますか? 答えは<a href="https://www.stackage.org/haddock/lts-9.4/memory-0.14.7/Data-ByteArray.html#v:convert">こちら</a>。</p>
<p><code>bytes</code> の値につけた、明示的な型シグネチャに気がつきましたか? えーと、<code>memory</code> と <code>cryptonite</code> を使っていく上で、これは大事です。 こうして、よく GHC に、型推論についてのヒントを与えてやらないといけなくなります。 なぜなら、これらのライブラリの中のかなり多くの関数が、具体的な型ではなく、型クラスを使っているからです。</p>
<p>さて、<code>ByteArrayAccess</code> に属する型の例をお見せしましたが、それは<code>ByteArray</code> についての例ではありませんでした。 今は型クラスを分ける意味が分からないかもしれませんが、実際にハッシュを使う段階で、型クラスを分けることの利点が見えてくると思います。 ちょっと待ってくださいね。</p>
<h3 id="なぜ違う型があるのか">なぜ違う型があるのか</h3>
<p>当然、<code>memory</code> の中になぜ <code>Bytes</code> という型があるのか、疑問に思う人もいるでしょうね。 <code>ByteString</code> と同じじゃないの? ってね。 まぁ違うんですけどね。 <code>Bytes</code> はメモリスライスのオフセットと長さを追跡しないことで、メモリのオーバーヘッドを小さくしています。 その代わりに、<code>Bytes</code> の値をスライスすることは許されません。 言い換えれば、<code>Bytes</code> に関する <code>drop</code>関数は、バッファの新しいコピーを作らなければならないということです。</p>
<p>まぁつまり、これはパフォーマンスの問題です。暗号を扱うライブラリは、一般的にパフォーマンスを重視する必要がありますからね。</p>
<p>また別の <code>memory</code> のおもしろい型に、<a href="https://www.stackage.org/haddock/lts-9.4/memory-0.14.7/Data-ByteArray.html#t:ScrubbedBytes"><code>ScrubbedBytes</code></a> というものがあります。 この型は、3つの特別な性質を有しています。 <code>Haddock</code> によると、</p>
<ul>
<li>スコープの範囲から出るとゴシゴシされる</li>
<li><code>Show</code> インスタンスは、中身を何1つとして出力しない</li>
<li>定数時間の <code>Eq</code> インスタンス</li>
</ul>
<p>つまり、これらの性質は何か機密性の高いデータを扱うとき、ありふれた脆弱性をいくつも塞いでくれるものです。</p>
<p>うん、コードがあまりない説明になりましたね。 もっと楽しいことをしよう!</p>
<h2 id="base16-エンコードデコード">Base16 エンコード/デコード</h2>
<p>ユーザの入力を、Base16 (16進数) に変換してみましょう。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteArray</span>          <span class="kw">as</span> <span class="dt">BA</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">import</span>           <span class="dt">Data.ByteArray.Encoding</span> (convertToBase, <span class="dt">Base</span> (<span class="dt">Base16</span>))</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Data.ByteString</span>         (<span class="dt">ByteString</span>)</a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Data.Text.Encoding</span>      (encodeUtf8)</a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.IO</span>            <span class="kw">as</span> <span class="dt">TIO</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">System.IO</span>               (hFlush, stdout)</a>
<a class="sourceLine" id="cb2-9" data-line-number="9"></a>
<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">  putStr <span class="st">&quot;Enter some text: &quot;</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13">  hFlush stdout</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">  text <span class="ot">&lt;-</span> TIO.getLine</a>
<a class="sourceLine" id="cb2-15" data-line-number="15">  <span class="kw">let</span> bs <span class="fu">=</span> encodeUtf8 text</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">  putStrLn <span class="fu">$</span> <span class="st">&quot;You entered: &quot;</span> <span class="fu">++</span> show bs</a>
<a class="sourceLine" id="cb2-17" data-line-number="17">  <span class="kw">let</span> encoded <span class="fu">=</span> convertToBase <span class="dt">Base16</span><span class="ot"> bs ::</span> <span class="dt">ByteString</span></a>
<a class="sourceLine" id="cb2-18" data-line-number="18">  putStrLn <span class="fu">$</span> <span class="st">&quot;Converted to base 16: &quot;</span> <span class="fu">++</span> show encoded</a></code></pre></div>
<p><code>convertToBase</code> は、どんな <code>ByteArrayAccess</code> も、与えられた基数を使って <code>ByteArray</code> に変換することができます。Base16 以外の基数には、Base64 などがあります。</p>
<p>見てお分かりの通り、上の例では明示的に <code>ByteString</code> の型シグネチャを指定する必要がありました。なぜならそうしなければ、GHC が<code>ByteArrayAccess</code> のインスタンスの内、どれを使うべきなのか判断できないからです。</p>
<p>既にお分かりかもしれませんが、全く逆の変換を行う、<code>convertFromBase</code>関数も存在します。 この関数は、入力のフォーマットが正しくなかった場合にも対応できるように、<code>Either String ByteArray</code> の値を返します。</p>
<p><strong>練習問題</strong> 入力に対して、Base16 のデコードを行うプログラムを書いてください (解答はすぐ下)。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteArray</span>          <span class="kw">as</span> <span class="dt">BA</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">import</span>           <span class="dt">Data.ByteArray.Encoding</span> (convertFromBase, <span class="dt">Base</span> (<span class="dt">Base16</span>))</a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Data.ByteString</span>         (<span class="dt">ByteString</span>)</a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Data.Text.Encoding</span>      (encodeUtf8)</a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.IO</span>            <span class="kw">as</span> <span class="dt">TIO</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">System.IO</span>               (hFlush, stdout)</a>
<a class="sourceLine" id="cb3-9" data-line-number="9"></a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12">  putStr <span class="st">&quot;Enter some hexadecimal text: &quot;</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13">  hFlush stdout</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">  text <span class="ot">&lt;-</span> TIO.getLine</a>
<a class="sourceLine" id="cb3-15" data-line-number="15">  <span class="kw">let</span> bs <span class="fu">=</span> encodeUtf8 text</a>
<a class="sourceLine" id="cb3-16" data-line-number="16">  putStrLn <span class="fu">$</span> <span class="st">&quot;You entered: &quot;</span> <span class="fu">++</span> show bs</a>
<a class="sourceLine" id="cb3-17" data-line-number="17">  <span class="kw">case</span> convertFromBase <span class="dt">Base16</span> bs <span class="kw">of</span></a>
<a class="sourceLine" id="cb3-18" data-line-number="18">    <span class="dt">Left</span> e <span class="ot">-&gt;</span> error <span class="fu">$</span> <span class="st">&quot;Invalid input: &quot;</span> <span class="fu">++</span> e</a>
<a class="sourceLine" id="cb3-19" data-line-number="19">    <span class="dt">Right</span> decoded <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb3-20" data-line-number="20">      putStrLn <span class="fu">$</span> <span class="st">&quot;Converted from base 16: &quot;</span> <span class="fu">++</span> show (<span class="ot">decoded ::</span> <span class="dt">ByteString</span>)</a></code></pre></div>
<p><em>練習問題</em> Base16 の入力を、Base64 のエンコードに変換するプログラムを書いてください。</p>
<h2 id="正格な-bytestring-のハッシュ">正格な <code>ByteString</code> のハッシュ</h2>
<p>よし、<code>memory</code> ライブラリに関する説明はもう十分でしょう。 これからは実際に暗号的なものをやっていきます。ユーザの入力を、SHA256 のハッシュ値 (ダイジェスト) に変換してみましょう。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Crypto.Hash</span>             (hash, <span class="dt">SHA256</span> (..), <span class="dt">Digest</span>)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="kw">import</span>           <span class="dt">Data.ByteString</span>         (<span class="dt">ByteString</span>)</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Data.Text.Encoding</span>      (encodeUtf8)</a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.IO</span>            <span class="kw">as</span> <span class="dt">TIO</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="kw">import</span>           <span class="dt">System.IO</span>               (hFlush, stdout)</a>
<a class="sourceLine" id="cb4-8" data-line-number="8"></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-10" data-line-number="10">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11">  putStr <span class="st">&quot;Enter some text: &quot;</span></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">  hFlush stdout</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">  text <span class="ot">&lt;-</span> TIO.getLine</a>
<a class="sourceLine" id="cb4-14" data-line-number="14">  <span class="kw">let</span> bs <span class="fu">=</span> encodeUtf8 text</a>
<a class="sourceLine" id="cb4-15" data-line-number="15">  putStrLn <span class="fu">$</span> <span class="st">&quot;You entered: &quot;</span> <span class="fu">++</span> show bs</a>
<a class="sourceLine" id="cb4-16" data-line-number="16">  <span class="kw">let</span><span class="ot"> digest ::</span> <span class="dt">Digest</span> <span class="dt">SHA256</span></a>
<a class="sourceLine" id="cb4-17" data-line-number="17">      digest <span class="fu">=</span> hash bs</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">  putStrLn <span class="fu">$</span> <span class="st">&quot;SHA256 hash: &quot;</span> <span class="fu">++</span> show digest</a></code></pre></div>
<p>たった今、<code>ByteString</code> (かもしくは <code>ByteArrayAccess</code> のインスタンス) を <code>Digest SHA256</code> に変換するために <code>hash</code> 関数を使いました。 実際、SHA256 以外のハッシュアルゴリズムも指定することができます。</p>
<p>今回の例では、<code>Digest SHA256</code> という型シグネチャが大事でした。GHC にどんなハッシュを使うのか知らせるためです。しかし次の例では、その代わりの関数が登場します。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Crypto.Hash</span>             (hashWith, <span class="dt">SHA256</span> (..))</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="kw">import</span>           <span class="dt">Data.ByteString</span>         (<span class="dt">ByteString</span>)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Data.Text.Encoding</span>      (encodeUtf8)</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.IO</span>            <span class="kw">as</span> <span class="dt">TIO</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="kw">import</span>           <span class="dt">System.IO</span>               (hFlush, stdout)</a>
<a class="sourceLine" id="cb5-8" data-line-number="8"></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">  putStr <span class="st">&quot;Enter some text: &quot;</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">  hFlush stdout</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">  text <span class="ot">&lt;-</span> TIO.getLine</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">  <span class="kw">let</span> bs <span class="fu">=</span> encodeUtf8 text</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">  putStrLn <span class="fu">$</span> <span class="st">&quot;You entered: &quot;</span> <span class="fu">++</span> show bs</a>
<a class="sourceLine" id="cb5-16" data-line-number="16">  <span class="kw">let</span> digest <span class="fu">=</span> hashWith <span class="dt">SHA256</span> bs</a>
<a class="sourceLine" id="cb5-17" data-line-number="17">  putStrLn <span class="fu">$</span> <span class="st">&quot;SHA256 hash: &quot;</span> <span class="fu">++</span> show digest</a></code></pre></div>
<p><code>Digest</code> の <code>Show</code> インスタンスは、ダイジェストを16進数 (Base16) で表示します。これはいいですね。 しかし、これをBase64 で表示したい欲求にかられたらどうでしょう? 考えてみましょう。 <code>Digest</code> は <code>ByteArrayAccess</code> のインスタンスです。なので、<code>convertToBase</code> を使うことができます (そして、<code>Digest</code> は <code>ByteArray</code>のインスタンスではありません。そうしてしまったら問題が生じるのですが、それはなぜでしょうか? 行き詰まったら、<a href="https://www.stackage.org/haddock/lts-9.3/cryptonite-0.23/Crypto-Hash.html#v:digestFromByteString">この関数のドキュメント</a>を読んでみましょう。答えが載っています。)。</p>
<p><strong>練習問題</strong> ダイジェストを Base64 でエンコードされた文字列として出力してみましょう (答えはすぐ下)。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Crypto.Hash</span>             (hashWith, <span class="dt">SHA256</span> (..))</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="kw">import</span>           <span class="dt">Data.ByteString</span>         (<span class="dt">ByteString</span>)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Data.ByteArray.Encoding</span> (convertToBase, <span class="dt">Base</span> (<span class="dt">Base64</span>))</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Data.Text.Encoding</span>      (encodeUtf8)</a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.IO</span>            <span class="kw">as</span> <span class="dt">TIO</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">System.IO</span>               (hFlush, stdout)</a>
<a class="sourceLine" id="cb6-9" data-line-number="9"></a>
<a class="sourceLine" id="cb6-10" data-line-number="10"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">  putStr <span class="st">&quot;Enter some text: &quot;</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  hFlush stdout</a>
<a class="sourceLine" id="cb6-14" data-line-number="14">  text <span class="ot">&lt;-</span> TIO.getLine</a>
<a class="sourceLine" id="cb6-15" data-line-number="15">  <span class="kw">let</span> bs <span class="fu">=</span> encodeUtf8 text</a>
<a class="sourceLine" id="cb6-16" data-line-number="16">  putStrLn <span class="fu">$</span> <span class="st">&quot;You entered: &quot;</span> <span class="fu">++</span> show bs</a>
<a class="sourceLine" id="cb6-17" data-line-number="17">  <span class="kw">let</span> digest <span class="fu">=</span> convertToBase <span class="dt">Base64</span> (hashWith <span class="dt">SHA256</span> bs)</a>
<a class="sourceLine" id="cb6-18" data-line-number="18">  putStrLn <span class="fu">$</span> <span class="st">&quot;SHA256 hash: &quot;</span> <span class="fu">++</span> show (<span class="ot">digest ::</span> <span class="dt">ByteString</span>)</a></code></pre></div>
<p><code>digest</code> が <code>ByteString</code> であることを明確にするために、型シグネチャが必要な理由を押さえてください。</p>
<h2 id="マッチするファイルがあるかどうか調べる">マッチするファイルがあるかどうか調べる</h2>
<p>ここにちょっとしたプログラムがあります。ユーザはコマンドライン引数として、複数個のファイル名を渡します。そして、プログラムは同一の内容の全てのファイルのリストを表示します (少なくとも、SHA256 のハッシュ値がマッチするファイルを。それと、以下の定義には、メモリの効率がよろしくない部分があります。見つけてみてください。この点についてはまた後述します)。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Crypto.Hash</span>             (<span class="dt">Digest</span>, <span class="dt">SHA256</span>, hash)</a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString</span>         <span class="kw">as</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Data.Foldable</span>           (forM_)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Data.Map.Strict</span>         (<span class="dt">Map</span>)</a>
<a class="sourceLine" id="cb7-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span>         <span class="kw">as</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">System.Environment</span>      (getArgs)</a>
<a class="sourceLine" id="cb7-9" data-line-number="9"></a>
<a class="sourceLine" id="cb7-10" data-line-number="10"><span class="ot">readFile&#39; ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Map</span> (<span class="dt">Digest</span> <span class="dt">SHA256</span>) [FilePath])</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">readFile&#39; fp <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-12" data-line-number="12">  bs <span class="ot">&lt;-</span> B.readFile fp</a>
<a class="sourceLine" id="cb7-13" data-line-number="13">  <span class="kw">let</span> digest <span class="fu">=</span> hash bs <span class="co">-- notice lack of type signature :)</span></a>
<a class="sourceLine" id="cb7-14" data-line-number="14">  return <span class="fu">$</span> Map.singleton digest [fp]</a>
<a class="sourceLine" id="cb7-15" data-line-number="15"></a>
<a class="sourceLine" id="cb7-16" data-line-number="16"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-17" data-line-number="17">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-18" data-line-number="18">  args <span class="ot">&lt;-</span> getArgs</a>
<a class="sourceLine" id="cb7-19" data-line-number="19">  m <span class="ot">&lt;-</span> Map.unionsWith (<span class="fu">++</span>) <span class="fu">&lt;$&gt;</span> mapM readFile&#39; args</a>
<a class="sourceLine" id="cb7-20" data-line-number="20">  forM_ (Map.toList m) <span class="fu">$</span> \(digest, files) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-21" data-line-number="21">    <span class="kw">case</span> files <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-22" data-line-number="22">      [] <span class="ot">-&gt;</span> error <span class="st">&quot;can never happen&quot;</span></a>
<a class="sourceLine" id="cb7-23" data-line-number="23">      [_] <span class="ot">-&gt;</span> return () <span class="co">-- only one file</span></a>
<a class="sourceLine" id="cb7-24" data-line-number="24">      <span class="co">--                                     unwords :: [String] -&gt; String</span></a>
<a class="sourceLine" id="cb7-25" data-line-number="25">      _ <span class="ot">-&gt;</span> putStrLn <span class="fu">$</span> show digest <span class="fu">++</span> <span class="st">&quot;: &quot;</span> <span class="fu">++</span> unwords (map show files)</a></code></pre></div>
<p><strong>練習問題</strong> コマンドライン引数として与えられた全てのファイルの SHA256 ハッシュ値を表示するプログラムを書いてください。</p>
<p><strong>質問</strong> 上のコードの、どこが非効率的なのでしょうか? 答えは次の章にあります。</p>
<h2 id="より効率的なファイルハッシュ">より効率的なファイルハッシュ</h2>
<p>もしもハッシュ関数を使わなければ、さっきのプログラムの実装は、それぞれのファイルの中身をメモリ上に一度に展開するか、O(n^2) のペアの比較をするような変なものになっていたでしょう。 さっきのハッシュを使った実装は、それよりも良い実装です。しかし、まだ問題があります。 <code>Data.ByteString.readFile</code>を使っているので、際限なくメモリを使ってしまう可能性があります。 <code>cryptonite-conduit</code> を使うと、ファイルの内容全てをもっと効率良くハッシュできます。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Crypto.Hash</span>         (<span class="dt">Digest</span>, <span class="dt">SHA256</span>, hash)</a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="kw">import</span>           <span class="dt">Crypto.Hash.Conduit</span> (hashFile)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Data.Foldable</span>       (forM_)</a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Data.Map.Strict</span>     (<span class="dt">Map</span>)</a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span>     <span class="kw">as</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">System.Environment</span>  (getArgs)</a>
<a class="sourceLine" id="cb8-9" data-line-number="9"></a>
<a class="sourceLine" id="cb8-10" data-line-number="10"><span class="ot">readFile&#39; ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Map</span> (<span class="dt">Digest</span> <span class="dt">SHA256</span>) [FilePath])</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">readFile&#39; fp <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">  digest <span class="ot">&lt;-</span> hashFile fp</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">  return <span class="fu">$</span> Map.singleton digest [fp]</a>
<a class="sourceLine" id="cb8-14" data-line-number="14"></a>
<a class="sourceLine" id="cb8-15" data-line-number="15"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-17" data-line-number="17">  args <span class="ot">&lt;-</span> getArgs</a>
<a class="sourceLine" id="cb8-18" data-line-number="18">  m <span class="ot">&lt;-</span> Map.unionsWith (<span class="fu">++</span>) <span class="fu">&lt;$&gt;</span> mapM readFile&#39; args</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">  forM_ (Map.toList m) <span class="fu">$</span> \(digest, files) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-20" data-line-number="20">    <span class="kw">case</span> files <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-21" data-line-number="21">      [] <span class="ot">-&gt;</span> error <span class="st">&quot;can never happen&quot;</span></a>
<a class="sourceLine" id="cb8-22" data-line-number="22">      [_] <span class="ot">-&gt;</span> return () <span class="co">-- only one file</span></a>
<a class="sourceLine" id="cb8-23" data-line-number="23">      _ <span class="ot">-&gt;</span> putStrLn <span class="fu">$</span> show digest <span class="fu">++</span> <span class="st">&quot;: &quot;</span> <span class="fu">++</span> unwords (map show files)</a></code></pre></div>
<p>かなりシンプルな変更です (というか、こっちの方が少し読みやすいのではないでしょうか)。 さらに、かなりメモリ効率の良いコードになりました(ファイル数に対して線形時間、ファイルサイズに対しては定数時間です)。</p>
<h2 id="ストリームハッシュ">ストリーム・ハッシュ</h2>
<p><code>conduit</code> と聞いて、耳か目が即座に反応したかもしれません。 質問された体で答えましょう。 はい、ハッシュに関してもストリーミング処理ができます。ここに、URL とファイルパスを受け取って、その URL の response body の中身をファイルパスに書きこみ、SHA256 でダイジェストを表示するプログラムがあります。 そして、それぞれのデータチャンクを 1回しか参照しないのがいいですね。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Crypto.Hash</span>         (<span class="dt">Digest</span>, <span class="dt">SHA256</span>, hash)</a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="kw">import</span> <span class="dt">Crypto.Hash.Conduit</span> (sinkHash)</a>
<a class="sourceLine" id="cb9-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Network.HTTP.Simple</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="kw">import</span> <span class="dt">System.Environment</span>  (getArgs)</a>
<a class="sourceLine" id="cb9-8" data-line-number="8"></a>
<a class="sourceLine" id="cb9-9" data-line-number="9"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-11" data-line-number="11">  args <span class="ot">&lt;-</span> getArgs</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">  (url, fp) <span class="ot">&lt;-</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13">    <span class="kw">case</span> args <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-14" data-line-number="14">      [x, y] <span class="ot">-&gt;</span> return (x, y)</a>
<a class="sourceLine" id="cb9-15" data-line-number="15">      _ <span class="ot">-&gt;</span> error <span class="fu">$</span> <span class="st">&quot;Expected: URL FILEPATH&quot;</span></a>
<a class="sourceLine" id="cb9-16" data-line-number="16">  req <span class="ot">&lt;-</span> parseRequest url</a>
<a class="sourceLine" id="cb9-17" data-line-number="17">  digest <span class="ot">&lt;-</span> runResourceT <span class="fu">$</span> httpSink req <span class="fu">$</span> \_res <span class="ot">-&gt;</span> getZipSink <span class="fu">$</span></a>
<a class="sourceLine" id="cb9-18" data-line-number="18">    <span class="dt">ZipSink</span> (sinkFile fp) <span class="fu">*&gt;</span></a>
<a class="sourceLine" id="cb9-19" data-line-number="19">    <span class="dt">ZipSink</span> sinkHash</a>
<a class="sourceLine" id="cb9-20" data-line-number="20">  print (<span class="ot">digest ::</span> <span class="dt">Digest</span> <span class="dt">SHA256</span>)</a></code></pre></div>
<p><code>conduit</code> にできるなら、もちろんあなたにもできるはずです。 <code>conduit</code> を使わずに、<code>hashFile</code> を実装してみましょう。 こうすることで、ハッシュの API の内部がいくらか分かります。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Crypto.Hash</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="kw">import</span> <span class="dt">System.Environment</span>  (getArgs)</a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="kw">import</span> <span class="dt">System.IO</span> (withBinaryFile, <span class="dt">IOMode</span> (<span class="dt">ReadMode</span>))</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Data.Foldable</span> (forM_)</a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString</span> <span class="kw">as</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8"></a>
<a class="sourceLine" id="cb10-9" data-line-number="9"><span class="ot">hashFile ::</span> <span class="dt">HashAlgorithm</span> ha <span class="ot">=&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Digest</span> ha)</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">hashFile fp <span class="fu">=</span> withBinaryFile fp <span class="dt">ReadMode</span> <span class="fu">$</span> \h <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb10-11" data-line-number="11">  <span class="kw">let</span> loop context <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-12" data-line-number="12">        chunk <span class="ot">&lt;-</span> B.hGetSome h <span class="dv">4096</span></a>
<a class="sourceLine" id="cb10-13" data-line-number="13">        <span class="kw">if</span> B.null chunk</a>
<a class="sourceLine" id="cb10-14" data-line-number="14">          <span class="kw">then</span> return <span class="fu">$</span> hashFinalize context</a>
<a class="sourceLine" id="cb10-15" data-line-number="15">          <span class="kw">else</span> loop <span class="fu">$!</span> hashUpdate context chunk</a>
<a class="sourceLine" id="cb10-16" data-line-number="16">   <span class="kw">in</span> loop hashInit</a>
<a class="sourceLine" id="cb10-17" data-line-number="17"></a>
<a class="sourceLine" id="cb10-18" data-line-number="18"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb10-19" data-line-number="19">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-20" data-line-number="20">  args <span class="ot">&lt;-</span> getArgs</a>
<a class="sourceLine" id="cb10-21" data-line-number="21">  forM_ args <span class="fu">$</span> \fp <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-22" data-line-number="22">    digest <span class="ot">&lt;-</span> hashFile fp</a>
<a class="sourceLine" id="cb10-23" data-line-number="23">    putStrLn <span class="fu">$</span> show (<span class="ot">digest ::</span> <span class="dt">Digest</span> <span class="dt">SHA256</span>) <span class="fu">++</span> <span class="st">&quot;  &quot;</span> <span class="fu">++</span> fp</a></code></pre></div>
<p>この実装では <code>Crypto.Hash</code> で提供されている純粋なハッシュ更新用関数を使っています。 今回の場合、いくつかバッファのコピーをスキップすることで、もう少し効率の良い実装を可能にする、可変ハッシュの関数を使うことができます。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Crypto.Hash</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Crypto.Hash.IO</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5"><span class="kw">import</span> <span class="dt">System.Environment</span>  (getArgs)</a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="kw">import</span> <span class="dt">System.IO</span> (withBinaryFile, <span class="dt">IOMode</span> (<span class="dt">ReadMode</span>))</a>
<a class="sourceLine" id="cb11-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Data.Foldable</span> (forM_)</a>
<a class="sourceLine" id="cb11-8" data-line-number="8"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString</span> <span class="kw">as</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9"></a>
<a class="sourceLine" id="cb11-10" data-line-number="10"><span class="ot">hashFile ::</span> <span class="dt">HashAlgorithm</span> ha <span class="ot">=&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Digest</span> ha)</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">hashFile fp <span class="fu">=</span> withBinaryFile fp <span class="dt">ReadMode</span> <span class="fu">$</span> \h <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-12" data-line-number="12">  context <span class="ot">&lt;-</span> hashMutableInit</a>
<a class="sourceLine" id="cb11-13" data-line-number="13">  <span class="kw">let</span> loop <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-14" data-line-number="14">        chunk <span class="ot">&lt;-</span> B.hGetSome h <span class="dv">4096</span></a>
<a class="sourceLine" id="cb11-15" data-line-number="15">        <span class="kw">if</span> B.null chunk</a>
<a class="sourceLine" id="cb11-16" data-line-number="16">          <span class="kw">then</span> hashMutableFinalize context</a>
<a class="sourceLine" id="cb11-17" data-line-number="17">          <span class="kw">else</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-18" data-line-number="18">            hashMutableUpdate context chunk</a>
<a class="sourceLine" id="cb11-19" data-line-number="19">            loop</a>
<a class="sourceLine" id="cb11-20" data-line-number="20">  loop</a>
<a class="sourceLine" id="cb11-21" data-line-number="21"></a>
<a class="sourceLine" id="cb11-22" data-line-number="22"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb11-23" data-line-number="23">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-24" data-line-number="24">  args <span class="ot">&lt;-</span> getArgs</a>
<a class="sourceLine" id="cb11-25" data-line-number="25">  forM_ args <span class="fu">$</span> \fp <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-26" data-line-number="26">    digest <span class="ot">&lt;-</span> hashFile fp</a>
<a class="sourceLine" id="cb11-27" data-line-number="27">    putStrLn <span class="fu">$</span> show (<span class="ot">digest ::</span> <span class="dt">Digest</span> <span class="dt">SHA256</span>) <span class="fu">++</span> <span class="st">&quot;  &quot;</span> <span class="fu">++</span> fp</a></code></pre></div>
<p><strong>練習問題</strong> 遅延入出力と <code>hashlazy</code>関数を使って、<code>hashFile</code> を実装してください (遅延入出力を支持しているわけじゃないですよ。)。</p>]]></summary>
</entry>

</feed>
