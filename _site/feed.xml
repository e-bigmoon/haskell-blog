<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>BIG MOON</title>
    <link href="https://haskell.e-bigmoon.com/feed.xml" rel="self" />
    <link href="https://haskell.e-bigmoon.com" />
    <id>https://haskell.e-bigmoon.com/feed.xml</id>
    <author>
        <name>BIG MOON</name>
        <email>it@e-bigmoon.com</email>
    </author>
    <updated>2018-10-22T00:00:00Z</updated>
    <entry>
    <title>Stack 1.9.1 がリリースされました。</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/10-22-stack-191.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/10-22-stack-191.html</id>
    <published>2018-10-22T00:00:00Z</published>
    <updated>2018-10-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>10月18日に Stack version 1.9.1 が<a href="https://github.com/commercialhaskell/stack/blob/v1.9.1/ChangeLog.md#v191">リリース</a>されました。</p>
<p>更新は <code>stack upgrade</code> コマンドを実行します。</p>
<pre class="shell"><code>$ stack upgrade
Current Stack version: 1.7.1, available download version: 1.9.1
Newer version detected, downloading
Querying for archive location for platform: linux-x86_64-static
Downloading from: https://github.com/commercialhaskell/stack/releases/download/v1.9.1/stack-1.9.1-linux-x86_64-static.tar.gz
Download complete, testing executable
Version 1.9.1, Git revision f9d0042c141660e1d38f797e1d426be4a99b2a3c (6168 commits) x86_64 hpack-0.31.0
New stack executable available at /home/guchi/.local/bin/stack
Also copying stack executable to /usr/local/bin/stack
Permission error when trying to copy: /usr/local/bin: copyFile:atomicCopyFileContents:withReplacementFile:openBinaryTempFile: permission denied (Permission denied)
Should I try to perform the file copy using sudo? This may fail
Try using sudo? (y/n)</code></pre>
<p>実行ファイルは <code>~/.local/bin/stack</code> と <code>/usr/local/bin</code> にインストールされます。</p>
<p>ただし、権限が無いと上記のように <code>/usr/local/bin</code> へのコピーに失敗するため <code>sudo</code> で再実行するか聞かれます。必要であれば <code>y</code> でインストールしましょう。</p>
<pre class="shell"><code>Try using sudo? (y/n) y
Going to run the following commands:

-  sudo cp /home/guchi/.local/bin/stack /usr/local/bin/stack.tmp
-  sudo mv /usr/local/bin/stack.tmp /usr/local/bin/stack

sudo file copy worked!</code></pre>
<p>インストールされるバージョンは以下の通りです。</p>
<pre class="shell"><code>$ stack --version
Version 1.9.1, Git revision f9d0042c141660e1d38f797e1d426be4a99b2a3c (6168 commits) x86_64 hpack-0.31.0</code></pre>
<p>気になる更新内容まとめ</p>
<ul>
<li>static binary の復活</li>
<li>Cabal 2.4 への対応</li>
<li>internal-library 関連のバグ修正</li>
<li>namespaced template</li>
<li>stack run</li>
<li>ghci に -fobject-code を渡した際にちゃんとキャッシュされるようになった</li>
</ul>
<!--more-->
<h2 id="changelog-翻訳">Changelog (翻訳)</h2>
<h3 id="リリースノート">リリースノート</h3>
<ul>
<li><a href="https://github.com/nh2">@nh2</a>さんのおかげで、静的にリンクされた Linux バイナリが再び利用できるようになりました。</li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/blob/c34f11190302b2db9bab44ac6e45ca2c5f7810ce/doc/maintainers/releases.md#build-linux-static-binary-distribution-with-nix">Build Linux static binary distribution with Nix</a></li>
<li><a href="https://github.com/nh2/static-haskell-nix/tree/upstream-nixpkgs-musl-1.1.19/static-stack">Fully statically linked stack</a></li>
</ul>
<hr />
<ul>
<li><code>download.fpcomplete.com</code> から Ubuntu, Debian, CentOS, Fedora, Arch のパッケージリポジトリを削除する予定です。これらは既に1年以上前から非推奨となっており、新しいリリースにも対応していませんでしたが、過去のスクリプトとの互換性のために残していました。</li>
</ul>
<hr />
<h3 id="大きな変更点">大きな変更点</h3>
<ul>
<li>Cabal 2.4 にアップグレードしました。
<ul>
<li>注意点: ファイル名のパターンマッチの動作が変わりました。Cabal spec 2.4 より前のバージョンでは <code>*.txt</code> は <code>foo.txt</code> にマッチしていましたが、<code>foo.2.txt</code> にはマッチしませんでした。</li>
</ul></li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4317">Use Cabal 2.4 for the 1.9 branch #4317</a></li>
<li><a href="https://github.com/haskell/cabal/blob/master/Cabal/ChangeLog.md#2400-mikhail-glushenkov-september-2018">ChangeLog (Cabal 2.4)</a></li>
<li><a href="https://github.com/haskell/cabal/pull/5372">Multi-dot globbing #5372</a></li>
<li><a href="https://github.com/haskell/cabal/issues/784">Wildcards in data-files don’t work with filenames containing multiple dots #784</a></li>
<li><a href="https://github.com/haskell/cabal/issues/5057"><code>cabal sdist</code> does not pick up files with multiple dots #5057</a></li>
</ul>
<hr />
<ul>
<li><code>GHCJS</code> のサポートが <code>experimental (実験的)</code> へ降格しました。また、<code>GHCJS</code> が実験段階であることをユーザに知らせるための警告が表示されるようになりました。</li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/issues/4086">DISCUSSION: Mark GHCJS support as deprecated? #4086</a></li>
<li><a href="https://github.com/commercialhaskell/stack/pull/4154">Warning about GHCJS use when constructing a build plan #4154</a></li>
<li><a href="https://github.com/commercialhaskell/stack/commit/729a052cede11855644bf00c4b7661a89148bdc7#diff-e705c8fadf1193ab59443a5e6c8cbe8b">commit@729a052cede11855644bf00c4b7661a89148bdc7</a></li>
</ul>
<hr />
<h3 id="変更点">変更点</h3>
<ul>
<li><code>stack.yaml</code> の <code>ghc-options</code> と <code>config.yaml</code> の <code>ghc-options</code> を結合するようにしました。今までは置き換えていました。</li>
</ul>
<h4 id="解説">解説</h4>
<p>グローバルな <code>~/.stack/.config.yaml</code> とプロジェクト固有の <code>stack.yaml</code> の話で <code>package.yaml</code> は関係しません。</p>
<p>例として、それぞれファイルの内容を以下のように設定しておきます。(<code>$everything</code> は全てのパッケージを指定)</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb4-1" title="1"><span class="co"># ~/.stack/config.yaml</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="fu">ghc-options:</span></a>
<a class="sourceLine" id="cb4-3" title="3">  <span class="fu">&quot;$everything&quot;:</span><span class="at"> </span><span class="st">&quot;aaa&quot;</span></a></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb5-1" title="1"><span class="co"># stack.yaml</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="fu">resolver:</span><span class="at"> lts-12.13</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="fu">packages:</span></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="kw">-</span> .</a>
<a class="sourceLine" id="cb5-5" title="5"><span class="fu">ghc-options:</span></a>
<a class="sourceLine" id="cb5-6" title="6">  <span class="fu">&quot;$everything&quot;:</span><span class="at"> </span><span class="st">&quot;bbb&quot;</span></a></code></pre></div>
<p>パッケージの指定が重複していたときに今までは、<code>stack.yaml</code> (プロジェクト固有) の <code>ghc-options</code> で上書きされていましたが、 <code>stack.yaml</code> の <code>ghc-options</code> を結合するようになりました。以下は動作例です。</p>
<pre class="shell"><code># stack v1.9.1 の動作
$ stack build
... --ghc-options aaa --ghc-options bbb

# stack v1.7.1 の動作
$ stack build
... --ghc-options bbb</code></pre>
<p><code>ghc-options</code> の内容が重複する場合は両方とも引数に与えられますが、後ろの値で上書きされるようなのでプロジェクト固有の設定が優先されます。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb7-1" title="1"><span class="co"># ~/.stack/config.yaml</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="fu">ghc-options:</span></a>
<a class="sourceLine" id="cb7-3" title="3">  <span class="fu">&quot;$everything&quot;:</span><span class="at"> </span><span class="st">&quot;-dumpdir=./respect-config&quot;</span></a></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb8-1" title="1"><span class="co"># stack.yaml</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="fu">resolver:</span><span class="at"> lts-12.13</span></a>
<a class="sourceLine" id="cb8-3" title="3"><span class="fu">packages:</span></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="kw">-</span> .</a>
<a class="sourceLine" id="cb8-5" title="5"><span class="fu">ghc-options:</span></a>
<a class="sourceLine" id="cb8-6" title="6">  <span class="fu">&quot;$everything&quot;:</span><span class="at"> </span><span class="st">&quot;-dumpdir=./respect-stack&quot;</span></a></code></pre></div>
<p>実際に試してみると、以下のようになると思います。</p>
<pre class="sell"><code>$ stack build -v
... --ghc-options -dumpdir=./respect-config --ghc-options -dumpdir=./respect-stack

$ ls  -l
...
drwxrwxr-x 5 guchi guchi 4096 10月 21 13:35 respect-stack
...</code></pre>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/issues/3753">Stack does not respect ghc-options in user config #3753</a></li>
<li><a href="https://github.com/commercialhaskell/stack/pull/3781">Fix inheritance of category ghc-options from config.yaml #3753 #3781</a></li>
<li><a href="https://github.com/commercialhaskell/stack/pull/4089">Have project ghc-options append to config.yaml ghc-options #3753</a></li>
</ul>
<hr />
<ul>
<li><code>stack build</code> コマンドはパッケージのサブライブラリをビルドする際に executables, test, benchmarks, libraries などと同様の方法でアナウンスを行うようになりました。</li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4111">Consistent handling of internal libraries #4111</a></li>
<li><a href="https://github.com/commercialhaskell/stack/pull/4111/commits/4a4b63f59130bb66477d155dcb401d50fac02fab">commit@4a4b63f59130bb66477d155dcb401d50fac02fab</a></li>
</ul>
<hr />
<ul>
<li><code>stack sdist</code> コマンドはサニティチェックの結果にかかわらず、生成された tarball の場所をアナウンスするようになりました。</li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4117">Mention tarball earlier in sdist #4117</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/4112">stack sdist fails when modules are exposed based on a flag in the cabal file #4112</a></li>
</ul>
<hr />
<ul>
<li><code>stack setup</code> コマンドの <code>--upgrade-cabal</code> オプションは廃止されます。この機能は GHC 8.2 以降では動作しません。また、このフラグが実装された当初の動機は Stack がカスタムセットアップのためにスナップショットの <code>Cabal</code> ライブラリを利用し始めたことでほとんど無くなりました。詳細: <a href="https://github.com/commercialhaskell/stack/issues/4070">#4070</a></li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4118">Deprecate the –upgrade-cabal flag (fixes #4070) #4118</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/4070"><code>stack setup --upgrade-cabal</code> doesn’t work for Cabal-2.2.0.1 + ghc-8.2.2 #4070</a></li>
</ul>
<hr />
<ul>
<li>新たに namespaced template 機能が実装されたため、<code>stack templates</code> コマンドは利用可能な全てのテンプレートの一覧を良い感じに表示できなくなりました。代わりに、テンプレートを見つける方法についての<a href="https://github.com/commercialhaskell/stack-templates/blob/master/STACK_HELP.md">ヘルプファイル</a>をダウンロードし、表示します。詳細: <a href="https://github.com/commercialhaskell/stack/issues/4039">#4039</a></li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4129">Get stack templates help from Github file #4039 #4129</a></li>
<li><a href="https://github.com/commercialhaskell/stack-templates/blob/master/STACK_HELP.md">help file</a></li>
</ul>
<hr />
<ul>
<li>ビルドツールを <code>cabal-install</code> と同様の方法で取り扱うようになりました。また、レガシーな <code>build-tools</code> フィールドに対しては、ツールマップの中からビルドツールパッケージを調べるのではなく、ハードコードされたビルドツールのリストを利用します。この変更により Stack の動作は <code>cabal-install</code> に近づいたため、いくつかのバグを回避し、最適化/遅延性の恩恵を得られる可能性があります。詳細: <a href="https://github.com/commercialhaskell/stack/issues/4125">#4125</a></li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/issues/4125">stack 1.7.1 still has problems finding build tools (“The program ‘happy’ is required”) #4125</a></li>
<li><a href="https://github.com/commercialhaskell/stack/pull/4132">Use a hard-coded tool dependency map (fixes #4125) #4132</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/595">Build-tools not detected when not using Stackage snapshot #595</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/3178">Stack cannot find happy during build #3178</a></li>
<li><a href="https://github.com/commercialhaskell/stack/pull/3249">Extensible snapshots #3249</a></li>
</ul>
<hr />
<ul>
<li>パフォーマンスの低下を避けるため、Mustache テンプレートに (50kb を超える) 大きなファイルを適用できなくなりました。詳細: <a href="https://github.com/commercialhaskell/stack/issues/4133">#4133</a></li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4134">Do not apply Mustache to large files (fixes #4133) #4134</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/4133">stack new is very slow at compiling Mustache templates #4133</a></li>
</ul>
<hr />
<ul>
<li><code>stack upload</code> はデフォルトでパッケージに署名を行うようになりました。また、<code>--no-signature</code> オプションで署名をスキップできます。詳細: <a href="https://github.com/commercialhaskell/stack/issues/3739">#3739</a></li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/issues/3739">stack upload –no-signature still shows “Unable to find gpg2 or gpg executable” #3739</a></li>
<li><a href="https://github.com/commercialhaskell/stack/pull/4167">Fix behavior of –no-signature to turn signing off #4167</a></li>
</ul>
<hr />
<ul>
<li>テンプレートダウンロード時のネットワーク接続問題に備えて、事前にチェックを行うようになりました。もし、問題があればキャッシュ済みのテンプレートを利用します。詳細: <a href="https://github.com/commercialhaskell/stack/issues/3850">stack new requires network to work #3850</a></li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/issues/3850">stack new requires network to work #3850</a></li>
<li><a href="https://github.com/commercialhaskell/stack/pull/4173">Use cached template if template download fails #4173</a></li>
</ul>
<hr />
<h3 id="その他の改良点">その他の改良点</h3>
<ul>
<li>Windows 10 より前の Windows 環境では、ターミナルのデフォルト値が <code>--color=never</code> となります。エミュレーションによる出力のみ ANSI カラーコードが利用できます。</li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4106">Re #4091: Pre-Windows 10, default –color=never #4106</a></li>
</ul>
<hr />
<ul>
<li>Windows 環境では、デフォルトのターミナルを ‘mintty’ (false) として認識するように変更しました。</li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4015">Windows: use ‘hIsTerminalDevice or isMinTTYHandle’ #4015</a></li>
</ul>
<hr />
<ul>
<li><code>stack build</code> コマンドは <code>stack.yaml</code> の <code>extra-deps</code> に <code>base</code> が明示的に記載されているとき、警告を出すようになりました。</li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/3993">Help users not to go down the road of base upgrade/downgrade, addresses #3940 #3993</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/3940">Warn when upgrading base #3940</a></li>
</ul>
<hr />
<ul>
<li><code>stack build</code> コマンドは、ビルドプランで達成不可能な <code>base</code> バージョンが要求された際に、別の GHC バージョンを試すように提案するようになりました。</li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/3993">Help users not to go down the road of base upgrade/downgrade, addresses #3940 #3993</a></li>
</ul>
<hr />
<ul>
<li>新たなサブコマンド <code>run</code> が導入されました。このコマンドは <code>cabal run</code> のように、指定された executable をビルド&amp;実行します。executable が省略された場合は、プロジェクト内で最初に利用可能な executable が指定されます。</li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/3952">Introduce <code>stack run</code> command line option #3952</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/233">Wishlist: <code>stack run</code> #233</a></li>
<li><a href="https://haskell.e-bigmoon.com/posts/2018/06-25-stack-run.html">stack run コマンド – BIGMOON Blog</a></li>
</ul>
<hr />
<ul>
<li><code>stack build</code> コマンドは、依存関係が足りない旨を伝えるメッセージにパッケージの最新の cabal ファイルリビジョンハッシュを含めるようになりました。詳細: <a href="https://github.com/commercialhaskell/stack/pull/4068">#4068</a></li>
</ul>
<h4 id="解説-1">解説</h4>
<p>こんな感じで表示されるようです。</p>
<pre class="shell"><code>...
  * Recommended action: try adding the following to your extra-deps in /home/thomas/github/stack/stack.yaml:
rio-0.1.2.0@sha256:cb2a65cee1c0450815002ca890633215e4544b5c1c9f7091a950142c6efe8f3f</code></pre>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4068">Add cabal-hash revision info when displaying recommended packages when failing to construct buildplan #4068</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/3925">Modify “recommended packages” output to include revision info #3925</a></li>
</ul>
<hr />
<ul>
<li><code>stack sdist</code> コマンドに新しく <code>--tar-dir</code> オプションを追加しました。このオプションにより指定したディレクトリに生成された tarball をコピーできるようになります。</li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/3621">3568 add tar files option to sdist #3621</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/3568">Stack sdist option to place build artefacts elsewhere #3568</a></li>
<li><a href="https://github.com/commercialhaskell/stack/commit/9a58d5bf5346bedb0d460335c7018c256591966d">commit@9a58d5bf5346bedb0d460335c7018c256591966d</a></li>
</ul>
<hr />
<ul>
<li><code>--interleaved-output</code> オプションと <code>build.interleaved-output</code> 設定値が導入されました。これにより、複数の並行ビルドの出力が <code>packagename&gt;</code> プレフィックス付きで同時に標準エラー出力にダンプされます。詳細: <a href="https://github.com/commercialhaskell/stack/issues/3225">#3225</a></li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4097">Add the interleaved-output option/config value #3225 #4097</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/3225">Add flag to print GHC output to stdout #3225</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/3508">Report progress on STDOUT/STDERR during compilation of individual modules #3508</a></li>
</ul>
<hr />
<ul>
<li>デフォルトの再接続戦略を exponential backoff に変更しました。これにより <a href="https://github.com/commercialhaskell/stack/issues/3510">#3510</a> の問題が緩和されます。</li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4109">Changed the default retry strategy #4109</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/3510">Stack does not retry effectively when S3 is being flaky. #3510</a></li>
<li><a href="https://www.stackage.org/haddock/lts-12.14/retry-0.7.7.0/Control-Retry.html#v:exponentialBackoff">exponentialBackoff</a></li>
</ul>
<hr />
<ul>
<li><code>stack new</code> コマンドは <code>username/foo</code> という形式で、<code>commercialstack</code> 以外のリポジトリからテンプレートをダウンロードできるようになりました。また <code>github:</code> という形式でプレフィックスを付けることでサービスを指定することもできます。現状は <code>github:</code> の他に <code>gitlab:</code> と <code>bitbucket:</code> が利用可能です。</li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4103">4039 namespaced templates #4103</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/4039">Namespaced templates #4039</a></li>
<li><a href="https://haskell.e-bigmoon.com/posts/2018/06-27-namespaced-templates.html">namespaced templates - BIGMOON Blog</a></li>
</ul>
<hr />
<ul>
<li><code>gitrev</code> から <code>githash</code> に切り替えました。このパッケージには <code>gitrev</code> にマージされていないバグフィックスが含まれています。</li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4130">Switch to githash to include some unmerged bugfixes in gitrev #4130</a></li>
</ul>
<hr />
<ul>
<li><code>'allow-newer': true</code> を追加するファイルがわかりづらいため、ユーザ設定ファイルへのパスをエラーメッセージに含めるようにしました。詳細: <a href="https://github.com/commercialhaskell/stack/issues/3685">#3685</a></li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/issues/3685">allow-newer in global-project doesn’t work #3685</a></li>
<li><a href="https://github.com/commercialhaskell/stack/pull/4127">Point to user’s config.yaml when advising ‘allow-newer: true’ #4127</a></li>
</ul>
<hr />
<ul>
<li><code>stack ghci</code> コマンドはビルド後ではなく、ビルド前にどのメインターゲットを読み込むか質問するようになりました。</li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4138">‘stack ghci’ now asks which main module to load before building #4138</a></li>
</ul>
<hr />
<ul>
<li>hpack のバージョンを 0.29.0 に更新しました。</li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4151">Bump to hpack 0.29 #4151</a></li>
</ul>
<hr />
<ul>
<li>GHC 8.4 以降のバージョンを利用したとき、自動的に Haddock へ <code>--quickjump</code> オプションが渡されるようになります。</li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4163">Pass –quickjump to Haddock for GHC 8.4 and later #4163</a></li>
</ul>
<hr />
<ul>
<li><p><code>hackage-base-url</code> 設定オプションを利用することで、パッケージアップロード時の Hackage ベースURL に任意のURLを指定できるようになりました。(デフォルトは <code>https://hackage.haskell.org/</code> です)</p></li>
<li><a href="https://github.com/commercialhaskell/stack/pull/4167">Fix behavior of –no-signature to turn signing off #4167</a></li>
<li><p><a href="https://github.com/commercialhaskell/stack/issues/3739">stack upload –no-signature still shows “Unable to find gpg2 or gpg executable” #3739</a></p></li>
</ul>
<hr />
<ul>
<li>Nix 利用時に GHC のマイナーバージョンを省略した場合、メジャーブランチの最新のマイナーバージョンを自動的に利用するようになりました。</li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4189">Do not hardcode GHC versions for Nixpkgs #4189</a></li>
</ul>
<hr />
<h3 id="バグフィックス">バグフィックス</h3>
<ul>
<li><code>stack ghci</code> を繰り返し実行したときに <code>.o</code> ファイルを無効化しなくなりました。これにより、<code>-fobject-code</code> でコンパイルされた全てのモジュールは ghci を実行する度にキャッシュされます。 詳細: <a href="https://github.com/commercialhaskell/stack/pull/4038">#4038</a></li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4038">Set cabal_macros.h work directory in stack ghci to something non-temporary #4038</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/3344">stack ghci recompiles all modules on every startup, even when invoked with “-fobject-code” or “–no-build” #3344</a></li>
</ul>
<hr />
<ul>
<li><code>~/.stack/config.yaml</code> と <code>stack.yaml</code> の最後に改行が追加されました。</li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/3983">fixed: terminating is newline #3983</a></li>
</ul>
<hr />
<ul>
<li>前回のリリースで <code>ghc-pkg</code> コマンドの出力が <code>stderr</code> に出力されてしまう問題が再発したので修正しました。現在の出力はとても静かになりました。</li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4028">Make ghc-pkg calls less noisy #4028</a></li>
</ul>
<hr />
<ul>
<li><code>v1.7.1</code> で導入された再コンパイルチェックの問題を修正し、回帰テストを追加しました。詳細: <a href="https://github.com/commercialhaskell/stack/issues/4001">#4001</a></li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4003">4001 excess recompilation #4003</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/4001">–file-watch is watching test suites again #4001</a></li>
</ul>
<hr />
<ul>
<li><code>stack ghci</code> は internal library を含むパッケージの処理で internal libray に対応する間違ったパッケージを探し、モジュールの読み込みに失敗していました。この問題は現在修正済みで、ライブラリとサブライブラリが適切に追跡されるようにコードが変更されました。詳細: <a href="https://github.com/commercialhaskell/stack/issues/3926">#3926</a></li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/issues/3926"><code>stack ghci</code> does not recognise internal libraries #3926</a></li>
<li><a href="https://github.com/commercialhaskell/stack/pull/3982">Handle internal libraries in GHCi. #3982</a></li>
</ul>
<hr />
<ul>
<li>internal library に依存していないパッケージを <code>stack build</code> すると、internal library をビルドしていないのにも関わらず登録しようとするため、ビルドに失敗していました。この問題は internal library を常にビルドすることで解決しました。</li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4033">Handle internal libs not listed as dependencies #4033</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/3996">Build fails with internal libraries that aren’t dependencies #3996</a></li>
</ul>
<hr />
<ul>
<li>NixOS 環境では <code>--no-nix</code> オプションの影響を受けなくなりました。</li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4021">Allow Nix mode to be disabled under NixOS #4021</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/4002">stack does not honor –no-nix under NixOS #4002</a></li>
</ul>
<hr />
<ul>
<li>RAM を大量に消費してしまう問題が再発していたので修正しました。詳細: <a href="https://github.com/commercialhaskell/stack/issues/4027">#4027</a></li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/issues/4027">Regression in 1.7.1 (compared to 1.6.5) in getPackageFiles RAM usage #4027</a></li>
<li><a href="https://github.com/commercialhaskell/stack/pull/4066">Fix RAM usage upon big dump-hi files parsing #4066</a></li>
</ul>
<hr />
<ul>
<li>コマンドラインの引数の順序によって動作が異なる問題を修正しました。詳細: <a href="https://github.com/commercialhaskell/stack/issues/3959">#3959</a></li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/issues/3959">It should not matter if flags given before command or after #3959</a></li>
<li><a href="https://github.com/commercialhaskell/stack/pull/4067">Change parsers to use <code>flag'</code> instead of <code>switch</code> #4067</a></li>
</ul>
<hr />
<ul>
<li>パッケージをアップロードする際の Hackage クレデンシャル保存プロンプトで、ユーザの入力前に表示されなければならないメッセージが入力後に表示されてしまっていた問題を修正しました。ghci のターゲット選択プロンプトでも同様の問題が発生していたので修正しました。</li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4063">Flush after prompt #4063</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/4162">Stack Upload waits for confirmation BEFORE printing confirmation message #4162</a></li>
</ul>
<hr />
<ul>
<li><code>stack solver</code> コマンドで、PATH に <code>cabal</code> が存在しない場合、ユーザに対して <code>stack install cabal-install</code> の実行を促すためのメッセージが表示されるようになりました。</li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4100">Solver cabal install hint #4100</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/3841">stack solver complains there’s no cabal in path. #3841</a></li>
</ul>
<hr />
<ul>
<li><code>stack build</code> コマンドはサブライブラリを含むパッケージが executable, test, benchmark などの依存関係になっている場合でも、正しくビルドできるようになりました。詳細: <a href="https://github.com/commercialhaskell/stack/issues/3787">#3787</a>.</li>
</ul>
<h4 id="解説-2">解説</h4>
<p>Cabal 2.0 から <code>internal Libraries</code> が追加され、stack 側も対応したという感じです。</p>
<p>例として以下のような <code>package.yaml</code> があった場合</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb11-1" title="1"><span class="co"># package.yaml</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="fu">name:</span><span class="at"> test-internal</span></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="fu">dependencies:</span></a>
<a class="sourceLine" id="cb11-4" title="4">  <span class="kw">-</span> base</a>
<a class="sourceLine" id="cb11-5" title="5"><span class="fu">internal-libraries:</span></a>
<a class="sourceLine" id="cb11-6" title="6">  <span class="fu">internal-foo:</span><span class="at"> </span><span class="kw">{}</span></a></code></pre></div>
<p>自動生成される <code>cabal</code> ファイルは以下のようになります。</p>
<pre class="cabal"><code>name:           test-internal
version:        0.0.0
build-type:     Simple
cabal-version:  &gt;= 2.0

library internal-foo
  other-modules:
      Paths_test_internal
  build-depends:
      base
  default-language: Haskell2010</code></pre>
<p>この状態でビルドした結果は次のとおりです。</p>
<pre class="shell"><code># v1.7.1
$ stack build
Package has buildable sublibraries but no buildable libraries, I&#39;m giving up
CallStack (from HasCallStack):
  error, called at src/Stack/Package.hs:280:30 in stack-1.7.1-JqFYW3fz7If7um4NzPRwPj:Stack.Package

# v1.9.1
$ stack build
test-internal-0.0.0: configure (internal-lib)
Configuring test-internal-0.0.0...
test-internal-0.0.0: build (internal-lib)
Preprocessing library &#39;internal-foo&#39; for test-internal-0.0.0..
Building library &#39;internal-foo&#39; for test-internal-0.0.0..
[1 of 1] Compiling Paths_test_internal ( .stack-work/dist/x86_64-linux/Cabal-2.2.0.1/build/internal-foo/autogen/Paths_test_internal.hs, .stack-work/dist/x86_64-linux/Cabal-2.2.0.1/build/internal-foo/Paths_test_internal.o )
ignoring (possibly broken) abi-depends field for packages
test-internal-0.0.0: copy/register
Installing internal library internal-foo in /home/guchi/Desktop/stack-191-working/test-internal/.stack-work/install/x86_64-linux/lts-12.14/8.4.3/lib/x86_64-linux-ghc-8.4.3/test-internal-0.0.0-6jijyMwb8IH16YEILzaUQW-internal-foo</code></pre>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4111">Consistent handling of internal libraries #4111</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/3787">Internal libraries does not work if there’s no main library #3787</a></li>
<li><a href="https://www.haskell.org/cabal/users-guide/developing-packages.html#sublibs">Internal Libraries - Cabal document</a></li>
<li><a href="https://github.com/sol/hpack#library-fields">hpack Top-level fields</a></li>
</ul>
<hr />
<ul>
<li>internal library に依存したテストスイートのカバレッジレポートで、サブライブラリが適切に処理されるようになりました。以前まではカバレッジレポートを生成するときにエラーとなっていました。詳細: <a href="https://github.com/commercialhaskell/stack/issues/4105">#4105</a></li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4111">Consistent handling of internal libraries #4111</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/4105">Error running test coverage when tests depend on internal lbraries. #4105</a></li>
</ul>
<hr />
<ul>
<li>スナップショット更新時にサブライブラリがプリコンパイルキャシュに追加されるようになりました。以前まではスナップショットにサブライブラリを含むパッケージが存在するようなスナップショットを更新するとビルドが壊れていました。詳細: <a href="https://github.com/commercialhaskell/stack/issues/4071">#4071</a></li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4111">Consistent handling of internal libraries #4111</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/4071">haddock-library’s internal attoparsec library cannot be found - broken package #4071</a></li>
</ul>
<hr />
<ul>
<li>Stack は <code>warning</code> の代わりに適切な <code>error</code> ログレベルでエラーメッセージをプリティプリントするようになりました。これにより self-executing scripts で runhaskell のプラン構築エラーがターミナルに出力されない問題も修正されます。詳細: <a href="https://github.com/commercialhaskell/stack/pull/4114">#4114</a></li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4114">Fixes self-executing scripts not piping plan construction errors from runhaskell to terminal, issue #3942 #4114</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/3942">Self-executing scripts don’t pipe plan construction errors from runhaskell to terminal #3942</a></li>
</ul>
<hr />
<ul>
<li>Cabal の呼び出しに失敗した際に “While building Setup.hs” という間違ったメッセージが表示されていた問題を修正しました。詳細: <a href="https://github.com/commercialhaskell/stack/issues/3934">#3934</a></li>
</ul>
<p>参考リンク</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/4131">Fix invalid “While building Setup.hs” #3934 #4131</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/3934">Invalid “While building Setup.hs” error message #3934</a></li>
</ul>
<hr />
<h2 id="changelog-オリジナル">Changelog (オリジナル)</h2>
<h3 id="release-notes">Release notes</h3>
<ul>
<li>Statically linked Linux bindists are back again, thanks to <a href="https://github.com/nh2">@nh2</a>.</li>
<li>We will be deleting the Ubuntu, Debian, CentOS, Fedora, and Arch package repos from <code>download.fpcomplete.com</code> soon. These have been deprecated for over a year and have not received new releases, but were left in place for compatibility with older scripts.</li>
</ul>
<h3 id="major-changes">Major changes</h3>
<ul>
<li>Upgrade to Cabal 2.4
<ul>
<li>Note that, in this process, the behavior of file globbing has been modified to match that of Cabal. In particular, this means that for Cabal spec versions less than 2.4, <code>*.txt</code> will match <code>foo.txt</code>, but not <code>foo.2.txt</code>.</li>
</ul></li>
<li><code>GHCJS</code> support is being downgraded to ‘experimental’. A warning notifying the user of the experimental status of <code>GHCJS</code> will be displayed.</li>
</ul>
<h3 id="behavior-changes">Behavior changes:</h3>
<ul>
<li><code>ghc-options</code> from <code>stack.yaml</code> are now appended to <code>ghc-options</code> from <code>config.yaml</code>, whereas before they would be replaced.</li>
<li><code>stack build</code> will now announce when sublibraries of a package are being build, in the same way executables, tests, benchmarks and libraries are announced</li>
<li><code>stack sdist</code> will now announce the destination of the generated tarball, regardless of whether or not it passed the sanity checks</li>
<li>The <code>--upgrade-cabal</code> option to <code>stack setup</code> has been deprecated. This feature no longer works with GHC 8.2 and later. Furthermore, the reason for this flag originally being implemented was drastically lessened once Stack started using the snapshot’s <code>Cabal</code> library for custom setups. See: <a href="https://github.com/commercialhaskell/stack/issues/4070">#4070</a>.</li>
<li>With the new namespaced template feature, <code>stack templates</code> is no longer able to meaningfully display a list of all templates available. Instead, the command will download and display a <a href="https://github.com/commercialhaskell/stack-templates/blob/master/STACK_HELP.md">help file</a> with more information on how to discover templates. See: <a href="https://github.com/commercialhaskell/stack/issues/4039">#4039</a></li>
<li>Build tools are now handled in a similar way to <code>cabal-install</code>. In particular, for legacy <code>build-tools</code> fields, we use a hard-coded list of build tools in place of looking up build tool packages in a tool map. This both brings Stack’s behavior closer into line with <code>cabal-install</code>, avoids some bugs, and opens up some possible optimizations/laziness. See: <a href="https://github.com/commercialhaskell/stack/issues/4125">#4125</a>.</li>
<li>Mustache templating is not applied to large files (over 50kb) to avoid performance degredation. See: <a href="https://github.com/commercialhaskell/stack/issues/4133">#4133</a>.</li>
<li><code>stack upload</code> signs the package by default, as documented. <code>--no-signature</code> turns the signing off. <a href="https://github.com/commercialhaskell/stack/issues/3739">#3739</a></li>
<li>In case there is a network connectivity issue while trying to download a template, stack will check whether that template had been downloaded before. In that case, the cached version will be used. See <a href="https://github.com/commercialhaskell/stack/issues/3739">#3850</a>.</li>
</ul>
<h3 id="other-enhancements">Other enhancements</h3>
<ul>
<li>On Windows before Windows 10, –color=never is the default on terminals that can support ANSI color codes in output only by emulation</li>
<li>On Windows, recognise a ‘mintty’ (false) terminal as a terminal, by default</li>
<li><code>stack build</code> issues a warning when <code>base</code> is explicitly listed in <code>extra-deps</code> of <code>stack.yaml</code></li>
<li><code>stack build</code> suggests trying another GHC version should the build plan end up requiring unattainable <code>base</code> version.</li>
<li>A new sub command <code>run</code> has been introduced to build and run a specified executable similar to <code>cabal run</code>. If no executable is provided as the first argument, it defaults to the first available executable in the project.</li>
<li><code>stack build</code> missing dependency suggestions (on failure to construct a valid build plan because of missing deps) are now printed with their latest cabal file revision hash. See <a href="https://github.com/commercialhaskell/stack/pull/4068">#4068</a>.</li>
<li>Added new <code>--tar-dir</code> option to <code>stack sdist</code>, that allows to copy the resulting tarball to the specified directory.</li>
<li>Introduced the <code>--interleaved-output</code> command line option and <code>build.interleaved-output</code> config value which causes multiple concurrent builds to dump to stderr at the same time with a <code>packagename&gt;</code> prefix. See <a href="https://github.com/commercialhaskell/stack/issues/3225">#3225</a>.</li>
<li>The default retry strategy has changed to exponential backoff. This should help with <a href="https://github.com/commercialhaskell/stack/issues/3510">#3510</a>.</li>
<li><code>stack new</code> now allows template names of the form <code>username/foo</code> to download from a user other than <code>commercialstack</code> on Github, and can be prefixed with the service <code>github:</code>, <code>gitlab:</code>, or <code>bitbucket:</code>. <a href="https://github.com/commercialhaskell/stack/issues/4039">#4039</a></li>
<li>Switch to <code>githash</code> to include some unmerged bugfixes in <code>gitrev</code> Suggestion to add <code>'allow-newer': true</code> now shows path to user config file where this flag should be put into <a href="https://github.com/commercialhaskell/stack/issues/3685">#3685</a></li>
<li><code>stack ghci</code> now asks which main target to load before doing the build, rather than after</li>
<li>Bump to hpack 0.29.0</li>
<li>With GHC 8.4 and later, Haddock is given the <code>--quickjump</code> flag.</li>
<li>It is possible to specify the Hackage base URL to upload packages to, instead of the default of <code>https://hackage.haskell.org/</code>, by using <code>hackage-base-url</code> configuration option.</li>
<li>When using Nix, if a specific minor version of GHC is not requested, the latest minor version in the given major branch will be used automatically.</li>
</ul>
<h3 id="bug-fixes">Bug fixes</h3>
<ul>
<li><code>stack ghci</code> now does not invalidate <code>.o</code> files on repeated runs, meaning any modules compiled with <code>-fobject-code</code> will be cached between ghci runs. See <a href="https://github.com/commercialhaskell/stack/pull/4038">#4038</a>.</li>
<li><code>~/.stack/config.yaml</code> and <code>stack.yaml</code> terminating by newline</li>
<li>The previous released caused a regression where some <code>stderr</code> from the <code>ghc-pkg</code> command showed up in the terminal. This output is now silenced.</li>
<li>A regression in recompilation checking introduced in v1.7.1 has been fixed. See <a href="https://github.com/commercialhaskell/stack/issues/4001">#4001</a></li>
<li><code>stack ghci</code> on a package with internal libraries was erroneously looking for a wrong package corresponding to the internal library and failing to load any module. This has been fixed now and changes to the code in the library and the sublibrary are properly tracked. See <a href="https://github.com/commercialhaskell/stack/issues/3926">#3926</a>.</li>
<li>For packages with internal libraries not depended upon, <code>stack build</code> used to fail the build process since the internal library was not built but it was tried to be registered. This is now fixed by always building internal libraries. See <a href="https://github.com/commercialhaskell/stack/issues/3996">#3996</a>.</li>
<li><code>--no-nix</code> was not respected under NixOS</li>
<li>Fix a regression which might use a lot of RAM. See <a href="https://github.com/commercialhaskell/stack/issues/4027">#4027</a>.</li>
<li>Order of commandline arguments does not matter anymore. See <a href="https://github.com/commercialhaskell/stack/issues/3959">#3959</a></li>
<li>When prompting users about saving their Hackage credentials on upload, flush to stdout before waiting for the response so the prompt actually displays. Also fixes a similar issue with ghci target selection prompt.</li>
<li>If <code>cabal</code> is not on PATH, running <code>stack solver</code> now prompts the user to run <code>stack install cabal-install</code></li>
<li><code>stack build</code> now succeeds in building packages which contain sublibraries which are dependencies of executables, tests or benchmarks but not of the main library. See <a href="https://github.com/commercialhaskell/stack/issues/3959">#3787</a>.</li>
<li>Sublibraries are now properly considered for coverage reports when the test suite depends on the internal library. Before, stack was erroring when trying to generate the coverage report, see <a href="https://github.com/commercialhaskell/stack/issues/4105">#4105</a>.</li>
<li>Sublibraries are now added to the precompiled cache and recovered from there when the snapshot gets updated. Previously, updating the snapshot when there was a package with a sublibrary in the snapshot resulted in broken builds. This is now fixed, see <a href="https://github.com/commercialhaskell/stack/issues/4071">#4071</a>.</li>
<li>[#4114] Stack pretty prints error messages with proper <code>error</code> logging level instead of <code>warning</code> now. This also fixes self-executing scripts not piping plan construction errors from runhaskell to terminal (issue #3942).</li>
<li>Fix invalid “While building Setup.hs” when Cabal calls fail. See: <a href="https://github.com/commercialhaskell/stack/issues/3934">#3934</a></li>
<li><code>stack upload</code> signs the package by default, as documented. <code>--no-signature</code> turns the signing off. <a href="https://github.com/commercialhaskell/stack/issues/3739">#3739</a></li>
</ul>]]></summary>
</entry>
<entry>
    <title>time パッケージの使い方</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/09-17-time-package.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/09-17-time-package.html</id>
    <published>2018-09-17T00:00:00Z</published>
    <updated>2018-09-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>Haskell で時間や日付を扱う際に良く利用されるのは <a href="https://www.stackage.org/lts-12.9/package/time">time</a> パッケージです。</p>
<p>このパッケージが使いやすいかどうかは人それぞれですが、使い方を知っておくと便利なのでよく使いそうな関数を簡単に解説しようと思います。</p>
<p>これからの例は以下のコマンドを実行していると仮定して話を進めます。</p>
<pre class="shell"><code>$ stack repl --package time --resolver lts-12.9
$ import Data.Time</code></pre>
<!--more-->
<h2 id="time-パッケージのモジュール構造">Time パッケージのモジュール構造</h2>
<p>基本的には <a href="https://www.stackage.org/haddock/lts-12.9/time-1.8.0.2/Data-Time.html">Data.Time</a> を import して使います。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">import</span> <span class="dt">Data.Time</span></a></code></pre></div>
<p>Data.Time は以下のモジュールを再エクスポートしています。</p>
<table>
<thead>
<tr class="header">
<th>モジュール名</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://www.stackage.org/haddock/lts-12.9/time-1.8.0.2/Data-Time-Calendar.html">Data.Time.Calendar</a></td>
<td>日付</td>
</tr>
<tr class="even">
<td><a href="https://www.stackage.org/haddock/lts-12.9/time-1.8.0.2/Data-Time-Clock.html">Data.Time.Clock</a></td>
<td>全然使わないので良くわからない</td>
</tr>
<tr class="odd">
<td><a href="https://www.stackage.org/haddock/lts-12.9/time-1.8.0.2/Data-Time-LocalTime.html">Data.Time.LocalTime</a></td>
<td>日本の現在時刻を取得など</td>
</tr>
<tr class="even">
<td><a href="https://www.stackage.org/haddock/lts-12.9/time-1.8.0.2/Data-Time-Format.html">Data.Time.Format</a></td>
<td>出力の整形</td>
</tr>
</tbody>
</table>
<h3 id="rio-を利用している場合">rio を利用している場合</h3>
<p><a href="https://www.stackage.org/lts-12.9/package/rio">rio</a> を利用している場合は <a href="https://www.stackage.org/haddock/lts-12.9/rio-0.1.5.0/RIO-Time.html">RIO.Time</a> を import します。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">import</span> <span class="dt">RIO.Time</span></a></code></pre></div>
<h2 id="data.time.localtime">Data.Time.LocalTime</h2>
<p>現在時刻を取得する場合にこのモジュールを使います。現在時刻を取得したいからと言って <a href="https://www.stackage.org/haddock/lts-12.9/time-1.8.0.2/Data-Time-Clock.html#v:getCurrentTime">getCurrentTime</a> を利用すると日本時間にならないので注意してください。</p>
<h3 id="getzonedtime">getZonedTime</h3>
<p>システムのタイムゾーンに応じた現在時刻を返します。</p>
<pre class="shell"><code>&gt; :t getZonedTime
getZonedTime :: IO ZonedTime

&gt; getZonedTime
2018-09-17 13:41:05.512522063 JST</code></pre>
<h3 id="getcurrenttimezone">getCurrentTimeZone</h3>
<p>システムのタイムゾーンを取得します。このタイムゾーンに基づいて <code>getZonedTime</code> が計算されます。</p>
<pre class="shell"><code>&gt; :t getCurrentTimeZone
getCurrentTimeZone :: IO TimeZone

&gt; getCurrentTimeZone
JST</code></pre>
<h3 id="zonedtimetoutc">zonedTimeToUTC</h3>
<p><code>ZonedTime</code> を <code>UTCTime</code> に変換するために使います。</p>
<pre class="shell"><code>&gt; :t zonedTimeToUTC
zonedTimeToUTC :: ZonedTime -&gt; UTCTime

&gt; zonedTimeToUTC &lt;$&gt; getZonedTime
2018-09-17 04:41:27.907476307 UTC</code></pre>
<h3 id="utctozonedtime">utcToZonedTime</h3>
<p><code>zonedTimeToUTC</code> の逆で <code>UTCTime</code> を <code>ZonedTime</code> に変換する関数です。タイムゾーンのための引数を余分に取ります。</p>
<pre class="shell"><code>&gt; :t utcToZonedTime
utcToZonedTime :: TimeZone -&gt; UTCTime -&gt; ZonedTime

&gt; utcToZonedTime &lt;$&gt; getCurrentTimeZone &lt;*&gt; getCurrentTime
2018-09-17 13:41:37.955641567 JST</code></pre>
<h2 id="日後の時間を計算するには">1日後の時間を計算するには？</h2>
<p>ここで、取得した時間の1日後を計算してみましょう。</p>
<p>そのためには Data.Time.Clock で定義されている <a href="https://www.stackage.org/haddock/lts-12.9/time-1.8.0.2/Data-Time-Clock.html#v:addUTCTime">addUTCTime</a> を使います。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">addUTCTime ::</span> <span class="dt">NominalDiffTime</span> <span class="ot">-&gt;</span> <span class="dt">UTCTime</span> <span class="ot">-&gt;</span> <span class="dt">UTCTime</span></a></code></pre></div>
<p>第一引数に <code>NominalDiffTime</code> という謎の型を取りますが、<code>nominalDay</code> の実装を見れば <code>60 * 60 * 24</code> っぽいことがわかるので、そんな感じで値を作ります。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="ot">nominalDay ::</span> <span class="dt">NominalDiffTime</span></a>
<a class="sourceLine" id="cb9-2" title="2">nominalDay <span class="fu">=</span> <span class="dv">86400</span></a></code></pre></div>
<p>ちなみに、上記の実装でなぜ <code>NominalDiffTime</code> の値になるかと言うと、<code>NominalDiffTime</code> は <code>Num</code> クラスのインスタンスになっているため、自動的に <code>fromInteger</code> が呼ばれて変換されるという仕組みです。</p>
<p>実際に試してみましょう。1日後を計算してみます。</p>
<pre class="shell"><code>&gt; t = addUTCTime nominalDay . zonedTimeToUTC &lt;$&gt; getZonedTime
2018-09-17 10:32:56.880362453 UTC

&gt; getZonedTime
2018-09-17 13:49:09.279378323 JST

&gt; utcToZonedTime &lt;$&gt; getCurrentTimeZone &lt;*&gt; t
2018-09-18 13:49:16.211737218 JST</code></pre>
<p>同様に1時間後も計算してみましょう。</p>
<pre class="shell"><code>&gt; t = addUTCTime (60 * 60) . zonedTimeToUTC &lt;$&gt; getZonedTime

&gt; getZonedTime
2018-09-17 13:49:33.169797528 JST

&gt; t
2018-09-17 05:49:36.757498845 UTC

&gt; utcToZonedTime &lt;$&gt; getCurrentTimeZone &lt;*&gt; t
2018-09-17 14:49:40.930944714 JST</code></pre>
<p>上手くいってますね！</p>
<h2 id="data.time.localtime-1">Data.Time.LocalTime</h2>
<p>時刻の取得・計算ができたら、あとは整形して出力するだけです！</p>
<p>Data.Time.LocalTime モジュールの関数を使って出力を整形してみましょう！</p>
<h3 id="formattime">formatTime</h3>
<p><a href="https://www.stackage.org/haddock/lts-12.9/time-1.8.0.2/Data-Time-Format.html#v:formatTime">formatTime</a> 関数の使い方がわかれば、任意の形式で出力できるようになります。</p>
<pre class="shell"><code>&gt; :t formatTime
formatTime :: FormatTime t =&gt; TimeLocale -&gt; String -&gt; t -&gt; String</code></pre>
<p>ここで <code>FormatTime t</code> の <code>t</code> は <code>UTCTime</code> や <code>ZonedTime</code>、<code>Day</code> などの型が使えます。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="ot">formatTime ::</span> <span class="dt">TimeLocale</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ZonedTime</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="ot">formatTime ::</span> <span class="dt">TimeLocale</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">UTCTime</span>   <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="ot">formatTime ::</span> <span class="dt">TimeLocale</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Day</span>       <span class="ot">-&gt;</span> <span class="dt">String</span></a></code></pre></div>
<p>型に応じて第三引数が変わるということです。</p>
<p>実際に使えばすぐに慣れます。(第一引数の値は <a href="https://www.stackage.org/haddock/lts-12.9/time-1.8.0.2/Data-Time-Format.html#v:defaultTimeLocale">defaultTimeLocale</a> を指定しておけば良いのですが、自分でカスタマイズしたものを使うこともあります)</p>
<p>第二引数がフォーマット文字列なので、空文字列を与えれば当然結果も空になります。</p>
<pre class="shell"><code>&gt; formatTime defaultTimeLocale &quot;&quot; &lt;$&gt; getZonedTime
&quot;&quot;</code></pre>
<p>フォーマットの指定方法については <a href="https://www.stackage.org/haddock/lts-12.9/time-1.8.0.2/Data-Time-Format.html#v:formatTime">haddock</a> を参照してください。</p>
<pre class="shell"><code>&gt; formatTime defaultTimeLocale &quot;%D&quot; &lt;$&gt; getZonedTime
&quot;09/17/18&quot;

&gt; formatTime defaultTimeLocale &quot;%F&quot; &lt;$&gt; getZonedTime
&quot;2018-09-17&quot;

&gt; formatTime defaultTimeLocale &quot;%x&quot; &lt;$&gt; getZonedTime
&quot;09/17/18&quot;

&gt; formatTime defaultTimeLocale &quot;%Y/%m/%d-%T&quot; &lt;$&gt; getZonedTime
&quot;2018/09/17-13:52:21&quot;

&gt; formatTime defaultTimeLocale rfc822DateFormat &lt;$&gt; getZonedTime
&quot;Sun, 16 Sep 2018 19:53:10 JST&quot;

&gt; formatTime defaultTimeLocale (iso8601DateFormat Nothing) &lt;$&gt; getZonedTime
&quot;2018-09-16&quot;</code></pre>
<h2 id="文字列をパーズして-zonedtime-や-day-の値を作る">文字列をパーズして ZonedTime や Day の値を作る</h2>
<p>ここまでは現在時刻を元に時刻の計算や出力結果の整形を行いました。</p>
<p>しかし、実際のプログラムでは文字列をパーズして <code>ZonedTime</code> や <code>Day</code> の値に変換したいこともあるでしょう。そのような場合は <a href="https://www.stackage.org/haddock/lts-12.9/time-1.8.0.2/Data-Time-Format.html#v:parseTimeM">parseTimeM</a> を使うと便利です。</p>
<pre class="shell"><code>&gt; :t parseTimeM
parseTimeM
  :: (Monad m, ParseTime t) =&gt;
     Bool -&gt; TimeLocale -&gt; String -&gt; String -&gt; m t</code></pre>
<p>型がわかりづらいですが、具体的にはこんな型で利用することができます。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="ot">parseTimeM ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">TimeLocale</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Day</span></a>
<a class="sourceLine" id="cb17-2" title="2"><span class="ot">parseTimeM ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">TimeLocale</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ZonedTime</span></a>
<a class="sourceLine" id="cb17-3" title="3"><span class="ot">parseTimeM ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">TimeLocale</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Day</span></a>
<a class="sourceLine" id="cb17-4" title="4"><span class="ot">parseTimeM ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">TimeLocale</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">ZonedTime</span></a></code></pre></div>
<ul>
<li>第一引数は <strong>空白</strong> を許容するかどうかのフラグです (True だと空白OK)</li>
<li>第二引数は気にせず <strong>defaultTimeLocale</strong> を指定しておきましょう</li>
<li>第三引数は <strong>パーズで利用するフォーマット</strong> を指定します</li>
<li>第四引数は <strong>入力の文字列</strong> です</li>
</ul>
<h3 id="具体例">具体例</h3>
<p>実際にいくつか使ってみましょう。以下の通り <code>%F</code> は <code>YYYY-MM-DD</code> の書式になります。</p>
<pre class="shell"><code>&gt; formatTime defaultTimeLocale &quot;%F&quot; &lt;$&gt; getZonedTime
&quot;2018-09-17&quot;</code></pre>
<p>モナドを <code>IO</code> や <code>Maybe</code> などに変化させた基本的な例。</p>
<pre class="shell"><code>&gt; parseTimeM True defaultTimeLocale &quot;%F&quot; &quot;2018-09-17&quot; :: IO ZonedTime
2018-09-17 00:00:00 +0000

&gt; parseTimeM True defaultTimeLocale &quot;%F&quot; &quot;2018-09-17&quot; :: Maybe ZonedTime
Just 2018-09-17 00:00:00 +0000</code></pre>
<p>第一引数を変化させて、入力文字列の空白の有無について確認する例。</p>
<pre class="shell"><code>&gt; parseTimeM True defaultTimeLocale &quot;%F&quot; &quot; 2018-09-17 &quot; :: IO ZonedTime
2018-09-17 00:00:00 +0000

&gt; parseTimeM False defaultTimeLocale &quot;%F&quot; &quot; 2018-09-17 &quot; :: IO ZonedTime
*** Exception: user error (parseTimeM: no parse of &quot;2018-09-17 &quot;)</code></pre>
<p>入力文字列とパーズの書式がマッチしない例</p>
<pre class="shell"><code>&gt; parseTimeM False defaultTimeLocale &quot;%x&quot; &quot; 2018-09-17 &quot; :: IO ZonedTime
*** Exception: user error (parseTimeM: no parse of &quot; 2018-09-17 &quot;)</code></pre>
<p>Day 型の値をとしてパーズする例</p>
<pre class="shell"><code>&gt; parseTimeM True defaultTimeLocale &quot;%F&quot; &quot;2018-09-17&quot; :: IO Day
2018-09-17</code></pre>
<p>このようにして日付を取得できれば、今回は説明していませんが <a href="https://www.stackage.org/haddock/lts-12.9/time-1.8.0.2/Data-Time-Calendar.html">Data.Time.Calendar</a> の <a href="https://www.stackage.org/haddock/lts-12.9/time-1.8.0.2/Data-Time-Calendar.html#v:addDays">addDays</a> 関数などを使って日付の計算を行うこともできるようになります。</p>
<pre class="shell"><code>&gt; d = parseTimeM True defaultTimeLocale &quot;%F&quot; &quot;2018-09-17&quot; :: IO Day

&gt; addDays 1 &lt;$&gt; d
2018-09-18

&gt; addDays 35 &lt;$&gt; d
2018-10-22</code></pre>
<h2 id="まとめ">まとめ</h2>
<ul>
<li>time パッケージを使うと時刻や日付の計算ができる</li>
<li>現在の<strong>日本</strong>時間を取得した場合は <strong>getCurrentTime</strong> ではなく、<strong>getZonedTime</strong> を使う</li>
<li>整形には <strong>formatTime</strong> を使う</li>
<li>文字列から <strong>ZonedTime</strong> や <strong>Day</strong> に変換する際は <strong>parseTimeM</strong> を使う</li>
</ul>
<p>Haskell入門の <strong>7.7 日付・時刻を扱う</strong> にも3ページほど <strong>time</strong> パッケージの解説があるので、気になる人はそちらも確認してみると良いかもしれません。</p>
<p>以上です。</p>
<h2 id="おまけ">おまけ</h2>
<p><code>getZonedTime</code> に対して <code>formatTime defaultTimeLocale &lt;フォーマット文字&gt;</code> の対応表です。</p>
<pre class="shell"><code>&gt; getZonedTime
2018-09-17 14:44:52.052040178 JST</code></pre>
<div class="narrow-table">
<table>
<thead>
<tr class="header">
<th>文字</th>
<th>出力結果</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>%-z</code></td>
<td><code>+900</code></td>
</tr>
<tr class="even">
<td><code>%_z</code></td>
<td><code>+ 900</code></td>
</tr>
<tr class="odd">
<td><code>%0z</code></td>
<td><code>+0900</code></td>
</tr>
<tr class="even">
<td><code>%^z</code></td>
<td><code>+0900</code></td>
</tr>
<tr class="odd">
<td><code>%#z</code></td>
<td><code>+0900</code></td>
</tr>
<tr class="even">
<td><code>%8z</code></td>
<td><code>+00000900</code></td>
</tr>
<tr class="odd">
<td><code>%_12z</code></td>
<td><code>+         900</code></td>
</tr>
<tr class="even">
<td><code>%%</code></td>
<td><code>%</code></td>
</tr>
<tr class="odd">
<td><code>%t</code></td>
<td><code>\t</code></td>
</tr>
<tr class="even">
<td><code>%n</code></td>
<td><code>\n</code></td>
</tr>
<tr class="odd">
<td><code>%z</code></td>
<td><code>+0900</code></td>
</tr>
<tr class="even">
<td><code>%Z</code></td>
<td><code>JST</code></td>
</tr>
<tr class="odd">
<td><code>%c</code></td>
<td><code>Mon Sep 17 14:39:34 JST 2018</code></td>
</tr>
<tr class="even">
<td><code>%R</code></td>
<td><code>14:39</code></td>
</tr>
<tr class="odd">
<td><code>%T</code></td>
<td><code>14:40:12</code></td>
</tr>
<tr class="even">
<td><code>%X</code></td>
<td><code>14:40:31</code></td>
</tr>
<tr class="odd">
<td><code>%r</code></td>
<td><code>02:40:55 PM</code></td>
</tr>
<tr class="even">
<td><code>%P</code></td>
<td><code>pm</code></td>
</tr>
<tr class="odd">
<td><code>%p</code></td>
<td><code>PM</code></td>
</tr>
<tr class="even">
<td><code>%H</code></td>
<td><code>14</code></td>
</tr>
<tr class="odd">
<td><code>%k</code></td>
<td><code>14</code></td>
</tr>
<tr class="even">
<td><code>%I</code></td>
<td><code>02</code></td>
</tr>
<tr class="odd">
<td><code>%l</code></td>
<td><code>2</code></td>
</tr>
<tr class="even">
<td><code>%M</code></td>
<td><code>43</code></td>
</tr>
<tr class="odd">
<td><code>%S</code></td>
<td><code>49</code></td>
</tr>
<tr class="even">
<td><code>%q</code></td>
<td><code>903244678000</code></td>
</tr>
<tr class="odd">
<td><code>%Q</code></td>
<td><code>.28084722</code></td>
</tr>
<tr class="even">
<td><code>%s</code></td>
<td><code>1537163079</code></td>
</tr>
<tr class="odd">
<td><code>%D</code></td>
<td><code>09/17/18</code></td>
</tr>
<tr class="even">
<td><code>%F</code></td>
<td><code>2018-09-17</code></td>
</tr>
<tr class="odd">
<td><code>%x</code></td>
<td><code>09/17/18</code></td>
</tr>
<tr class="even">
<td><code>%Y</code></td>
<td><code>2018</code></td>
</tr>
<tr class="odd">
<td><code>%y</code></td>
<td><code>18</code></td>
</tr>
<tr class="even">
<td><code>%C</code></td>
<td><code>20</code></td>
</tr>
<tr class="odd">
<td><code>%B</code></td>
<td><code>September</code></td>
</tr>
<tr class="even">
<td><code>%b</code></td>
<td><code>Sep</code></td>
</tr>
<tr class="odd">
<td><code>%h</code></td>
<td><code>Sep</code></td>
</tr>
<tr class="even">
<td><code>%m</code></td>
<td><code>09</code></td>
</tr>
<tr class="odd">
<td><code>%d</code></td>
<td><code>17</code></td>
</tr>
<tr class="even">
<td><code>%e</code></td>
<td><code>17</code></td>
</tr>
<tr class="odd">
<td><code>%j</code></td>
<td><code>260</code></td>
</tr>
<tr class="even">
<td><code>%f</code></td>
<td><code>20</code></td>
</tr>
<tr class="odd">
<td><code>%V</code></td>
<td><code>38</code></td>
</tr>
<tr class="even">
<td><code>%u</code></td>
<td><code>1</code></td>
</tr>
<tr class="odd">
<td><code>%a</code></td>
<td><code>Mon</code></td>
</tr>
<tr class="even">
<td><code>%A</code></td>
<td><code>Monday</code></td>
</tr>
<tr class="odd">
<td><code>%U</code></td>
<td><code>37</code></td>
</tr>
<tr class="even">
<td><code>%w</code></td>
<td><code>1</code></td>
</tr>
<tr class="odd">
<td><code>%W</code></td>
<td><code>38</code></td>
</tr>
</tbody>
</table>
</div>]]></summary>
</entry>
<entry>
    <title>stack でアプリケーションのバックトレースを取得する (デバッグ)</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/09-01-stack-profile-build.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/09-01-stack-profile-build.html</id>
    <published>2018-09-01T00:00:00Z</published>
    <updated>2018-09-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>Haskell のデバッグ手法については、以下の記事がとても詳しく参考になります。素晴らしい記事です。</p>
<ul>
<li><a href="https://blog.miz-ar.info/2018/01/debugging-haskell-program">Haskell でのデバッグ手法あれこれ</a></li>
</ul>
<p>今回はHaskellアプリケーションをデバックする際に、バックトレースのとても簡単な取得方法があったのでご紹介したいと思います。</p>
<p>まとめると以下の2行です。</p>
<pre class="shell"><code>$ stack build --profile
$ stack exec -- &lt;exe_name&gt; +RTS -xc</code></pre>
<!--more-->
<h2 id="バックトレースの取得方法">バックトレースの取得方法</h2>
<p>まず、バックトレースを取得するために <a href="https://www.stackage.org/haddock/lts-12.8/base-4.11.1.0/GHC-Stack.html">GHC.Stack</a> で定義されている <a href="https://www.stackage.org/haddock/lts-12.8/base-4.11.1.0/GHC-Stack.html#t:HasCallStack">HasCallStack</a> をクラス制約として追加します。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">module</span> <span class="dt">Lib</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="ot">f1 ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-4" title="4">f1 <span class="fu">=</span> f2</a>
<a class="sourceLine" id="cb2-5" title="5"></a>
<a class="sourceLine" id="cb2-6" title="6"><span class="ot">f2 ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-7" title="7">f2 <span class="fu">=</span> f3</a>
<a class="sourceLine" id="cb2-8" title="8"></a>
<a class="sourceLine" id="cb2-9" title="9"><span class="ot">f3 ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-10" title="10">f3 <span class="fu">=</span> <span class="fu">error</span> <span class="st">&quot;f3&quot;</span></a></code></pre></div>
<p>上記の例を雛形として、<strong>HasCallStack</strong> を追加するとどうなるのか確認していきましょう。</p>
<p><code>Main.hs</code> はこんな感じで <strong>f1</strong> を呼び出します。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">module</span> <span class="dt">Main</span> (main) <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">import</span> <span class="dt">Lib</span></a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-6" title="6">main <span class="fu">=</span> f1</a></code></pre></div>
<p><strong>HasCallStack</strong> を追加しない場合は以下のような出力となります。</p>
<pre class="shell"><code>$ stack build
...
$ stack exec example
example: f3
CallStack (from HasCallStack):
  error, called at src/Lib.hs:10:6 in backtrace-example-0.1.0.0-hgO68xdg85BUcmGsdFId:Lib</code></pre>
<p><strong>f3</strong> でエラーが発生したことはわかりますが、それ以外は何もわかりません。</p>
<h3 id="f1-f2-f3-に-hascallstack-を追加した場合">f1, f2, f3 に HasCallStack を追加した場合</h3>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">module</span> <span class="dt">Lib</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">import</span> <span class="dt">GHC.Stack</span></a>
<a class="sourceLine" id="cb5-4" title="4"></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="ot">f1 ::</span> <span class="dt">HasCallStack</span> <span class="ot">=&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb5-6" title="6">f1 <span class="fu">=</span> f2</a>
<a class="sourceLine" id="cb5-7" title="7"></a>
<a class="sourceLine" id="cb5-8" title="8"><span class="ot">f2 ::</span> <span class="dt">HasCallStack</span> <span class="ot">=&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb5-9" title="9">f2 <span class="fu">=</span> f3</a>
<a class="sourceLine" id="cb5-10" title="10"></a>
<a class="sourceLine" id="cb5-11" title="11"><span class="ot">f3 ::</span> <span class="dt">HasCallStack</span> <span class="ot">=&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb5-12" title="12">f3 <span class="fu">=</span> <span class="fu">error</span> <span class="st">&quot;f3&quot;</span></a></code></pre></div>
<p>ビルドしてみます。</p>
<pre class="shell"><code>$ stack build
...
$ stack exec example
example: f3
CallStack (from HasCallStack):
  error, called at src/Lib.hs:12:6 in backtrace-example-0.1.0.0-hgO68xdg85BUcmGsdFId:Lib
  f3, called at src/Lib.hs:9:6 in backtrace-example-0.1.0.0-hgO68xdg85BUcmGsdFId:Lib
  f2, called at src/Lib.hs:6:6 in backtrace-example-0.1.0.0-hgO68xdg85BUcmGsdFId:Lib
  f1, called at app/Main.hs:6:8 in main:Main</code></pre>
<p>ちゃんと呼び出しの関係が <code>error</code> -&gt; <code>f3</code> -&gt; <code>f2</code> -&gt; <code>f1</code> と表示されていますね！</p>
<h3 id="f2-f3-にのみ-hascallstack-を追加する">f2, f3 にのみ HasCallStack を追加する</h3>
<p>では、ここで <code>f1</code> の <strong>HasCallStack</strong> 制約を取り除くとどうなるか確認してみます。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">module</span> <span class="dt">Lib</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" title="2"></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="kw">import</span> <span class="dt">GHC.Stack</span></a>
<a class="sourceLine" id="cb7-4" title="4"></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="ot">f1 ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-6" title="6">f1 <span class="fu">=</span> f2</a>
<a class="sourceLine" id="cb7-7" title="7"></a>
<a class="sourceLine" id="cb7-8" title="8"><span class="ot">f2 ::</span> <span class="dt">HasCallStack</span> <span class="ot">=&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-9" title="9">f2 <span class="fu">=</span> f3</a>
<a class="sourceLine" id="cb7-10" title="10"></a>
<a class="sourceLine" id="cb7-11" title="11"><span class="ot">f3 ::</span> <span class="dt">HasCallStack</span> <span class="ot">=&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-12" title="12">f3 <span class="fu">=</span> <span class="fu">error</span> <span class="st">&quot;f3&quot;</span></a></code></pre></div>
<p>実行してみます。</p>
<pre class="shell"><code>$ stack build
...
$ stack exec example
example: f3
CallStack (from HasCallStack):
  error, called at src/Lib.hs:12:6 in backtrace-example-0.1.0.0-hgO68xdg85BUcmGsdFId:Lib
  f3, called at src/Lib.hs:9:6 in backtrace-example-0.1.0.0-hgO68xdg85BUcmGsdFId:Lib
  f2, called at src/Lib.hs:6:6 in backtrace-example-0.1.0.0-hgO68xdg85BUcmGsdFId:Lib</code></pre>
<p><strong>f1</strong> の <strong>HasCallStack</strong> 制約を取り除いた影響により、先程出力されていた <code>f1, called at app/Main.hs:6:8 in main:Main</code> が出なくなりました。</p>
<p>しかし、依然として <strong>f2</strong> と <strong>f3</strong> のバックトレースは取得できています。そのため、本当に全てのバックトレースを取得したい場合は全ての関数に <strong>HasCallStack</strong> 制約を追加しなけばなりません。</p>
<h3 id="f1-と-f3-にのみ-hascallstack-制約を追加する">f1 と f3 にのみ HasCallStack 制約を追加する</h3>
<p>次に中間の <strong>f2</strong> の <strong>HasCallStack</strong> 制約を取り除いてみましょう。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">module</span> <span class="dt">Lib</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" title="2"></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="kw">import</span> <span class="dt">GHC.Stack</span></a>
<a class="sourceLine" id="cb9-4" title="4"></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="ot">f1 ::</span> <span class="dt">HasCallStack</span> <span class="ot">=&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-6" title="6">f1 <span class="fu">=</span> f2</a>
<a class="sourceLine" id="cb9-7" title="7"></a>
<a class="sourceLine" id="cb9-8" title="8"><span class="ot">f2 ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-9" title="9">f2 <span class="fu">=</span> f3</a>
<a class="sourceLine" id="cb9-10" title="10"></a>
<a class="sourceLine" id="cb9-11" title="11"><span class="ot">f3 ::</span> <span class="dt">HasCallStack</span> <span class="ot">=&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-12" title="12">f3 <span class="fu">=</span> <span class="fu">error</span> <span class="st">&quot;f3&quot;</span></a></code></pre></div>
<p>実行してみます。</p>
<pre class="shell"><code>$ stack build
...
$ stack exec example
example: f3
CallStack (from HasCallStack):
  error, called at src/Lib.hs:12:6 in backtrace-example-0.1.0.0-hgO68xdg85BUcmGsdFId:Lib
  f3, called at src/Lib.hs:9:6 in backtrace-example-0.1.0.0-hgO68xdg85BUcmGsdFId:Lib</code></pre>
<p>今度は <strong>f2</strong> と <strong>f1</strong> の両方の情報がが抜け落ちてしまいました。<strong>f2</strong> で <strong>HasCallStack</strong> の伝搬がストップしてしまったということです。</p>
<h3 id="f1-と-f2-のみに-hascallstack-を追加する">f1 と f2 のみに HasCallStack を追加する</h3>
<div class="sourceCode" id="cb11"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">module</span> <span class="dt">Lib</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-2" title="2"></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="kw">import</span> <span class="dt">GHC.Stack</span></a>
<a class="sourceLine" id="cb11-4" title="4"></a>
<a class="sourceLine" id="cb11-5" title="5"><span class="ot">f1 ::</span> <span class="dt">HasCallStack</span> <span class="ot">=&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb11-6" title="6">f1 <span class="fu">=</span> f2</a>
<a class="sourceLine" id="cb11-7" title="7"></a>
<a class="sourceLine" id="cb11-8" title="8"><span class="ot">f2 ::</span> <span class="dt">HasCallStack</span> <span class="ot">=&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb11-9" title="9">f2 <span class="fu">=</span> f3</a>
<a class="sourceLine" id="cb11-10" title="10"></a>
<a class="sourceLine" id="cb11-11" title="11"><span class="ot">f3 ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb11-12" title="12">f3 <span class="fu">=</span> <span class="fu">error</span> <span class="st">&quot;f3&quot;</span></a></code></pre></div>
<pre class="shell"><code>$ stack build
$ stack exec example
example: f3
CallStack (from HasCallStack):
  error, called at src/Lib.hs:12:6 in backtrace-example-0.1.0.0-hgO68xdg85BUcmGsdFId:Lib
...</code></pre>
<p>予想通り <strong>f1</strong>, <strong>f2</strong>, <strong>f3</strong> の全ての情報が途絶えましたね・・・。</p>
<h2 id="hascallstack-を省略したままバックトレースを取りたい">HasCallStack を省略したままバックトレースを取りたい</h2>
<p>先程の結果を見たとおり、正確な情報を取得するためには全ての関数に <strong>HasCallStack</strong> 制約を追加する必要がありそうです。</p>
<p>しかしながら、規模が大きくなってくるとそんなの不可能ですよね。</p>
<p>そんな時には <code>stack</code> の <code>--profile</code> オプションと <code>+RTS -xc</code> オプションを利用します。(<code>--profile</code> オプションは <strong>ghc</strong> のオプションを良い感じに追加してくれます)</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">module</span> <span class="dt">Lib</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-2" title="2"></a>
<a class="sourceLine" id="cb13-3" title="3"><span class="ot">f1 ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb13-4" title="4">f1 <span class="fu">=</span> f2</a>
<a class="sourceLine" id="cb13-5" title="5"></a>
<a class="sourceLine" id="cb13-6" title="6"><span class="ot">f2 ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb13-7" title="7">f2 <span class="fu">=</span> f3</a>
<a class="sourceLine" id="cb13-8" title="8"></a>
<a class="sourceLine" id="cb13-9" title="9"><span class="ot">f3 ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb13-10" title="10">f3 <span class="fu">=</span> <span class="fu">error</span> <span class="st">&quot;f3&quot;</span></a></code></pre></div>
<p>上記のような素のコードに対しても、同様にバックトレースが取得できるようになります。</p>
<pre class="shell"><code>$ stack build --profile
...
$ stack exec -- example +RTS -xc
*** Exception (reporting due to +RTS -xc): (THUNK_2_0), stack trace:
  Lib.f3,
  called from Lib.CAF:f3
  --&gt; evaluated by: Lib.CAF:f2
  --&gt; evaluated by: Lib.CAF:f1
  --&gt; evaluated by: Main.CAF:main
example: f3
CallStack (from HasCallStack):
  error, called at src/Lib.hs:10:6 in backtrace-example-0.1.0.0-hgO68xdg85BUcmGsdFId:Lib
CallStack (from -prof):
  Lib.f3 (src/Lib.hs:10:1-15)
  Lib.CAF:f3 (src/Lib.hs:10:1-2)</code></pre>
<p>なんか沢山表示されますが、<code>reporting due to +RTS -xc</code> の部分を見ると、しっかりとバックトレースが取得できています。</p>
<h2 id="まとめ">まとめ</h2>
<ul>
<li><strong>HasCallStack</strong> を使うとバックトレースが取得できる</li>
<li><code>stack build --profile</code> でビルドする</li>
<li><code>stack exec -- &lt;exe&gt; +RTS -xc</code> を使えば、明示的に <strong>HasCallStack</strong> を追加しなくても、バックトレースが取得できる</li>
<li>アプリケーションのコードに対して有効</li>
</ul>
<p>参考</p>
<ul>
<li><a href="https://blog.miz-ar.info/2018/01/debugging-haskell-program/#HasCallStack">Haskell でのデバッグ手法あれこれ</a></li>
<li><a href="https://github.com/commercialhaskell/stack/blob/master/doc/GUIDE.md#debugging">Debugging – stack document</a></li>
<li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/runtime_control.html#rts-flag--xc">-xc option – GHC Users Guide</a></li>
</ul>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>stack-1.11 から location に extra-dep を指定できなくなります。</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/08-31-stack-extradep-legacy-syntax.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/08-31-stack-extradep-legacy-syntax.html</id>
    <published>2018-08-31T00:00:00Z</published>
    <updated>2018-08-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>まだまだ先の話ですが、<code>extra-dep</code> の書き方が <strong>Legacy syntax</strong> になりました。<code>stack-1.11</code> からはビルドできなくなります。</p>
<p>以下の設定例は<a href="https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md#packages">公式ドキュメント</a>の例を少し変更したものです。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb1-1" title="1"><span class="fu">packages:</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="kw">-</span> .</a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">-</span> <span class="fu">location:</span></a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="fu">git:</span><span class="at"> https://github.com/bitemyapp/esqueleto.git</span></a>
<a class="sourceLine" id="cb1-5" title="5">    <span class="fu">commit:</span><span class="at"> 08c9b4cdf977d5bcd1baba046a007940c1940758</span></a>
<a class="sourceLine" id="cb1-6" title="6">  <span class="fu">extra-dep:</span><span class="at"> </span><span class="ch">true</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="kw">-</span> <span class="fu">location:</span></a>
<a class="sourceLine" id="cb1-8" title="8">    ./submodules/haskell-lsp</a>
<a class="sourceLine" id="cb1-9" title="9">  <span class="fu">extra-dep:</span><span class="at"> </span><span class="ch">true</span></a>
<a class="sourceLine" id="cb1-10" title="10">  <span class="fu">subdirs:</span></a>
<a class="sourceLine" id="cb1-11" title="11">    <span class="kw">-</span> .</a>
<a class="sourceLine" id="cb1-12" title="12">    <span class="kw">-</span> haskell-lsp-types</a>
<a class="sourceLine" id="cb1-13" title="13"></a>
<a class="sourceLine" id="cb1-14" title="14"><span class="fu">extra-deps:</span></a>
<a class="sourceLine" id="cb1-15" title="15">  <span class="kw">-</span> streaming-commons-0.2.0.0</a></code></pre></div>
<p>修正方法は、設定ファイルの <code>packages</code> に <code>extra-dep: true</code> と指定している部分を、以下のように <code>extra-deps</code> へ追加するだけです。また、 <code>subdirs</code> を指定している場合は単純に分割して指定します。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb2-1" title="1"><span class="fu">packages:</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="kw">-</span> .</a>
<a class="sourceLine" id="cb2-3" title="3"></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="fu">extra-deps:</span></a>
<a class="sourceLine" id="cb2-5" title="5">  <span class="kw">-</span> <span class="fu">git:</span><span class="at"> https://github.com/bitemyapp/esqueleto.git</span></a>
<a class="sourceLine" id="cb2-6" title="6">    <span class="fu">commit:</span><span class="at"> 08c9b4cdf977d5bcd1baba046a007940c1940758</span></a>
<a class="sourceLine" id="cb2-7" title="7">  <span class="kw">-</span> ./submodules/haskell-lsp</a>
<a class="sourceLine" id="cb2-8" title="8">  <span class="kw">-</span> ./submodules/haskell-lsp/haskell-lsp-types</a>
<a class="sourceLine" id="cb2-9" title="9">  <span class="kw">-</span> streaming-commons-0.2.0.0</a></code></pre></div>
<p><code>extra-deps</code> の構文は従来の <code>stack</code> でも使えるので、今から対応しておいても問題ないと思います。</p>
<p>以上です。</p>
<!--more-->]]></summary>
</entry>
<entry>
    <title>RecordWildCards と Reader モナド</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/08-26-recordwildcards.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/08-26-recordwildcards.html</id>
    <published>2018-08-26T00:00:00Z</published>
    <updated>2018-08-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p><code>Twitter</code> で <code>RecordWildCards</code> の話が流れて来たので <code>Reader</code> モナドと組み合わせた例を1つご紹介します。</p>
<p>この書き方は <span class="citation" data-cites="fumieval">@fumieval</span> さんが使っていてカッコイイ書き方だなぁと思った記憶があります。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">{-# LANGUAGE RecordWildCards #-}</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span></a>
<a class="sourceLine" id="cb1-4" title="4">  {<span class="ot"> personName ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb1-5" title="5">  ,<span class="ot"> personAge  ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb1-6" title="6">  }</a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="ot">func ::</span> <span class="dt">Reader</span> <span class="dt">Person</span> ()</a>
<a class="sourceLine" id="cb1-9" title="9">func <span class="fu">=</span> ask <span class="fu">&gt;&gt;=</span> \<span class="dt">Person</span> {<span class="fu">..</span>} <span class="ot">-&gt;</span> <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-10" title="10">  <span class="fu">...</span> <span class="co">-- personName, personAge という名前でそのまま値を利用できる</span></a></code></pre></div>
<p><code>RecordWildCards</code> に関しては既に色んな方が記事にしてくれているので、そちらをご参照ください。</p>
<ul>
<li><a href="https://haskell.jp/blog/posts/2018/about-ghc-exts-1.html">GHC拡張ノック(Part 1)</a></li>
<li><a href="http://rf0444.hatenablog.jp/entry/20120617/1339910411">Haskellの言語拡張たち 2</a></li>
<li><a href="http://fumieval.hatenablog.com/entry/2016/12/18/181540">波打たせるものの正体(エクステンシブル・タングル)</a></li>
<li><a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#record-wildcards">GHC user guide 10.5.5. Record wildcards</a></li>
</ul>
<!--more-->
<h2 id="具体例">具体例</h2>
<p>あまり良い例が思いつかなかったのですが、 <code>Env</code> に必要な情報を持たせておけば任意のタイミングで利用できて便利です。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="co">-- stack script --resolver lts-12.7</span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="ot">{-# LANGUAGE RecordWildCards #-}</span></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></a>
<a class="sourceLine" id="cb2-5" title="5"></a>
<a class="sourceLine" id="cb2-6" title="6"><span class="kw">import</span>           <span class="dt">Control.Monad.IO.Class</span></a>
<a class="sourceLine" id="cb2-7" title="7"><span class="kw">import</span>           <span class="dt">Control.Monad.Trans.Reader</span></a>
<a class="sourceLine" id="cb2-8" title="8"><span class="kw">import</span>           <span class="dt">Data.IORef</span></a>
<a class="sourceLine" id="cb2-9" title="9"><span class="kw">import</span>           <span class="dt">Data.Time.LocalTime</span></a>
<a class="sourceLine" id="cb2-10" title="10"><span class="kw">import</span>           <span class="dt">Path</span></a>
<a class="sourceLine" id="cb2-11" title="11"></a>
<a class="sourceLine" id="cb2-12" title="12"><span class="kw">data</span> <span class="dt">Env</span> <span class="fu">=</span> <span class="dt">Env</span></a>
<a class="sourceLine" id="cb2-13" title="13">  {<span class="ot"> envCounter  ::</span> <span class="dt">IORef</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-14" title="14">  ,<span class="ot"> envLogPath  ::</span> <span class="dt">Path</span> <span class="dt">Rel</span> <span class="dt">File</span></a>
<a class="sourceLine" id="cb2-15" title="15">  ,<span class="ot"> envUserName ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb2-16" title="16">  }</a>
<a class="sourceLine" id="cb2-17" title="17"></a>
<a class="sourceLine" id="cb2-18" title="18"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-19" title="19">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-20" title="20">  counter <span class="ot">&lt;-</span> newIORef <span class="dv">0</span></a>
<a class="sourceLine" id="cb2-21" title="21">  <span class="kw">let</span> env <span class="fu">=</span> <span class="dt">Env</span></a>
<a class="sourceLine" id="cb2-22" title="22">        { envCounter  <span class="fu">=</span> counter</a>
<a class="sourceLine" id="cb2-23" title="23">        , envLogPath  <span class="fu">=</span> <span class="fu">$</span>(mkRelFile <span class="st">&quot;./output.log&quot;</span>)</a>
<a class="sourceLine" id="cb2-24" title="24">        , envUserName <span class="fu">=</span> <span class="st">&quot;wado&quot;</span></a>
<a class="sourceLine" id="cb2-25" title="25">        }</a>
<a class="sourceLine" id="cb2-26" title="26"></a>
<a class="sourceLine" id="cb2-27" title="27">  runReaderT (access <span class="fu">&gt;&gt;</span> access <span class="fu">&gt;&gt;</span> access) env</a>
<a class="sourceLine" id="cb2-28" title="28"></a>
<a class="sourceLine" id="cb2-29" title="29">  n <span class="ot">&lt;-</span> readIORef counter</a>
<a class="sourceLine" id="cb2-30" title="30">  <span class="fu">putStrLn</span> <span class="fu">$</span> <span class="fu">mconcat</span> [<span class="st">&quot;counter = &quot;</span>, <span class="fu">show</span> n]</a>
<a class="sourceLine" id="cb2-31" title="31"></a>
<a class="sourceLine" id="cb2-32" title="32"><span class="ot">access ::</span> <span class="dt">ReaderT</span> <span class="dt">Env</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-33" title="33">access <span class="fu">=</span> ask <span class="fu">&gt;&gt;=</span> \<span class="dt">Env</span> {<span class="fu">..</span>} <span class="ot">-&gt;</span> liftIO <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-34" title="34">  modifyIORef envCounter (<span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb2-35" title="35">  now <span class="ot">&lt;-</span> getZonedTime</a>
<a class="sourceLine" id="cb2-36" title="36">  <span class="fu">appendFile</span> (toFilePath envLogPath)</a>
<a class="sourceLine" id="cb2-37" title="37">    <span class="fu">$</span> <span class="fu">mconcat</span> [envUserName, <span class="st">&quot;: &quot;</span>, <span class="st">&quot;access&quot;</span>, <span class="st">&quot; (&quot;</span>, <span class="fu">show</span> now, <span class="st">&quot;)&quot;</span>, <span class="st">&quot;\n&quot;</span>]</a>
<a class="sourceLine" id="cb2-38" title="38">  <span class="fu">return</span> ()</a></code></pre></div>
<h3 id="実行結果">実行結果</h3>
<pre class="shell"><code>$ ./Sample.hs
counter = 3

$ cat ./output.log
wado: access (2018-08-26 14:04:07.132813451 JST)
wado: access (2018-08-26 14:04:07.133330363 JST)
wado: access (2018-08-26 14:04:07.133389916 JST)</code></pre>
<h2 id="missing-fields-警告">missing-fields 警告</h2>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="ot">{-# LANGUAGE RecordWildCards #-}</span></a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span></a>
<a class="sourceLine" id="cb4-4" title="4">  {<span class="ot"> personName ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb4-5" title="5">  ,<span class="ot"> personAge  ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb4-6" title="6">  } <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb4-7" title="7"></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="ot">f ::</span> <span class="dt">Person</span></a>
<a class="sourceLine" id="cb4-9" title="9">f <span class="fu">=</span> <span class="dt">Person</span> { <span class="fu">..</span> }</a>
<a class="sourceLine" id="cb4-10" title="10">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-11" title="11">    personName <span class="fu">=</span> <span class="st">&quot;bigmoon&quot;</span></a></code></pre></div>
<p>上記のようにフィールドが全て初期化されていないコードはコンパイル時に <code>missing-fields</code> 警告が出ます。</p>
<p>この警告を無視すると実行時エラーになる可能性があります。無視せずにしっかり修正しましょう。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1">warning<span class="fu">:</span> [<span class="fu">-</span><span class="dt">Wmissing</span><span class="fu">-</span>fields]</a>
<a class="sourceLine" id="cb5-2" title="2">    • <span class="dt">Fields</span> <span class="kw">of</span> ‘<span class="dt">Person</span>’ <span class="fu">not</span> initialised<span class="fu">:</span> personAge</a>
<a class="sourceLine" id="cb5-3" title="3">    • <span class="dt">In</span> the expression<span class="fu">:</span> <span class="dt">Person</span> {<span class="fu">..</span>}</a>
<a class="sourceLine" id="cb5-4" title="4">      <span class="dt">In</span> an equation for ‘f’<span class="fu">:</span></a>
<a class="sourceLine" id="cb5-5" title="5">          f <span class="fu">=</span> <span class="dt">Person</span> {<span class="fu">..</span>}</a>
<a class="sourceLine" id="cb5-6" title="6">            <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-7" title="7">                personName <span class="fu">=</span> <span class="st">&quot;bigmoon&quot;</span></a>
<a class="sourceLine" id="cb5-8" title="8">   <span class="fu">|</span></a>
<a class="sourceLine" id="cb5-9" title="9"><span class="dv">46</span> <span class="fu">|</span> f <span class="fu">=</span> <span class="dt">Person</span> { <span class="fu">..</span> }</a>
<a class="sourceLine" id="cb5-10" title="10">   <span class="fu">|</span></a></code></pre></div>
<p>ちなみに、通常のレコード構文でもフィールドが部分的にしか初期化されていない場合は、同様の警告がでます。(<span class="citation" data-cites="fumieval">@fumieval</span> さん、ご指摘ありがとうございます)</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span></a>
<a class="sourceLine" id="cb6-2" title="2">  {<span class="ot"> personName ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb6-3" title="3">  ,<span class="ot"> personAge  ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb6-4" title="4">  } <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb6-5" title="5"></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="ot">f ::</span> <span class="dt">Person</span></a>
<a class="sourceLine" id="cb6-7" title="7">f <span class="fu">=</span> <span class="dt">Person</span> { personName <span class="fu">=</span> <span class="st">&quot;bigmoon&quot;</span> }</a></code></pre></div>
<ul>
<li><a href="https://ghc.haskell.org/trac/ghc/ticket/5334">record wildcards: field not initialised reported as type error</a></li>
</ul>
<h2 id="まとめ">まとめ</h2>
<ul>
<li>RecordWildCards 言語拡張は現実世界ではとても便利 (レコードのフィールドがかなり沢山あったりするので)</li>
<li>Reader とかと組み合わせるとオシャレ</li>
<li>GHC の <code>missing-fields</code> 警告は絶対に無視しない (実行時エラーが発生する可能性がある)</li>
</ul>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>path ＆ path-io パッケージ</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/08-21-path-and-path-io.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/08-21-path-and-path-io.html</id>
    <published>2018-08-21T00:00:00Z</published>
    <updated>2018-08-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>Haskell でファイルやディレクトリを扱うプログラムを書く時によく使うパッケージとして <a href="https://www.stackage.org/lts-12.7/package/filepath-1.4.2">filepath</a> パッケージや <a href="https://www.stackage.org/lts-12.7/package/directory-1.3.1.5">directory</a> パッケージがあります。(Haskell入門の「4.4 ファイルシステム」に <strong>directory</strong> パッケージの話が少し載っています。)</p>
<p>これらのパッケージは結局のところただの文字列操作なので、バグを出さないためにはパッケージ利用者がかなり注意深く使わなければなりません。</p>
<p>例えば、以下のようなパスは型レベルでは同じ文字列 (<strong>FilePath</strong>) ですが</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="co">-- 相対パス</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="ot">pathRel ::</span> <span class="dt">FilePath</span></a>
<a class="sourceLine" id="cb1-3" title="3">pathRel <span class="fu">=</span> <span class="fu">./</span>aaa<span class="fu">/</span>bbb<span class="fu">/</span>ccc</a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="co">-- 絶対パス</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="ot">pathAbs ::</span> <span class="dt">FilePath</span></a>
<a class="sourceLine" id="cb1-7" title="7">pathAbs <span class="fu">=</span> <span class="fu">/</span>home<span class="fu">/</span>user<span class="fu">/</span>aaa<span class="fu">/</span>bbb<span class="fu">/</span>ccc</a>
<a class="sourceLine" id="cb1-8" title="8"></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="co">-- ファイルへのパス</span></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="ot">pathFile ::</span> <span class="dt">FilePath</span></a>
<a class="sourceLine" id="cb1-11" title="11">pathFile <span class="fu">=</span> <span class="fu">./</span>aaa<span class="fu">/</span>a<span class="fu">.</span>png</a>
<a class="sourceLine" id="cb1-12" title="12"></a>
<a class="sourceLine" id="cb1-13" title="13"><span class="co">-- ディレクトリへのパス</span></a>
<a class="sourceLine" id="cb1-14" title="14"><span class="ot">pathDir ::</span> <span class="dt">FilePath</span></a>
<a class="sourceLine" id="cb1-15" title="15">pathDir <span class="fu">=</span> <span class="fu">./</span>aaa</a></code></pre></div>
<p>このように、<strong>FilePath</strong> 型では<strong>相対パス</strong>なのか<strong>絶対パス</strong>なのか型レベルで判断する方法が無かったり、そもそもパスが<strong>ファイル</strong>なのか<strong>ディレクトリ</strong>なのかすらわからなかったりします。</p>
<p>今回紹介するのは、型レベルでこれらをちゃんと分類できるようにしている <a href="https://github.com/commercialhaskell/path">path</a> と <a href="https://github.com/mrkkrp/path-io">path-io</a> パッケージです。</p>
<p>型レベルで <strong>相対パス</strong> or <strong>絶対パス</strong> と <strong>ファイル</strong> or <strong>ディレクトリ</strong> を表現するため、不正な操作はコンパイル時にチェックできるようになります。</p>
<p>また、<strong>stack</strong> の内部でも利用していたので、実用しても大丈夫だと思います。</p>
<p>パッケージのバージョンは以下のとおりです</p>
<ul>
<li>path-0.6.1</li>
<li>path-io-1.3.3</li>
</ul>
<p>まだまだ更新が活発なパッケージなので、path-0.7 では破壊的変更を含む更新があるようです。(<a href="https://github.com/commercialhaskell/path/blob/master/CHANGELOG">CHANGELOG</a>)</p>
<!--more-->
<h2 id="path-パッケージ">path パッケージ</h2>
<p>ドキュメントが充実しているので <a href="https://github.com/commercialhaskell/path/blob/master/README.md">Readme</a> を読めば使い方はすぐにわかると思います。</p>
<h3 id="データ型">データ型</h3>
<p><code>Path</code> の型は <code>FilePath</code> を幽霊型 (Phantom type) を使ってラップしているだけです。(幽霊型については <a href="https://qiita.com/nobkz/items/5926257a375a4a181dde">ElmでPhantom Type (幽霊型)入門</a> や <a href="https://qiita.com/HirotoShioi/items/3444e215070144b8ca0f">で、出たー！幽霊型だー！(Phantom Type)</a> などが日本語のわかりやすい解説だと思います)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">newtype</span> <span class="dt">Path</span> b t <span class="fu">=</span> <span class="dt">Path</span> <span class="dt">FilePath</span></a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="kw">deriving</span> (<span class="dt">Data</span>, <span class="dt">Typeable</span>, <span class="dt">Generic</span>)</a></code></pre></div>
<p>ここで2つの型変数の意味は以下の通りです。</p>
<ul>
<li><code>b</code> - 相対パス or 絶対パス</li>
<li><code>t</code> - ファイル or ディレクトリ</li>
</ul>
<p>型変数 <code>b</code> は実際には以下の型のどちらかを取ります。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">data</span> <span class="dt">Abs</span> <span class="kw">deriving</span> (<span class="dt">Typeable</span>)</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">data</span> <span class="dt">Rel</span> <span class="kw">deriving</span> (<span class="dt">Typeable</span>)</a></code></pre></div>
<p>同様に型変数 <code>t</code> は以下の型を取ります。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">data</span> <span class="dt">File</span> <span class="kw">deriving</span> (<span class="dt">Typeable</span>)</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">data</span> <span class="dt">Dir</span> <span class="kw">deriving</span> (<span class="dt">Typeable</span>)</a></code></pre></div>
<p>具体的なパスの型は以下の4種類のどれかになります。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">Path</span> <span class="dt">Abs</span> <span class="dt">File</span> <span class="co">-- ファイルへの絶対パス</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="dt">Path</span> <span class="dt">Abs</span> <span class="dt">Dir</span>  <span class="co">-- ディレクトリへの絶対パス</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="dt">Path</span> <span class="dt">Rel</span> <span class="dt">File</span> <span class="co">-- ファイルへの相対パス</span></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="dt">Path</span> <span class="dt">Rel</span> <span class="dt">Dir</span>  <span class="co">-- ディレクトリへの相対パス</span></a></code></pre></div>
<p>型を見るだけでどんなパスなのか一目瞭然なので、めっちゃ良いですね。</p>
<h3 id="値の作り方">値の作り方</h3>
<p>型については説明したので、次は実際に <code>Path</code> 型の値を作っていきましょう！</p>
<h4 id="パースする方法">パースする方法</h4>
<p><code>Path</code> 型は4種類あるので、パーズする関数も4種類あります。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="ot">parseAbsDir  ::</span> <span class="dt">MonadThrow</span> m <span class="ot">=&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> m (<span class="dt">Path</span> <span class="dt">Abs</span> <span class="dt">Dir</span>)</a>
<a class="sourceLine" id="cb6-2" title="2"><span class="ot">parseRelDir  ::</span> <span class="dt">MonadThrow</span> m <span class="ot">=&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> m (<span class="dt">Path</span> <span class="dt">Rel</span> <span class="dt">Dir</span>)</a>
<a class="sourceLine" id="cb6-3" title="3"><span class="ot">parseAbsFile ::</span> <span class="dt">MonadThrow</span> m <span class="ot">=&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> m (<span class="dt">Path</span> <span class="dt">Abs</span> <span class="dt">File</span>)</a>
<a class="sourceLine" id="cb6-4" title="4"><span class="ot">parseRelFile ::</span> <span class="dt">MonadThrow</span> m <span class="ot">=&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> m (<span class="dt">Path</span> <span class="dt">Rel</span> <span class="dt">File</span>)</a></code></pre></div>
<p><code>MonadThrow m</code> がついていますが、この <code>m</code> は <code>IO</code> だと思えば以下の型と同じですし</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="ot">parseAbsDir  ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Path</span> <span class="dt">Abs</span> <span class="dt">Dir</span>)</a>
<a class="sourceLine" id="cb7-2" title="2"><span class="ot">parseRelDir  ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Path</span> <span class="dt">Rel</span> <span class="dt">Dir</span>)</a>
<a class="sourceLine" id="cb7-3" title="3"><span class="ot">parseAbsFile ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Path</span> <span class="dt">Abs</span> <span class="dt">File</span>)</a>
<a class="sourceLine" id="cb7-4" title="4"><span class="ot">parseRelFile ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Path</span> <span class="dt">Rel</span> <span class="dt">File</span>)</a></code></pre></div>
<p><code>Maybe</code> であれば、以下の型と同じです。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">parseAbsDir  ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Path</span> <span class="dt">Abs</span> <span class="dt">Dir</span>)</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="ot">parseRelDir  ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Path</span> <span class="dt">Rel</span> <span class="dt">Dir</span>)</a>
<a class="sourceLine" id="cb8-3" title="3"><span class="ot">parseAbsFile ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Path</span> <span class="dt">Abs</span> <span class="dt">File</span>)</a>
<a class="sourceLine" id="cb8-4" title="4"><span class="ot">parseRelFile ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Path</span> <span class="dt">Rel</span> <span class="dt">File</span>)</a></code></pre></div>
<p>難しいことはあまり気にせず、(<a href="https://www.stackage.org/haddock/lts-12.7/exceptions-0.10.0/Control-Monad-Catch.html#t:MonadThrow">MonadThrow</a> 型クラスのインスタンスになっている) 色んなモナドで使えるんだなと思えば良いと思います。</p>
<p>実際に <code>ghci</code> を使って動作を確認してみましょう！</p>
<pre class="shel"><code>$ stack repl --package path
&gt; import Path

# 型のチェック
&gt; :t parseAbsDir &quot;/&quot;
parseAbsDir &quot;/&quot; :: MonadThrow m =&gt; m (Path Abs Dir)
&gt; :t parseAbsDir &quot;./&quot;
parseAbsDir &quot;./&quot; :: MonadThrow m =&gt; m (Path Abs Dir)

# IO モナドの文脈
&gt; parseAbsDir &quot;/&quot;
&quot;/&quot;
&gt; parseAbsDir &quot;./&quot;
*** Exception: InvalidAbsDir &quot;./&quot;

# Maybe モナドの文脈
&gt; parseAbsDir &quot;/&quot; :: Maybe (Path Abs Dir)
Just &quot;/&quot;
&gt; parseAbsDir &quot;./&quot; :: Maybe (Path Abs Dir)
Nothing

# 以下のような &quot;../&quot; を含むパスはパーズできない
&gt; parseAbsDir &quot;./../a/b/&quot;
*** Exception: InvalidAbsDir &quot;./../a/b/&quot;
&gt; parseRelDir &quot;./../a/b/&quot;
*** Exception: InvalidAbsDir &quot;./../a/b/&quot;</code></pre>
<p>これで文字列から <code>Path</code> 型に変換する方法がわかりましたね！結構簡単です。</p>
<h4 id="template-haskell-quasiquotes">Template Haskell &amp; QuasiQuotes</h4>
<p>コンパイル時にすでにファイルパスが決まっている時はテンプレートHaskellや準クォートを使うこともできます。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="fu">$</span>(mkAbsDir <span class="st">&quot;/home/chris&quot;</span>)</a>
<a class="sourceLine" id="cb10-2" title="2"><span class="fu">$</span>(mkRelDir <span class="st">&quot;chris&quot;</span>)</a>
<a class="sourceLine" id="cb10-3" title="3"><span class="fu">$</span>(mkAbsFile <span class="st">&quot;/home/chris/x.txt&quot;</span>)</a>
<a class="sourceLine" id="cb10-4" title="4"><span class="fu">$</span>(mkRelFile <span class="st">&quot;chris/x.txt&quot;</span>)</a></code></pre></div>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1">[absdir|/home/chris|]</a>
<a class="sourceLine" id="cb11-2" title="2">[reldir|chris|]</a>
<a class="sourceLine" id="cb11-3" title="3">[absfile|/home/chris/x.txt|]</a>
<a class="sourceLine" id="cb11-4" title="4">[relfile|chris/x.txt|]</a></code></pre></div>
<p>これで不正なパスはコンパイル時エラーとなるため、かなり安全ですね。</p>
<h3 id="path-から-filepath-への変換">Path から FilePath への変換</h3>
<p><code>Path</code> 型の値を <code>FilePath</code> に変換するためには <code>toFilePath</code> 関数を利用します。</p>
<pre class="shell"><code>&gt; toFilePath &lt;$&gt; parseRelDir &quot;./a/b&quot;
&quot;a/b/&quot;

&gt; toFilePath &lt;$&gt; parseRelDir &quot;./a/b/&quot;
&quot;a/b/&quot;

&gt; toFilePath &lt;$&gt; parseRelDir &quot;./a////b//////&quot;
&quot;a/b/&quot;</code></pre>
<p>こんな感じで期待している文字列に変換されているか確かめることができます。</p>
<h3 id="パスの等価性">パスの等価性</h3>
<p>2つの <code>Path</code> の等しさは単純に文字列の等価性として定義されています。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">instance</span> <span class="dt">Eq</span> (<span class="dt">Path</span> b t) <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-2" title="2">  (<span class="fu">==</span>) (<span class="dt">Path</span> x) (<span class="dt">Path</span> y) <span class="fu">=</span> x <span class="fu">==</span> y</a></code></pre></div>
<p>実際にいくつか試してみます。</p>
<pre class="shell"><code>&gt; (==) &lt;$&gt; parseRelDir &quot;./a/b&quot; &lt;*&gt; parseRelDir &quot;./a/b&quot;
True

&gt; (==) &lt;$&gt; parseRelDir &quot;./a/b&quot; &lt;*&gt; parseRelDir &quot;./a/b/c&quot;
False

&gt; (==) &lt;$&gt; parseRelDir &quot;./a/b&quot; &lt;*&gt; parseRelDir &quot;./a/b/&quot;
True</code></pre>
<h3 id="パスの操作">パスの操作</h3>
<p>関数と実行結果のみを紹介していきます。</p>
<h4 id="つのパスの結合">2つのパスの結合</h4>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="ot">(&lt;/&gt;) ::</span> <span class="dt">Path</span> b <span class="dt">Dir</span> <span class="ot">-&gt;</span> <span class="dt">Path</span> <span class="dt">Rel</span> t <span class="ot">-&gt;</span> <span class="dt">Path</span> b t</a></code></pre></div>
<p>第一引数は <strong>Dir</strong> で第二引数は <strong>Rel</strong> が指定されている点に注意してください。そのため、第一引数にファイルへのパスを与えようとするとコンパイルエラーになります。</p>
<pre class="shell"><code>&gt; (&lt;/&gt;) &lt;$&gt; parseRelDir &quot;a/b/c&quot; &lt;*&gt; parseRelFile &quot;a.png&quot;
&quot;a/b/c/a.png&quot;

&gt; (&lt;/&gt;) &lt;$&gt; parseRelDir &quot;a/b/c&quot; &lt;*&gt; parseRelDir &quot;d&quot;
&quot;a/b/c/d/&quot;</code></pre>
<h4 id="パスの先頭部分からディレクトリパスを除去">パスの先頭部分から、ディレクトリパスを除去</h4>
<p>Data.List の <a href="https://www.stackage.org/haddock/lts-12.7/base-4.11.1.0/Data-List.html#v:stripPrefix">stripPrefix</a> 関数と同じように利用できます。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="ot">stripProperPrefix ::</span> <span class="dt">MonadThrow</span> m <span class="ot">=&gt;</span> <span class="dt">Path</span> b <span class="dt">Dir</span> <span class="ot">-&gt;</span> <span class="dt">Path</span> b t <span class="ot">-&gt;</span> m (<span class="dt">Path</span> <span class="dt">Rel</span> t)</a></code></pre></div>
<pre class="shell"><code>&gt; join $ stripProperPrefix &lt;$&gt; parseAbsDir &quot;/usr/local/bin/&quot; &lt;*&gt; parseAbsFile &quot;/usr/local/bin/stack&quot;
&quot;stack&quot;

&gt; join $ stripProperPrefix &lt;$&gt; parseAbsDir &quot;/local/bin/&quot; &lt;*&gt; parseAbsFile &quot;/usr/local/bin/stack&quot;
*** Exception: NotAProperPrefix &quot;/local/bin/&quot; &quot;/usr/local/bin/stack&quot;</code></pre>
<h4 id="パスから親ディレクトリパスを取得">パスから親ディレクトリパスを取得</h4>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1"><span class="ot">parent ::</span> <span class="dt">Path</span> b t <span class="ot">-&gt;</span> <span class="dt">Path</span> b <span class="dt">Dir</span></a></code></pre></div>
<pre class="shell"><code>&gt; parent &lt;$&gt; parseRelFile &quot;ab&quot;
&quot;./&quot;

&gt; parent &lt;$&gt; parseRelFile &quot;./a/b/c/d&quot;
&quot;a/b/c/&quot;</code></pre>
<h4 id="ディレクトリパスから相対ディレクトリパスを取得">ディレクトリパスから、相対ディレクトリパスを取得</h4>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1"><span class="ot">dirname ::</span> <span class="dt">Path</span> b <span class="dt">Dir</span> <span class="ot">-&gt;</span> <span class="dt">Path</span> <span class="dt">Rel</span> <span class="dt">Dir</span></a></code></pre></div>
<pre class="shell"><code>&gt; dirname &lt;$&gt; parseAbsDir &quot;/a/b/c/d&quot;
&quot;d/&quot;

&gt; dirname &lt;$&gt; parseRelDir &quot;./a/b/c/d&quot;
&quot;d/&quot;</code></pre>
<h4 id="ファイルパスから相対ファイルパスを取得">ファイルパスから相対ファイルパスを取得</h4>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" title="1"><span class="ot">filename ::</span> <span class="dt">Path</span> b <span class="dt">File</span> <span class="ot">-&gt;</span> <span class="dt">Path</span> <span class="dt">Rel</span> <span class="dt">File</span></a></code></pre></div>
<pre class="shell"><code>&gt; filename &lt;$&gt; parseAbsFile &quot;/a/b/c/d.png&quot;
&quot;d.png&quot;

&gt; filename &lt;$&gt; parseRelFile &quot;./a/b/c/d.png&quot;
&quot;d.png&quot;</code></pre>
<h4 id="ファイルパスから拡張子を取得">ファイルパスから拡張子を取得</h4>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" title="1"><span class="ot">fileExtension ::</span> <span class="dt">Path</span> b <span class="dt">File</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a></code></pre></div>
<pre class="shell"><code>&gt; fileExtension &lt;$&gt; parseAbsFile &quot;/a/b/c.png&quot;
&quot;.png&quot;

&gt; fileExtension &lt;$&gt; parseRelFile &quot;a/b/c.png&quot;
&quot;.png&quot;</code></pre>
<h4 id="ファイルパスに拡張子を追加">ファイルパスに拡張子を追加</h4>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" title="1"><span class="ot">addFileExtension ::</span> <span class="dt">MonadThrow</span> m <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Path</span> b <span class="dt">File</span> <span class="ot">-&gt;</span> m (<span class="dt">Path</span> b <span class="dt">File</span>)</a>
<a class="sourceLine" id="cb27-2" title="2"></a>
<a class="sourceLine" id="cb27-3" title="3"><span class="co">-- 演算子バージョンとして (&lt;.&gt;) が定義されている</span></a>
<a class="sourceLine" id="cb27-4" title="4"><span class="ot">(&lt;.&gt;) ::</span> <span class="dt">MonadThrow</span> m <span class="ot">=&gt;</span> <span class="dt">Path</span> b <span class="dt">File</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> m (<span class="dt">Path</span> b <span class="dt">File</span>)</a></code></pre></div>
<pre class="shell"><code>&gt; join $ addFileExtension &quot;hs&quot; &lt;$&gt; parseAbsFile &quot;/a/b/c&quot;
&quot;/a/b/c.hs&quot;

&gt; join $ addFileExtension &quot;.hs&quot; &lt;$&gt; parseAbsFile &quot;/a/b/c&quot;
&quot;/a/b/c.hs&quot;

&gt; join $ addFileExtension &quot;.hs&quot; &lt;$&gt; parseRelFile &quot;a/b/c&quot;
&quot;a/b/c.hs&quot;

&gt; join $ addFileExtension &quot;.hs&quot; &lt;$&gt; parseRelFile &quot;a/b/c.rs&quot;
&quot;a/b/c.rs.hs&quot;

&gt; join $ (&lt;.&gt; &quot;.hs&quot;) &lt;$&gt; parseRelFile &quot;a/b/c.rs&quot;
&quot;a/b/c.rs.hs&quot;</code></pre>
<p>既に拡張子があっても、追加する点に注意。</p>
<h4 id="ファイルパスに拡張子を追加-既に拡張子がある場合は置き換える">ファイルパスに拡張子を追加 (既に拡張子がある場合は置き換える)</h4>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" title="1"><span class="ot">setFileExtension ::</span> <span class="dt">MonadThrow</span> m <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Path</span> b <span class="dt">File</span> <span class="ot">-&gt;</span> m (<span class="dt">Path</span> b <span class="dt">File</span>)</a>
<a class="sourceLine" id="cb29-2" title="2"></a>
<a class="sourceLine" id="cb29-3" title="3"><span class="co">-- 演算子バージョンとして (-&lt;.&gt;) が定義されている</span></a>
<a class="sourceLine" id="cb29-4" title="4"><span class="ot">(-&lt;.&gt;) ::</span> <span class="dt">MonadThrow</span> m <span class="ot">=&gt;</span> <span class="dt">Path</span> b <span class="dt">File</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> m (<span class="dt">Path</span> b <span class="dt">File</span>)</a></code></pre></div>
<pre class="shell"><code>&gt; join $ setFileExtension &quot;hs&quot; &lt;$&gt; parseAbsFile &quot;/a/b/c&quot;
&quot;/a/b/c.hs&quot;

&gt; join $ setFileExtension &quot;.hs&quot; &lt;$&gt; parseAbsFile &quot;/a/b/c&quot;
&quot;/a/b/c.hs&quot;

&gt; join $ setFileExtension &quot;.hs&quot; &lt;$&gt; parseRelFile &quot;a/b/c&quot;
&quot;a/b/c.hs&quot;

&gt; join $ setFileExtension &quot;.hs&quot; &lt;$&gt; parseRelFile &quot;a/b/c.rs&quot;
&quot;a/b/c.hs&quot;

&gt; join $ (-&lt;.&gt; &quot;.hs&quot;) &lt;$&gt; parseRelFile &quot;a/b/c.rs&quot;
&quot;a/b/c.hs&quot;</code></pre>
<h2 id="path-io">path-io</h2>
<p>ここまでで <code>Path</code> 型の定義や値の作り方、操作する関数などを見てきました。</p>
<p>しかしながら、これだけでは実際にファイルを作ったり削除したりすることはできません。文字列に変換して <code>directory</code> パッケージを利用することもできますが、やはり <code>Path</code> 型のまま使いたいですよね。</p>
<p>そのためには <a href="https://github.com/mrkkrp/path-io">path-io</a> パッケージを利用すると良いです。内部的には <code>directory</code> パッケージを再利用していますが、<code>Path</code> 型で使えるようにラップしてくれています。(また、便利な関数もいくつか追加されています)</p>
<h3 id="サンプルプログラム">サンプルプログラム</h3>
<p>例えばこんな感じで使えます。以下の例はコマンドライン引数から受け取った文字列に拡張子 <code>.hs</code> を追加して適当な内容で保存し、最後にディレクトリを再帰的にコピーする例です。</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" title="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb31-2" title="2"><span class="co">-- stack script --resolver lts-12.7</span></a>
<a class="sourceLine" id="cb31-3" title="3"><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></a>
<a class="sourceLine" id="cb31-4" title="4"></a>
<a class="sourceLine" id="cb31-5" title="5"><span class="kw">import</span> <span class="dt">Path</span></a>
<a class="sourceLine" id="cb31-6" title="6"><span class="kw">import</span> <span class="dt">Path.IO</span></a>
<a class="sourceLine" id="cb31-7" title="7"></a>
<a class="sourceLine" id="cb31-8" title="8"><span class="kw">import</span> <span class="dt">Control.Monad</span> (when)</a>
<a class="sourceLine" id="cb31-9" title="9"><span class="kw">import</span> <span class="dt">System.Environment</span> (getArgs)</a>
<a class="sourceLine" id="cb31-10" title="10"></a>
<a class="sourceLine" id="cb31-11" title="11"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb31-12" title="12">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb31-13" title="13">  args <span class="ot">&lt;-</span> getArgs</a>
<a class="sourceLine" id="cb31-14" title="14"></a>
<a class="sourceLine" id="cb31-15" title="15">  when (<span class="fu">length</span> args <span class="fu">==</span> <span class="dv">1</span>) <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb31-16" title="16">    <span class="kw">let</span> src  <span class="fu">=</span> <span class="fu">$</span>(mkRelDir <span class="st">&quot;./src&quot;</span>)</a>
<a class="sourceLine" id="cb31-17" title="17">        dest <span class="fu">=</span> <span class="fu">$</span>(mkRelDir <span class="st">&quot;./.backup&quot;</span>)</a>
<a class="sourceLine" id="cb31-18" title="18"></a>
<a class="sourceLine" id="cb31-19" title="19">    <span class="co">-- 安全にディレクトリを作成</span></a>
<a class="sourceLine" id="cb31-20" title="20">    <span class="fu">mapM_</span> ensureDir [src, dest]</a>
<a class="sourceLine" id="cb31-21" title="21"></a>
<a class="sourceLine" id="cb31-22" title="22">    rawName <span class="ot">&lt;-</span> parseRelFile <span class="fu">$</span> <span class="fu">head</span> args</a>
<a class="sourceLine" id="cb31-23" title="23">    fn <span class="ot">&lt;-</span> (src <span class="fu">&lt;/&gt;</span> rawName) <span class="fu">-&lt;.&gt;</span> <span class="st">&quot;hs&quot;</span></a>
<a class="sourceLine" id="cb31-24" title="24"></a>
<a class="sourceLine" id="cb31-25" title="25">    <span class="fu">writeFile</span> (toFilePath fn) <span class="st">&quot;main :: IO ()\nmain = undefined\n&quot;</span></a>
<a class="sourceLine" id="cb31-26" title="26"></a>
<a class="sourceLine" id="cb31-27" title="27">    <span class="co">-- ディレクトリを再帰的にコピー</span></a>
<a class="sourceLine" id="cb31-28" title="28">    copyDirRecur&#39; src dest</a></code></pre></div>
<p>実行結果</p>
<pre class="shell"><code>$ ./Sample.hs aaa

$ tree -a .
.
├── .backup
│   └── aaa.hs
├── Sample.hs
└── src
    └── aaa.hs

2 directories, 3 files

$ cat src/aaa.hs
main :: IO ()
main = undefined

$ cat .backup/aaa.hs
main :: IO ()
main = undefined</code></pre>
<p>動いているようです。</p>
<h2 id="まとめ">まとめ</h2>
<ul>
<li><code>filepath</code> や <code>directory</code> パッケージでは文字列の操作となってしまうため、コンパイル時に不正な利用方法をチェックできない</li>
<li><code>path</code> や <code>path-io</code> は幽霊型を使って不正な利用をコンパイル時にチェックする</li>
<li>実際に <code>stack</code> でも利用されているパッケージ</li>
</ul>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>二分木の操作 (Haskell Quiz No.16)</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/08-12-quiz-16.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/08-12-quiz-16.html</id>
    <published>2018-08-12T00:00:00Z</published>
    <updated>2018-08-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="haskell-quiz-no.16">Haskell Quiz No.16</h2>
<p>難易度: λλ</p>
<p>以下のような二分木の定義があります。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="fu">=</span> <span class="dt">Leaf</span> a</a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="fu">|</span> <span class="dt">Node</span> (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</a></code></pre></div>
<p>以下の操作を定義してみましょう！</p>
<h3 id="部分木を左右反転させた木を返す関数">(1) 部分木を左右反転させた木を返す関数</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="ot">mirror ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb2-2" title="2">mirror <span class="fu">=</span> <span class="fu">undefined</span></a></code></pre></div>
<p><img style="width: 45%" src="/images/2018/08-12/mirror_before.svg" alt="mirror 関数適用前"> → <img style="width: 45%" src="/images/2018/08-12/mirror_after.svg" alt="mirror 関数適用後"></p>
<p>左の木に <strong>mirror</strong> 関数を適用すると、右の木を返します。</p>
<h3 id="木の高さを計算する関数">(2) 木の高さを計算する関数</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">depth ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb3-2" title="2">depth <span class="fu">=</span> <span class="fu">undefined</span></a></code></pre></div>
<p><img style="width: 45%" src="/images/2018/08-12/mirror_before.svg" alt="depth"></p>
<p><strong>depth</strong> 関数で上記の木の高さを計算すると <strong>3</strong> になります。</p>
<h3 id="木が平衡かチェックする関数">(3) 木が平衡かチェックする関数</h3>
<ul>
<li>平衡の定義: 左右の部分木の高さが高々1しか違わない</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="ot">isBalanced ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb4-2" title="2">isBalanced <span class="fu">=</span> <span class="fu">undefined</span></a></code></pre></div>
<p><img style="width: 45%" src="/images/2018/08-12/mirror_before.svg" alt="isBalanced"></p>
<p>上記の木は <strong>平衡</strong> です。</p>
<p>さらに <a href="https://www.stackage.org/haddock/lts-12.5/base-4.11.1.0/Prelude.html#t:Functor">Functor</a> と <a href="https://www.stackage.org/haddock/lts-12.5/base-4.11.1.0/Prelude.html#t:Foldable">Foldable</a> のインスタンスを定義してみましょう！(ここでは <a href="https://www.stackage.org/haddock/lts-12.5/base-4.11.1.0/Prelude.html#v:fmap">fmap</a> と <a href="https://www.stackage.org/haddock/lts-12.5/base-4.11.1.0/Prelude.html#v:foldMap">foldMap</a> を定義することにします。)</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">instance</span> <span class="dt">Functor</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> b</a>
<a class="sourceLine" id="cb5-3" title="3">  <span class="fu">fmap</span> <span class="fu">=</span> <span class="fu">undefined</span></a>
<a class="sourceLine" id="cb5-4" title="4"></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="kw">instance</span> <span class="dt">Foldable</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="ot">  foldMap ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> m</a>
<a class="sourceLine" id="cb5-7" title="7">  <span class="fu">foldMap</span> <span class="fu">=</span> <span class="fu">undefined</span></a></code></pre></div>
<p>答えは次回。</p>
<p>※ 図の作成には <a href="https://mermaidjs.github.io/">mermaid</a>というツールを使っています。</p>
<h3 id="参考">参考</h3>
<ul>
<li>Programming in Haskell (14.2 Foldables and friends)</li>
<li>関数プログラミング入門 Haskell で学ぶ原理と技法 (8.3.2 木による表現)</li>
<li><a href="http://www.cis.syr.edu/courses/cis623/p2.html">CIS 623</a></li>
</ul>
<!--more-->
<h2 id="はじめに">はじめに</h2>
<p><a href="./07-24-quiz-15.html">前回</a>の問題と答えは以下の通りです。</p>
<h3 id="問題">問題</h3>
<p>難易度: λ</p>
<p>葉に<strong>だけ</strong>値を持つような<strong>二分木</strong>を定義してみてください！</p>
<p>図で書くとこんな感じです。</p>
<p><img src="/images/2018/07-24/tree.svg" alt="木の図" width="50%"></p>
<h3 id="こたえ">こたえ</h3>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">data</span> <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="fu">=</span> <span class="dt">Leaf</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb6-3" title="3">  <span class="fu">|</span> <span class="dt">Node</span> <span class="dt">Tree</span> <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb6-4" title="4"></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="co">-- より一般的な定義</span></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb6-7" title="7">  <span class="fu">=</span> <span class="dt">Leaf</span> a</a>
<a class="sourceLine" id="cb6-8" title="8">  <span class="fu">|</span> <span class="dt">Node</span> (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</a></code></pre></div>
<h3 id="解説">解説</h3>
<p>この定義を使って図の木を作るとこんな感じになります。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="ot">t ::</span> <span class="dt">Tree</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-2" title="2">t <span class="fu">=</span> <span class="dt">Node</span> t1 t3</a>
<a class="sourceLine" id="cb7-3" title="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-4" title="4">    t1 <span class="fu">=</span> <span class="dt">Node</span> (<span class="dt">Leaf</span> <span class="dv">1</span>) t2</a>
<a class="sourceLine" id="cb7-5" title="5">    t2 <span class="fu">=</span> <span class="dt">Node</span> (<span class="dt">Leaf</span> <span class="dv">2</span>) (<span class="dt">Leaf</span> <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb7-6" title="6">    t3 <span class="fu">=</span> <span class="dt">Node</span> (<span class="dt">Leaf</span> <span class="dv">4</span>) (<span class="dt">Leaf</span> <span class="dv">5</span>)</a></code></pre></div>
<p><strong>where</strong> を使わない場合はこんな感じです。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">intTree ::</span> <span class="dt">Tree</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-2" title="2">intTree <span class="fu">=</span></a>
<a class="sourceLine" id="cb8-3" title="3">  <span class="dt">Node</span></a>
<a class="sourceLine" id="cb8-4" title="4">    (<span class="dt">Node</span></a>
<a class="sourceLine" id="cb8-5" title="5">      (<span class="dt">Leaf</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb8-6" title="6">      (<span class="dt">Node</span></a>
<a class="sourceLine" id="cb8-7" title="7">        (<span class="dt">Leaf</span> <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb8-8" title="8">        (<span class="dt">Leaf</span> <span class="dv">3</span>)))</a>
<a class="sourceLine" id="cb8-9" title="9">    (<span class="dt">Node</span></a>
<a class="sourceLine" id="cb8-10" title="10">      (<span class="dt">Leaf</span> <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb8-11" title="11">      (<span class="dt">Leaf</span> <span class="dv">5</span>))</a></code></pre></div>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>(^>>) と (>>^)</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/08-07-arrow-operators.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/08-07-arrow-operators.html</id>
    <published>2018-08-07T00:00:00Z</published>
    <updated>2018-08-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p><a href="https://www.stackage.org/haddock/lts-12.5/base-4.11.1.0/Control-Arrow.html#">Control.Arrow</a> モジュールに <a href="https://www.stackage.org/haddock/lts-12.5/base-4.11.1.0/Control-Arrow.html#v:-94--62--62-">(^&gt;&gt;)</a> と <a href="https://www.stackage.org/haddock/lts-12.5/base-4.11.1.0/Control-Arrow.html#v:-62--62--94-">(&gt;&gt;^)</a> という演算子が定義されています。</p>
<p>ちょっとだけ面白かったので紹介しようと思います。</p>
<!--more-->
<h2 id="準備">準備</h2>
<p>例として、文字列を全て<strong>大文字</strong>に変換する関数を考えてみましょう。</p>
<p>素朴に書けばこんな感じでしょうか。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">import</span> <span class="dt">Data.Char</span> (toUpper)</a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="ot">toAllUpper ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb1-4" title="4">toAllUpper <span class="fu">=</span> <span class="fu">map</span> <span class="fu">toUpper</span></a></code></pre></div>
<p>この関数は以下のように期待通りに動きます。</p>
<pre class="shell"><code>*Main&gt; toAllUpper &quot;B|g0on&quot;
&quot;B|G0ON&quot;</code></pre>
<p>ではここで、同じように <code>Text</code> バージョンを作りたいと思います。何も考えずに pack と unpack を使えばすぐ定義できますね。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">import</span>           <span class="dt">Data.Char</span> (toUpper)</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">import</span>           <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="ot">toAllUpper ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb3-6" title="6">toAllUpper <span class="fu">=</span> <span class="fu">map</span> <span class="fu">toUpper</span></a>
<a class="sourceLine" id="cb3-7" title="7"></a>
<a class="sourceLine" id="cb3-8" title="8"><span class="ot">toAllUpperText ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb3-9" title="9">toAllUpperText <span class="fu">=</span> T.pack <span class="fu">.</span> toAllUpper <span class="fu">.</span> T.unpack</a></code></pre></div>
<p>この関数も同様にちゃんと動きます。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> toAllUpperText <span class="fu">$</span> T.pack <span class="st">&quot;B|g0on&quot;</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="st">&quot;B|G0ON&quot;</span></a></code></pre></div>
<h2 id="と-を無理矢理使ってみる">(^&gt;&gt;) と (&gt;&gt;^) を無理矢理使ってみる</h2>
<p>先程定義した <code>toAllUpperText</code> 関数は <code>(^&gt;&gt;)</code> と <code>(&gt;&gt;^)</code> を使って、以下のように書き直すことができます。(<code>Control.Arrow</code> をインポートする必要があります。)</p>
<p>左から右バージョン</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="ot">toAllUpperText&#39; ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb5-2" title="2">toAllUpperText&#39; <span class="fu">=</span> T.unpack <span class="fu">^&gt;&gt;</span> toAllUpper <span class="fu">&gt;&gt;^</span> T.pack</a></code></pre></div>
<p>右から左バージョン</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="ot">toAllUpperText&#39;&#39; ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb6-2" title="2">toAllUpperText&#39;&#39; <span class="fu">=</span> T.pack <span class="fu">&lt;&lt;^</span> toAllUpper <span class="fu">^&lt;&lt;</span> T.unpack</a></code></pre></div>
<p>関数合成 (<code>.</code>) を単純に置き換えただけです・・・。</p>
<h3 id="型">型</h3>
<p>この演算子の何が面白いかと言うと、<strong>入力</strong>と<strong>出力</strong>をそれぞれ変換できるんですね！</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="ot">(^&gt;&gt;) ::</span> <span class="dt">Arrow</span> a <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> a c d <span class="ot">-&gt;</span> a b d</a>
<a class="sourceLine" id="cb7-2" title="2"><span class="ot">(&gt;&gt;^) ::</span> <span class="dt">Arrow</span> a <span class="ot">=&gt;</span> a b c <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> a b d</a></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">(&lt;&lt;^) ::</span> <span class="dt">Arrow</span> a <span class="ot">=&gt;</span> a c d <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> a b d</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="ot">(^&lt;&lt;) ::</span> <span class="dt">Arrow</span> a <span class="ot">=&gt;</span> (c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> a b c <span class="ot">-&gt;</span> a b d</a></code></pre></div>
<p>先程の例は <code>Arrow a</code> の <code>a</code> を関数型 <code>(-&gt;)</code> として具体化したものになります。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="ot">(^&gt;&gt;) ::</span> <span class="dt">Arrow</span> a <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> a c d <span class="ot">-&gt;</span> a b d</a>
<a class="sourceLine" id="cb9-2" title="2">  <span class="co">-- a = (-&gt;) として具体化した</span></a>
<a class="sourceLine" id="cb9-3" title="3">    (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (<span class="ot">-&gt;</span>) c d <span class="ot">-&gt;</span> (<span class="ot">-&gt;</span>) b d</a>
<a class="sourceLine" id="cb9-4" title="4">  <span class="fu">=</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> d)</a></code></pre></div>
<p>引数の順番を逆にすれば関数合成の型と同じですね。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1">  <span class="fu">=</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> d)</a>
<a class="sourceLine" id="cb10-2" title="2">  <span class="co">-- 引数を逆にした</span></a>
<a class="sourceLine" id="cb10-3" title="3">  (c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> d)</a>
<a class="sourceLine" id="cb10-4" title="4">  <span class="co">-- 変数名の変更</span></a>
<a class="sourceLine" id="cb10-5" title="5">  <span class="fu">=</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb10-6" title="6"></a>
<a class="sourceLine" id="cb10-7" title="7"><span class="ot">(.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> c)</a></code></pre></div>
<h2 id="まとめ">まとめ</h2>
<ul>
<li>現実世界で Arrow をバリバリ使っているコードをみかけることは (僕は) 全く無いです。(Hakyll は過去に Arrow ベースで定義されていたようですが、Monad ベースに切り替わりました)</li>
</ul>
<p>たぶん使うことは無いですが、パズルみたいで楽しい。</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Yesod には脆弱性があるのかな？</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/07-31-yesodsecurity.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/07-31-yesodsecurity.html</id>
    <published>2018-07-31T00:00:00Z</published>
    <updated>2018-07-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p><a href="https://www.yesodweb.com/">Yesod</a> は Haskell で書かれた Web アプリケーションフレームワークです。</p>
<p>WordPress や Drupal と違って、セキュリティはかなり万全です。(ユーザが気にしなければならない部分が非常に少ないです)</p>
<p>最近、<a href="https://www.sbcr.jp/products/4797393163.html">体系的に学ぶ 安全なWebアプリケーションの作り方 第2版 (通称: 徳丸本)</a> が発売されました。</p>
<p>勉強のため、本書の内容を Yesod で確認しているのですが、その中で面白い例を見つけました。</p>
<p>今回はその内容について紹介したいと思います。(セキュリティの専門家ではないので間違いがあればご指摘ください)</p>
<!--more-->
<h2 id="脆弱性のあるコード">脆弱性のあるコード</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="co">-- stack script --resolver lts-12.4</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="ot">{-# LANGUAGE OverloadedStrings     #-}</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="ot">{-# LANGUAGE QuasiQuotes           #-}</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="ot">{-# LANGUAGE TemplateHaskell       #-}</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="ot">{-# LANGUAGE TypeFamilies          #-}</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="kw">import</span>           <span class="dt">Yesod</span></a>
<a class="sourceLine" id="cb1-8" title="8"></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="kw">data</span> <span class="dt">App</span> <span class="fu">=</span> <span class="dt">App</span></a>
<a class="sourceLine" id="cb1-10" title="10"></a>
<a class="sourceLine" id="cb1-11" title="11">mkYesod <span class="st">&quot;App&quot;</span> [parseRoutes|</a>
<a class="sourceLine" id="cb1-12" title="12">/ HomeR GET</a>
<a class="sourceLine" id="cb1-13" title="13">|]</a>
<a class="sourceLine" id="cb1-14" title="14"></a>
<a class="sourceLine" id="cb1-15" title="15"><span class="kw">instance</span> <span class="dt">Yesod</span> <span class="dt">App</span></a>
<a class="sourceLine" id="cb1-16" title="16"></a>
<a class="sourceLine" id="cb1-17" title="17"><span class="ot">getHomeR ::</span> <span class="dt">Handler</span> <span class="dt">Html</span></a>
<a class="sourceLine" id="cb1-18" title="18">getHomeR <span class="fu">=</span> defaultLayout <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-19" title="19">  mname <span class="ot">&lt;-</span> lookupGetParam <span class="st">&quot;name&quot;</span></a>
<a class="sourceLine" id="cb1-20" title="20"></a>
<a class="sourceLine" id="cb1-21" title="21">  [whamlet|</a>
<a class="sourceLine" id="cb1-22" title="22">    <span class="kw">$maybe</span> name <span class="ot">&lt;-</span> mname</a>
<a class="sourceLine" id="cb1-23" title="23">      <span class="kw">&lt;img</span><span class="ot"> onload=</span><span class="st">&quot;init(&#39;#{name}&#39;)&quot;</span><span class="ot"> src=</span><span class="st">&quot;https://www.yesodweb.com/static/logo-home2-no-esod-smaller2.png&quot;</span><span class="kw">&gt;</span></a>
<a class="sourceLine" id="cb1-24" title="24">    <span class="kw">$nothing</span></a>
<a class="sourceLine" id="cb1-25" title="25">      パラメータが設定されていません。</a>
<a class="sourceLine" id="cb1-26" title="26">  |]</a>
<a class="sourceLine" id="cb1-27" title="27"></a>
<a class="sourceLine" id="cb1-28" title="28">  toWidget [julius|</a>
<a class="sourceLine" id="cb1-29" title="29">    <span class="kw">function</span> <span class="at">init</span>(text) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-30" title="30">      <span class="co">// 何かしらの処理</span></a>
<a class="sourceLine" id="cb1-31" title="31">    <span class="op">}</span></a>
<a class="sourceLine" id="cb1-32" title="32">  |]</a>
<a class="sourceLine" id="cb1-33" title="33"></a>
<a class="sourceLine" id="cb1-34" title="34"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-35" title="35">main <span class="fu">=</span> warp <span class="dv">3000</span> <span class="dt">App</span></a></code></pre></div>
<p>このコードには脆弱性があります。</p>
<p><strong>Yesod</strong> の変数展開 <code>#{..}</code> は、このような <strong>JavaScript</strong> の動的生成でも大丈夫だろうと思っていたのですが、そうではありませんでした。</p>
<h3 id="正常系">正常系</h3>
<p>期待する動作として、例えば <code>http://localhost/?name=bigmoon</code> いう形式の <strong>URL</strong> にアクセスすると、以下のような URL が組み立てられます。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode html"><code class="sourceCode html"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">&lt;img</span><span class="ot"> onload=</span><span class="st">&quot;init(&#39;bigmoon&#39;)&quot;</span><span class="ot"> src=</span><span class="st">&quot;...&quot;</span><span class="kw">&gt;</span></a></code></pre></div>
<p>これは予定通りです。</p>
<h3 id="異常系">異常系</h3>
<p><strong>URL</strong> の形式を <code>http://localhost/?name=%27),alert(XSS)//</code> とするとインジェクションが発生します。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode html"><code class="sourceCode html"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">&lt;img</span><span class="ot"> onload=</span><span class="st">&quot;init(&#39;%27),alert(XSS)//&#39;)&quot;</span><span class="ot"> src=</span><span class="st">&quot;...&quot;</span><span class="kw">&gt;</span></a></code></pre></div>
<p>読みやすさのため、パーセントエンコーディングを元に戻します。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode html"><code class="sourceCode html"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">&lt;img</span><span class="ot"> onload=</span><span class="st">&quot;init(&#39;&#39;),alert(XSS)//&#39;)&quot;</span><span class="ot"> src=</span><span class="st">&quot;...&quot;</span><span class="kw">&gt;</span></a></code></pre></div>
<p><code>alert</code> が出てきてしまいましたね・・・。</p>
<p>余談ですが <strong>Yesod</strong> ではパラメータ中に出現する <code>;</code> をパラメータの区切り文字として認識するようです。そのため <code>http://localhost/?name=%27);alert(XSS)//</code> ではインジェクションは発生しません。</p>
<h2 id="原因">原因</h2>
<p>問題はどこにあるのでしょうか？</p>
<p>パラメータを取得しているコードはこの部分です。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1">mname <span class="ot">&lt;-</span> lookupGetParam <span class="st">&quot;name&quot;</span></a></code></pre></div>
<p><a href="https://www.stackage.org/haddock/lts-12.4/yesod-core-1.6.6/Yesod-Core-Handler.html#v:lookupGetParam">lookupGetParam</a> の型は以下の通りです。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="ot">lookupGetParam ::</span> <span class="dt">MonadHandler</span> m <span class="ot">=&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> <span class="dt">Text</span>)</a></code></pre></div>
<p>つまり、<code>mname :: Maybe Text</code> 型となってしまいます。ここが問題の原因です。</p>
<p>ただの <strong>Text</strong> 型なので変数展開時に <strong>HTMLのエスケープ処理</strong> が行われます。本来ならば <strong>JavaScript</strong> 用のエスケープ処理が必要なのです。</p>
<h2 id="展開部分を改良してみる">展開部分を改良してみる</h2>
<p>では <strong>Javascript</strong> 型に変換すれば問題は解決するのでしょうか？</p>
<p>試しに以下のようにコードを変更してみました。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="fu">&lt;</span>img onload<span class="fu">=</span><span class="st">&quot;init(&#39;#{renderJavascript $ toJavascript $ rawJS $ name}&#39;)&quot;</span> src<span class="fu">=</span><span class="st">&quot;...&quot;</span><span class="fu">&gt;</span></a></code></pre></div>
<p>ですが、やはり結果は同じです。</p>
<h2 id="エスケープ処理">エスケープ処理</h2>
<p>ソースコードを追いかけてみるとどうやら <strong>Value</strong> の値については <a href="https://www.stackage.org/haddock/lts-12.4/shakespeare-2.0.15/src/Text.Julius.html#string">string</a> というサニタイザーが適用されるようです。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">string ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">Builder</span></a>
<a class="sourceLine" id="cb8-2" title="2">string s <span class="fu">=</span> <span class="ot">{-# SCC &quot;string&quot; #-}</span> singleton <span class="ch">&#39;&quot;&#39;</span> <span class="fu">&lt;&gt;</span> quote s <span class="fu">&lt;&gt;</span> singleton <span class="ch">&#39;&quot;&#39;</span></a>
<a class="sourceLine" id="cb8-3" title="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-4" title="4">    quote q <span class="fu">=</span> <span class="kw">case</span> T.uncons t <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-5" title="5">                <span class="dt">Nothing</span>      <span class="ot">-&gt;</span> fromText h</a>
<a class="sourceLine" id="cb8-6" title="6">                <span class="dt">Just</span> (<span class="fu">!</span>c,t&#39;) <span class="ot">-&gt;</span> fromText h <span class="fu">&lt;&gt;</span> escape c <span class="fu">&lt;&gt;</span> quote t&#39;</a>
<a class="sourceLine" id="cb8-7" title="7">        <span class="kw">where</span> (h,t) <span class="fu">=</span> <span class="ot">{-# SCC &quot;break&quot; #-}</span> T.break isEscape q</a>
<a class="sourceLine" id="cb8-8" title="8">    isEscape c <span class="fu">=</span> c <span class="fu">==</span> <span class="ch">&#39;\&quot;&#39;</span> <span class="fu">||</span></a>
<a class="sourceLine" id="cb8-9" title="9">                 c <span class="fu">==</span> <span class="ch">&#39;\\&#39;</span> <span class="fu">||</span></a>
<a class="sourceLine" id="cb8-10" title="10">                 c <span class="fu">==</span> <span class="ch">&#39;&lt;&#39;</span>  <span class="fu">||</span></a>
<a class="sourceLine" id="cb8-11" title="11">                 c <span class="fu">==</span> <span class="ch">&#39;&gt;&#39;</span>  <span class="fu">||</span></a>
<a class="sourceLine" id="cb8-12" title="12">                 c <span class="fu">==</span> <span class="ch">&#39;&amp;&#39;</span>  <span class="fu">||</span></a>
<a class="sourceLine" id="cb8-13" title="13">                 c <span class="fu">&lt;</span> <span class="ch">&#39;\x20&#39;</span></a>
<a class="sourceLine" id="cb8-14" title="14">    escape <span class="ch">&#39;\&quot;&#39;</span> <span class="fu">=</span> <span class="st">&quot;\\\&quot;&quot;</span></a>
<a class="sourceLine" id="cb8-15" title="15">    escape <span class="ch">&#39;\\&#39;</span> <span class="fu">=</span> <span class="st">&quot;\\\\&quot;</span></a>
<a class="sourceLine" id="cb8-16" title="16">    escape <span class="ch">&#39;\n&#39;</span> <span class="fu">=</span> <span class="st">&quot;\\n&quot;</span></a>
<a class="sourceLine" id="cb8-17" title="17">    escape <span class="ch">&#39;\r&#39;</span> <span class="fu">=</span> <span class="st">&quot;\\r&quot;</span></a>
<a class="sourceLine" id="cb8-18" title="18">    escape <span class="ch">&#39;\t&#39;</span> <span class="fu">=</span> <span class="st">&quot;\\t&quot;</span></a>
<a class="sourceLine" id="cb8-19" title="19">    escape <span class="ch">&#39;&lt;&#39;</span> <span class="fu">=</span> <span class="st">&quot;\\u003c&quot;</span></a>
<a class="sourceLine" id="cb8-20" title="20">    escape <span class="ch">&#39;&gt;&#39;</span> <span class="fu">=</span> <span class="st">&quot;\\u003e&quot;</span></a>
<a class="sourceLine" id="cb8-21" title="21">    escape <span class="ch">&#39;&amp;&#39;</span> <span class="fu">=</span> <span class="st">&quot;\\u0026&quot;</span></a>
<a class="sourceLine" id="cb8-22" title="22"></a>
<a class="sourceLine" id="cb8-23" title="23">    escape c</a>
<a class="sourceLine" id="cb8-24" title="24">        <span class="fu">|</span> c <span class="fu">&lt;</span> <span class="ch">&#39;\x20&#39;</span> <span class="fu">=</span> fromString <span class="fu">$</span> <span class="st">&quot;\\u&quot;</span> <span class="fu">++</span> <span class="fu">replicate</span> (<span class="dv">4</span> <span class="fu">-</span> <span class="fu">length</span> h) <span class="ch">&#39;0&#39;</span> <span class="fu">++</span> h</a>
<a class="sourceLine" id="cb8-25" title="25">        <span class="fu">|</span> <span class="fu">otherwise</span>  <span class="fu">=</span> singleton c</a>
<a class="sourceLine" id="cb8-26" title="26">        <span class="kw">where</span> h <span class="fu">=</span> showHex (<span class="fu">fromEnum</span> c) <span class="st">&quot;&quot;</span></a></code></pre></div>
<p>なので、先程のコードを少し修正してこの <code>string</code> を適用してみました。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="fu">&lt;</span>img onload<span class="fu">=</span><span class="st">&quot;init(&#39;#{renderJavascript $ toJavascript $ rawJS $ string $ name}&#39;)&quot;</span> src<span class="fu">=</span><span class="st">&quot;...&quot;</span><span class="fu">&gt;</span></a></code></pre></div>
<p>しかし、これでもやっぱりだめです。なぜなら <code>'</code> に対してはサニタイズしていないからだと思います。</p>
<h3 id="string-関数の修正">string 関数の修正</h3>
<p>以下のように <code>'</code> のエスケープ処理を追加したところ、インジェクションが発生しなくなりました。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1">isEscape c <span class="fu">=</span> c <span class="fu">==</span> <span class="ch">&#39;\&quot;&#39;</span> <span class="fu">||</span></a>
<a class="sourceLine" id="cb10-2" title="2">             c <span class="fu">==</span> <span class="ch">&#39;\\&#39;</span> <span class="fu">||</span></a>
<a class="sourceLine" id="cb10-3" title="3">             c <span class="fu">==</span> <span class="ch">&#39;&lt;&#39;</span>  <span class="fu">||</span></a>
<a class="sourceLine" id="cb10-4" title="4">             c <span class="fu">==</span> <span class="ch">&#39;&gt;&#39;</span>  <span class="fu">||</span></a>
<a class="sourceLine" id="cb10-5" title="5">             c <span class="fu">==</span> <span class="ch">&#39;&amp;&#39;</span>  <span class="fu">||</span></a>
<a class="sourceLine" id="cb10-6" title="6">             c <span class="fu">==</span> <span class="ch">&#39;\&#39;&#39;</span> <span class="fu">||</span> <span class="co">-- 追記</span></a>
<a class="sourceLine" id="cb10-7" title="7">             c <span class="fu">&lt;</span> <span class="ch">&#39;\x20&#39;</span></a>
<a class="sourceLine" id="cb10-8" title="8"></a>
<a class="sourceLine" id="cb10-9" title="9">escape <span class="ch">&#39;\&quot;&#39;</span> <span class="fu">=</span> <span class="st">&quot;\\\&quot;&quot;</span></a>
<a class="sourceLine" id="cb10-10" title="10">escape <span class="ch">&#39;\\&#39;</span> <span class="fu">=</span> <span class="st">&quot;\\\\&quot;</span></a>
<a class="sourceLine" id="cb10-11" title="11">escape <span class="ch">&#39;\n&#39;</span> <span class="fu">=</span> <span class="st">&quot;\\n&quot;</span></a>
<a class="sourceLine" id="cb10-12" title="12">escape <span class="ch">&#39;\r&#39;</span> <span class="fu">=</span> <span class="st">&quot;\\r&quot;</span></a>
<a class="sourceLine" id="cb10-13" title="13">escape <span class="ch">&#39;\t&#39;</span> <span class="fu">=</span> <span class="st">&quot;\\t&quot;</span></a>
<a class="sourceLine" id="cb10-14" title="14">escape <span class="ch">&#39;&lt;&#39;</span> <span class="fu">=</span> <span class="st">&quot;\\u003c&quot;</span></a>
<a class="sourceLine" id="cb10-15" title="15">escape <span class="ch">&#39;&gt;&#39;</span> <span class="fu">=</span> <span class="st">&quot;\\u003e&quot;</span></a>
<a class="sourceLine" id="cb10-16" title="16">escape <span class="ch">&#39;&amp;&#39;</span> <span class="fu">=</span> <span class="st">&quot;\\u0026&quot;</span></a>
<a class="sourceLine" id="cb10-17" title="17"><span class="co">-- 追記</span></a>
<a class="sourceLine" id="cb10-18" title="18">escape <span class="ch">&#39;\&#39;&#39;</span> <span class="fu">=</span> <span class="st">&quot;\\\&#39;&quot;</span></a></code></pre></div>
<h2 id="まとめ">まとめ</h2>
<ul>
<li><strong>JavaScript</strong> を動的に組み立てない</li>
<li>ユーザが気をつけなけば <strong>Yesod</strong> でも脆弱性が発生する</li>
<li>変数展開で全てがエスケープされると思っていたが、場所によってはそれだけでは不十分な場合がある</li>
</ul>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>二分木 (Haskell Quiz No.15)</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/07-24-quiz-15.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/07-24-quiz-15.html</id>
    <published>2018-07-24T00:00:00Z</published>
    <updated>2018-07-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="haskell-quiz-no.15">Haskell Quiz No.15</h2>
<p>難易度: λ</p>
<p>葉に<strong>だけ</strong>値を持つような<strong>二分木</strong>を定義してみてください！</p>
<p>図で書くとこんな感じです。</p>
<p><img src="/images/2018/07-24/tree.svg" alt="木の図" width="50%"></p>
<p>答えは<a href="./08-12-quiz-16.html">次回</a>。</p>
<p>この図は <strong>mermaid</strong> というツールを使って書きました。</p>
<ul>
<li><a href="https://mermaidjs.github.io/">mermaid</a></li>
<li><a href="https://mermaidjs.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoiZ3JhcGggVERcbkEoKE5vZGUpKVxuQSAtLT4gQjEoKE5vZGUpKVxuQjEgLS0-IEMxW0xlYWYgMV1cbkIxIC0tPiBEMSgoTm9kZSkpXG5EMSAtLT4gRTFbTGVhZiAyXVxuRDEgLS0-IEUyW0xlYWYgM11cblxuQSAtLT4gQjIoKE5vZGUpKVxuQjIgLS0-IEMyW0xlYWYgNF1cbkIyIC0tPiBDM1tMZWFmIDVdIiwibWVybWFpZCI6eyJ0aGVtZSI6ImZvcmVzdCJ9fQ">Mermaid Live Editor</a></li>
</ul>
<!--more-->
<h2 id="はじめに">はじめに</h2>
<p><a href="./07-16-quiz-14.html">前回</a>の問題と答えは以下の通りです。</p>
<h3 id="問題">問題</h3>
<p>難易度: λ</p>
<p><code>utf8.txt</code> と <code>shift-jis.txt</code> はそれぞれ <code>utf8</code> と <code>shift-jis</code> で保存されたテキストファイルです。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">bad ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-2" title="2">bad <span class="fu">=</span> <span class="fu">readFile</span> <span class="st">&quot;./shift-jis.txt&quot;</span> <span class="fu">&gt;&gt;=</span> <span class="fu">putStrLn</span></a>
<a class="sourceLine" id="cb1-3" title="3"></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="ot">good ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-5" title="5">good <span class="fu">=</span> <span class="fu">readFile</span> <span class="st">&quot;./utf8.txt&quot;</span> <span class="fu">&gt;&gt;=</span> <span class="fu">putStrLn</span></a></code></pre></div>
<p>上記のプログラムを実行すると、こんな感じでエラーになってしまいます。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> good</a>
<a class="sourceLine" id="cb2-2" title="2">はすける</a>
<a class="sourceLine" id="cb2-3" title="3"></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> bad</a>
<a class="sourceLine" id="cb2-5" title="5"><span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> <span class="fu">./</span>shift<span class="fu">-</span>jis<span class="fu">.</span>txt<span class="fu">:</span> hGetContents<span class="fu">:</span> invalid argument (invalid byte <span class="fu">sequence</span>)</a></code></pre></div>
<p><code>shift-jis</code> で保存されたテキストファイルを読むにはどうしたら良いでしょうか？</p>
<h3 id="こたえ">こたえ</h3>
<p>色々ありそうですが、ここでは <a href="https://www.stackage.org/haddock/lts-12.2/base-4.11.1.0/GHC-IO-Handle.html#v:hSetEncoding">hSetEncoding</a> を使う方法を解答の一例としておきます。</p>
<p>ここでは Windows で保存された <strong>shift-jis</strong> を扱うために <code>cp932</code> にしていますが、通常の <strong>shift-jis</strong> であれば <code>mkTextEncoding &quot;shift-jis&quot;</code> で大丈夫です。(たぶん)</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="co">-- stack script --resolver lts-12.2</span></a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="kw">import</span> <span class="dt">System.IO</span></a>
<a class="sourceLine" id="cb3-5" title="5"></a>
<a class="sourceLine" id="cb3-6" title="6"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-7" title="7">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-8" title="8">  h <span class="ot">&lt;-</span> openFile <span class="st">&quot;./shift-jis.txt&quot;</span> <span class="dt">ReadMode</span></a>
<a class="sourceLine" id="cb3-9" title="9">  cp932 <span class="ot">&lt;-</span> mkTextEncoding <span class="st">&quot;cp932&quot;</span></a>
<a class="sourceLine" id="cb3-10" title="10">  hSetEncoding h cp932</a>
<a class="sourceLine" id="cb3-11" title="11">  content <span class="ot">&lt;-</span> hGetContents h</a>
<a class="sourceLine" id="cb3-12" title="12"></a>
<a class="sourceLine" id="cb3-13" title="13">  <span class="fu">putStrLn</span> content</a></code></pre></div>
<pre class="shell"><code>$ ./Ans1.hs
はすける</code></pre>
<p><a href="https://www.stackage.org/package/extra">extra</a> パッケージの <a href="https://www.stackage.org/haddock/lts-12.2/extra-1.6.9/System-IO-Extra.html#v:readFileEncoding">readFileEncoding</a> を使えばもっとすっきり書くことができます。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="co">-- stack script --resolver lts-12.2</span></a>
<a class="sourceLine" id="cb5-3" title="3"></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="kw">import</span> <span class="dt">System.IO.Extra</span></a>
<a class="sourceLine" id="cb5-5" title="5"></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb5-7" title="7">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-8" title="8">  cp932 <span class="ot">&lt;-</span> mkTextEncoding <span class="st">&quot;cp932&quot;</span></a>
<a class="sourceLine" id="cb5-9" title="9">  content <span class="ot">&lt;-</span> readFileEncoding cp932 <span class="st">&quot;./shift-jis.txt&quot;</span></a>
<a class="sourceLine" id="cb5-10" title="10">  <span class="fu">putStrLn</span> content</a></code></pre></div>
<h3 id="解説">解説</h3>
<p>理解を深めるために <a href="https://www.stackage.org/haddock/lts-12.2/base-4.11.1.0/Prelude.html#v:readFile">readFile</a> 関数がどのように定義されているか確認してみましょう！</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="fu">readFile</span><span class="ot"> ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="fu">readFile</span> name <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-3" title="3">  h <span class="ot">&lt;-</span> openFile name <span class="dt">ReadMode</span></a>
<a class="sourceLine" id="cb6-4" title="4">  hGetContents h</a></code></pre></div>
<p>なるほど。<a href="https://www.stackage.org/haddock/lts-12.2/base-4.11.1.0/System-IO.html#v:ReadMode">ReadMode</a> でファイルハンドルを取得し、<a href="https://www.stackage.org/haddock/lts-12.2/base-4.11.1.0/System-IO.html#v:hGetContents">hGetContents</a> でファイルの内容を返しているようです。</p>
<p>解答例ではこの処理の間に <a href="https://www.stackage.org/haddock/lts-12.2/base-4.11.1.0/System-IO.html#v:mkTextEncoding">mkTextEncoding</a> と <a href="https://www.stackage.org/haddock/lts-12.2/base-4.11.1.0/System-IO.html#v:hSetEncoding">hSetEncoding</a> を使った処理を挟んでいましたね。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1">  cp932 <span class="ot">&lt;-</span> mkTextEncoding <span class="st">&quot;cp932&quot;</span></a>
<a class="sourceLine" id="cb7-2" title="2">  hSetEncoding h cp932</a></code></pre></div>
<p>この処理によって、<strong>shift-jis</strong> で保存されたファイルの内容を <strong>String</strong> 型の文字列として扱うことができるようになります。</p>
<h4 id="readfileencoding">readFileEncoding</h4>
<p><a href="https://www.stackage.org/package/extra">extra</a> パッケージの <a href="https://www.stackage.org/haddock/lts-12.2/extra-1.6.9/System-IO-Extra.html#v:readFileEncoding">readFileEncoding</a> の定義は以下のようになっています。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">readFileEncoding ::</span> <span class="dt">TextEncoding</span> <span class="ot">-&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb8-2" title="2">readFileEncoding enc file <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-3" title="3">  h <span class="ot">&lt;-</span> openFile file <span class="dt">ReadMode</span></a>
<a class="sourceLine" id="cb8-4" title="4">  hSetEncoding h enc</a>
<a class="sourceLine" id="cb8-5" title="5">  hGetContents h</a></code></pre></div>
<p>便利ですね！</p>
<h2 id="まとめ">まとめ</h2>
<ul>
<li><strong>mkTextEncoding</strong> で <strong>TextEncoding</strong> 型の値を作ることができる</li>
<li><strong>hSetEncoding</strong> を利用すればエンコードを指定してファイルの内容を読み込むことができる</li>
<li><strong>extra</strong> パッケージで提供されている <strong>readFileEncoding</strong> はそれらの処理を良い感じにまとめてくれる</li>
</ul>
<p>実際の開発において <strong>readFile</strong> のような (<strong>getContents</strong> 系の関数) を使うことは少ないと思います。しかし、何か動くものを <strong>Haskell</strong> で作ってみたいと思っている人は、とりあえず気にせず使いましょう。(ストリーミングライブラリの知識があればそっちを使った方が良いです)</p>
<p>Haskell はリファクタリングの得意な言語ですから、問題として認識したときに修正すれば良いと思います。</p>
<p>IO の処理については <a href="http://gihyo.jp/book/2017/978-4-7741-9237-6">Haskell入門 関数型プログラミング言語の基礎と実践</a> の4章, <a href="https://www.oreilly.co.jp/books/9784873114231/">Read World Haskell</a> の7章で詳しく解説されているので、興味を持った方はそちらも参照してみると良いかもしれません。</p>
<p>以上です。</p>]]></summary>
</entry>

</feed>
