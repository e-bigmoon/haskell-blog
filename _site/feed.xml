<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>BIG MOON</title>
    <link href="https://haskell.e-bigmoon.com/feed.xml" rel="self" />
    <link href="https://haskell.e-bigmoon.com" />
    <id>https://haskell.e-bigmoon.com/feed.xml</id>
    <author>
        <name>BIG MOON</name>
        <email>it@e-bigmoon.com</email>
    </author>
    <updated>2017-12-27T00:00:00Z</updated>
    <entry>
    <title>haddock に Grid Table 記法が追加されました</title>
    <link href="https://haskell.e-bigmoon.com/posts/2017-12-27-haddock-grid-table.html" />
    <id>https://haskell.e-bigmoon.com/posts/2017-12-27-haddock-grid-table.html</id>
    <published>2017-12-27T00:00:00Z</published>
    <updated>2017-12-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>みなさん <code>haddock</code> を使ってますか？</p>
<p>コメントを残す時に <code>|</code> や <code>^</code> を追加するだけで <code>haddock</code> 形式のコメントを残すことができます。</p>
<p>具体的にはこんな感じです。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co">-- | リストの合計を計算する関数</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">sum<span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">sum <span class="fu">=</span> foldl (<span class="fu">+</span>) <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">data</span> <span class="dt">Person</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  {<span class="ot"> name ::</span> <span class="dt">Text</span> <span class="co">-- ^ フルネーム</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  }</a></code></pre></div>
<p>コメントを <code>haddock</code> 形式にしてあげることで <code>HTML</code> のドキュメントがより充実するので、少ない労力で凄く楽しい気持ちになります。</p>
<p><code>stack</code> を使っている場合はこのようにしてビルドするだけです。</p>
<pre class="shell"><code>$ stack haddock --open</code></pre>
<p>今回、この <code>haddock</code> に <code>Grid Table</code> 記法が追加されたそうなので、その機能についてご紹介したいと思います。</p>
<!--more-->
<h2 id="grid-table-記法">Grid Table 記法</h2>
<p>以下の内容を参考としています。</p>
<ul>
<li><a href="https://github.com/haskell/haddock/pull/718">Grid Tables #718</a></li>
<li><a href="https://github.com/haskell/haddock/issues/530">Add markup support for tables #530</a></li>
<li><a href="http://haskell-haddock.readthedocs.io/en/latest/markup.html#grid-tables">Grid Tables</a></li>
</ul>
<h3 id="haddock-の更新">haddock の更新</h3>
<p><code>Grid Table</code> を使うためには <code>haddock-2.18.2</code> 以上である必要があります。</p>
<p>現状 <code>Hackage</code> の最新版が <code>2.18.1</code> なので <code>github</code> の最新版を利用する必要があります。</p>
<pre class="shell"><code>$ haddock --version
Haddock version 2.18.1, (c) Simon Marlow 2006
Ported to use the GHC API by David Waern 2006-2008</code></pre>
<p>ここでは <code>stack</code> を使って最新版をインストールします。(その他の各種ビルド方法については <a href="https://github.com/haskell/haddock#hacking">Readme</a> に詳しく載っているので、そちらをご参照ください)</p>
<pre class="shell"><code>$ git clone https://github.com/haskell/haddock.git
$ cd haddock
$ stack init
$ stack install

$ haddock --version
Haddock version 2.18.2, (c) Simon Marlow 2006
Ported to use the GHC API by David Waern 2006-2008</code></pre>
<p>これで準備は整いました！</p>
<h3 id="使ってみる">使ってみる</h3>
<p>まずは新規プロジェクトを作って、初期状態で <code>haddock</code> を生成します。</p>
<pre class="shell"><code>$ stack new test-haddock-grid-table
$ cd test-haddock-grid-table
$ stack haddock --open</code></pre>
<p>ブラウザが自動的に立ち上がるので <code>Lib</code> モジュールを見てみましょう。</p>
<p><code>someFunc</code> だけの味気ない <code>HTML</code> ですね。<code>haddock</code> コメントを追加して、もう一度確認してみます。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co">-- src/Lib.hs</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Lib</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    ( someFunc</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    ) <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="co">-- | haddock test</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="ot">someFunc ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">someFunc <span class="fu">=</span> putStrLn <span class="st">&quot;someFunc&quot;</span></a></code></pre></div>
<pre class="shell"><code>$ stack haddock --open</code></pre>
<p>ちょっと変わりましたね。</p>
<p>では、本題の <code>Grid Table</code> を追加してみます。また、一行コメントを書き続けるのつらいので、複数行の形式に変更します。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">-- src/Lib.hs</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Lib</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    ( someFunc</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    ) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"></a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="co">-- | Table with header.</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="co">--</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"><span class="co">-- +------+--------------+------------------------------------------+</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9"><span class="co">-- | code | message      | description                              |</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10"><span class="co">-- +======+==============+==========================================+</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11"><span class="co">-- | 200  |   @OK@       | operation successful                     |</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12"><span class="co">-- +------+--------------+------------------------------------------+</span></a>
<a class="sourceLine" id="cb8-13" data-line-number="13"><span class="co">-- | 204  | @No Content@ | operation successful, no body returned   |</span></a>
<a class="sourceLine" id="cb8-14" data-line-number="14"><span class="co">-- +------+--------------+------------------------------------------+</span></a>
<a class="sourceLine" id="cb8-15" data-line-number="15"><span class="ot">someFunc ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">someFunc <span class="fu">=</span> putStrLn <span class="st">&quot;someFunc&quot;</span></a></code></pre></div>
<p>失敗しました・・・。</p>
<p>これはどうやら <code>stack</code> が利用している <code>haddock</code> が <code>~/.local/bin</code> にインストールした最新版の <code>haddock</code> を参照していないためです。</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/issues/2922">Allow use of custom haddock binary to generate the documentation #2922</a></li>
<li><a href="https://stackoverflow.com/questions/41628606/how-to-use-a-custom-haddock-executable-to-generate-documentation-with-stack">ow to use a custom haddock executable to generate documentation with stack?</a></li>
</ul>
<p>以下のコマンドで確認することができます。</p>
<pre class="shell"><code>$ stack exec -- which haddock
/home/bm12/.stack/programs/x86_64-linux/ghc-nopie-8.2.2/bin/haddock

$ stack exec -- haddock --version
Haddock version 2.18.1, (c) Simon Marlow 2006
Ported to use the GHC API by David Waern 2006-2008</code></pre>
<p>ここで、<code>stack</code> が参照する <code>haddock</code> プログラムはシンボリックリンクとなっているため、一時的に上書きすることにしました。</p>
<pre class="shell"><code>$ stack path --compiler-bin
/home/bm12/.stack/programs/x86_64-linux/ghc-nopie-8.2.2/bin

$ ln -snf ~/.local/bin/haddock $(stack path --compiler-bin)/</code></pre>
<p>これでやっと <code>Grid Table</code> が使えます！</p>
<pre class="shell"><code>$ stack haddock --open</code></pre>
<p>なかなかオシャレな感じです。</p>
<h2 id="後片付け">後片付け</h2>
<p>シンボリックリンクを元に戻しておきましょう。</p>
<pre class="shell"><code>$ ls -l $(stack path --compiler-bin)
合計 32
lrwxrwxrwx 1 bm12 bm12    9 11月 27 00:39 ghc -&gt; ghc-8.2.2*
-rwxr-xr-x 1 bm12 bm12  444 11月 27 00:39 ghc-8.2.2*
lrwxrwxrwx 1 bm12 bm12   10 11月 27 00:39 ghci -&gt; ghci-8.2.2*
-rwxr-xr-x 1 bm12 bm12  108 11月 27 00:39 ghci-8.2.2*
lrwxrwxrwx 1 bm12 bm12   13 11月 27 00:39 ghc-pkg -&gt; ghc-pkg-8.2.2*
-rwxr-xr-x 1 bm12 bm12  476 11月 27 00:39 ghc-pkg-8.2.2*
lrwxrwxrwx 1 bm12 bm12   29 12月 27 14:24 haddock -&gt; /home/bm12/.local/bin/haddock*
-rwxr-xr-x 1 bm12 bm12  435 11月 27 00:39 haddock-ghc-8.2.2*
-rwxr-xr-x 1 bm12 bm12  408 11月 27 00:39 hp2ps*
-rwxr-xr-x 1 bm12 bm12  406 11月 27 00:39 hpc*
-rwxr-xr-x 1 bm12 bm12 1206 11月 27 00:39 hsc2hs*
lrwxrwxrwx 1 bm12 bm12   12 11月 27 00:39 runghc -&gt; runghc-8.2.2*
-rwxr-xr-x 1 bm12 bm12  452 11月 27 00:39 runghc-8.2.2*
lrwxrwxrwx 1 bm12 bm12    6 11月 27 00:39 runhaskell -&gt; runghc*

$ ln -snf $(stack path --compiler-bin)/haddock-ghc-8.2.2 $(stack path --compiler-bin)/haddock
$ cd ../
$ rm -rf test-haddock-grid-table</code></pre>
<h2 id="終わりに">終わりに</h2>
<p><code>stack</code> の謎の挙動によって若干苦戦しながらも、無事に試してみることができました。</p>
<p><code>--with-haddock</code> のようなオプションが欲しいなぁと感じました・・・。</p>
<p><code>Grid Table</code> についてはデータベース系の操作結果などを例示する際に使えそうです！</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Haskell のパフォーマンスをデバッグする</title>
    <link href="https://haskell.e-bigmoon.com/posts/2017-12-27-Haskell-Performance-Debugging.html" />
    <id>https://haskell.e-bigmoon.com/posts/2017-12-27-Haskell-Performance-Debugging.html</id>
    <published>2017-12-27T00:00:00Z</published>
    <updated>2017-12-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Great original post: <a href="http://www.parsonsmatt.org/2017/12/18/haskell_performance_debugging.html">Haskell Performance Debugging</a>.</p>
<p>2017年 12月 18日 Matt Parsons</p>
<p>誰かが reddit に <a href="https://www.reddit.com/r/haskell/comments/7km60k/optimization_ideas_in_treap_implementation/">Treap の実装が遅い</a> と投稿していました。それを分析して、何が起きているのかを考えてみましょう。</p>
<p>レポジトリは<a href="https://github.com/parsonsmatt/performance-debugging">ここ</a>にあります。</p>
<h2 id="最初の実行">最初の実行</h2>
<p>Cabalプロジェクトを作り、makefile を作ります。そして、最初のプロファイルを取ります。コードとプロファイル結果は GitHub の <code>master</code>ブランチにあります。</p>
<p>実行されているコードやプロファイル結果を見る前に、質問のデータ構造の定義を確認しておきましょう:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Node</span>  v d <span class="fu">=</span> <span class="dt">Node</span> {<span class="ot"> val ::</span> v,<span class="ot"> info ::</span> d,<span class="ot"> prior ::</span> <span class="dt">Int</span> }</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Treap</span> v d <span class="fu">=</span> <span class="dt">Leaf</span> <span class="fu">|</span> <span class="dt">Tree</span> {<span class="ot">node ::</span> <span class="dt">Node</span> v d,<span class="ot"> left ::</span> <span class="dt">Treap</span> v d,<span class="ot"> right ::</span> <span class="dt">Treap</span> v d}</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="kw">deriving</span> <span class="dt">Show</span></a></code></pre></div>
<!--more-->
<p>注釈つきの2分木ですね。 spine と値は、リスト同様に遅延評価されます。</p>
<p>以下が <code>main</code> 関数で、この出力を調べます。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    g <span class="ot">&lt;-</span> getStdGen</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="kw">let</span> nulls <span class="fu">=</span> repeat ()</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">        n <span class="fu">=</span> <span class="dv">100000</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">        rxs <span class="fu">=</span> take n <span class="fu">$</span> randomRs (<span class="dv">1</span>,<span class="dv">100000</span>)<span class="ot"> g  ::</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">        nodeList <span class="fu">=</span> feedFold (zip rxs nulls) g buildNode</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">        treap <span class="fu">=</span> insertMany empty nodeList</a>
<a class="sourceLine" id="cb2-8" data-line-number="8"></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">    print <span class="fu">$</span> heightTreap treap</a>
<a class="sourceLine" id="cb2-10" data-line-number="10"></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">    print <span class="fu">$</span> map (\<span class="dt">Node</span>{val <span class="fu">=</span> v} <span class="ot">-&gt;</span> v) <span class="fu">$</span> inOrder treap</a></code></pre></div>
<p>これをプロファイリングしつつビルドして、<code>-p</code> と <code>-s</code> をつけて実行します。これは時間とメモリ確保についてのプロファイリングをしてくれます。 以下が <code>-s</code> の出力です:</p>
<pre><code>   1,691,027,808 bytes allocated in the heap
   1,179,783,328 bytes copied during GC
      42,694,944 bytes maximum residency (25 sample(s))
       8,493,296 bytes maximum slop
             121 MB total memory in use (0 MB lost due to fragmentation)

                                     Tot time (elapsed)  Avg pause  Max pause
  Gen  0      3033 colls,     0 par    0.716s   0.752s     0.0002s    0.0008s
  Gen  1        25 colls,     0 par    0.544s   0.560s     0.0224s    0.0460s

  INIT    time    0.000s  (  0.000s elapsed)
  MUT     time    1.088s  (  1.140s elapsed)
  GC      time    1.260s  (  1.312s elapsed)
  RP      time    0.000s  (  0.000s elapsed)
  PROF    time    0.000s  (  0.000s elapsed)
  EXIT    time    0.000s  (  0.003s elapsed)
  Total   time    2.404s  (  2.455s elapsed)

  %GC     time      52.4%  (53.4% elapsed)

  Alloc rate    1,554,253,500 bytes per MUT second

  Productivity  47.6% of total user, 46.5% of total elapsed</code></pre>
<p>GC に 52% の時間が割かれているのはよろしくないですね。</p>
<p>プロファイル結果によると、かなり大部分の時間を <code>splitTreap</code>関数で消費してしまっているようです。なので、そこで何が起きているのか確認しましょう:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">splitTreap ::</span> (<span class="dt">Ord</span> v) <span class="ot">=&gt;</span> <span class="dt">Treap</span> v d <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> (<span class="dt">Treap</span> v d, <span class="dt">Treap</span> v d)</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">splitTreap <span class="dt">Leaf</span> _ <span class="fu">=</span> (<span class="dt">Leaf</span>, <span class="dt">Leaf</span>)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">splitTreap (tree <span class="fu">@</span> <span class="dt">Tree</span> {node <span class="fu">=</span> <span class="dt">Node</span> { val <span class="fu">=</span> x }, left <span class="fu">=</span> l, right <span class="fu">=</span> r})   v</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    <span class="fu">|</span> x <span class="fu">&lt;</span> v  <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">        <span class="kw">let</span> (lt, rt) <span class="fu">=</span> splitTreap r v</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">         <span class="kw">in</span> ( <span class="dt">Tree</span> { node <span class="fu">=</span> node tree, left <span class="fu">=</span> l, right <span class="fu">=</span> lt }</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">            , rt</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">            )</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">    <span class="fu">|</span> v <span class="fu">&lt;=</span> x <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">        <span class="kw">let</span> (lt, rt) <span class="fu">=</span> splitTreap l v</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">         <span class="kw">in</span> ( lt</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">            , <span class="dt">Tree</span> { node <span class="fu">=</span> node tree, left <span class="fu">=</span> rt, right <span class="fu">=</span> r}</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">            )</a></code></pre></div>
<p>私には気になる点が2つ見つかりました:</p>
<ul>
<li>タプル</li>
<li>再帰</li>
</ul>
<p>タプルはしばしば、意図しない遅延やスペースリークの原因になります。GHC がタプルのデータ構造を見て、それを完全にアンボックス化し、オーバーヘッドを 0 にできる場合もあります。しかし、それができないときもあります。結果割り当てられまくって、サンクリークが始まります。</p>
<p>再帰は GHC のインライン化能力を完全に上回っており、パフォーマンスを台無しにしてしまいます。<code>map</code> や <code>foldr</code> などはクレバーな最適化を受けることができますが、単純な再帰関数には大抵、インライン化において問題が存在します。</p>
<p>これらが実験を始める前の私の印象です。私のタプルメモリ割り当て仮説を検証するために、ヒープのプロファイリングを行いましょう。<code>-hd</code>フラグを使って確保されたデータコンストラクタを取得します:</p>
<p><img src="http://www.parsonsmatt.org/treap-base-hd.png"></p>
<p>いい感じですね! さて、このグラフは <code>Tree</code> コンストラクタの割り当て前に、大量のノード、タプル、<code>I#</code> (<code>Int</code> のコンストラクタ) を割り当てていることを示しています。対象の <code>main</code> 関数だと、この挙動は完全に非合理的というわけではありません。</p>
<h2 id="実験1-データ構造を正格化する">実験1: データ構造を正格化する</h2>
<p>このセクション関連のコードは <code>strictify-treap</code> にあります。</p>
<p>データ構造のところどころにバンパターンを差し込んでみました:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Node</span> v d</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Node</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    {<span class="ot"> val ::</span> <span class="fu">!</span>v</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    ,<span class="ot"> info ::</span> d</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    ,<span class="ot"> prior ::</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="kw">data</span> <span class="dt">Treap</span> v d</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">    <span class="fu">=</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    <span class="fu">|</span> <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    {<span class="ot"> node ::</span> <span class="fu">!</span>(<span class="dt">Node</span> v d)</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">    ,<span class="ot"> left ::</span> <span class="dt">Treap</span> v d</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">    ,<span class="ot"> right ::</span> <span class="dt">Treap</span> v d</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">    } <span class="kw">deriving</span> <span class="dt">Show</span></a></code></pre></div>
<p>こうすることで <code>Node</code> 型の <code>val</code> フィールドと <code>prior</code> フィールドが正格になり、<code>Treap</code> 型は <code>node</code> フィールドに正格になります。<code>info</code> フィールドはたいていのコンテナのように、lazy のままにしてあります。データ構造の spine も lazy のままです。</p>
<p><code>-s</code> の出力です:</p>
<pre><code>1,659,050,200 bytes allocated in the heap
   1,144,049,696 bytes copied during GC
      43,890,168 bytes maximum residency (33 sample(s))
       8,508,680 bytes maximum slop
             102 MB total memory in use (0 MB lost due to fragmentation)

                                     Tot time (elapsed)  Avg pause  Max pause
  Gen  0      2905 colls,     0 par    0.676s   0.696s     0.0002s    0.0007s
  Gen  1        33 colls,     0 par    0.544s   0.567s     0.0172s    0.0409s

  INIT    time    0.000s  (  0.000s elapsed)
  MUT     time    0.920s  (  0.996s elapsed)
  GC      time    1.220s  (  1.263s elapsed)
  RP      time    0.000s  (  0.000s elapsed)
  PROF    time    0.000s  (  0.000s elapsed)
  EXIT    time    0.000s  (  0.001s elapsed)
  Total   time    2.196s  (  2.260s elapsed)

  %GC     time      55.6%  (55.9% elapsed)

  Alloc rate    1,803,315,434 bytes per MUT second

  Productivity  44.4% of total user, 44.1% of total elapsed</code></pre>
<p>20MB も使用しているメモリが減っています。これはいいですね。そして全体の使用時間も少なくなっています (2.4秒 vs 2.2秒)。これもいいことです! しかし GC が使っている時間は 55% です。前より悪くなってるじゃなイカ!</p>
<p>以下はヒーププロファイリングの結果です:</p>
<p><img src="http://www.parsonsmatt.org/treap-strict-nodes.png"></p>
<p>大きな違いはありませんが、確かに少し良い結果です。時間と割り当てのプロファイリングは全く違う結果を証明していています。後々、プログラムの実行時間は 2.49秒から 0.97秒になります。</p>
<p>この結果にかなり励まされつつ、木の spine も正格にしようと思います。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Node</span> v d</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Node</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    {<span class="ot"> val ::</span> <span class="fu">!</span>v</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    ,<span class="ot"> info ::</span> d</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    ,<span class="ot"> prior ::</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb7-7" data-line-number="7"></a>
<a class="sourceLine" id="cb7-8" data-line-number="8"><span class="kw">data</span> <span class="dt">Treap</span> v d</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">    <span class="fu">=</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">    <span class="fu">|</span> <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb7-11" data-line-number="11">    {<span class="ot"> node ::</span> <span class="fu">!</span>(<span class="dt">Node</span> v d)</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">    ,<span class="ot"> left ::</span> <span class="fu">!</span>(<span class="dt">Treap</span> v d)</a>
<a class="sourceLine" id="cb7-13" data-line-number="13">    ,<span class="ot"> right ::</span> <span class="fu">!</span>(<span class="dt">Treap</span> v d)</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">    } <span class="kw">deriving</span> <span class="dt">Show</span></a></code></pre></div>
<p><code>-s</code> の出力結果によると、合計でまだ 94MB 程度のメモリを使っているようです。</p>
<pre><code>  1,161,437,656 bytes allocated in the heap
     449,893,272 bytes copied during GC
      43,890,328 bytes maximum residency (24 sample(s))
       8,520,808 bytes maximum slop
              94 MB total memory in use (0 MB lost due to fragmentation)

                                     Tot time (elapsed)  Avg pause  Max pause
  Gen  0      2143 colls,     0 par    0.152s   0.166s     0.0001s    0.0006s
  Gen  1        24 colls,     0 par    0.188s   0.203s     0.0085s    0.0272s

  INIT    time    0.000s  (  0.000s elapsed)
  MUT     time    0.556s  (  0.644s elapsed)
  GC      time    0.320s  (  0.345s elapsed)
  RP      time    0.000s  (  0.000s elapsed)
  PROF    time    0.020s  (  0.024s elapsed)
  EXIT    time    0.000s  (  0.000s elapsed)
  Total   time    0.952s  (  0.989s elapsed)

  %GC     time      33.6%  (34.9% elapsed)

  Alloc rate    2,088,916,647 bytes per MUT second

  Productivity  64.3% of total user, 62.6% of total elapsed</code></pre>
<p>これはかなり良い結果です。GC が 33% なのは良くないですが、それでも前よりもだいぶ良い結果です。2.4秒から 0.95秒になりました。これはかなりの改善です。</p>
<p>今度はヒープの出力も見てみましょう:</p>
<p><img src="http://www.parsonsmatt.org/treap-strict-spine.png"></p>
<p>もう少しですね! 大きなメモリの山が生成され、それが回収されています。何かが起きていることの兆候です。タプルコンストラクタに多くの割り当てをしてしまっています。つらいですね。</p>
<h2 id="split-を正格化する">Split を正格化する</h2>
<p>まだ <code>splitTreap</code> という最大の犯罪者がいます。こいつはプログラムの実行時間のほぼ半分を占めています。タプルを割り当て、それを捨てていることはわかっているので、そこにスペースリークがある可能性があります。タプルの中にバンパターンを追加し、結果を見てみます。</p>
<p>これが変更点です:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">splitTreap ::</span> (<span class="dt">Ord</span> v) <span class="ot">=&gt;</span> <span class="dt">Treap</span> v d <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> (<span class="dt">Treap</span> v d, <span class="dt">Treap</span> v d)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">splitTreap <span class="dt">Leaf</span> _ <span class="fu">=</span> (<span class="dt">Leaf</span>, <span class="dt">Leaf</span>)</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">splitTreap (tree <span class="fu">@</span> <span class="dt">Tree</span> {node <span class="fu">=</span> <span class="dt">Node</span> { val <span class="fu">=</span> x }, left <span class="fu">=</span> l, right <span class="fu">=</span> r})   v</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">    <span class="fu">|</span> x <span class="fu">&lt;</span> v  <span class="fu">=</span> <span class="kw">let</span> (<span class="fu">!</span>lt, <span class="fu">!</span>rt) <span class="fu">=</span> splitTreap r v <span class="kw">in</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">                (   <span class="dt">Tree</span> { node <span class="fu">=</span> node tree, left <span class="fu">=</span> l, right <span class="fu">=</span> lt },</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">                    rt  )</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    <span class="fu">|</span> v <span class="fu">&lt;=</span> x <span class="fu">=</span> <span class="kw">let</span> (<span class="fu">!</span>lt, <span class="fu">!</span>rt) <span class="fu">=</span> splitTreap l v <span class="kw">in</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">                (   lt,</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">                    <span class="dt">Tree</span> { node <span class="fu">=</span> node tree, left <span class="fu">=</span> rt, right <span class="fu">=</span> r}  )</a></code></pre></div>
<p>元のコードがタプルを直ちに破棄して <code>lt</code> と <code>rt</code> 変数を lazy なままにしているのに対して、これらの変数を WHNF に強制しています。</p>
<p>新しい <code>-s</code> の出力結果です:</p>
<pre><code>   1,331,896,120 bytes allocated in the heap
     497,880,136 bytes copied during GC
      43,890,328 bytes maximum residency (25 sample(s))
       8,516,712 bytes maximum slop
              94 MB total memory in use (0 MB lost due to fragmentation)

                                     Tot time (elapsed)  Avg pause  Max pause
  Gen  0      2245 colls,     0 par    0.188s   0.186s     0.0001s    0.0007s
  Gen  1        25 colls,     0 par    0.212s   0.251s     0.0100s    0.0386s

  INIT    time    0.000s  (  0.000s elapsed)
  MUT     time    0.636s  (  0.756s elapsed)
  GC      time    0.360s  (  0.394s elapsed)
  RP      time    0.000s  (  0.000s elapsed)
  PROF    time    0.040s  (  0.043s elapsed)
  EXIT    time    0.000s  (  0.000s elapsed)
  Total   time    1.084s  (  1.151s elapsed)

  %GC     time      33.2%  (34.2% elapsed)

  Alloc rate    2,094,176,289 bytes per MUT second

  Productivity  63.1% of total user, 62.0% of total elapsed</code></pre>
<p>これはさっきの実行からほとんど変わっていません。ヒーププロファイルも変更されませんでした。これらのタプルがどこに割り当てられるのかを見るために、<code>-hc</code> をつけて実行してみます。<code>-hc</code> は実際にどの関数がデータを生成しているのかを記録してくれるので、どこに注目するべきかが分かります。</p>
<p><img src="http://www.parsonsmatt.org/treap-strict-tuple-hc.png"></p>
<p><strong>あぁナッツ!</strong> <code>splitTreap</code> がほんの少ししかメモリ割り当てがされなくなってるぞ。<code>buildNode</code>, <code>feedFold</code>, <code>insertMany</code> でほとんどの割り当てを行っているみたいです。これは、<code>splitTreap</code> に多くの時間と割り当てをしているという <code>-p</code> オプションの結果に反しているように見えます。</p>
<p>今は <code>insertMany</code> に集中するべきでしょう。</p>
<h2 id="insertmany">insertMany</h2>
<p>このセクションのコードは、GitHub の<code>insert-many</code>ブランチにあります。</p>
<p><code>mergeTreap</code> はなぜかしらカリー化されていましたが:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">mergeTreap ::</span> (<span class="dt">Treap</span> v d, <span class="dt">Treap</span> v d) <span class="ot">-&gt;</span> <span class="dt">Treap</span> v d</a></code></pre></div>
<p>これはうざかったので、上のようにアンカリー化しました。これはパフォーマンスには関係ありません。</p>
<p>ここで、<code>insertMany</code> を実際に見てみます:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">insertMany ::</span> (<span class="dt">Ord</span> v) <span class="ot">=&gt;</span> <span class="dt">Treap</span> v d <span class="ot">-&gt;</span> [<span class="dt">Node</span> v d] <span class="ot">-&gt;</span> <span class="dt">Treap</span> v d</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">insertMany <span class="fu">=</span> foldl insertTreap</a></code></pre></div>
<p>あぁ。<code>foldl</code> がまた来やがりました。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">insertMany ::</span> (<span class="dt">Ord</span> v) <span class="ot">=&gt;</span> <span class="dt">Treap</span> v d <span class="ot">-&gt;</span> [<span class="dt">Node</span> v d] <span class="ot">-&gt;</span> <span class="dt">Treap</span> v d</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">insertMany <span class="fu">=</span> foldl&#39; insertTreap</a></code></pre></div>
<p>さぁ、GHC のアメージングな最適化力とプライムボーイ、どちらが勝つのでしょうか? <code>-s</code> の結果です:</p>
<pre class="plain"><code>   1,115,162,944 bytes allocated in the heap
     245,033,472 bytes copied during GC
      12,088,896 bytes maximum residency (22 sample(s))
         306,112 bytes maximum slop
              32 MB total memory in use (0 MB lost due to fragmentation)

                                     Tot time (elapsed)  Avg pause  Max pause
  Gen  0      2134 colls,     0 par    0.116s   0.128s     0.0001s    0.0003s
  Gen  1        22 colls,     0 par    0.080s   0.105s     0.0048s    0.0136s

  INIT    time    0.000s  (  0.000s elapsed)
  MUT     time    0.596s  (  0.700s elapsed)
  GC      time    0.180s  (  0.216s elapsed)
  RP      time    0.000s  (  0.000s elapsed)
  PROF    time    0.016s  (  0.018s elapsed)
  EXIT    time    0.000s  (  0.001s elapsed)
  Total   time    0.852s  (  0.916s elapsed)

  %GC     time      21.1%  (23.6% elapsed)

  Alloc rate    1,871,078,765 bytes per MUT second

  Productivity  77.0% of total user, 74.4% of total elapsed</code></pre>
<p>良いですね、トータルの使用メモリが 32MB になり、全体の時間は 10分の1 ぐらい減りました。しかも、GC にかかっている時間はたったの 22% です。我々の大勝利です。</p>
<p>ヒープのプロファイル結果を見てみましょう:</p>
<p><img src="http://www.parsonsmatt.org/treap-foldl.png"></p>
<h2 id="何があっても-foldl-を使わず常に-foldl-を使うべし">何があっても foldl を使わず、常に foldl’ を使うべし</h2>
<p>最初の状態で foldl を foldl’ に変更してみたらどうでしょう?</p>
<p><code>git checkout base</code> を走らせて元に戻し、<code>foldl</code> を <code>foldl'</code> に変更してみました。<code>-s</code> の結果です:</p>
<pre class="plain"><code>1,581,972,168 bytes allocated in the heap
   1,140,799,032 bytes copied during GC
      40,964,944 bytes maximum residency (43 sample(s))
         495,784 bytes maximum slop
             114 MB total memory in use (0 MB lost due to fragmentation)

                                     Tot time (elapsed)  Avg pause  Max pause
  Gen  0      3044 colls,     0 par    0.664s   0.636s     0.0002s    0.0004s
  Gen  1        43 colls,     0 par    0.796s   0.812s     0.0189s    0.0611s

  INIT    time    0.000s  (  0.000s elapsed)
  MUT     time    0.964s  (  1.226s elapsed)
  GC      time    1.336s  (  1.320s elapsed)
  RP      time    0.000s  (  0.000s elapsed)
  PROF    time    0.124s  (  0.128s elapsed)
  EXIT    time    0.000s  (  0.002s elapsed)
  Total   time    2.488s  (  2.548s elapsed)

  %GC     time      53.7%  (51.8% elapsed)

  Alloc rate    1,641,049,966 bytes per MUT second

  Productivity  41.3% of total user, 43.2% of total elapsed</code></pre>
<p>よろしくはないですね。というか、初めよりもちょっと悪くなってます! ヒープのプロファイル結果はどうでしょう?</p>
<p><img src="http://www.parsonsmatt.org/treap-just-foldl.png"></p>
<p>これもほとんど同じですね! 割り当てはちょっとなめらかになっていますが、顕著な違いでもありません。というわけで、データ構造を正格にせずに、ただ <code>foldl'</code> に変更しても意味がありませんでした。</p>
<h2 id="最終結果">最終結果</h2>
<p>プロファイリングを無効にして、もう一回コードを実行してみます:</p>
<pre class="plain"><code>     650,786,800 bytes allocated in the heap
     132,515,880 bytes copied during GC
       7,278,528 bytes maximum residency (17 sample(s))
         353,296 bytes maximum slop
              21 MB total memory in use (0 MB lost due to fragmentation)

                                     Tot time (elapsed)  Avg pause  Max pause
  Gen  0      1233 colls,     0 par    0.112s   0.100s     0.0001s    0.0004s
  Gen  1        17 colls,     0 par    0.056s   0.056s     0.0033s    0.0122s

  INIT    time    0.000s  (  0.000s elapsed)
  MUT     time    0.212s  (  0.341s elapsed)
  GC      time    0.168s  (  0.156s elapsed)
  EXIT    time    0.000s  (  0.000s elapsed)
  Total   time    0.436s  (  0.497s elapsed)

  %GC     time      38.5%  (31.3% elapsed)

  Alloc rate    3,069,749,056 bytes per MUT second

  Productivity  61.5% of total user, 68.7% of total elapsed</code></pre>
<p>メモリ消費は 21MB, 実行時間は 0.43秒でした。</p>
<h2 id="結論">結論?</h2>
<h3 id="spine-は正格にリーブは-lazy-に">spine は正格に、リーブは lazy に</h3>
<p>データ構造的には、spine は正格に、リーブは lazy にすべきです。データコンストラクタを、ストリームの形で組み立てたり消費したいという強い意思があるなら話は別ですが。</p>
<h3 id="foldl-は絶対に使うな">foldl は絶対に使うな</h3>
<p>まじめに使っちゃダメです。<code>hlint</code> のルールにそうしないように書いてください。コードから排除しましょう。廃止して、<code>Prelude</code> を置き換えるように GHC に提案しましょう。</p>]]></summary>
</entry>
<entry>
    <title>stack v1.6.3 がリリースされました。</title>
    <link href="https://haskell.e-bigmoon.com/posts/2017-12-24-stack163.html" />
    <id>https://haskell.e-bigmoon.com/posts/2017-12-24-stack163.html</id>
    <published>2017-12-24T00:00:00Z</published>
    <updated>2017-12-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>以下のコマンドで <code>stack v1.6.3</code> のバイナリが落ちてきます。</p>
<pre class="shell"><code>$ stack upgrade</code></pre>
<h2 id="リリースノート">リリースノート</h2>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/blob/master/ChangeLog.md#v163">Changelog.md</a></li>
</ul>
<p>機能追加は無く、改良とバグフィックスのみです。</p>
<p><code>stack ls</code> コマンドは今回に含まれていないので <code>v1.7.0</code> で追加されそうな感じですね。</p>
<!--more-->
<h3 id="enhancements">Enhancements</h3>
<ul>
<li>In addition to supporting <code>.tar.gz</code> and <code>.zip</code> files as remote archives, plain <code>.tar</code> files are now accepted too. This will additionally help with cases where HTTP servers mistakenly set the transfer encoding to <code>gzip</code>. See <a href="https://github.com/commercialhaskell/stack/issues/3647">#3647</a>.</li>
</ul>
<p>ということで <code>.tar</code> に加えて <code>extra-deps</code> に <code>.tar.gz</code>, <code>.zip</code> 形式が指定できるようになったみたいです。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="fu">extra-deps:</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">-</span> <span class="fu">http:</span><span class="at">//www.mathstat.dal.ca/~selinger/quipper/downloads/quipper-0.8.tgz</span></a></code></pre></div>
<p>僕は使ったこと無いですが、役立ちそう。</p>
<hr />
<ul>
<li>Links to docs.haskellstack.org ignore Stack version patchlevel.</li>
<li>Downloading Docker-compatible stack binary ignores Stack version patchlevel.</li>
</ul>
<p>たぶん <code>stack v1.6.1.1</code> のようなバージョンは無視されるということでしょうか。</p>
<h2 id="bug-fixes">Bug fixes</h2>
<ul>
<li>For versions of Cabal before 1.24, ensure that the dependencies of non-buildable components are part of the build plan to work around an old Cabal bug. See <a href="https://github.com/commercialhaskell/stack/issues/3631">#3631</a>.</li>
</ul>
<p>古めの <code>LTS</code> (issue は lts-6.35 で報告されてる) 使ってる人はこの問題が解決されますのでアップデート推奨と思われます。</p>
<hr />
<ul>
<li>Run the Cabal file checking in the <code>sdist</code> command more reliably by allowing the Cabal library to flatten the <code>GenericPackageDescription</code> itself.</li>
</ul>
<p>よくわかりません。</p>
<hr />
<ul>
<li>The script interpreter’s implicit file arguments are now passed before other arguments. See <a href="Error%20when%20using%20RTS%20options%20with%20the%20Stack%20script%20interpreter%20#3658">#3658</a>. In particular, this makes it possible to pass <code>-- +RTS ... -RTS</code> to specify RTS arguments used when running the script.</li>
</ul>
<p>スクリプトインタプリタの暗黙的なファイル引数を他の引数より先に渡すように修正されたようです。 その結果、以下のような <code>RTS</code> オプションの指定が適切に処理できるようになりました。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="co">{- stack</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="co">  script</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="co">  --resolver lts-6.25</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="co">  --package turtle</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="co">  --</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="co">  +RTS -s -RTS</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="co">-}</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9"></a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="ot">main ::</span> <span class="dt">IO</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">main <span class="fu">=</span> putStrLn <span class="st">&quot;Hello, world!&quot;</span></a></code></pre></div>
<hr />
<ul>
<li>Don’t ignore the template year parameter in config files, and clarify the surrounding documentation. See <a href="stack%20new%20--%20AesonException%20#2275">#2275</a>.</li>
</ul>
<p><code>config.yaml</code> に <code>year</code> パラメータを指定できるようになったそうです。こんな感じです。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">templates:</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="fu">params:</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    <span class="fu">author-email:</span><span class="at"> 415fox@gmail.com</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    <span class="fu">author-name:</span><span class="at"> michael fox</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    <span class="fu">category:</span><span class="at"> Application</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">    <span class="fu">copyright:</span><span class="at"> copytright michael fox 2016</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    <span class="fu">github-username:</span><span class="at"> gitfoxi</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8">    <span class="fu">year:</span><span class="at"> 2016</span></a></code></pre></div>
<p>ドキュメントを見る限り <code>copyright</code> を省略した場合は <code>author-name</code> と <code>year</code> を使って <code>copyright</code> が生成されるようです。 また <code>year</code> を省略した場合は現在の年が設定されるとのことなので、設定しなくても良さそうですね。</p>
<blockquote>
<p>year - if copyright is not specified, year and author-name are used to generate the copyright property in cabal. If year is not specified, it defaults to the current year.</p>
</blockquote>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>VS Code で Ghcid を使う</title>
    <link href="https://haskell.e-bigmoon.com/posts/2017-12-24-Ghcid-with-VS-Code.html" />
    <id>https://haskell.e-bigmoon.com/posts/2017-12-24-Ghcid-with-VS-Code.html</id>
    <published>2017-12-24T00:00:00Z</published>
    <updated>2017-12-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Great original post: <a href="http://neilmitchell.blogspot.jp/2017/11/ghcid-with-vs-code.html">Ghcid with VS Code</a>.</p>
<p>2017年 11月 10日 Neil Mitchell</p>
<p><em>概要: 新しいバージョンの Ghcid と VS Code拡張がリリースされ、よりいい感じに動くようになった。</em></p>
<p><a href="https://hackage.haskell.org/package/ghcid">Ghcid v0.6.8</a> と関連する VS Code拡張 <a href="https://marketplace.visualstudio.com/items?itemName=ndmitchell.haskell-ghcid">haskell-ghcid v0.2.0</a> をリリースしました。 一緒に使うと、Ghcid + VS Code 環境をシンプルなものにしてくれます。</p>
<!--more-->
<h2 id="ghcid-ファイルの読み込み-ghcid">.ghcid ファイルの読み込み (Ghcid)</h2>
<p>Ghcid に、カレントディレクトリに <code>.ghcid</code> ファイルがあった場合はそれを追加の引数としてロードする機能が追加されました。 例えば、Shake レポジトリには <a href="https://github.com/ndmitchell/shake/blob/master/.ghcid">.ghcid</a> ファイルがあって:</p>
<pre><code>-c &quot;ghci -fno-code -ferror-spans&quot;</code></pre>
<p><code>ghcid</code> に、コマンドでこれを解釈させずに (例えば <code>.stack-work</code> があれば <code>stack</code> でこれを解釈させずに) 常に <code>ghci -fno-code -ferror-spans</code> を実行させています。 このコマンドは、<a href="https://github.com/ndmitchell/shake/blob/master/.ghci"><code>.ghci</code> ファイル</a> があって、必要なファイルを全てロードしているのでうまく動いています。 ちなみに <code>-fno-code</code> はコンパイル速度を上げるために、<code>-ferror-spans</code> はエラーのハイライトをより良くするために指定しています。</p>
<h2 id="ghcid-を開始-ghcid-vs-code">ghcid を開始 (Ghcid VS Code)</h2>
<p><code>Start Ghcid</code> アクションという VS Code 拡張の新機能は、新しい <code>ghcid</code> 端末を起動します。 起動した後、出力は一時ファイルに保存され、Problems ペインに表示されます。 この拡張は <code>ghcid</code> を追加の引数なしで実行するため、引数を渡したい場合は <code>.ghcid</code> でこの引数を指定する必要があります。</p>
<p>このような変更をしたのは、VS Code からより少ないキーで <code>ghcid</code> を開始するためです。 以前は、ファイルを開いたり、特別なフラグを追加したり、コマンドの実行などが必要でした。</p>]]></summary>
</entry>
<entry>
    <title>カスタムスナップショットの紹介</title>
    <link href="https://haskell.e-bigmoon.com/posts/2017-12-23-stack161.html" />
    <id>https://haskell.e-bigmoon.com/posts/2017-12-23-stack161.html</id>
    <published>2017-12-23T00:00:00Z</published>
    <updated>2017-12-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>ちょっと前に <a href="https://github.com/commercialhaskell/stack/blob/master/ChangeLog.md#v161">version 1.6.1</a> がリリースされたので、その中の目玉機能でもある <code>カスタムスナップショット</code> を紹介したいと思います。</p>
<!--more-->
<h2 id="news">NEWS</h2>
<p>すでに多くの方がご存知かと思いますが、<code>stack</code> 界隈で大きな出来事が3つありました。</p>
<ul>
<li><code>stack 1.6.1</code> のリリース</li>
<li><code>lts-10.0</code> のリリース</li>
<li><code>stack new</code> で生成されるテンプレートのデフォルトが <code>hpack</code> になった</li>
</ul>
<p>以下の記事は <code>hpack</code> についての記述があるため、stack 初心者におすすめです！</p>
<ul>
<li><a href="https://myuon.github.io/posts/haskell-project-setup/">Haskellプロジェクトを始めるにあたって</a></li>
<li><a href="https://qiita.com/ogata-k/items/2b21326b2b7351bfc28c">Haskellのstackによるプロジェクトについて</a></li>
<li><a href="https://qiita.com/waddlaw/items/49874f4cf9b680e4b015">本気で Haskell したい人向けの Stack チュートリアル</a>
<ul>
<li>僕が作成して、時々加筆修正していますが、量が多くなりすぎたのでどうにかしようと思っています・・・。</li>
<li>タイトルは煽っている感じが少々ありますが、結構真面目です。</li>
</ul></li>
</ul>
<p>ただ、古い記事が全部だめかというとそうでもありません。</p>
<p>細部を自分で補完できれば有用な記事も多くあります。</p>
<ul>
<li><a href="https://qiita.com/tanakh/items/6866d0f570d0547df026">Haskellのビルドツール“stack”の紹介</a></li>
<li><a href="https://qiita.com/igrep/items/da1d8df6d40eb001a561">Stackでやる最速Haskell Hello world! (GHCのインストール付き！)</a></li>
</ul>
<h2 id="custom-snapshots-カスタムスナップショット-について">Custom Snapshots (カスタムスナップショット) について</h2>
<ul>
<li><a href="https://docs.haskellstack.org/en/stable/custom_snapshot/">Custom Snapshots</a></li>
<li><a href="https://www.fpcomplete.com/blog/2017/07/stacks-new-extensible-snapshots">STACK’S NEW EXTENSIBLE SNAPSHOTS.</a></li>
<li><a href="https://github.com/commercialhaskell/stack/pull/3249">Extensible snapshots #3249</a></li>
</ul>
<p>カスタムスナップショットは名前から想像できるように、スナップショットを好きにカスタマイズできる新機能です！</p>
<p>公式のスナップショットは <code>resolver</code> に指定する <code>lts</code> や <code>nightly</code> で始まるものです。</p>
<p>カスタムスナップショットとは関係ないですが、<code>lts</code>, <code>nightly</code> とバージョンを省略すると最新版のスナップショットを指定できるという小技もあります。(<a href="https://github.com/commercialhaskell/stack/issues/3641">Feature request: stack init –latest-nightly #3641</a>)</p>
<pre class="shell"><code>$ stack new sample --resolver=nightly
$ stack new sample --resolver=lts</code></pre>
<h2 id="カスタムスナップショットを作ってみよう">カスタムスナップショットを作ってみよう！</h2>
<p>通常であれば <code>stack new</code> で生成されるプロジェクトの <code>stack.yaml</code> と <code>package.yaml</code> を使いますが、今回は全部ゼロから作って行こうと思います。</p>
<h3 id="カスタムスナップショットの作成">カスタムスナップショットの作成</h3>
<p>まずは <code>my-snapshot.yaml</code> という名前で空のファイルを作ります。</p>
<pre class="shell"><code>$ touch my-snapshot.yaml
$ tree
.
└── my-snapshot.yaml</code></pre>
<p>カスタムスナップショットを定義するためには、まずはベースとなるスナップショットを決める必要があります。</p>
<p>そのため、 <code>my-snapshot.yaml</code> に <code>resolver</code> を追記しましょう。今回は新しくリリースされた <code>lts-10.0</code> を指定します。</p>
<p>また <code>name</code> フィールドで自分のスナップショットに名前をつけます。</p>
<p>この2つが必須のフィールドになります。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">resolver:</span><span class="at"> lts-10.0</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="fu">name:</span><span class="at"> waddlaw-1.0</span></a></code></pre></div>
<p>これで <code>lts-10.0</code> と全く同じカスタムスナップショットを定義することができました。</p>
<p><code>name</code> フィールドは <code>~/.stack/snapshots/</code> 以下に保存されるスナップショットのディレクトリ名の一部として利用されたりします。</p>
<h3 id="stack.yaml-の作成">stack.yaml の作成</h3>
<p>実際に使ってみましょう。まずは <code>stack.yaml</code> を用意します。</p>
<pre class="shell"><code>$ touch stack.yaml

$ tree
.
├── my-snapshot.yaml
└── stack.yaml</code></pre>
<p><code>stack.yaml</code> の <code>resolver</code> に先に作ったカスタムスナップショットを指定します。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="fu">resolver:</span><span class="at"> my-snapshot.yaml</span></a></code></pre></div>
<p>このままでは <code>cabal</code> ファイルが無いため、まだビルドできません。</p>
<h3 id="package.yaml-の作成">package.yaml の作成</h3>
<p><code>package.yaml</code> もゼロから作っていきましょう。</p>
<pre class="shell"><code>$ touch package.yaml

$ tree
.
├── my-snapshot.yaml
├── package.yaml
└── stack.yaml</code></pre>
<p>最小の <code>package.yaml</code> はこんな感じです。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="fu">name:</span><span class="at"> test-custom-snapshot</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="fu">dependencies:</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">-</span> base</a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="fu">library:</span><span class="at"> </span><span class="kw">{}</span></a></code></pre></div>
<p>ではビルドしてみましょう。</p>
<pre class="shell"><code>$ stack build
...

$ tree
.
├── my-snapshot.yaml
├── package.yaml
├── stack.yaml
└── test-custom-snapshot.cabal</code></pre>
<p>無事に <code>cabal</code> ファイルが生成されていますね。</p>
<h2 id="パッケージの追加">パッケージの追加</h2>
<p>現時点の依存関係を確認してみます。</p>
<pre class="shell"><code>$ stack list-dependencies
base 4.10.1.0
ghc-prim 0.5.1.1
integer-gmp 1.0.1.0
rts 1.0
test-custom-snapshot 0.0.0</code></pre>
<p>まずは、いつも通り何かパッケージを追加してみましょう。</p>
<p>今回は <a href="https://www.stackage.org/package/hakyll-shakespeare">hakyll-shakespeare</a> を追加することにします。<code>hamlet</code> 記法が好きなので <code>hakyll</code> でサイト作る時は個人的にお世話になっているパッケージです。</p>
<p>現時点で <code>lts-10.0</code> に <code>hakyll-shakespeare</code> は含まれていません。</p>
<pre><code>$ cat my-snapshot.yaml
resolver: lts-10.0
name: waddlaw-1.0

packages:
  - hakyll-shakespeare-0.1.0.0.2</code></pre>
<p>こんな感じでカスタムスナップショットに <code>hakyll-shakespeare</code> を指定します。</p>
<p><code>packages</code> フィールドには <code>extra-deps</code> と同じ構文が利用できます。そのため <code>hackage</code> などにアップロードしていないパッケージでも同様に指定可能です。</p>
<p>それでは、ちゃんと追加されるか確認してみます。</p>
<pre class="shell"><code>$ stack build
$ stack list-dependencies | grep hakyll-shakespeare
hakyll-shakespeare 0.1.0.0.2</code></pre>
<p>大丈夫そうですね！</p>
<h2 id="カスタムスナップショットを共有する">カスタムスナップショットを共有する</h2>
<p>ここまでで基本的なカスタムスナップショットの作り方はマスターできたと思います。</p>
<p>しかし、複数のプロジェクトでカスタムスナップショットが利用できなければ、うれしさ半減です。なので、カスタムスナップショットには、そういった仕組みも用意されています。</p>
<p>どこかにカスタムスナップショットをアップロードし、単純に <code>resolver</code> に <code>URL</code> を指定するだけです。</p>
<pre class="shell"><code>$ cat stack.yaml
resolver: https://raw.githubusercontent.com/waddlaw/example-custom-snapshot/master/my-snapshot.yaml</code></pre>
<h3 id="注意点">注意点</h3>
<p>1つ注意しなければならない点として、ローカルに用意するカスタムスナップショットファイルと違い、リモートのファイルについてはイミュータブル (変更されないもの) として処理されるという点です。つまり、 <code>URL</code> にアクセスするのは一度だけということです。</p>
<p>そのため、リモートのファイルを上書き更新したとしても、その内容は既存のプロジェクトには反映されません。</p>
<pre class="shell"><code>$ tree ~/.stack/custom-plan/
/home/bm12/.stack/custom-plan/
└── yaml
    └── tCj-vP1QL-9k.yaml

$ cat ~/.stack/custom-plan/yaml/tCj-vP1QL-9k.yaml
resolver: lts-10.0
name: waddlaw-1.0

packages:
  - hakyll-shakespeare-0.1.0.0.2</code></pre>
<p>なので <code>Stackage</code> 同様にカスタムスナップショットの内容を変更する場合は、その都度新しいスナップショットを作る必要があります。</p>
<h2 id="カスタマイズ可能な設定">カスタマイズ可能な設定</h2>
<p>スナップショットをカスタマイズできる項目は以下の4つです。</p>
<ul>
<li>コンパイラの上書き</li>
<li>除外パッケージの指定</li>
<li>ghc-options の指定</li>
<li>flags の指定</li>
</ul>
<p>具体的な使い方についてはドキュメントをご確認ください。</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/blob/master/doc/custom_snapshot.md#using-a-url-instead-of-a-filepath">Custom Snapshots</a></li>
</ul>
<h2 id="まとめ">まとめ</h2>
<p>この機能は <code>Hakyll</code> などの静的サイトジェネレータを良く使う人にとっては、便利なのではないでしょうか。</p>
<p>個人的には、<code>lts-9</code> 系で最新の <code>pandoc</code> と <code>hakyll</code> を使おうとしたとき、数多くの <code>extra-deps</code> を追加する必要があり、そういう場面で便利かなと少し感じました。</p>]]></summary>
</entry>
<entry>
    <title>将来も使えるテストスイート</title>
    <link href="https://haskell.e-bigmoon.com/posts/2017-12-22-future-proofing-test-suites.html" />
    <id>https://haskell.e-bigmoon.com/posts/2017-12-22-future-proofing-test-suites.html</id>
    <published>2017-12-22T00:00:00Z</published>
    <updated>2017-12-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Great original post: <a href="https://www.snoyman.com/blog/2017/11/future-proofing-test-suites">Future proofing test suites</a>.</p>
<p>2017年 11月 12日 Michael Snoyman</p>
<p>まず、最近何回か見た具体的なケースから話を始めましょう。そしてそれを元に一般的な話をします。もしもあなたがパッケージの作者で、この問題に直面してきたのなら、ちょっと聞いてくださいよ。私がこの情報をブログの記事にしているのは、いくつものバグトラッカーで同じ説明を何回もするよりも、ここに一回だけ書いて、そのリンクを貼ればいいと考えたからです。</p>
<p><a href="https://www.stackage.org/package/hlint">hlint</a> は Haskell のコードをより良くするためのアドバイスをくれる、素晴らしいツールです (Neil Mitchell のもう一つの素晴らしいプロダクト)。その別のプロダクトのように、hlint もまた新しいバージョンで、より良いアドバイスをくれるような進化を遂げています。まぁこれは、昔の hlint では出なかった警告が、新しいバージョンで突然出るようになるかもしれない、という意味でもあります。</p>
<!--more-->
<p>最近、Stackage のキュレーション中に 2回、コードを全く変えていないのに、何個もテストが失敗するのを見ています。この、以前通っていたテストが失敗するようになる現象は、hlint のバージョンを新しくしたのが原因でした。これは明らかに、hlint のバージョンを新しくしたからコードがいきなりぶっ壊れたのではありません。テストの失敗の診断が関係しているので、hlint の警告のせいでしょうね (意訳)。</p>
<h2 id="推奨するやり方">推奨するやり方</h2>
<p>hlint を使ってプロジェクトのコードを改善するのは、すごくおすすめです。Stack などの CI のプロセスでこいつを使って、素晴らしい結果を返してくれるのを何回か見ています。(ちなみにこれは私のアイディアではなくて、実際に使ったりもしていませんでした。ただスタイルエラーがある PR を投げてしまって、それが失敗するのに気づいて、嬉しい驚きだった、というだけです)。でも、hlint のバージョンを新しくしたせいで、パッケージ全体としてのテストが失敗する現象。これは起こりすぎです。なので、</p>
<ul>
<li>警告が出る PR をブロックしたいのなら、CI から hlint を呼び出すように<strong>してください</strong>。私が思いつく方法は 2つあります:
<ul>
<li>Stack のやり方をまねる。Stack にはスタイルエラー専用の、<a href="https://github.com/commercialhaskell/stack/blob/46121be1b96465f1164e3f84cafa19c7369da9cc/.travis.yml#L39">Travis CI のビルドマトリックス</a>があります。プロジェクトの cabal ファイルは、hlint について何も知りません。</li>
<li>cabalファイルのテストを使うが、デフォルトで無効にしておく。CI の設定から、フラグを使ってそのテストを有効にします。 </li>
</ul></li>
<li>Hackage にアップロードされ、Stackage でビルドされた際に、スタイルに関連するエラーによってテストが失敗するようなパッケージのセットアップはやめましょう。</li>
</ul>
<h2 id="一般的に推奨するやり方">一般的に推奨するやり方</h2>
<p>ここから考察される一般論は、CI でコードをビルドするときは、やりたいだけ厳密にやる、ということです。標準を高く保ち、PR をブロックし、master がぶっ壊れた! と叫んでください。ささいな問題でもそうでなくても、重要だと思う問題全てに対してです。<code>-Wall -Werror</code> をオンにし、タブや文末のスペースに対してエラーを吐くようにしてください。これらは全て良いものです (タブかスペースかなどの、必要な議論はしてください)。</p>
<p>しかし、他の場所でコードをリリースするときは、メインではない機能に対しては、テストを緩くしましょう。コードがビルドに失敗するのなら、それは問題です。ビルドに成功しても、実行時に正しくない結果を返すようなら、それは問題です。これらの問題が存在すると、Stackage などのビルドシステムは、そのようなパッケージを受け入れてくれません。でも、スタイルの問題や新しく追加されたコンパイラの警告のようなものなら、あなたのパッケージを使うより下流の利用者に対して、失敗させるべきではないでしょうね。</p>]]></summary>
</entry>
<entry>
    <title>stack ls コマンドが追加されます</title>
    <link href="https://haskell.e-bigmoon.com/posts/2017-12-20-stack-ls-command.html" />
    <id>https://haskell.e-bigmoon.com/posts/2017-12-20-stack-ls-command.html</id>
    <published>2017-12-20T00:00:00Z</published>
    <updated>2017-12-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><code>Stack</code> の <code>master</code> に <code>stack ls</code> コマンドがマージされました。</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/3672">Add stack ls snapshots documentation to the user guide #3672</a></li>
</ul>
<p>今後、このコマンドのサブコマンドに <code>list-dependencies</code> などを順次追加していく方針?のようです。</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/issues/3669">Stack list-dependencies : Bring it under the new ls umbrella command #3669</a></li>
</ul>
<!--more-->
<h2 id="使ってみよう">使ってみよう！</h2>
<p>このコマンドを使うためには <code>stack</code> の <code>master</code> ブランチの最新版をインストールする必要があります。</p>
<pre class="shell"><code>$ stack upgrade --git
# ソースからコンパイルするので時間がかかります

$ stack --version
Version 1.7.0, Git revision 7d68bd695c4de8f231a95e66d0c882031f8255de (5468 commits) x86_64 hpack-0.20.0</code></pre>
<p>現状、実装されているコマンドとしては <code>stack ls snapshots</code> があります。</p>
<pre class="shell"><code># ローカルのスナップショット一覧を表示
$ stack ls snapshots

# lts のみ表示 (lts の略)
$ stack ls snapshots -l

# nightly のみ表示 (nightly の略)
$ stack ls snapshots -n

# リモートのスナップショット一覧を表示
$ stack ls snapshots remote

$ stack ls snapshots -l remote

$ stack ls snapshots -n remote</code></pre>
<p>実行すると <code>less</code> が立ち上がり、結果を確認することができます。</p>
<p>もとの <code>stack</code> のバージョンに戻すためには以下のコマンドを実行しましょう。</p>
<pre class="shell"><code>$ stack upgrade --binary-version 1.6.1
# バイナリが落ちてくるのですぐに元通りです。

$ stack --version
Version 1.6.1, Git revision f25811329bbc40b0c21053a8160c56f923e1201b (5435 commits) x86_64 hpack-0.20.0</code></pre>
<h2 id="まとめ">まとめ</h2>
<p>これで <a href="https://www.stackage.org/">Stackage</a> を見なくても、どんなスナップショットが利用できるか、すぐに確認できるようになりますね。</p>]]></summary>
</entry>
<entry>
    <title>Haskell で暗号学的ハッシュを扱う</title>
    <link href="https://haskell.e-bigmoon.com/posts/2017-09-18-cryptographic-hashing-haskell.html" />
    <id>https://haskell.e-bigmoon.com/posts/2017-09-18-cryptographic-hashing-haskell.html</id>
    <published>2017-09-18T00:00:00Z</published>
    <updated>2017-09-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Great original post: <a href="https://www.fpcomplete.com/blog/2017/09/cryptographic-hashing-haskell">CRYPTOGRAPHIC HASHING IN HASKELL.</a>.</p>
<p>2017年 9月 18日 Michael Snoyman</p>
<p><a href="https://www.stackage.org/package/cryptonite">cryptonite</a> は現在、Haskell で暗号を扱う際のデファクトスタンダードです。 一般的に安全な乱数、共通鍵・公開鍵暗号、MAC (メッセージ認証符号)等をサポートしていて、その中には今日の話題、暗号学的ハッシュも含まれています。</p>
<p>まず、ハッシュ関数について軽く説明しましょう。ハッシュ関数とは、任意長のデータを固定長のデータに変換するものです。暗号学的ハッシュ関数は、暗号を扱う上で望ましい性質をそなえたハッシュ関数です (詳しくは <a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">Wikipedia</a> を参照)。 一般的な暗号学的ハッシュ関数の使われ方の一例として、ダウンロードされたファイルが改ざんされていないことを保証するための、チェックサムを提供する、というものがあります。 今日使われている暗号学的ハッシュ関数には、SHA256、Skein512、そしてまぁ、ちょっと古いですが MD5 などがあります。</p>
<p><code>cryptonite</code> は <a href="https://www.stackage.org/package/memory">memory</a> というライブラリの一番上の階層にあります。この <code>memory</code> ライブラリは、Byte 配列を扱うための型クラスと便利な関数を提供しています。 「全て <code>ByteString</code> でいいのでは?」と思うかもしれませんが、後ほどこの型クラスの便利さを示します。</p>
<!--more-->
<p>一旦これら 2つのライブラリに慣れれば、簡単に使いこなすことができます。 ですが、API のドキュメントを見るだけでは、部分部分がどう組み合わさるのか理解するのは至難の技です。特に、どこで明示的な型シグネチャが必要になるのかの理解が難しい。 この記事では、理解に必要な部分について1つ1つの簡単な例を、実行可能なコードで紹介します。 読み進める中で、API のドキュメントについてざっくりと理解していってください。</p>
<p>この記事のコードの例は、全て <code>Stack</code> のスクリプトインタプリタ機能を使っています。 まず <code>Stack</code> を<a href="https://haskell-lang.org/get-started">インストール</a>して、次の手順で実行してください。</p>
<ul>
<li><code>Main.hs</code> にコードをコピペする</li>
<li><code>stack Main.hs</code> を実行</li>
</ul>
<h2 id="基本的な型クラス">基本的な型クラス</h2>
<p>文字列っぽい型を扱うのは慣れているでしょう? 正格・遅延評価される <code>ByteString</code> や <code>Text</code> や普通の <code>String</code> などです。 正格なバイトシーケンスを表現する際、<code>Data.ByteString.ByteString</code> を思い浮かべるのではないでしょうか。 しかし、これから見るように、バイトシーケンスとして扱いたい型はいろいろ見つかります。</p>
<p><code>memory</code> はこの要望に答えるべく、以下の 2つの型クラスを定義しています。</p>
<ul>
<li><code>ByteArrayAccess</code> ある型のバイトへ、読み取り専用のアクセスを提供</li>
<li><code>ByteArray</code> 読み / 書きのアクセスを提供する。<code>ByteArrayAccess</code> の子クラス</li>
</ul>
<p>例えば、以下に示すコードは、意味もなく <code>ByteString</code> と <code>Byte</code> の変換をしています。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteArray</span> <span class="kw">as</span> <span class="dt">BA</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">import</span> <span class="dt">Data.ByteString</span> (<span class="dt">ByteString</span>)</a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString</span> <span class="kw">as</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-9" data-line-number="9">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  B.writeFile <span class="st">&quot;test.txt&quot;</span> <span class="st">&quot;This is a test&quot;</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  byteString <span class="ot">&lt;-</span> B.readFile <span class="st">&quot;test.txt&quot;</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  <span class="kw">let</span><span class="ot"> bytes ::</span> <span class="dt">BA.Bytes</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">      bytes <span class="fu">=</span> BA.convert byteString</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">  print bytes</a></code></pre></div>
<p><code>bytestring</code> ライブラリを使ってファイルの入出力から話を始めたのは、<a href="http://www.snoyman.com/blog/2016/12/beware-of-readfile">入出力は bytestring でやるべき</a> だからです。 <code>convert</code>関数を使うと、<code>ByteString</code> を <code>Bytes</code> に変換することができます。</p>
<p><strong>練習問題</strong> 上の2つの型クラスの説明を踏まえて <code>convert</code> の型シグネチャは何だと思いますか? 答えは<a href="https://www.stackage.org/haddock/lts-9.4/memory-0.14.7/Data-ByteArray.html#v:convert">こちら</a>。</p>
<p><code>bytes</code> の値につけた、明示的な型シグネチャに気がつきましたか? えーと、<code>memory</code> と <code>cryptonite</code> を使っていく上で、これは大事です。 こうして、よく GHC に、型推論についてのヒントを与えてやらないといけなくなります。 なぜなら、これらのライブラリの中のかなり多くの関数が、具体的な型ではなく、型クラスを使っているからです。</p>
<p>さて、<code>ByteArrayAccess</code> に属する型の例をお見せしましたが、それは<code>ByteArray</code> についての例ではありませんでした。 今は型クラスを分ける意味が分からないかもしれませんが、実際にハッシュを使う段階で、型クラスを分けることの利点が見えてくると思います。 ちょっと待ってくださいね。</p>
<h3 id="なぜ違う型があるのか">なぜ違う型があるのか</h3>
<p>当然、<code>memory</code> の中になぜ <code>Bytes</code> という型があるのか、疑問に思う人もいるでしょうね。 <code>ByteString</code> と同じじゃないの? ってね。 まぁ違うんですけどね。 <code>Bytes</code> はメモリスライスのオフセットと長さを追跡しないことで、メモリのオーバーヘッドを小さくしています。 その代わりに、<code>Bytes</code> の値をスライスすることは許されません。 言い換えれば、<code>Bytes</code> に関する <code>drop</code>関数は、バッファの新しいコピーを作らなければならないということです。</p>
<p>まぁつまり、これはパフォーマンスの問題です。暗号を扱うライブラリは、一般的にパフォーマンスを重視する必要がありますからね。</p>
<p>また別の <code>memory</code> のおもしろい型に、<a href="https://www.stackage.org/haddock/lts-9.4/memory-0.14.7/Data-ByteArray.html#t:ScrubbedBytes"><code>ScrubbedBytes</code></a> というものがあります。 この型は、3つの特別な性質を有しています。 <code>Haddock</code> によると、</p>
<ul>
<li>スコープの範囲から出るとゴシゴシされる</li>
<li><code>Show</code> インスタンスは、中身を何1つとして出力しない</li>
<li>定数時間の <code>Eq</code> インスタンス</li>
</ul>
<p>つまり、これらの性質は何か機密性の高いデータを扱うとき、ありふれた脆弱性をいくつも塞いでくれるものです。</p>
<p>うん、コードがあまりない説明になりましたね。 もっと楽しいことをしよう!</p>
<h2 id="base16-エンコードデコード">Base16 エンコード/デコード</h2>
<p>ユーザの入力を、Base16 (16進数) に変換してみましょう。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteArray</span>          <span class="kw">as</span> <span class="dt">BA</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="kw">import</span>           <span class="dt">Data.ByteArray.Encoding</span> (convertToBase, <span class="dt">Base</span> (<span class="dt">Base16</span>))</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Data.ByteString</span>         (<span class="dt">ByteString</span>)</a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Data.Text.Encoding</span>      (encodeUtf8)</a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.IO</span>            <span class="kw">as</span> <span class="dt">TIO</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">System.IO</span>               (hFlush, stdout)</a>
<a class="sourceLine" id="cb2-9" data-line-number="9"></a>
<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">  putStr <span class="st">&quot;Enter some text: &quot;</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13">  hFlush stdout</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">  text <span class="ot">&lt;-</span> TIO.getLine</a>
<a class="sourceLine" id="cb2-15" data-line-number="15">  <span class="kw">let</span> bs <span class="fu">=</span> encodeUtf8 text</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">  putStrLn <span class="fu">$</span> <span class="st">&quot;You entered: &quot;</span> <span class="fu">++</span> show bs</a>
<a class="sourceLine" id="cb2-17" data-line-number="17">  <span class="kw">let</span> encoded <span class="fu">=</span> convertToBase <span class="dt">Base16</span><span class="ot"> bs ::</span> <span class="dt">ByteString</span></a>
<a class="sourceLine" id="cb2-18" data-line-number="18">  putStrLn <span class="fu">$</span> <span class="st">&quot;Converted to base 16: &quot;</span> <span class="fu">++</span> show encoded</a></code></pre></div>
<p><code>convertToBase</code> は、どんな <code>ByteArrayAccess</code> も、与えられた基数を使って <code>ByteArray</code> に変換することができます。Base16 以外の基数には、Base64 などがあります。</p>
<p>見てお分かりの通り、上の例では明示的に <code>ByteString</code> の型シグネチャを指定する必要がありました。なぜならそうしなければ、GHC が<code>ByteArrayAccess</code> のインスタンスの内、どれを使うべきなのか判断できないからです。</p>
<p>既にお分かりかもしれませんが、全く逆の変換を行う、<code>convertFromBase</code>関数も存在します。 この関数は、入力のフォーマットが正しくなかった場合にも対応できるように、<code>Either String ByteArray</code> の値を返します。</p>
<p><strong>練習問題</strong> 入力に対して、Base16 のデコードを行うプログラムを書いてください (解答はすぐ下)。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteArray</span>          <span class="kw">as</span> <span class="dt">BA</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="kw">import</span>           <span class="dt">Data.ByteArray.Encoding</span> (convertFromBase, <span class="dt">Base</span> (<span class="dt">Base16</span>))</a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Data.ByteString</span>         (<span class="dt">ByteString</span>)</a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Data.Text.Encoding</span>      (encodeUtf8)</a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.IO</span>            <span class="kw">as</span> <span class="dt">TIO</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">System.IO</span>               (hFlush, stdout)</a>
<a class="sourceLine" id="cb3-9" data-line-number="9"></a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-12" data-line-number="12">  putStr <span class="st">&quot;Enter some hexadecimal text: &quot;</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13">  hFlush stdout</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">  text <span class="ot">&lt;-</span> TIO.getLine</a>
<a class="sourceLine" id="cb3-15" data-line-number="15">  <span class="kw">let</span> bs <span class="fu">=</span> encodeUtf8 text</a>
<a class="sourceLine" id="cb3-16" data-line-number="16">  putStrLn <span class="fu">$</span> <span class="st">&quot;You entered: &quot;</span> <span class="fu">++</span> show bs</a>
<a class="sourceLine" id="cb3-17" data-line-number="17">  <span class="kw">case</span> convertFromBase <span class="dt">Base16</span> bs <span class="kw">of</span></a>
<a class="sourceLine" id="cb3-18" data-line-number="18">    <span class="dt">Left</span> e <span class="ot">-&gt;</span> error <span class="fu">$</span> <span class="st">&quot;Invalid input: &quot;</span> <span class="fu">++</span> e</a>
<a class="sourceLine" id="cb3-19" data-line-number="19">    <span class="dt">Right</span> decoded <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb3-20" data-line-number="20">      putStrLn <span class="fu">$</span> <span class="st">&quot;Converted from base 16: &quot;</span> <span class="fu">++</span> show (<span class="ot">decoded ::</span> <span class="dt">ByteString</span>)</a></code></pre></div>
<p><em>練習問題</em> Base16 の入力を、Base64 のエンコードに変換するプログラムを書いてください。</p>
<h2 id="正格な-bytestring-のハッシュ">正格な <code>ByteString</code> のハッシュ</h2>
<p>よし、<code>memory</code> ライブラリに関する説明はもう十分でしょう。 これからは実際に暗号的なものをやっていきます。ユーザの入力を、SHA256 のハッシュ値 (ダイジェスト) に変換してみましょう。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Crypto.Hash</span>             (hash, <span class="dt">SHA256</span> (..), <span class="dt">Digest</span>)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="kw">import</span>           <span class="dt">Data.ByteString</span>         (<span class="dt">ByteString</span>)</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Data.Text.Encoding</span>      (encodeUtf8)</a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.IO</span>            <span class="kw">as</span> <span class="dt">TIO</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="kw">import</span>           <span class="dt">System.IO</span>               (hFlush, stdout)</a>
<a class="sourceLine" id="cb4-8" data-line-number="8"></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-10" data-line-number="10">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11">  putStr <span class="st">&quot;Enter some text: &quot;</span></a>
<a class="sourceLine" id="cb4-12" data-line-number="12">  hFlush stdout</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">  text <span class="ot">&lt;-</span> TIO.getLine</a>
<a class="sourceLine" id="cb4-14" data-line-number="14">  <span class="kw">let</span> bs <span class="fu">=</span> encodeUtf8 text</a>
<a class="sourceLine" id="cb4-15" data-line-number="15">  putStrLn <span class="fu">$</span> <span class="st">&quot;You entered: &quot;</span> <span class="fu">++</span> show bs</a>
<a class="sourceLine" id="cb4-16" data-line-number="16">  <span class="kw">let</span><span class="ot"> digest ::</span> <span class="dt">Digest</span> <span class="dt">SHA256</span></a>
<a class="sourceLine" id="cb4-17" data-line-number="17">      digest <span class="fu">=</span> hash bs</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">  putStrLn <span class="fu">$</span> <span class="st">&quot;SHA256 hash: &quot;</span> <span class="fu">++</span> show digest</a></code></pre></div>
<p>たった今、<code>ByteString</code> (かもしくは <code>ByteArrayAccess</code> のインスタンス) を <code>Digest SHA256</code> に変換するために <code>hash</code> 関数を使いました。 実際、SHA256 以外のハッシュアルゴリズムも指定することができます。</p>
<p>今回の例では、<code>Digest SHA256</code> という型シグネチャが大事でした。GHC にどんなハッシュを使うのか知らせるためです。しかし次の例では、その代わりの関数が登場します。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Crypto.Hash</span>             (hashWith, <span class="dt">SHA256</span> (..))</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="kw">import</span>           <span class="dt">Data.ByteString</span>         (<span class="dt">ByteString</span>)</a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Data.Text.Encoding</span>      (encodeUtf8)</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.IO</span>            <span class="kw">as</span> <span class="dt">TIO</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="kw">import</span>           <span class="dt">System.IO</span>               (hFlush, stdout)</a>
<a class="sourceLine" id="cb5-8" data-line-number="8"></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">  putStr <span class="st">&quot;Enter some text: &quot;</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">  hFlush stdout</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">  text <span class="ot">&lt;-</span> TIO.getLine</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">  <span class="kw">let</span> bs <span class="fu">=</span> encodeUtf8 text</a>
<a class="sourceLine" id="cb5-15" data-line-number="15">  putStrLn <span class="fu">$</span> <span class="st">&quot;You entered: &quot;</span> <span class="fu">++</span> show bs</a>
<a class="sourceLine" id="cb5-16" data-line-number="16">  <span class="kw">let</span> digest <span class="fu">=</span> hashWith <span class="dt">SHA256</span> bs</a>
<a class="sourceLine" id="cb5-17" data-line-number="17">  putStrLn <span class="fu">$</span> <span class="st">&quot;SHA256 hash: &quot;</span> <span class="fu">++</span> show digest</a></code></pre></div>
<p><code>Digest</code> の <code>Show</code> インスタンスは、ダイジェストを16進数 (Base16) で表示します。これはいいですね。 しかし、これをBase64 で表示したい欲求にかられたらどうでしょう? 考えてみましょう。 <code>Digest</code> は <code>ByteArrayAccess</code> のインスタンスです。なので、<code>convertToBase</code> を使うことができます (そして、<code>Digest</code> は <code>ByteArray</code>のインスタンスではありません。そうしてしまったら問題が生じるのですが、それはなぜでしょうか? 行き詰まったら、<a href="https://www.stackage.org/haddock/lts-9.3/cryptonite-0.23/Crypto-Hash.html#v:digestFromByteString">この関数のドキュメント</a>を読んでみましょう。答えが載っています。)。</p>
<p><strong>練習問題</strong> ダイジェストを Base64 でエンコードされた文字列として出力してみましょう (答えはすぐ下)。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Crypto.Hash</span>             (hashWith, <span class="dt">SHA256</span> (..))</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="kw">import</span>           <span class="dt">Data.ByteString</span>         (<span class="dt">ByteString</span>)</a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Data.ByteArray.Encoding</span> (convertToBase, <span class="dt">Base</span> (<span class="dt">Base64</span>))</a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Data.Text.Encoding</span>      (encodeUtf8)</a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.IO</span>            <span class="kw">as</span> <span class="dt">TIO</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">System.IO</span>               (hFlush, stdout)</a>
<a class="sourceLine" id="cb6-9" data-line-number="9"></a>
<a class="sourceLine" id="cb6-10" data-line-number="10"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">  putStr <span class="st">&quot;Enter some text: &quot;</span></a>
<a class="sourceLine" id="cb6-13" data-line-number="13">  hFlush stdout</a>
<a class="sourceLine" id="cb6-14" data-line-number="14">  text <span class="ot">&lt;-</span> TIO.getLine</a>
<a class="sourceLine" id="cb6-15" data-line-number="15">  <span class="kw">let</span> bs <span class="fu">=</span> encodeUtf8 text</a>
<a class="sourceLine" id="cb6-16" data-line-number="16">  putStrLn <span class="fu">$</span> <span class="st">&quot;You entered: &quot;</span> <span class="fu">++</span> show bs</a>
<a class="sourceLine" id="cb6-17" data-line-number="17">  <span class="kw">let</span> digest <span class="fu">=</span> convertToBase <span class="dt">Base64</span> (hashWith <span class="dt">SHA256</span> bs)</a>
<a class="sourceLine" id="cb6-18" data-line-number="18">  putStrLn <span class="fu">$</span> <span class="st">&quot;SHA256 hash: &quot;</span> <span class="fu">++</span> show (<span class="ot">digest ::</span> <span class="dt">ByteString</span>)</a></code></pre></div>
<p><code>digest</code> が <code>ByteString</code> であることを明確にするために、型シグネチャが必要な理由を押さえてください。</p>
<h2 id="マッチするファイルがあるかどうか調べる">マッチするファイルがあるかどうか調べる</h2>
<p>ここにちょっとしたプログラムがあります。ユーザはコマンドライン引数として、複数個のファイル名を渡します。そして、プログラムは同一の内容の全てのファイルのリストを表示します (少なくとも、SHA256 のハッシュ値がマッチするファイルを。それと、以下の定義には、メモリの効率がよろしくない部分があります。見つけてみてください。この点についてはまた後述します)。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Crypto.Hash</span>             (<span class="dt">Digest</span>, <span class="dt">SHA256</span>, hash)</a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString</span>         <span class="kw">as</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Data.Foldable</span>           (forM_)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Data.Map.Strict</span>         (<span class="dt">Map</span>)</a>
<a class="sourceLine" id="cb7-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span>         <span class="kw">as</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">System.Environment</span>      (getArgs)</a>
<a class="sourceLine" id="cb7-9" data-line-number="9"></a>
<a class="sourceLine" id="cb7-10" data-line-number="10"><span class="ot">readFile&#39; ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Map</span> (<span class="dt">Digest</span> <span class="dt">SHA256</span>) [FilePath])</a>
<a class="sourceLine" id="cb7-11" data-line-number="11">readFile&#39; fp <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-12" data-line-number="12">  bs <span class="ot">&lt;-</span> B.readFile fp</a>
<a class="sourceLine" id="cb7-13" data-line-number="13">  <span class="kw">let</span> digest <span class="fu">=</span> hash bs <span class="co">-- notice lack of type signature :)</span></a>
<a class="sourceLine" id="cb7-14" data-line-number="14">  return <span class="fu">$</span> Map.singleton digest [fp]</a>
<a class="sourceLine" id="cb7-15" data-line-number="15"></a>
<a class="sourceLine" id="cb7-16" data-line-number="16"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-17" data-line-number="17">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-18" data-line-number="18">  args <span class="ot">&lt;-</span> getArgs</a>
<a class="sourceLine" id="cb7-19" data-line-number="19">  m <span class="ot">&lt;-</span> Map.unionsWith (<span class="fu">++</span>) <span class="fu">&lt;$&gt;</span> mapM readFile&#39; args</a>
<a class="sourceLine" id="cb7-20" data-line-number="20">  forM_ (Map.toList m) <span class="fu">$</span> \(digest, files) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb7-21" data-line-number="21">    <span class="kw">case</span> files <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-22" data-line-number="22">      [] <span class="ot">-&gt;</span> error <span class="st">&quot;can never happen&quot;</span></a>
<a class="sourceLine" id="cb7-23" data-line-number="23">      [_] <span class="ot">-&gt;</span> return () <span class="co">-- only one file</span></a>
<a class="sourceLine" id="cb7-24" data-line-number="24">      <span class="co">--                                     unwords :: [String] -&gt; String</span></a>
<a class="sourceLine" id="cb7-25" data-line-number="25">      _ <span class="ot">-&gt;</span> putStrLn <span class="fu">$</span> show digest <span class="fu">++</span> <span class="st">&quot;: &quot;</span> <span class="fu">++</span> unwords (map show files)</a></code></pre></div>
<p><strong>練習問題</strong> コマンドライン引数として与えられた全てのファイルの SHA256 ハッシュ値を表示するプログラムを書いてください。</p>
<p><strong>質問</strong> 上のコードの、どこが非効率的なのでしょうか? 答えは次の章にあります。</p>
<h2 id="より効率的なファイルハッシュ">より効率的なファイルハッシュ</h2>
<p>もしもハッシュ関数を使わなければ、さっきのプログラムの実装は、それぞれのファイルの中身をメモリ上に一度に展開するか、O(n^2) のペアの比較をするような変なものになっていたでしょう。 さっきのハッシュを使った実装は、それよりも良い実装です。しかし、まだ問題があります。 <code>Data.ByteString.readFile</code>を使っているので、際限なくメモリを使ってしまう可能性があります。 <code>cryptonite-conduit</code> を使うと、ファイルの内容全てをもっと効率良くハッシュできます。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Crypto.Hash</span>         (<span class="dt">Digest</span>, <span class="dt">SHA256</span>, hash)</a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="kw">import</span>           <span class="dt">Crypto.Hash.Conduit</span> (hashFile)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Data.Foldable</span>       (forM_)</a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Data.Map.Strict</span>     (<span class="dt">Map</span>)</a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span>     <span class="kw">as</span> <span class="dt">Map</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">System.Environment</span>  (getArgs)</a>
<a class="sourceLine" id="cb8-9" data-line-number="9"></a>
<a class="sourceLine" id="cb8-10" data-line-number="10"><span class="ot">readFile&#39; ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Map</span> (<span class="dt">Digest</span> <span class="dt">SHA256</span>) [FilePath])</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">readFile&#39; fp <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">  digest <span class="ot">&lt;-</span> hashFile fp</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">  return <span class="fu">$</span> Map.singleton digest [fp]</a>
<a class="sourceLine" id="cb8-14" data-line-number="14"></a>
<a class="sourceLine" id="cb8-15" data-line-number="15"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-17" data-line-number="17">  args <span class="ot">&lt;-</span> getArgs</a>
<a class="sourceLine" id="cb8-18" data-line-number="18">  m <span class="ot">&lt;-</span> Map.unionsWith (<span class="fu">++</span>) <span class="fu">&lt;$&gt;</span> mapM readFile&#39; args</a>
<a class="sourceLine" id="cb8-19" data-line-number="19">  forM_ (Map.toList m) <span class="fu">$</span> \(digest, files) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-20" data-line-number="20">    <span class="kw">case</span> files <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-21" data-line-number="21">      [] <span class="ot">-&gt;</span> error <span class="st">&quot;can never happen&quot;</span></a>
<a class="sourceLine" id="cb8-22" data-line-number="22">      [_] <span class="ot">-&gt;</span> return () <span class="co">-- only one file</span></a>
<a class="sourceLine" id="cb8-23" data-line-number="23">      _ <span class="ot">-&gt;</span> putStrLn <span class="fu">$</span> show digest <span class="fu">++</span> <span class="st">&quot;: &quot;</span> <span class="fu">++</span> unwords (map show files)</a></code></pre></div>
<p>かなりシンプルな変更です (というか、こっちの方が少し読みやすいのではないでしょうか)。 さらに、かなりメモリ効率の良いコードになりました(ファイル数に対して線形時間、ファイルサイズに対しては定数時間です)。</p>
<h2 id="ストリームハッシュ">ストリーム・ハッシュ</h2>
<p><code>conduit</code> と聞いて、耳か目が即座に反応したかもしれません。 質問された体で答えましょう。 はい、ハッシュに関してもストリーミング処理ができます。ここに、URL とファイルパスを受け取って、その URL の response body の中身をファイルパスに書きこみ、SHA256 でダイジェストを表示するプログラムがあります。 そして、それぞれのデータチャンクを 1回しか参照しないのがいいですね。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Crypto.Hash</span>         (<span class="dt">Digest</span>, <span class="dt">SHA256</span>, hash)</a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="kw">import</span> <span class="dt">Crypto.Hash.Conduit</span> (sinkHash)</a>
<a class="sourceLine" id="cb9-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Network.HTTP.Simple</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="kw">import</span> <span class="dt">System.Environment</span>  (getArgs)</a>
<a class="sourceLine" id="cb9-8" data-line-number="8"></a>
<a class="sourceLine" id="cb9-9" data-line-number="9"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-11" data-line-number="11">  args <span class="ot">&lt;-</span> getArgs</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">  (url, fp) <span class="ot">&lt;-</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13">    <span class="kw">case</span> args <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-14" data-line-number="14">      [x, y] <span class="ot">-&gt;</span> return (x, y)</a>
<a class="sourceLine" id="cb9-15" data-line-number="15">      _ <span class="ot">-&gt;</span> error <span class="fu">$</span> <span class="st">&quot;Expected: URL FILEPATH&quot;</span></a>
<a class="sourceLine" id="cb9-16" data-line-number="16">  req <span class="ot">&lt;-</span> parseRequest url</a>
<a class="sourceLine" id="cb9-17" data-line-number="17">  digest <span class="ot">&lt;-</span> runResourceT <span class="fu">$</span> httpSink req <span class="fu">$</span> \_res <span class="ot">-&gt;</span> getZipSink <span class="fu">$</span></a>
<a class="sourceLine" id="cb9-18" data-line-number="18">    <span class="dt">ZipSink</span> (sinkFile fp) <span class="fu">*&gt;</span></a>
<a class="sourceLine" id="cb9-19" data-line-number="19">    <span class="dt">ZipSink</span> sinkHash</a>
<a class="sourceLine" id="cb9-20" data-line-number="20">  print (<span class="ot">digest ::</span> <span class="dt">Digest</span> <span class="dt">SHA256</span>)</a></code></pre></div>
<p><code>conduit</code> にできるなら、もちろんあなたにもできるはずです。 <code>conduit</code> を使わずに、<code>hashFile</code> を実装してみましょう。 こうすることで、ハッシュの API の内部がいくらか分かります。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Crypto.Hash</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="kw">import</span> <span class="dt">System.Environment</span>  (getArgs)</a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="kw">import</span> <span class="dt">System.IO</span> (withBinaryFile, <span class="dt">IOMode</span> (<span class="dt">ReadMode</span>))</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Data.Foldable</span> (forM_)</a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString</span> <span class="kw">as</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8"></a>
<a class="sourceLine" id="cb10-9" data-line-number="9"><span class="ot">hashFile ::</span> <span class="dt">HashAlgorithm</span> ha <span class="ot">=&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Digest</span> ha)</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">hashFile fp <span class="fu">=</span> withBinaryFile fp <span class="dt">ReadMode</span> <span class="fu">$</span> \h <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb10-11" data-line-number="11">  <span class="kw">let</span> loop context <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-12" data-line-number="12">        chunk <span class="ot">&lt;-</span> B.hGetSome h <span class="dv">4096</span></a>
<a class="sourceLine" id="cb10-13" data-line-number="13">        <span class="kw">if</span> B.null chunk</a>
<a class="sourceLine" id="cb10-14" data-line-number="14">          <span class="kw">then</span> return <span class="fu">$</span> hashFinalize context</a>
<a class="sourceLine" id="cb10-15" data-line-number="15">          <span class="kw">else</span> loop <span class="fu">$!</span> hashUpdate context chunk</a>
<a class="sourceLine" id="cb10-16" data-line-number="16">   <span class="kw">in</span> loop hashInit</a>
<a class="sourceLine" id="cb10-17" data-line-number="17"></a>
<a class="sourceLine" id="cb10-18" data-line-number="18"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb10-19" data-line-number="19">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-20" data-line-number="20">  args <span class="ot">&lt;-</span> getArgs</a>
<a class="sourceLine" id="cb10-21" data-line-number="21">  forM_ args <span class="fu">$</span> \fp <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-22" data-line-number="22">    digest <span class="ot">&lt;-</span> hashFile fp</a>
<a class="sourceLine" id="cb10-23" data-line-number="23">    putStrLn <span class="fu">$</span> show (<span class="ot">digest ::</span> <span class="dt">Digest</span> <span class="dt">SHA256</span>) <span class="fu">++</span> <span class="st">&quot;  &quot;</span> <span class="fu">++</span> fp</a></code></pre></div>
<p>この実装では <code>Crypto.Hash</code> で提供されている純粋なハッシュ更新用関数を使っています。 今回の場合、いくつかバッファのコピーをスキップすることで、もう少し効率の良い実装を可能にする、可変ハッシュの関数を使うことができます。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="co">-- stack --resolver lts-9.3 script</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Crypto.Hash</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Crypto.Hash.IO</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5"><span class="kw">import</span> <span class="dt">System.Environment</span>  (getArgs)</a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="kw">import</span> <span class="dt">System.IO</span> (withBinaryFile, <span class="dt">IOMode</span> (<span class="dt">ReadMode</span>))</a>
<a class="sourceLine" id="cb11-7" data-line-number="7"><span class="kw">import</span> <span class="dt">Data.Foldable</span> (forM_)</a>
<a class="sourceLine" id="cb11-8" data-line-number="8"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString</span> <span class="kw">as</span> <span class="dt">B</span></a>
<a class="sourceLine" id="cb11-9" data-line-number="9"></a>
<a class="sourceLine" id="cb11-10" data-line-number="10"><span class="ot">hashFile ::</span> <span class="dt">HashAlgorithm</span> ha <span class="ot">=&gt;</span> FilePath <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Digest</span> ha)</a>
<a class="sourceLine" id="cb11-11" data-line-number="11">hashFile fp <span class="fu">=</span> withBinaryFile fp <span class="dt">ReadMode</span> <span class="fu">$</span> \h <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-12" data-line-number="12">  context <span class="ot">&lt;-</span> hashMutableInit</a>
<a class="sourceLine" id="cb11-13" data-line-number="13">  <span class="kw">let</span> loop <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-14" data-line-number="14">        chunk <span class="ot">&lt;-</span> B.hGetSome h <span class="dv">4096</span></a>
<a class="sourceLine" id="cb11-15" data-line-number="15">        <span class="kw">if</span> B.null chunk</a>
<a class="sourceLine" id="cb11-16" data-line-number="16">          <span class="kw">then</span> hashMutableFinalize context</a>
<a class="sourceLine" id="cb11-17" data-line-number="17">          <span class="kw">else</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-18" data-line-number="18">            hashMutableUpdate context chunk</a>
<a class="sourceLine" id="cb11-19" data-line-number="19">            loop</a>
<a class="sourceLine" id="cb11-20" data-line-number="20">  loop</a>
<a class="sourceLine" id="cb11-21" data-line-number="21"></a>
<a class="sourceLine" id="cb11-22" data-line-number="22"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb11-23" data-line-number="23">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-24" data-line-number="24">  args <span class="ot">&lt;-</span> getArgs</a>
<a class="sourceLine" id="cb11-25" data-line-number="25">  forM_ args <span class="fu">$</span> \fp <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-26" data-line-number="26">    digest <span class="ot">&lt;-</span> hashFile fp</a>
<a class="sourceLine" id="cb11-27" data-line-number="27">    putStrLn <span class="fu">$</span> show (<span class="ot">digest ::</span> <span class="dt">Digest</span> <span class="dt">SHA256</span>) <span class="fu">++</span> <span class="st">&quot;  &quot;</span> <span class="fu">++</span> fp</a></code></pre></div>
<p><strong>練習問題</strong> 遅延入出力と <code>hashlazy</code>関数を使って、<code>hashFile</code> を実装してください (遅延入出力を支持しているわけじゃないですよ。)。</p>]]></summary>
</entry>

</feed>
