<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>BIG MOON</title>
    <link href="https://haskell.e-bigmoon.com/feed.xml" rel="self" />
    <link href="https://haskell.e-bigmoon.com" />
    <id>https://haskell.e-bigmoon.com/feed.xml</id>
    <author>
        <name>BIG MOON</name>
        <email>it@e-bigmoon.com</email>
    </author>
    <updated>2018-07-21T00:00:00Z</updated>
    <entry>
    <title>Circle CI 2.0 の設定</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/07-21-circleci-2.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/07-21-circleci-2.html</id>
    <published>2018-07-21T00:00:00Z</published>
    <updated>2018-07-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p><strong>Haskell</strong> プロジェクトの多くは <strong>Travis CI</strong> を使って CI を回しています。</p>
<p>しかしここ最近、いくつかのプロジェクトで <strong>Circle CI</strong> の利用が進んでいるように思います。</p>
<p>僕も社内のプロジェクトでは <strong>Circle CI</strong> を使っています。実際に <strong>Circle CI</strong> を使っていて個人的に良いなと感じたのは以下の4点です。</p>
<ul>
<li>docker イメージを指定できる</li>
<li>プライベートリポジトリで利用できる</li>
<li>travis より速い気がする</li>
<li>キャッシュが不変</li>
</ul>
<p>キャッシュの動作に関しては <strong>travis</strong> とは逆なので少し違和感があるかもしれませんが、キャッシュでCIが失敗するということが無くなるので、非常に良いと思います。</p>
<p>今回は Haskell プロジェクトで汎用的に使える <strong>Circle CI</strong> の設定をご紹介したいと思います。ただ、開発が進むにつれて色々とカスタマイズする必要が出てくると思いますので、今回参考にした設定ファイル等のリンクを参考資料として載せておきます。現実的に利用されている設定なので非常に役立つと思います。</p>
<p>参考にした <code>config.yml</code></p>
<ul>
<li><a href="https://github.com/ghc/ghc/blob/master/.circleci/config.yml">ghc/ghc</a></li>
<li><a href="https://github.com/haskell/haskell-ide-engine/blob/master/.circleci/config.yml">haskell/haskell-ide-engine</a></li>
<li><a href="https://github.com/haskell-jp/blog/blob/master/.circleci/config.yml">haskell-jp/blog</a></li>
<li><a href="https://github.com/restyled-io/restyled.io/blob/master/.circleci/config.yml">restyled-io/restyled.io</a></li>
<li><a href="https://github.com/pbrisbin/hs-shellwords/blob/master/.circleci/config.yml">pbrisbin/hs-shellwords</a></li>
<li><a href="https://github.com/haskell-works/stack-build">haskell-works/stack-build</a></li>
</ul>
<p>参考にした記事</p>
<ul>
<li><a href="https://mmhaskell.com/blog/2018/4/25/dockerizing-our-haskell-app">Dockerizing our Haskell App</a></li>
<li><a href="https://circleci.com/docs/2.0/configuration-reference/">Configuring CircleCI</a></li>
<li><a href="https://tech.recruit-mp.co.jp/dev-tools/post-13981/">CircleCI2.0でHaskellのテストを実行する</a></li>
</ul>
<!--more-->
<h2 id="注意点">注意点</h2>
<p><strong>Circle CI 2.0</strong> の設定ファイルは <code>.circleci/config.yml</code> という名前でなければなりません。</p>
<p>config.<strong>yaml</strong> にすると認識しないので注意しましょう。(これで何時間か無駄にしたことがあります)</p>
<h2 id="シンプルな設定">シンプルな設定</h2>
<p><a href="https://github.com/waddlaw/circleci-sandobx/blob/simple-fast/.circleci/config.yml">config.yml</a> にシンプルな設定例を置いてあります。</p>
<p>CI に含めたい内容は人それぞれだと思いますが、ここでは以下の4種類を検査できるようにします。</p>
<ul>
<li>stack test</li>
<li>stack test –pedantic</li>
<li>hlint</li>
<li>stylish-haskell</li>
</ul>
<p>また、以下の要件を満たすようにします。</p>
<ul>
<li>stack のバージョンを柔軟に切り替えたい</li>
<li>キャッシュを強制的にクリアしたい</li>
<li>一度設定したら、できるだけ設定ファイルをいじらない</li>
</ul>
<h3 id="config.yml">config.yml</h3>
<p>完全な <strong>config.yml</strong> は以下になります。これをコピペでプロジェクトの <strong>.circleci/config.yml</strong> に保存すればすぐに動きます！</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="fu">version:</span><span class="at"> 2</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="fu">aliases:</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  <span class="kw">-</span> <span class="dt">&amp;default_env</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    <span class="fu">environment:</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">      <span class="fu">CACHE_KEY:</span><span class="at"> 1</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">      <span class="fu">STACK_VERSION:</span><span class="at"> 1.7.1</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">  <span class="kw">-</span> <span class="dt">&amp;create_cache_key_file</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">    <span class="fu">run:</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">      <span class="fu">name:</span><span class="at"> Create cache control key file</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">      <span class="fu">command:</span><span class="at"> echo $CACHE_KEY &gt; cache_key</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  <span class="kw">-</span> <span class="dt">&amp;restore_build_results</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">    <span class="fu">restore_cache:</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">      <span class="fu">keys:</span></a>
<a class="sourceLine" id="cb1-15" data-line-number="15">        <span class="kw">-</span> stack-<span class="kw">{</span>{ checksum &quot;cache_key&quot; <span class="kw">}</span>}-<span class="kw">{</span>{ checksum &quot;stack.yaml&quot; <span class="kw">}</span>}-<span class="kw">{</span>{ checksum &quot;package.yaml&quot; <span class="kw">}</span>}</a>
<a class="sourceLine" id="cb1-16" data-line-number="16">        <span class="kw">-</span> stack-<span class="kw">{</span>{ checksum &quot;cache_key&quot; <span class="kw">}</span>}-<span class="kw">{</span>{ checksum &quot;stack.yaml&quot; <span class="kw">}</span>}</a>
<a class="sourceLine" id="cb1-17" data-line-number="17">        <span class="kw">-</span> stack-<span class="kw">{</span>{ checksum &quot;cache_key&quot; <span class="kw">}</span>}</a>
<a class="sourceLine" id="cb1-18" data-line-number="18">  <span class="kw">-</span> <span class="dt">&amp;save_build_results</span></a>
<a class="sourceLine" id="cb1-19" data-line-number="19">      <span class="fu">save_cache:</span></a>
<a class="sourceLine" id="cb1-20" data-line-number="20">        <span class="fu">key:</span><span class="at"> stack-{{ checksum &quot;cache_key&quot; }}-{{ checksum &quot;stack.yaml&quot; }}-{{ checksum &quot;package.yaml&quot; }}</span></a>
<a class="sourceLine" id="cb1-21" data-line-number="21">        <span class="fu">paths:</span></a>
<a class="sourceLine" id="cb1-22" data-line-number="22">          <span class="kw">-</span> ~/.stack</a>
<a class="sourceLine" id="cb1-23" data-line-number="23">          <span class="kw">-</span> ~/.local/bin</a>
<a class="sourceLine" id="cb1-24" data-line-number="24">          <span class="kw">-</span> .stack-work</a>
<a class="sourceLine" id="cb1-25" data-line-number="25">  <span class="kw">-</span> <span class="dt">&amp;display_stack_version</span></a>
<a class="sourceLine" id="cb1-26" data-line-number="26">    <span class="fu">run:</span></a>
<a class="sourceLine" id="cb1-27" data-line-number="27">      <span class="fu">name:</span><span class="at"> Display stack version</span></a>
<a class="sourceLine" id="cb1-28" data-line-number="28">      <span class="fu">command:</span><span class="at"> |</span></a>
<a class="sourceLine" id="cb1-29" data-line-number="29">        stack upgrade --binary-version=$STACK_VERSION</a>
<a class="sourceLine" id="cb1-30" data-line-number="30">        stack --version</a>
<a class="sourceLine" id="cb1-31" data-line-number="31"><span class="fu">jobs:</span></a>
<a class="sourceLine" id="cb1-32" data-line-number="32">  <span class="fu">build:</span></a>
<a class="sourceLine" id="cb1-33" data-line-number="33">    <span class="fu">docker:</span></a>
<a class="sourceLine" id="cb1-34" data-line-number="34">      <span class="kw">-</span> <span class="fu">image:</span><span class="at"> quay.io/haskell_works/stack-build-minimal</span></a>
<a class="sourceLine" id="cb1-35" data-line-number="35">    <span class="fu">&lt;&lt;:</span><span class="at"> </span><span class="dt">*default_env</span></a>
<a class="sourceLine" id="cb1-36" data-line-number="36">    <span class="fu">steps:</span></a>
<a class="sourceLine" id="cb1-37" data-line-number="37">      <span class="kw">-</span> checkout</a>
<a class="sourceLine" id="cb1-38" data-line-number="38">      <span class="kw">-</span> <span class="dt">*create_cache_key_file</span></a>
<a class="sourceLine" id="cb1-39" data-line-number="39">      <span class="kw">-</span> <span class="dt">*restore_build_results</span></a>
<a class="sourceLine" id="cb1-40" data-line-number="40">      <span class="kw">-</span> <span class="dt">*display_stack_version</span></a>
<a class="sourceLine" id="cb1-41" data-line-number="41">      <span class="kw">-</span> <span class="fu">run:</span></a>
<a class="sourceLine" id="cb1-42" data-line-number="42">          <span class="fu">name:</span><span class="at"> Install dependencies</span></a>
<a class="sourceLine" id="cb1-43" data-line-number="43">          <span class="fu">command:</span><span class="at"> stack test -j 1 --only-dependencies --no-terminal --no-run-tests</span></a>
<a class="sourceLine" id="cb1-44" data-line-number="44">          <span class="fu">no_output_timeout:</span><span class="at"> 120m</span></a>
<a class="sourceLine" id="cb1-45" data-line-number="45">      <span class="kw">-</span> <span class="fu">run:</span></a>
<a class="sourceLine" id="cb1-46" data-line-number="46">          <span class="fu">name:</span><span class="at"> Run stack test</span></a>
<a class="sourceLine" id="cb1-47" data-line-number="47">          <span class="fu">command:</span><span class="at"> stack test --fast</span></a>
<a class="sourceLine" id="cb1-48" data-line-number="48">      <span class="kw">-</span> <span class="fu">run:</span></a>
<a class="sourceLine" id="cb1-49" data-line-number="49">          <span class="fu">name:</span><span class="at"> Run stack test --pedantic</span></a>
<a class="sourceLine" id="cb1-50" data-line-number="50">          <span class="fu">command:</span><span class="at"> |</span></a>
<a class="sourceLine" id="cb1-51" data-line-number="51">            stack clean</a>
<a class="sourceLine" id="cb1-52" data-line-number="52">            stack test --pedantic --fast --no-run-tests</a>
<a class="sourceLine" id="cb1-53" data-line-number="53">      <span class="kw">-</span> <span class="fu">run:</span></a>
<a class="sourceLine" id="cb1-54" data-line-number="54">          <span class="fu">name:</span><span class="at"> Run HLint</span></a>
<a class="sourceLine" id="cb1-55" data-line-number="55">          <span class="fu">command:</span><span class="at"> |</span></a>
<a class="sourceLine" id="cb1-56" data-line-number="56">            <span class="fu">curl -sL https:</span><span class="at">//raw.github.com/ndmitchell/hlint/master/misc/travis.sh | sh -s -- --version</span></a>
<a class="sourceLine" id="cb1-57" data-line-number="57">            <span class="fu">curl -sL https:</span><span class="at">//raw.github.com/ndmitchell/hlint/master/misc/travis.sh | sh -s .</span></a>
<a class="sourceLine" id="cb1-58" data-line-number="58">      <span class="kw">-</span> <span class="fu">run:</span></a>
<a class="sourceLine" id="cb1-59" data-line-number="59">          <span class="fu">name:</span><span class="at"> Run stylish-haskell</span></a>
<a class="sourceLine" id="cb1-60" data-line-number="60">          <span class="fu">command:</span><span class="at"> |</span></a>
<a class="sourceLine" id="cb1-61" data-line-number="61">            <span class="co"># </span><span class="al">TODO</span><span class="co">: https://github.com/jaspervdj/stylish-haskell/pull/218</span></a>
<a class="sourceLine" id="cb1-62" data-line-number="62">            <span class="fu">curl -sL https:</span><span class="at">//raw.githubusercontent.com/waddlaw/stylish-haskell/master/scripts/latest.sh | sh -s -- -i $(find . -type f -name &quot;*hs&quot; -not -path &#39;.git&#39; -not -path &#39;*.stack-work*&#39;)</span></a>
<a class="sourceLine" id="cb1-63" data-line-number="63">            git --no-pager diff --exit-code</a>
<a class="sourceLine" id="cb1-64" data-line-number="64">      <span class="kw">-</span> <span class="dt">*save_build_results</span></a></code></pre></div>
<p>それぞれの内容について個別に説明します。</p>
<h4 id="default_env">default_env</h4>
<div class="sourceCode" id="cb2"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="fu">aliases:</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="kw">-</span> <span class="dt">&amp;default_env</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="fu">environment:</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">      <span class="fu">CACHE_KEY:</span><span class="at"> 1</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">      <span class="fu">STACK_VERSION:</span><span class="at"> 1.7.1</span></a></code></pre></div>
<p><strong>Circle CI</strong> のキャッシュは不変なので一度作られると上書きできません。また、<strong>travis</strong> のようにキャッシュのクリアボタンもありません。</p>
<p>そのため、キャッシュキーの指定に <strong>Circle CI</strong> の環境変数を利用するというやり方がよく用いられます。個人的には管理画面でいちいち変更するのは面倒なので <strong>config.yml</strong> に含めてしまえば良いかなと思います。</p>
<p>なので <strong>CACHE_KEY</strong> は、明示的にキャッシュをクリアする際に利用します。</p>
<p><strong>STACK_VERSION</strong> は利用する <strong>stack</strong> のバージョンを指定するためにあります。基本的に最新版を指定しておけば良いのですが、更新された直後など、古いバージョンを指定したい場合があるので環境変数として用意しています。</p>
<h4 id="create_cache_key_file">create_cache_key_file</h4>
<div class="sourceCode" id="cb3"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb3-1" data-line-number="1">  <span class="kw">-</span> <span class="dt">&amp;create_cache_key_file</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">    <span class="fu">run:</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3">      <span class="fu">name:</span><span class="at"> Create cache control key file</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">      <span class="fu">command:</span><span class="at"> echo $CACHE_KEY &gt; cache_key</span></a></code></pre></div>
<p>このやり方は <a href="https://github.com/haskell/haskell-ide-engine/blob/master/.circleci/config.yml">haskell/haskell-ide-engine</a> を参考にしました。</p>
<p>キャッシュキーに直接環境変数を指定できれば良いのですが、そのような方法が無いためこのように一度ファイルに書き出しています。</p>
<h4 id="restore_build_results">restore_build_results</h4>
<div class="sourceCode" id="cb4"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">-</span> <span class="dt">&amp;restore_build_results</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">    <span class="fu">restore_cache:</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">      <span class="fu">keys:</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">        <span class="kw">-</span> stack-<span class="kw">{</span>{ checksum &quot;cache_key&quot; <span class="kw">}</span>}-<span class="kw">{</span>{ checksum &quot;stack.yaml&quot; <span class="kw">}</span>}-<span class="kw">{</span>{ checksum &quot;package.yaml&quot; <span class="kw">}</span>}</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">        <span class="kw">-</span> stack-<span class="kw">{</span>{ checksum &quot;cache_key&quot; <span class="kw">}</span>}-<span class="kw">{</span>{ checksum &quot;stack.yaml&quot; <span class="kw">}</span>}</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">        <span class="kw">-</span> stack-<span class="kw">{</span>{ checksum &quot;cache_key&quot; <span class="kw">}</span>}</a></code></pre></div>
<p>キャッシュの復元部分です。よくあるイディオムですが</p>
<ol type="1">
<li>cache_key</li>
<li>stack.yaml</li>
<li>package.yaml</li>
</ol>
<p>の順番でキャッシュが残るようにしています。</p>
<p>また <code>stack-{{ checksum &quot;cache_key&quot; }}-{{ checksum &quot;stack.yaml&quot; }}-{{ checksum &quot;package.yaml&quot; }}</code> だけの設定ですと、<strong>package.yaml</strong> を更新した際にキャッシュがヒットしないため、依存関係のインストールから再度始めることになってしまいます。</p>
<h4 id="save_build_results">save_build_results</h4>
<div class="sourceCode" id="cb5"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb5-1" data-line-number="1">  <span class="kw">-</span> <span class="dt">&amp;save_build_results</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">      <span class="fu">save_cache:</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">        <span class="fu">key:</span><span class="at"> stack-{{ checksum &quot;cache_key&quot; }}-{{ checksum &quot;stack.yaml&quot; }}-{{ checksum &quot;package.yaml&quot; }}</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">        <span class="fu">paths:</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">          <span class="kw">-</span> ~/.stack</a>
<a class="sourceLine" id="cb5-6" data-line-number="6">          <span class="kw">-</span> ~/.local/bin</a>
<a class="sourceLine" id="cb5-7" data-line-number="7">          <span class="kw">-</span> .stack-work</a></code></pre></div>
<p>ここがキャッシュを保存している部分です。依存関係を毎回インストールしなくても良いように <code>~/.stack</code> と <code>.stack-work</code> を指定しています。</p>
<p><code>~/.local/bin</code> はどちらでも良いような気がします。</p>
<h4 id="display_stack_version">display_stack_version</h4>
<div class="sourceCode" id="cb6"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">-</span> <span class="dt">&amp;display_stack_version</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">    <span class="fu">run:</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">      <span class="fu">name:</span><span class="at"> Display stack version</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">      <span class="fu">command:</span><span class="at"> |</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">        stack upgrade --binary-version=$STACK_VERSION</a>
<a class="sourceLine" id="cb6-6" data-line-number="6">        stack --version</a></code></pre></div>
<p><strong>stack</strong> のバージョンを強制的に <code>$STACK_VERSION</code> にします。</p>
<p>また、ちゃんと期待しているバージョンが利用されているか確認するためにバージョンを表示しています。</p>
<h4 id="build-image">build image</h4>
<div class="sourceCode" id="cb7"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb7-1" data-line-number="1">  <span class="fu">build:</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">    <span class="fu">docker:</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">      <span class="kw">-</span> <span class="fu">image:</span><span class="at"> quay.io/haskell_works/stack-build-minimal</span></a></code></pre></div>
<p>どのイメージを利用するかは人それぞれです。<strong>fpco/stack-build:lts</strong> でも良いですが、イメージの pull に3分かかるのでお勧めしません。</p>
<p>そのため、ここでは <strong>quay.io/haskell_works/stack-build-minimal</strong> を利用しています。hie でも利用しているので問題無いでしょう。</p>
<p>Docker ファイルの内容については以下のリポジトリで確認ができます。</p>
<ul>
<li><a href="https://github.com/haskell-works/stack-build">haskell-works/stack-build</a></li>
</ul>
<h4 id="依存関係のインストール">依存関係のインストール</h4>
<div class="sourceCode" id="cb8"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb8-1" data-line-number="1">      <span class="kw">-</span> <span class="fu">run:</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">          <span class="fu">name:</span><span class="at"> Install dependencies</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">          <span class="fu">command:</span><span class="at"> stack test -j 1 --only-dependencies --no-terminal --no-run-tests</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">          <span class="fu">no_output_timeout:</span><span class="at"> 120m</span></a></code></pre></div>
<p>コマンドのオプションはそれぞれ以下のために利用しています。</p>
<ul>
<li><code>-j 1</code>: ビルド時のメモリ不足エラーを回避するため</li>
<li><code>--only-dependencies</code>: ここでは依存関係のみをインストールしたいので</li>
<li><code>--no-terminal</code>: 詳細表示は不必要なので</li>
<li><code>--no-run-tests</code>: そのままではテストが実行されるため</li>
</ul>
<p>また <code>no_output_timeout: 120m</code> はデフォルトのビルド制限時間 (20分) を回避するために追加しています。</p>
<h4 id="stack-test">stack test</h4>
<div class="sourceCode" id="cb9"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb9-1" data-line-number="1">      <span class="kw">-</span> <span class="fu">run:</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">          <span class="fu">name:</span><span class="at"> Run stack test</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">          <span class="fu">command:</span><span class="at"> stack test --fast</span></a></code></pre></div>
<p>単純にテストを実行します。なんとなく <code>--fast</code> をつけています。</p>
<h4 id="pedantic">pedantic</h4>
<div class="sourceCode" id="cb10"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb10-1" data-line-number="1">      <span class="kw">-</span> <span class="fu">run:</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2">          <span class="fu">name:</span><span class="at"> Run stack test --pedantic</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3">          <span class="fu">command:</span><span class="at"> |</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">            stack clean</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">            stack test --pedantic --fast --no-run-tests</a></code></pre></div>
<p><code>stack test --pedantic --fast</code> としておけばテストと両方できて良いんじゃないの？と思われるかもしれませんが、おすすめしません。実際にやってみればわかりますが、めっちゃイライラします。</p>
<p><strong>pedantic</strong> は必ずテストと分離した方が良いです。<code>--no-run-tests</code> オプションを付けているので、テストの実行は行われません。</p>
<p>また、ビルドのキャッシュが残っていると <strong>pedantic</strong> の警告がスルーされることがあるので <strong>stack clean</strong> を事前に行っておいた方が良いでしょう。</p>
<h4 id="hlint">hlint</h4>
<div class="sourceCode" id="cb11"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb11-1" data-line-number="1">      <span class="kw">-</span> <span class="fu">run:</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2">          <span class="fu">name:</span><span class="at"> Run HLint</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">          <span class="fu">command:</span><span class="at"> |</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">            <span class="fu">curl -sL https:</span><span class="at">//raw.github.com/ndmitchell/hlint/master/misc/travis.sh | sh -s -- --version</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">            <span class="fu">curl -sL https:</span><span class="at">//raw.github.com/ndmitchell/hlint/master/misc/travis.sh | sh -s .</span></a></code></pre></div>
<p><strong>hint</strong> はバージョンによって動作が結構違うので、バージョンを表示させておくと便利です。</p>
<h4 id="stylish-haskell">stylish-haskell</h4>
<div class="sourceCode" id="cb12"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb12-1" data-line-number="1">      <span class="kw">-</span> <span class="fu">run:</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">          <span class="fu">name:</span><span class="at"> Run stylish-haskell</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">          <span class="fu">command:</span><span class="at"> |</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4">            <span class="co"># </span><span class="al">TODO</span><span class="co">: https://github.com/jaspervdj/stylish-haskell/pull/218</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">            <span class="fu">curl -sL https:</span><span class="at">//raw.githubusercontent.com/waddlaw/stylish-haskell/master/scripts/latest.sh | sh -s -- -i $(find . -type f -name &quot;*hs&quot; -not -path &#39;.git&#39; -not -path &#39;*.stack-work*&#39;)</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">            git --no-pager diff --exit-code</a></code></pre></div>
<p><strong>stylish-haskell</strong> もチェックしたい人向けです。必要なければ削除しましょう。</p>
<p>スクリプトがバグってたので修正しました。やっていることとしては、</p>
<ol type="1">
<li>全ての <strong>.hs</strong> ファイルに対して <strong>stylish-haskell</strong> を実行</li>
<li>もし、整形の必要があれば <strong>git diff</strong> の結果として出力される</li>
</ol>
<p>という感じです。</p>
<h2 id="ワークフローバージョン">ワークフローバージョン</h2>
<ul>
<li><a href="https://github.com/waddlaw/circleci-sandobx/blob/simple-fast-workflows/.circleci/config.yml">config.yml</a></li>
</ul>
<p>個人的にはワークフローにしておく方が好きなので、ワークフローバージョンも掲載しておきます。シンプルバージョンと内容は同じです。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="fu">version:</span><span class="at"> 2</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="fu">aliases:</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  <span class="kw">-</span> <span class="dt">&amp;default_env</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    <span class="fu">environment:</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">      <span class="fu">CACHE_KEY:</span><span class="at"> 7</span></a>
<a class="sourceLine" id="cb13-7" data-line-number="7">      <span class="fu">STACK_VERSION:</span><span class="at"> 1.7.1</span></a>
<a class="sourceLine" id="cb13-8" data-line-number="8">  <span class="kw">-</span> <span class="dt">&amp;create_cache_key_file</span></a>
<a class="sourceLine" id="cb13-9" data-line-number="9">    <span class="fu">run:</span></a>
<a class="sourceLine" id="cb13-10" data-line-number="10">      <span class="fu">name:</span><span class="at"> Create cache control key file</span></a>
<a class="sourceLine" id="cb13-11" data-line-number="11">      <span class="fu">command:</span><span class="at"> echo $CACHE_KEY &gt; cache_key</span></a>
<a class="sourceLine" id="cb13-12" data-line-number="12">  <span class="kw">-</span> <span class="dt">&amp;restore_build_results</span></a>
<a class="sourceLine" id="cb13-13" data-line-number="13">    <span class="fu">restore_cache:</span></a>
<a class="sourceLine" id="cb13-14" data-line-number="14">      <span class="fu">keys:</span></a>
<a class="sourceLine" id="cb13-15" data-line-number="15">        <span class="kw">-</span> stack-<span class="kw">{</span>{ checksum &quot;cache_key&quot; <span class="kw">}</span>}-<span class="kw">{</span>{ checksum &quot;stack.yaml&quot; <span class="kw">}</span>}-<span class="kw">{</span>{ checksum &quot;package.yaml&quot; <span class="kw">}</span>}</a>
<a class="sourceLine" id="cb13-16" data-line-number="16">        <span class="kw">-</span> stack-<span class="kw">{</span>{ checksum &quot;cache_key&quot; <span class="kw">}</span>}-<span class="kw">{</span>{ checksum &quot;stack.yaml&quot; <span class="kw">}</span>}</a>
<a class="sourceLine" id="cb13-17" data-line-number="17">        <span class="kw">-</span> stack-<span class="kw">{</span>{ checksum &quot;cache_key&quot; <span class="kw">}</span>}</a>
<a class="sourceLine" id="cb13-18" data-line-number="18">  <span class="kw">-</span> <span class="dt">&amp;save_build_results</span></a>
<a class="sourceLine" id="cb13-19" data-line-number="19">      <span class="fu">save_cache:</span></a>
<a class="sourceLine" id="cb13-20" data-line-number="20">        <span class="fu">key:</span><span class="at"> stack-{{ checksum &quot;cache_key&quot; }}-{{ checksum &quot;stack.yaml&quot; }}-{{ checksum &quot;package.yaml&quot; }}</span></a>
<a class="sourceLine" id="cb13-21" data-line-number="21">        <span class="fu">paths:</span></a>
<a class="sourceLine" id="cb13-22" data-line-number="22">          <span class="kw">-</span> ~/.stack</a>
<a class="sourceLine" id="cb13-23" data-line-number="23">          <span class="kw">-</span> ~/.local/bin</a>
<a class="sourceLine" id="cb13-24" data-line-number="24">          <span class="kw">-</span> .stack-work</a>
<a class="sourceLine" id="cb13-25" data-line-number="25">  <span class="kw">-</span> <span class="dt">&amp;display_stack_version</span></a>
<a class="sourceLine" id="cb13-26" data-line-number="26">    <span class="fu">run:</span></a>
<a class="sourceLine" id="cb13-27" data-line-number="27">      <span class="fu">name:</span><span class="at"> Display stack version</span></a>
<a class="sourceLine" id="cb13-28" data-line-number="28">      <span class="fu">command:</span><span class="at"> |</span></a>
<a class="sourceLine" id="cb13-29" data-line-number="29">        stack upgrade --binary-version=$STACK_VERSION</a>
<a class="sourceLine" id="cb13-30" data-line-number="30">        stack --version</a>
<a class="sourceLine" id="cb13-31" data-line-number="31"><span class="fu">jobs:</span></a>
<a class="sourceLine" id="cb13-32" data-line-number="32">  <span class="fu">build:</span></a>
<a class="sourceLine" id="cb13-33" data-line-number="33">    <span class="fu">docker:</span></a>
<a class="sourceLine" id="cb13-34" data-line-number="34">      <span class="kw">-</span> <span class="fu">image:</span><span class="at"> quay.io/haskell_works/stack-build-minimal</span></a>
<a class="sourceLine" id="cb13-35" data-line-number="35">    <span class="fu">&lt;&lt;:</span><span class="at"> </span><span class="dt">*default_env</span></a>
<a class="sourceLine" id="cb13-36" data-line-number="36">    <span class="fu">steps:</span></a>
<a class="sourceLine" id="cb13-37" data-line-number="37">      <span class="kw">-</span> checkout</a>
<a class="sourceLine" id="cb13-38" data-line-number="38">      <span class="kw">-</span> <span class="dt">*create_cache_key_file</span></a>
<a class="sourceLine" id="cb13-39" data-line-number="39">      <span class="kw">-</span> <span class="dt">*restore_build_results</span></a>
<a class="sourceLine" id="cb13-40" data-line-number="40">      <span class="kw">-</span> <span class="dt">*display_stack_version</span></a>
<a class="sourceLine" id="cb13-41" data-line-number="41">      <span class="kw">-</span> <span class="fu">run:</span></a>
<a class="sourceLine" id="cb13-42" data-line-number="42">          <span class="fu">name:</span><span class="at"> Install dependencies</span></a>
<a class="sourceLine" id="cb13-43" data-line-number="43">          <span class="fu">command:</span><span class="at"> stack test -j 1 --only-dependencies --no-terminal --no-run-tests</span></a>
<a class="sourceLine" id="cb13-44" data-line-number="44">          <span class="fu">no_output_timeout:</span><span class="at"> 120m</span></a>
<a class="sourceLine" id="cb13-45" data-line-number="45">      <span class="kw">-</span> <span class="fu">run:</span></a>
<a class="sourceLine" id="cb13-46" data-line-number="46">          <span class="fu">name:</span><span class="at"> Run stack test</span></a>
<a class="sourceLine" id="cb13-47" data-line-number="47">          <span class="fu">command:</span><span class="at"> stack test --fast</span></a>
<a class="sourceLine" id="cb13-48" data-line-number="48">      <span class="kw">-</span> <span class="dt">*save_build_results</span></a>
<a class="sourceLine" id="cb13-49" data-line-number="49"></a>
<a class="sourceLine" id="cb13-50" data-line-number="50">  <span class="fu">pedantic:</span></a>
<a class="sourceLine" id="cb13-51" data-line-number="51">    <span class="fu">docker:</span></a>
<a class="sourceLine" id="cb13-52" data-line-number="52">      <span class="kw">-</span> <span class="fu">image:</span><span class="at"> quay.io/haskell_works/stack-build-minimal</span></a>
<a class="sourceLine" id="cb13-53" data-line-number="53">    <span class="fu">&lt;&lt;:</span><span class="at"> </span><span class="dt">*default_env</span></a>
<a class="sourceLine" id="cb13-54" data-line-number="54">    <span class="fu">steps:</span></a>
<a class="sourceLine" id="cb13-55" data-line-number="55">      <span class="kw">-</span> checkout</a>
<a class="sourceLine" id="cb13-56" data-line-number="56">      <span class="kw">-</span> <span class="dt">*create_cache_key_file</span></a>
<a class="sourceLine" id="cb13-57" data-line-number="57">      <span class="kw">-</span> <span class="dt">*restore_build_results</span></a>
<a class="sourceLine" id="cb13-58" data-line-number="58">      <span class="kw">-</span> <span class="dt">*display_stack_version</span></a>
<a class="sourceLine" id="cb13-59" data-line-number="59">      <span class="kw">-</span> <span class="fu">run:</span></a>
<a class="sourceLine" id="cb13-60" data-line-number="60">          <span class="fu">name:</span><span class="at"> Run stack test --pedantic</span></a>
<a class="sourceLine" id="cb13-61" data-line-number="61">          <span class="fu">command:</span><span class="at"> |</span></a>
<a class="sourceLine" id="cb13-62" data-line-number="62">            stack clean</a>
<a class="sourceLine" id="cb13-63" data-line-number="63">            stack test --pedantic --fast --no-run-tests</a>
<a class="sourceLine" id="cb13-64" data-line-number="64">  <span class="fu">check:</span></a>
<a class="sourceLine" id="cb13-65" data-line-number="65">    <span class="fu">docker:</span></a>
<a class="sourceLine" id="cb13-66" data-line-number="66">      <span class="kw">-</span> <span class="fu">image:</span><span class="at"> quay.io/haskell_works/stack-build-minimal</span></a>
<a class="sourceLine" id="cb13-67" data-line-number="67">    <span class="fu">steps:</span></a>
<a class="sourceLine" id="cb13-68" data-line-number="68">      <span class="kw">-</span> checkout</a>
<a class="sourceLine" id="cb13-69" data-line-number="69">      <span class="kw">-</span> <span class="fu">run:</span></a>
<a class="sourceLine" id="cb13-70" data-line-number="70">          <span class="fu">name:</span><span class="at"> Run HLint</span></a>
<a class="sourceLine" id="cb13-71" data-line-number="71">          <span class="fu">command:</span><span class="at"> |</span></a>
<a class="sourceLine" id="cb13-72" data-line-number="72">            <span class="fu">curl -sL https:</span><span class="at">//raw.github.com/ndmitchell/hlint/master/misc/travis.sh | sh -s -- --version</span></a>
<a class="sourceLine" id="cb13-73" data-line-number="73">            <span class="fu">curl -sL https:</span><span class="at">//raw.github.com/ndmitchell/hlint/master/misc/travis.sh | sh -s .</span></a>
<a class="sourceLine" id="cb13-74" data-line-number="74">      <span class="kw">-</span> <span class="fu">run:</span></a>
<a class="sourceLine" id="cb13-75" data-line-number="75">          <span class="fu">name:</span><span class="at"> Run stylish-haskell</span></a>
<a class="sourceLine" id="cb13-76" data-line-number="76">          <span class="fu">command:</span><span class="at"> |</span></a>
<a class="sourceLine" id="cb13-77" data-line-number="77">            <span class="co"># </span><span class="al">TODO</span><span class="co">: https://github.com/jaspervdj/stylish-haskell/pull/218</span></a>
<a class="sourceLine" id="cb13-78" data-line-number="78">            <span class="fu">curl -sL https:</span><span class="at">//raw.githubusercontent.com/waddlaw/stylish-haskell/master/scripts/latest.sh | sh -s -- -i $(find . -type f -name &quot;*hs&quot; -not -path &#39;.git&#39; -not -path &#39;*.stack-work*&#39;)</span></a>
<a class="sourceLine" id="cb13-79" data-line-number="79">            git --no-pager diff --exit-code</a>
<a class="sourceLine" id="cb13-80" data-line-number="80"><span class="fu">workflows:</span></a>
<a class="sourceLine" id="cb13-81" data-line-number="81">  <span class="fu">version:</span><span class="at"> 2</span></a>
<a class="sourceLine" id="cb13-82" data-line-number="82">  <span class="fu">test-check:</span></a>
<a class="sourceLine" id="cb13-83" data-line-number="83">    <span class="fu">jobs:</span></a>
<a class="sourceLine" id="cb13-84" data-line-number="84">      <span class="kw">-</span> build</a>
<a class="sourceLine" id="cb13-85" data-line-number="85">      <span class="kw">-</span> <span class="fu">pedantic:</span></a>
<a class="sourceLine" id="cb13-86" data-line-number="86">          <span class="fu">requires:</span></a>
<a class="sourceLine" id="cb13-87" data-line-number="87">            <span class="kw">-</span> build</a>
<a class="sourceLine" id="cb13-88" data-line-number="88">      <span class="kw">-</span> check</a></code></pre></div>
<h2 id="まとめ">まとめ</h2>
<p>Circle CI めっちゃ便利です。</p>
<p><strong>docker-compose</strong> と連携させればデータベースと接続してテストすることもできたりするので良いですよ。</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Haskell Quiz No.14 shift-jis ファイルの読み込み</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/07-16-quiz-14.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/07-16-quiz-14.html</id>
    <published>2018-07-16T00:00:00Z</published>
    <updated>2018-07-16T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="haskell-quiz-no.14">Haskell Quiz No.14</h2>
<p>難易度: λ</p>
<p><code>utf8.txt</code> と <code>shift-jis.txt</code> はそれぞれ <code>utf8</code> と <code>shift-jis</code> で保存されたテキストファイルです。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">bad ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">bad <span class="fu">=</span> readFile <span class="st">&quot;./shift-jis.txt&quot;</span> <span class="fu">&gt;&gt;=</span> putStrLn</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">good ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">good <span class="fu">=</span> readFile <span class="st">&quot;./utf8.txt&quot;</span> <span class="fu">&gt;&gt;=</span> putStrLn</a></code></pre></div>
<p>上記のプログラムを実行すると、こんな感じでエラーになってしまいます。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> good</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">はすける</a>
<a class="sourceLine" id="cb2-3" data-line-number="3"></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="fu">*</span><span class="dt">Main</span><span class="fu">&gt;</span> bad</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> <span class="fu">./</span>shift<span class="fu">-</span>jis<span class="fu">.</span>txt<span class="fu">:</span> hGetContents<span class="fu">:</span> invalid argument (invalid byte sequence)</a></code></pre></div>
<p><code>shift-jis</code> で保存されたテキストファイルを読むにはどうしたら良いでしょうか？</p>
<p>答えは次回。</p>
<!--more-->
<h2 id="はじめに">はじめに</h2>
<p><a href="./07-11-quiz-13.html">前回</a>の問題と答えは以下の通りです。</p>
<h3 id="問題">問題</h3>
<p>難易度: λλ</p>
<p>以下のプログラムの実行結果はどうなるでしょうか？</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="co">-- stack script --resolver lts-12.0</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">main <span class="fu">=</span> runConduit <span class="fu">$</span> yieldMany [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">.|</span> iterMC print <span class="fu">.|</span> return () <span class="fu">.|</span> sinkNull</a></code></pre></div>
<h3 id="こたえ">こたえ</h3>
<pre class="shell"><code>$ ./Quiz13.hs</code></pre>
<p>何も表示されません。</p>
<h3 id="解説">解説</h3>
<p>今回は <code>sinkNull</code> があるので全ての値 (<code>1〜10</code>) が上流から流れてくると思う人もいたかもしれません。</p>
<p>しかし、途中で <code>return ()</code> が挟まっているため、そこで <code>await</code> の伝達が止まります。そのため、値の要求が <code>yieldMany</code> まで届かないのです。</p>
<h2 id="まとめ">まとめ</h2>
<ul>
<li><code>await</code> はパイプごとに伝搬して上流に伝わるため、途中で途切れている場合は何も起こらない</li>
</ul>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Haskell Quiz No.13 Conduit Part.8</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/07-11-quiz-13.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/07-11-quiz-13.html</id>
    <published>2018-07-11T00:00:00Z</published>
    <updated>2018-07-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="haskell-quiz-no.13">Haskell Quiz No.13</h2>
<p>難易度: λλ</p>
<p>以下のプログラムの実行結果はどうなるでしょうか？</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="co">-- stack script --resolver lts-12.0</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">main <span class="fu">=</span> runConduit <span class="fu">$</span> yieldMany [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">.|</span> iterMC print <span class="fu">.|</span> return () <span class="fu">.|</span> sinkNull</a></code></pre></div>
<p>答えは<a href="./07-16-quiz-14.html">次回</a>。</p>
<!--more-->
<h2 id="はじめに">はじめに</h2>
<p><a href="./07-10-quiz-12.html">前回</a>の問題と答えは以下の通りです。</p>
<h3 id="問題">問題</h3>
<p>難易度: λ</p>
<p>以下のプログラムの実行結果はどうなるでしょうか？</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.17</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">main <span class="fu">=</span> runConduit <span class="fu">$</span> yieldMany [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">.|</span> iterMC print <span class="fu">.|</span> sinkNull</a></code></pre></div>
<h3 id="こたえ">こたえ</h3>
<pre class="shell"><code>$ ./Quiz12.hs
1
2
3
4
5
6
7
8
9
10</code></pre>
<h3 id="解説">解説</h3>
<p><a href="./07-08-quiz-10.html">Quiz10</a> でよく似た問題を出題しました。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot"># Quiz10</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">main <span class="fu">=</span> runConduit <span class="fu">$</span> yieldMany [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">.|</span> iterMC print <span class="fu">.|</span> return ()</a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="ot"># Quiz12</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">main <span class="fu">=</span> runConduit <span class="fu">$</span> yieldMany [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">.|</span> iterMC print <span class="fu">.|</span> sinkNull</a></code></pre></div>
<p>異なるのは最後の <code>return ()</code> と <code>sinkNull</code> だけです。</p>
<p>Quiz10 の結果は何も表示されませんでしたが、今回は <code>1 ~ 10</code> の数字が表示されています。</p>
<p>この挙動を理解するために <code>sinkNull</code> の実装を確認してみましょう。</p>
<h4 id="sinknull">sinkNull</h4>
<p><a href="https://www.stackage.org/haddock/lts-11.17/conduit-1.3.0.3/Data-Conduit-Combinators.html#v:sinkNull">sinkNull</a> 関数の実装は以下の通りです。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">sinkNull ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ConduitT</span> i o m ()</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">sinkNull <span class="fu">=</span> awaitForever <span class="fu">$</span> \_ <span class="ot">-&gt;</span> return ()</a></code></pre></div>
<p>非常にシンプルな実装になっています。 <a href="https://www.stackage.org/haddock/lts-11.17/conduit-1.3.0.3/Data-Conduit.html#v:awaitForever">awaitForever</a> の実装は以下の通りです。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">awaitForever ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (i <span class="ot">-&gt;</span> <span class="dt">ConduitT</span> i o m r) <span class="ot">-&gt;</span> <span class="dt">ConduitT</span> i o m ()</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">awaitForever f <span class="fu">=</span> <span class="dt">ConduitT</span> <span class="fu">$</span> \rest <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    <span class="kw">let</span> go <span class="fu">=</span> <span class="dt">NeedInput</span> (\i <span class="ot">-&gt;</span> unConduitT (f i) (const go)) rest</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">     <span class="kw">in</span> go</a></code></pre></div>
<p>つまり、上流に対して値を要求し、その値に対して、引数として与えられた関数 <code>f</code> を適用するという関数です。 <code>Forever</code> という名前の通り、この関数は上流の値が無くなるまで値を要求し続けます。(そのため、<code>yieldMany [1..]</code> のような無限リストの場合は停止しません。)</p>
<p><a href="https://www.stackage.org/haddock/lts-11.17/conduit-1.3.0.3/Data-Conduit.html#v:await">await</a> 関数はこのような定義だったので、とても似ていますね。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">await ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ConduitT</span> i o m (<span class="dt">Maybe</span> i)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">await <span class="fu">=</span> <span class="dt">ConduitT</span> <span class="fu">$</span> \f <span class="ot">-&gt;</span> <span class="dt">NeedInput</span> (f <span class="fu">.</span> <span class="dt">Just</span>) (const <span class="fu">$</span> f <span class="dt">Nothing</span>)</a></code></pre></div>
<h2 id="まとめ">まとめ</h2>
<ul>
<li><code>sinkNull</code> は上流で用意した値を全て処理するために使うと便利</li>
<li><code>await</code> は上流の値を一度だけ要求する</li>
<li><code>awaitForever</code> は上流の値が無くなるまで要求する</li>
</ul>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Haskell Quiz No.12 Conduit Part.7</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/07-10-quiz-12.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/07-10-quiz-12.html</id>
    <published>2018-07-10T00:00:00Z</published>
    <updated>2018-07-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="haskell-quiz-no.12">Haskell Quiz No.12</h2>
<p>難易度: λ</p>
<p>以下のプログラムの実行結果はどうなるでしょうか？</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.17</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">main <span class="fu">=</span> runConduit <span class="fu">$</span> yieldMany [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">.|</span> iterMC print <span class="fu">.|</span> sinkNull</a></code></pre></div>
<p>答えは<a href="./07-11-quiz-13.html">次回</a>。</p>
<!--more-->
<h2 id="はじめに">はじめに</h2>
<p><a href="./07-09-quiz-11.html">前回</a>の問題と答えは以下の通りです。</p>
<h3 id="問題">問題</h3>
<p>難易度: λ</p>
<p>以下のプログラムの実行結果はどうなるでしょうか？</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.17</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Data.Char</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  print <span class="fu">$</span> isUpper <span class="ch">&#39;あ&#39;</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  print <span class="fu">$</span> isAsciiUpper <span class="ch">&#39;あ&#39;</span></a></code></pre></div>
<h3 id="こたえ">こたえ</h3>
<p>出力結果は以下のようになります。</p>
<pre class="shell"><code>$ ./Quiz11.hs
False
False</code></pre>
<h3 id="解説">解説</h3>
<p>問題をミスりました。実際に出したかったのはこんな感じです。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.17</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Data.Char</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">  print <span class="fu">$</span> isUpper <span class="ch">&#39;A&#39;</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8">  print <span class="fu">$</span> isAsciiUpper <span class="ch">&#39;A&#39;</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">  print <span class="fu">$</span> isUpper <span class="ch">&#39;Ａ&#39;</span></a>
<a class="sourceLine" id="cb4-11" data-line-number="11">  print <span class="fu">$</span> isAsciiUpper <span class="ch">&#39;Ａ&#39;</span></a></code></pre></div>
<p>この結果はこうなります。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="dt">True</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="dt">True</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="dt">True</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="dt">False</span></a></code></pre></div>
<p>半角文字だけをパスするようなバリデーションを書く時に <code>isUpper</code> を使うと、全角も <code>True</code> になってしまうので気をつけましょう。</p>
<p>また、ひらがなやカタカナ、漢字を判定したいときは <a href="https://www.stackage.org/haddock/nightly-2018-07-08/kanji-3.4.0/Data-Kanji.html">kanji-3.4.0</a> パッケージがおすすめです。</p>
<ul>
<li><a href="https://www.stackage.org/haddock/nightly-2018-07-08/kanji-3.4.0/Data-Kanji.html">isKanji</a></li>
<li><a href="https://www.stackage.org/haddock/nightly-2018-07-08/kanji-3.4.0/Data-Kanji.html">isHiragana</a></li>
<li><a href="https://www.stackage.org/haddock/nightly-2018-07-08/kanji-3.4.0/Data-Kanji.html">isKatakana</a></li>
</ul>
<h2 id="まとめ">まとめ</h2>
<ul>
<li>半角アルファベットだけバリデーションしたい場合は <code>isAsciiUpper</code> 等の関数を使う</li>
<li><code>kanji</code> パッケージが便利</li>
</ul>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Haskell Quiz No.11 isUpper と isAsciiUpper</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/07-09-quiz-11.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/07-09-quiz-11.html</id>
    <published>2018-07-09T00:00:00Z</published>
    <updated>2018-07-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="haskell-quiz-no.11">Haskell Quiz No.11</h2>
<p>難易度: λ</p>
<p>以下のプログラムの実行結果はどうなるでしょうか？</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.17</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Data.Char</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  print <span class="fu">$</span> isUpper <span class="ch">&#39;あ&#39;</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">  print <span class="fu">$</span> isAsciiUpper <span class="ch">&#39;あ&#39;</span></a></code></pre></div>
<p>答えは<a href="./07-10-quiz-12.html">次回</a>。</p>
<!--more-->
<h2 id="はじめに">はじめに</h2>
<p><a href="./07-08-quiz-10.html">前回</a>の問題と答えは以下の通りです。</p>
<h3 id="問題">問題</h3>
<p>難易度: λ</p>
<p>以下の実行結果はどうなるでしょう！</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.17</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">main <span class="fu">=</span> runConduit <span class="fu">$</span> yieldMany [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">.|</span> iterMC print <span class="fu">.|</span> return ()</a></code></pre></div>
<h3 id="こたえ">こたえ</h3>
<p>何も表示されない。</p>
<pre class="shell"><code>$ ./Quiz10.hs</code></pre>
<h3 id="解説">解説</h3>
<p><code>yieldMany</code> 関数があるので <code>iterMC print</code> によって <code>1 〜 10</code> が表示されるように思うかもしれません。</p>
<p>しかし、最後のパイプが <code>return ()</code> となっているため、何も起きません。</p>
<h2 id="まとめ">まとめ</h2>
<ul>
<li>Conduit は値が上流から自然に流れてくるのではなく、必要な時に下流から引っ張っているイメージで考えると良い。</li>
</ul>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Haskell Quiz No.10 Conduit Part.6</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/07-08-quiz-10.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/07-08-quiz-10.html</id>
    <published>2018-07-08T00:00:00Z</published>
    <updated>2018-07-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="haskell-quiz-no.10">Haskell Quiz No.10</h2>
<p>難易度: λ</p>
<p>以下の実行結果はどうなるでしょう！</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.17</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">main <span class="fu">=</span> runConduit <span class="fu">$</span> yieldMany [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">.|</span> iterMC print <span class="fu">.|</span> return ()</a></code></pre></div>
<p>答えは<a href="./07-09-quiz-11.html">次回</a>。</p>
<!--more-->
<h2 id="はじめに">はじめに</h2>
<p><a href="./07-06-quiz-9.html">前回</a>の問題と答えは以下の通りです。</p>
<h3 id="問題">問題</h3>
<p>難易度: λλ</p>
<p>以下の2つのコードのうち、1つめはコンパイルできますが、2つめはコンパイルできません。</p>
<p>なぜでしょう！</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.16</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">main <span class="fu">=</span> print <span class="fu">$</span> runConduitPure <span class="fu">$</span> return () <span class="fu">.|</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  mapM_ leftover [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  sinkList</a></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.16</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">main <span class="fu">=</span> print <span class="fu">$</span> runConduitPure <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7">  mapM_ leftover [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</a>
<a class="sourceLine" id="cb3-8" data-line-number="8">  sinkList</a></code></pre></div>
<p>エラーメッセージ</p>
<pre class="shell"><code>error:
    • No instance for (Num ()) arising from the literal ‘1’
    • In the expression: 1
      In the second argument of ‘mapM_’, namely ‘[1 .. 10]’
      In a stmt of a &#39;do&#39; block: mapM_ leftover [1 .. 10]

    mapM_ leftover [1..10]</code></pre>
<h3 id="解説">解説</h3>
<p>先に2つ目の例がエラーとなってしまう理由を確認します。</p>
<p>まずは関数の型を確認しておきましょう。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">runConduitPure ::</span> <span class="dt">ConduitT</span> () <span class="dt">Void</span> <span class="dt">Identity</span> r <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="ot">leftover ::</span> i <span class="ot">-&gt;</span> <span class="dt">ConduitT</span> i o m ()</a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="ot">sinkList ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ConduitT</span> a o m [a]</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">mapM_<span class="ot"> ::</span> (<span class="dt">Foldable</span> t, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">mapM_<span class="ot"> leftover ::</span> t i <span class="ot">-&gt;</span> <span class="dt">ConduitT</span> i o m ()</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">mapM_ leftover [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]<span class="ot"> ::</span> (<span class="dt">Enum</span> i, <span class="dt">Num</span> i) <span class="ot">=&gt;</span> <span class="dt">ConduitT</span> i o m ()</a></code></pre></div>
<p>次にモナドの型クラスも一応確認しておきます。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="ot">m ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ot">  return ::</span> a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="ot">  (&gt;&gt;=)  ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="ot">  (&gt;&gt;)   ::</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m b</a></code></pre></div>
<p>さらに型を確認していきます。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">mapM_ leftover [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">&gt;&gt;</span> sinkList</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">  ::</span> (<span class="dt">Monad</span> m, <span class="dt">Enum</span> i, <span class="dt">Num</span> i) <span class="ot">=&gt;</span>  <span class="dt">ConduitT</span> i o m [i]</a></code></pre></div>
<p>さて、ここまで確認するとなぜ2つ目の結果がエラーとなることがわかります。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">runConduitPure ::</span> <span class="dt">ConduitT</span> () <span class="dt">Void</span> <span class="dt">Identity</span> r <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">mapM_ leftover [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">&gt;&gt;</span> sinkList</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="ot">  ::</span> (<span class="dt">Monad</span> m, <span class="dt">Enum</span> i, <span class="dt">Num</span> i) <span class="ot">=&gt;</span>  <span class="dt">ConduitT</span> i o m [i]</a></code></pre></div>
<p><code>ConduitT</code> のパラメータはそれぞれ以下のような具体的な型になります。</p>
<ul>
<li><code>i</code> = <code>()</code></li>
<li><code>o</code> = <code>Void</code></li>
<li><code>m</code> = <code>Identity</code></li>
<li><code>r</code> = <code>[i]</code></li>
</ul>
<p>さらに <code>m</code> と <code>i</code> にはクラス制約があるため以下のインスタンス定義が要求されます。</p>
<ul>
<li><code>instance Monad Identity</code></li>
<li><code>instance Enum ()</code></li>
<li><code>instance Num ()</code></li>
</ul>
<p>ここで <a href="https://www.stackage.org/haddock/lts-11.17/base-4.10.1.0/Prelude.html#t:Num">Num</a> クラスのインスタンス定義には <code>()</code> が含まれないため、エラーとなってしまいました。</p>
<h4 id="つ目の例がエラーにならない理由">１つ目の例がエラーにならない理由</h4>
<p>ではなぜ <code>return () .|</code> が追加されるとエラーにならないのでしょうか？</p>
<p>型を確認してみます。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">(.|)   ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ConduitT</span> a b m () <span class="ot">-&gt;</span> <span class="dt">ConduitT</span> b c m r <span class="ot">-&gt;</span> <span class="dt">ConduitT</span> a c m r</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">return<span class="ot"> ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> m a</a></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">return<span class="ot"> ()      ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ConduitT</span> i o m ()</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">(return () <span class="fu">.|</span>)<span class="ot"> ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ConduitT</span> o c m r <span class="ot">-&gt;</span> <span class="dt">ConduitT</span> i c m r</a></code></pre></div>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">mapM_ leftover [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">&gt;&gt;</span> sinkList</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="ot">  ::</span> (<span class="dt">Monad</span> m, <span class="dt">Enum</span> i, <span class="dt">Num</span> i) <span class="ot">=&gt;</span>  <span class="dt">ConduitT</span> i o m [i]</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">(return () <span class="fu">.|</span> mapM_ leftover [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>] <span class="fu">&gt;&gt;</span> sinkList)</a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="ot">  ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ConduitT</span> i o m [i]</a></code></pre></div>
<p>2つ目の例では <code>runConduitPure</code> に直接適用してしまったため、型クラス制約が必要になりましたが、今回は <code>return ()</code> と合成した結果を <code>runConduitPure</code> に適用するため、この問題を回避することができています。</p>
<h2 id="まとめ">まとめ</h2>
<ul>
<li><code>runConduitPure</code> に適用する時に今回のようなエラーが出てしまう場合は <code>return () .|</code> として合成してから適用すると良い。</li>
</ul>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Haskell Quiz No.9 Conduit Part.5</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/07-06-quiz-9.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/07-06-quiz-9.html</id>
    <published>2018-07-06T00:00:00Z</published>
    <updated>2018-07-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="haskell-quiz-no.9">Haskell Quiz No.9</h2>
<p>難易度: λλ</p>
<p>以下の2つのコードのうち、1つめはコンパイルできますが、2つめはコンパイルできません。</p>
<p>なぜでしょう！</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.16</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">main <span class="fu">=</span> print <span class="fu">$</span> runConduitPure <span class="fu">$</span> return () <span class="fu">.|</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  mapM_ leftover [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">  sinkList</a></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.16</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">main <span class="fu">=</span> print <span class="fu">$</span> runConduitPure <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  mapM_ leftover [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  sinkList</a></code></pre></div>
<p>エラーメッセージ</p>
<pre class="shell"><code>error:
    • No instance for (Num ()) arising from the literal ‘1’
    • In the expression: 1
      In the second argument of ‘mapM_’, namely ‘[1 .. 10]’
      In a stmt of a &#39;do&#39; block: mapM_ leftover [1 .. 10]

    mapM_ leftover [1..10]</code></pre>
<p>答えは<a href="./07-08-quiz-10.html">次回</a>。</p>
<!--more-->
<h2 id="はじめに">はじめに</h2>
<p><a href="./04-08-quiz-8.html">前回</a>の問題と答えは以下の通りです。</p>
<h3 id="問題">問題</h3>
<p>難易度: λλλ</p>
<p>以下の <code>Conduit</code> を使ったコードの実行結果を予想してみてください！</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.3</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">main <span class="fu">=</span> print <span class="fu">$</span> runConduitPure <span class="fu">$</span> return () <span class="fu">.|</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">  mapM_ leftover [<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span>]</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">  sinkList</a></code></pre></div>
<h3 id="こたえ">こたえ</h3>
<p>実際に実行してみましょう！</p>
<pre class="shell"><code>$ ./Quiz8.hs
[10,9,8,7,6,5,4,3,2,1]</code></pre>
<p><code>leftover</code> に <code>[1..10]</code> を与えたのに、なぜか逆順になってしまいましたね。</p>
<h3 id="解説">解説</h3>
<p>この問題で抑えておきたいポイントは <code>leftover</code> の動作についてです。</p>
<p>問題の例を上記のように <code>leftover</code> ではなく <code>sourceList</code> を使うように修正した場合、プログラムの実行結果は次のようになります。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="co">-- stack script --resolver lts-11.3</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="kw">import</span> <span class="dt">Conduit</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Data.Conduit.List</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">main <span class="fu">=</span> print <span class="fu">$</span> runConduitPure <span class="fu">$</span> sourceList [(<span class="dv">1</span><span class="ot">::</span><span class="dt">Int</span>)<span class="fu">..</span><span class="dv">10</span>]</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">                             <span class="fu">.|</span> sinkList</a></code></pre></div>
<pre class="shell"><code>[1,2,3,4,5,6,7,8,9,10]</code></pre>
<p>入力として与えたリストの順番がきちんと保存されています。</p>
<p>この挙動を理解するためには <code>Conduit</code> の内部をちょっとだけみていく必要があります。</p>
<h4 id="定義の確認">定義の確認</h4>
<p>まずは <code>sourceList</code>, <code>yield</code>, <code>leftover</code> の定義を確認してみましょう。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">sourceList ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">ConduitT</span> i a m ()</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">sourceList <span class="fu">=</span> Prelude.mapM_ yield</a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="ot">yield ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> o <span class="ot">-&gt;</span> <span class="dt">ConduitT</span> i o m ()</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">yield    o <span class="fu">=</span> <span class="dt">ConduitT</span> <span class="fu">$</span> \rest <span class="ot">-&gt;</span> <span class="dt">HaveOutput</span> (rest ()) o</a>
<a class="sourceLine" id="cb8-6" data-line-number="6"></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="ot">leftover ::</span> i <span class="ot">-&gt;</span> <span class="dt">ConduitT</span> i o m ()</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">leftover i <span class="fu">=</span> <span class="dt">ConduitT</span> <span class="fu">$</span> \rest <span class="ot">-&gt;</span> <span class="dt">Leftover</span>   (rest ()) i</a></code></pre></div>
<p><code>yeld</code> と <code>leftover</code> はほとんど同じ関数です。本質的に異なる点は <code>HaveOutput</code> と <code>Leftover</code> という構成子の違いだけです。</p>
<p>しかし、この違いが今回のような違いを生み出します。</p>
<p>次に、<code>runConduitPure</code> 関数の定義を確認します。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">runConduitPure ::</span> <span class="dt">ConduitT</span> () <span class="dt">Void</span> <span class="dt">Identity</span> r <span class="ot">-&gt;</span> r</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">runConduitPure <span class="fu">=</span> runIdentity <span class="fu">.</span> runConduit</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="ot">runConduit ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ConduitT</span> () <span class="dt">Void</span> m r <span class="ot">-&gt;</span> m r</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">runConduit (<span class="dt">ConduitT</span> p) <span class="fu">=</span> runPipe <span class="fu">$</span> injectLeftovers <span class="fu">$</span> p <span class="dt">Done</span></a></code></pre></div>
<p><code>injectLeftovers</code> が今回の問題で一番重要な関数です。</p>
<h4 id="injectleftovers-関数">injectLeftovers 関数</h4>
<p><code>injectLeftovers</code> 関数の定義は以下のとおりです。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">injectLeftovers ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Pipe</span> i i o u m r <span class="ot">-&gt;</span> <span class="dt">Pipe</span> l i o u m r</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">injectLeftovers <span class="fu">=</span> go []</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4">    go ls (<span class="dt">HaveOutput</span> p o) <span class="fu">=</span> <span class="dt">HaveOutput</span> (go ls p) o</a>
<a class="sourceLine" id="cb10-5" data-line-number="5">    go (l<span class="fu">:</span>ls) (<span class="dt">NeedInput</span> p _) <span class="fu">=</span> go ls <span class="fu">$</span> p l</a>
<a class="sourceLine" id="cb10-6" data-line-number="6">    go [] (<span class="dt">NeedInput</span> p c) <span class="fu">=</span> <span class="dt">NeedInput</span> (go [] <span class="fu">.</span> p) (go [] <span class="fu">.</span> c)</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">    go _ (<span class="dt">Done</span> r) <span class="fu">=</span> <span class="dt">Done</span> r</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">    go ls (<span class="dt">PipeM</span> mp) <span class="fu">=</span> <span class="dt">PipeM</span> (liftM (go ls) mp)</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">    go ls (<span class="dt">Leftover</span> p l) <span class="fu">=</span> go (l<span class="fu">:</span>ls) p</a></code></pre></div>
<p><code>go</code> が少しごちゃごちゃしていますが、実際に着目すべきポイントは以下の行です。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">injectLeftovers ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Pipe</span> i i o u m r <span class="ot">-&gt;</span> <span class="dt">Pipe</span> l i o u m r</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">injectLeftovers <span class="fu">=</span> go []</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4">    <span class="fu">...</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">    go ls (<span class="dt">Leftover</span> p l) <span class="fu">=</span> go (l<span class="fu">:</span>ls) p</a></code></pre></div>
<p><code>go</code> 関数の第一引数の <code>ls</code> は <code>leftover</code> によって上流に戻される値を保存しておくための蓄積変数です。</p>
<p>ここで <code>mapM_ leftover [1..10]</code> はこんなような形をしているパイプです。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">p <span class="fu">=</span> <span class="dt">Leftover</span> (<span class="dt">Leftover</span> (<span class="dt">Leftover</span> nextPipe <span class="dv">3</span>) <span class="dv">2</span>) <span class="dv">1</span></a></code></pre></div>
<p><code>mapM_ leftover [1..10]</code> のときに、<code>ls</code> が逆順になっていることを確認するため、実際に <code>go</code> 関数を簡約してみます。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">go [] p</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="fu">=</span> go [] (<span class="dt">Leftover</span> (<span class="dt">Leftover</span> (<span class="dt">Leftover</span> p <span class="dv">3</span>) <span class="dv">2</span>) <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="fu">=</span> go (<span class="dv">1</span><span class="fu">:</span>[]) (<span class="dt">Leftover</span> (<span class="dt">Leftover</span> p <span class="dv">3</span>) <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  <span class="fu">=</span> go (<span class="dv">2</span><span class="fu">:</span>(<span class="dv">1</span><span class="fu">:</span>[])) (<span class="dt">Leftover</span> p <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  <span class="fu">=</span> go (<span class="dv">3</span><span class="fu">:</span>(<span class="dv">2</span><span class="fu">:</span>(<span class="dv">1</span><span class="fu">:</span>[]))) p</a></code></pre></div>
<p>ここで <code>leftover</code> した値が逆順で蓄積され、次のパイプに渡されることになります。</p>
<p>今回の例では、次のパイプは <code>sinkList</code> となっていました。実装は次のようになっています。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="ot">sinkList ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ConduitT</span> a o m [a]</a>
<a class="sourceLine" id="cb14-2" data-line-number="2">sinkList <span class="fu">=</span> loop id</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    loop front <span class="fu">=</span> await <span class="fu">&gt;&gt;=</span> maybe (return <span class="fu">$</span> front []) (\x <span class="ot">-&gt;</span> loop <span class="fu">$</span> front <span class="fu">.</span> (x<span class="fu">:</span>))</a>
<a class="sourceLine" id="cb14-5" data-line-number="5"></a>
<a class="sourceLine" id="cb14-6" data-line-number="6"><span class="ot">await ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Consumer</span> i m (<span class="dt">Maybe</span> i)</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">await <span class="fu">=</span> <span class="dt">ConduitT</span> <span class="fu">$</span> \f <span class="ot">-&gt;</span> <span class="dt">NeedInput</span> (f <span class="fu">.</span> <span class="dt">Just</span>) (const <span class="fu">$</span> f <span class="dt">Nothing</span>)</a></code></pre></div>
<p><code>await</code> は <code>NeedInput</code> になっていますね。</p>
<p>これは <code>injectLeftovers</code> の <code>go</code> ではこのようにパターンマッチしていました。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode hs"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">go (l<span class="fu">:</span>ls) (<span class="dt">NeedInput</span> p _) <span class="fu">=</span> go ls <span class="fu">$</span> p l</a>
<a class="sourceLine" id="cb15-2" data-line-number="2">go [] (<span class="dt">NeedInput</span> p c) <span class="fu">=</span> <span class="dt">NeedInput</span> (go [] <span class="fu">.</span> p) (go [] <span class="fu">.</span> c)</a></code></pre></div>
<p>つまり、先に <code>leftover</code> で積んだ値を全て消費してから、上流に対して値を要求します。</p>
<h2 id="おわりに">おわりに</h2>
<ul>
<li><code>leftover</code> を使えば任意の値を上流に返すことができる。(実際には消費した値を返すことが多いと思う)</li>
<li>値を1つだけ上流に返す場合は特に気にすることは無い</li>
<li>一度にまとめて複数の値を返そうとすると、処理の順番が変わってしまうことがあるので注意が必要</li>
</ul>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>namespaced templates</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/06-27-namespaced-templates.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/06-27-namespaced-templates.html</id>
    <published>2018-06-27T00:00:00Z</published>
    <updated>2018-06-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>つい先日 <a href="https://github.com/commercialhaskell/stack/pull/4103">namespaced templates</a> という、PRが <strong>master</strong> にマージされました。(<a href="https://github.com/commercialhaskell/stack/issues/4039">Namespaced templates #4039</a> が該当する isssue です)</p>
<p>通常、<strong>stack new</strong> コマンドを実行すると、ローカルに保存されている <a href="https://github.com/commercialhaskell/stack-templates/blob/master/new-template.hsfiles">new-template</a> の内容に基づいてプロジェクトの雛形が作成されます。</p>
<p>もし、ローカルに保存されているテンプレートの内容を確認したい場合は以下のようなコマンドを実行すれば良いでしょう。</p>
<pre class="shell"><code>$ cat $(stack path --stack-root)/templates/new-template.hsfiles</code></pre>
<p><strong>config.yaml</strong> を変更すれば、このデフォルトテンプレートを変更することもできます。(詳しくは <a href="https://haskell.e-bigmoon.com/stack/tips/config-yaml.html">config.yaml のよくある設定</a> をご確認ください)</p>
<p>今回新たに実装された namespaced templates 機能は、これらのテンプレート機能をより強化するものとなっています。</p>
<p>具体的には <strong>username/foo</strong> という形式でリモートリポジトリから自分のプロジェクトテンプレートをダウンロードし、それをもとにプロジェクトを作成できるようになります。</p>
<p>それでは使い方を見ていきたいと思います。</p>
<pre class="shell"><code>$ stack --version
Version 1.8.0, Git revision 466da22ce21cddc20323fc2611cd2a2d3cc56ec6 (dirty) (5998 commits) x86_64 hpack-0.28.2</code></pre>
<!--more-->
<h2 id="リポジトリを用意しよう">リポジトリを用意しよう！</h2>
<p>namespaced templates 機能は以下のサービスで利用可能です。</p>
<ul>
<li>github</li>
<li>gitlab</li>
<li>bitbucket</li>
</ul>
<p>まずは、<strong>stack-templates</strong> という名前でリポジトリを作っておいてください。(今のところは任意の名前に変更する方法はありません。)</p>
<p>この名前のリポジトリに存在するテンプレートファイルを参照することができます。</p>
<h2 id="テンプレートファイルを作ってみよう">テンプレートファイルを作ってみよう！</h2>
<ul>
<li>テンプレートの参考になるのは <a href="https://github.com/commercialhaskell/stack-templates/blob/master/simple.hsfiles">commercialhaskell/simple.hsfiles</a> です。</li>
<li>テンプレートエンジンは <a href="https://mustache.github.io/mustache.1.html">mustache</a> を使っているそうです。</li>
<li>今から作るテンプレートファイルは <a href="https://github.com/e-bigmoon/stack-templates/blob/master/sample.hsfiles">e-bigmoon/sample.hsfiles</a> にあります。</li>
</ul>
<h3 id="最小のプロジェクトテンプレート">最小のプロジェクトテンプレート</h3>
<p>とりあえず <strong>Readme.md</strong> ぐらいは欲しいですよね。</p>
<pre class="mastache"><code>{-# START_FILE README.md #-}
# {{name}}</code></pre>
<ul>
<li><code>{-# START_FILE README.md #-}</code> はそれ以降に続く内容で <strong>README.md</strong> というファイルを作ります ｰ <code>{{name}}</code> には、<strong>stack new</strong> の引数で与えたプロジェクト名が挿入されます。</li>
</ul>
<p>ここまでで実際に動かして確認してみます。</p>
<pre class="shell"><code>$ cd /tmp
$ stack new test-proj e-bigmoon/sample
Downloading template &quot;e-bigmoon/sample&quot; to create project &quot;test-proj&quot; in test-proj/ ...
The template &quot;e-bigmoon/sample&quot; is invalid and could not be used. The error was: Template does not contain a .cabal or package.yaml file</code></pre>
<p>怒られました。どうやら <strong>cabal</strong> ファイルか <strong>package.yaml</strong> が含まれている必要があるみたいです。</p>
<p><strong>package.yaml</strong> ファイルも追加して作成するために、少し編集しましょう。</p>
<pre class="mastache"><code>{-# START_FILE README.md #-}
# {{name}}

{-# START_FILE package.yaml #-}
name: {{name}}
dependencies:
  - base
library: {}</code></pre>
<p>もう一度実行してみます。</p>
<pre class="shell"><code>$ stack new test-proj e-bigmoon/sample
...
All done.

$ tree test-proj/
test-proj/
├── package.yaml
├── README.md
├── stack.yaml
└── test-proj.cabal</code></pre>
<p>今度は成功しました。簡単でいいですね。</p>
<p>ダウンロードしたテンプレートファイルは <code>~/.stack/templates/&lt;username&gt;/&lt;template&gt;</code> というパスで保存されています。</p>
<h2 id="stack-new-コマンド">stack new コマンド</h2>
<p>先程は github リポジトリ上のテンプレートファイルを取得したので以下のコマンドを実行しました。</p>
<pre class="shell"><code>$ stack new test-proj e-bigmoon/sample</code></pre>
<p>このコマンドは次のコマンドの省略形です。</p>
<pre class="shell"><code>$ stack new test-proj github:e-bigmoon/sample.hsfiles</code></pre>
<p>そのため gitlab や bitbucket にあるテンプレートファイルをダウンロードする場合は以下のようになります。</p>
<pre class="shell"><code># gitlab
$ stack new test-proj gitlab:e-bigmoon/sample.hsfiles

# bitbucket
$ stack new test-proj bitbucket:e-bigmoon/sample.hsfiles</code></pre>
<p>また、テンプレート名を省略した場合は公式のテンプレートが利用されるため、次のコマンドを実行していることと同じです。</p>
<pre class="shell"><code>$ stack new test-proj commercialhaskell/new-template</code></pre>
<p>完全なURLで別のサーバーにあるテンプレートファイルを指定することも可能です。</p>
<pre class="shell"><code>$ stack new test-proj https://my-site.com/content/template9.hsfiles</code></pre>
<p>github のテンプレートファイルを完全なURLで指定する際、上記のURLは invalid なので注意。ちゃんと raw の URL を指定しましょう。</p>
<pre class="shell"><code># NG
$ stack new test-proj https://github.com/commercialhaskell/stack-templates/blob/master/hspec.hsfiles

# OK
$ stack new test-proj https://raw.githubusercontent.com/commercialhaskell/stack-templates/master/new-template.hsfiles</code></pre>
<h2 id="stack.yaml-が含まれる場合">stack.yaml が含まれる場合</h2>
<p>プロジェクトテンプレートに <strong>stack.yaml</strong> が含まれる場合は初期化処理がスキップされます。(<a href="https://haskell.e-bigmoon.com/posts/2018/05-04-stack171.html">v1.7.1</a> で導入された修正ですね)</p>
<pre class="shell"><code>$ stack new test-proj e-bigmoon/sample
Downloading template &quot;e-bigmoon/sample&quot; to create project &quot;test-proj&quot; in test-proj/ ...
Initialized empty Git repository in /tmp/test-proj/.git/</code></pre>
<h2 id="もっと複雑なテンプレート">もっと複雑なテンプレート</h2>
<p><code>~/.stack/config.yaml</code> に変数を定義しておき、プロジェクトテンプレートから参照することもできます。</p>
<p><strong>config.yaml</strong> ファイルの内容が以下のようになっているとしましょう。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="fu">templates:</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  <span class="fu">params:</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">    <span class="fu">author-email:</span><span class="at"> chrisdone@gmail.com</span></a>
<a class="sourceLine" id="cb14-4" data-line-number="4">    <span class="fu">author-name:</span><span class="at"> Chris Done</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    <span class="fu">copyright:</span><span class="at"> 2018 Chris Done</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    <span class="fu">github-username:</span><span class="at"> chrisdone</span></a>
<a class="sourceLine" id="cb14-7" data-line-number="7">    <span class="fu">category:</span><span class="at"> Development</span></a></code></pre></div>
<p>テンプレートファイル内から単純に <code>{{author-email}}</code> の形式で変数を展開できます。</p>
<pre><code>{-# START_FILE {{name}}.cabal #-}
name:                {{name}}
version:             0.1.0.0
-- synopsis:
-- description:
homepage:            https://github.com/{{github-username}}{{^github-username}}githubuser{{/github-username}}/{{name}}#readme
license:             BSD3
license-file:        LICENSE
author:              {{author-name}}{{^author-name}}Author name here{{/author-name}}
maintainer:          {{author-email}}{{^author-email}}example@example.com{{/author-email}}
copyright:           {{copyright}}{{^copyright}}{{year}}{{^year}}2018{{/year}} {{author-name}}{{^author-name}}Author name here{{/author-name}}{{/copyright}}
category:            {{category}}{{^category}}Web{{/category}}</code></pre>
<h2 id="まとめ">まとめ</h2>
<p>今までも自分で作ったプロジェクトテンプレートを使うことはできましたが、<strong>new-template</strong> を置き換えるか <strong>config.yml</strong> を設定する必要がありました。</p>
<p>今回の機能追加により、<strong>stack new</strong> コマンドで直接プロジェクトテンプレートを簡単に指定できるため、自作テンプレート作りがはかどりそうです。</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>ContT を使ってコードを綺麗にしよう！</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/06-26-cont-param.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/06-26-cont-param.html</id>
    <published>2018-06-26T00:00:00Z</published>
    <updated>2018-06-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>Continuation (継続) について全く勉強したことが無いので <a href="https://www.stackage.org/haddock/lts-11.15/mtl-2.2.2/Control-Monad-Cont.html">Control.Monad.Cont</a> で定義されている ContT とかいつ使うんだろうなーと思っていましたが、ついに利用機会がありました！！！</p>
<p>僕が考えたんじゃなくて fumieval さんに相談して、教えてもらったんですけどね。</p>
<!--more-->
<h2 id="問題のコード">問題のコード</h2>
<p><strong>Yesod</strong> の <strong>Handler</strong> ではパラメータの取得するために <a href="https://www.stackage.org/haddock/lts-11.15/yesod-core-1.6.5/Yesod-Core-Handler.html#v:lookupGetParam">lookupGetParam</a> や <a href="https://www.stackage.org/haddock/lts-11.15/yesod-core-1.6.5/Yesod-Core-Handler.html#v:lookupPostParam">lookupPostParam</a> を利用すると思います。</p>
<p>実際にはこんな感じでパラメータを取得していくつか処理を行います。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">deleteTestR ::</span> <span class="dt">Handler</span> <span class="dt">Html</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">deleteTestR <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  mParam <span class="ot">&lt;-</span> lookupPostParam <span class="st">&quot;key&quot;</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  <span class="kw">case</span> mParam <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> returnJson <span class="fu">$</span> <span class="dt">String</span> <span class="st">&quot;パラメータが不正です。&quot;</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">    <span class="dt">Just</span> param <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">      <span class="kw">case</span> textToSqlKey param <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> returnJson <span class="fu">$</span> <span class="dt">String</span> <span class="st">&quot;キーが見つかりませんでした。&quot;</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">        <span class="dt">Just</span> key <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">          mRecord <span class="ot">&lt;-</span> runDB <span class="fu">$</span> get key</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">          <span class="kw">case</span> mRecord <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">            <span class="dt">Nothing</span> <span class="ot">-&gt;</span> returnJson <span class="fu">$</span> <span class="dt">String</span> <span class="st">&quot;削除対象のデータが見つかりませんでした。&quot;</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">            <span class="dt">Just</span> _  <span class="ot">-&gt;</span> returnJson <span class="fu">$</span> <span class="dt">String</span> <span class="st">&quot;success&quot;</span></a></code></pre></div>
<p>このコード、どう考えても嫌な感じですよね・・・。ネストやばいし。</p>
<p><strong>do</strong> で書くと <strong>Maybe</strong> 型なので値を返せないし、ベースに <strong>Handler</strong> モナドがあるので <strong>Either</strong> で置き換えるのも良くわかんないな・・・。と思って、結構放置してました。</p>
<h2 id="contt-を使ってリファクタリング">ContT を使ってリファクタリング！</h2>
<p>先程のプログラムを <a href="https://www.stackage.org/haddock/lts-11.15/mtl-2.2.2/Control-Monad-Cont.html#t:ContT">ContT</a> で置き換えるとこうなります。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">deleteTestR ::</span> <span class="dt">Handler</span> <span class="dt">Html</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">deleteTestR <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  mParam <span class="ot">&lt;-</span> lookupPostParam <span class="st">&quot;key&quot;</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  evalContT <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    param <span class="ot">&lt;-</span> mParam <span class="fu">!?</span> <span class="st">&quot;パラメータが不正です。&quot;</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">    key <span class="ot">&lt;-</span> textToSqlKey param <span class="fu">!?</span> <span class="st">&quot;キーが見つかりませんでした。&quot;</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">    mRecord <span class="ot">&lt;-</span> lift <span class="fu">$</span> runDB <span class="fu">$</span> get key</a>
<a class="sourceLine" id="cb2-9" data-line-number="9">    deletedBrand <span class="ot">&lt;-</span> mRecord <span class="fu">!?</span> <span class="st">&quot;削除対象のデータが見つかりませんでした。&quot;</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">    lift <span class="fu">$</span> returnJson <span class="fu">$</span> <span class="dt">String</span> <span class="st">&quot;success&quot;</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">    <span class="dt">Nothing</span> <span class="fu">!?</span> e <span class="fu">=</span> <span class="dt">ContT</span> <span class="fu">$</span> const <span class="fu">$</span> returnJson <span class="fu">$</span> <span class="dt">String</span> e</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">    <span class="dt">Just</span> a  <span class="fu">!?</span> _ <span class="fu">=</span> <span class="dt">ContT</span> (<span class="fu">$</span> a)</a></code></pre></div>
<p>感動しましたね。継続すごいな！って。</p>
<h2 id="まとめ">まとめ</h2>
<p>継続勉強しよ。</p>]]></summary>
</entry>
<entry>
    <title>stack run コマンド</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018/06-25-stack-run.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018/06-25-stack-run.html</id>
    <published>2018-06-25T00:00:00Z</published>
    <updated>2018-06-25T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>先日 stack の master ブランチに <a href="https://github.com/commercialhaskell/stack/pull/3952">Introduce stack run command line option #3952</a> がマージされました。とても便利なので紹介したいと思います。</p>
<p><strong>stack run</strong> コマンドについて簡単に説明するとこんな感じです。</p>
<ul>
<li><strong>cabal run</strong> の <strong>stack</strong> バージョンです。</li>
<li><code>stack build &amp;&amp; stack exec foo</code> の短縮形です。</li>
</ul>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" data-line-number="1">$ <span class="ex">stack</span> --version</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ex">Version</span> 1.8.0, Git revision 466da22ce21cddc20323fc2611cd2a2d3cc56ec6 (dirty) <span class="kw">(</span><span class="ex">5998</span> commits<span class="kw">)</span> <span class="ex">x86_64</span> hpack-0.28.2</a></code></pre></div>
<p>現在の <strong>stack</strong> の最新バージョンは <strong>1.7.1</strong> です。</p>
<!--more-->
<h2 id="stack-run-コマンド">stack run コマンド</h2>
<p>実際にプロジェクトを作って試してみましょう。</p>
<pre class="shell"><code>$ stack new stack-run-test
$ cd stack-run-test</code></pre>
<p>初回は通常通りビルドが実行され、その後に someFunc が出力されます。</p>
<pre class="shell"><code>$ stack run
Building all executables for `stack-run-test&#39; once. After a successful build of all of them, only specified executables

...

Registering library for stack-run-test-0.1.0.0..
someFunc</code></pre>
<p>2回目以降はビルド結果がキャッシュされているので、ファイルを変更しなれければ再ビルドされることはありません。</p>
<pre class="shell"><code>$ stack run
someFunc</code></pre>
<h2 id="まとめ">まとめ</h2>
<p><code>stack run</code> コマンドは <a href="https://github.com/commercialhaskell/stack/issues/233">Wishlist: stack run #233</a> によって2015年6月に提案されているので3年越しの実装ということになります。この調子で色々と便利なコマンドが増えると良いですね。</p>
<p>実行ファイル名の指定を省略できるのは、非常に便利なので僕も使っていこうと思います。</p>
<p>以上です。</p>]]></summary>
</entry>

</feed>
