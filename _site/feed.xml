<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>BIG MOON</title>
    <link href="https://haskell.e-bigmoon.com/feed.xml" rel="self" />
    <link href="https://haskell.e-bigmoon.com" />
    <id>https://haskell.e-bigmoon.com/feed.xml</id>
    <author>
        <name>BIG MOON</name>
        <email>it@e-bigmoon.com</email>
    </author>
    <updated>2018-01-29T00:00:00Z</updated>
    <entry>
    <title>素晴らしき HLint を使いこなす</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018-01-29-awesome-hlint.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018-01-29-awesome-hlint.html</id>
    <published>2018-01-29T00:00:00Z</published>
    <updated>2018-01-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p><a href="https://github.com/ndmitchell/hlint">HLint</a> は <a href="https://www.stackage.org/package/haskell-src-exts">haskell-src-exts</a> を使って実装されている静的解析ツールです。</p>
<p><code>HLint</code> を使えば <code>github</code> などを使って <code>PR</code> ベースで開発する場合のコードレビューでこんな事を言わなくて済みます。</p>
<ul>
<li><code>fromJust</code> とかの部分関数は使わないで！</li>
<li><code>maybe</code> 関数って知ってる？</li>
<li>この言語拡張って本当に使ってるの？</li>
<li><code>undefined</code> まだ残ってるじゃん！</li>
</ul>
<p>嬉しいことに <code>Travis CI</code> や <code>CircleCI</code> などで一度設定するだけなので導入もお手軽です！ また、最近知ったのですが、プロジェクト内で使って欲しくない関数なども <code>HLint</code> によって検出可能です。</p>
<p>さらに、独学で <code>Haskell</code> の学習を進めている人は <code>HLint</code> が素晴らしい教師役となってくれるでしょう。</p>
<ul>
<li><a href="https://github.com/waddlaw/blog-example-hlint">利用したコード</a></li>
</ul>
<!--more-->
<h2 id="hlint-の参考記事">HLint の参考記事</h2>
<p><code>HLint</code> は割と有名なので日本語の解説記事がいくつかありました。</p>
<ul>
<li><a href="https://qiita.com/suzuki-hoge/items/6d101e523620178c6f7b">Haskellの静的解析ツール HLint を使おう</a></li>
<li><a href="https://www.ncaq.net/2017/10/07/">Haskellを書くときはstylish-haskellとhlintを使って労せずして綺麗なコードを書きましょう</a></li>
<li><a href="https://qiita.com/VoQn/items/fe7953aec010d8f68a59">OverloadedStringsとANNプラグマが干渉する場合の回避方法</a></li>
</ul>
<p>ちゃんと使おうとすると上記の解説記事では少し物足りません。具体的には以下の点が不足しています。</p>
<ul>
<li>カスタムヒントの設定方法</li>
<li>関数の利用制限方法</li>
<li>関数・モジュール・ファイル単位でヒントを無視する方法</li>
<li><code>CI</code> で利用するための設定方法</li>
</ul>
<p>本記事では、これらの内容について解説を行います。<code>HLint</code> でどんなことが出来るかについては、上記の記事または<a href="https://github.com/ndmitchell/hlint">公式リポジトリ</a>をご参考ください。</p>
<p>また、内部の仕組みについては、作者の <code>Neil Mitchell</code> さんの解説記事が参考になります。</p>
<ul>
<li><a href="https://qiita.com/rounddelta/items/4584f5486c1061c93f0b">HLint のルールを理解する (和訳)</a></li>
</ul>
<h2 id="hlint-の導入">HLint の導入</h2>
<p><code>HLint</code> は以下のコマンドで簡単に導入できます。</p>
<pre class="shell"><code>$ stack install hlint

$ hlint --version
HLint v2.0.15, (C) Neil Mitchell 2006-2018</code></pre>
<p>現在の最新版は <code>v2.0.15</code> となっています。<code>HLint</code> のバージョンによって出力内容が異なることが良くありますのでご注意ください。</p>
<p>また、お試しで使ってみたい人は以下のコマンドを実行してみましょう。カレントディレクトリ以下のファイルが検査されます。</p>
<pre class="shell"><code>$ curl -sL https://raw.github.com/ndmitchell/hlint/master/misc/travis.sh | sh -s .</code></pre>
<h2 id="hlint-の実行方法">HLint の実行方法</h2>
<p><code>HLint</code> はディレクトリを指定すると再帰的に解析を行ってくれます。</p>
<h3 id="プロジェクト全体に対して再帰的に実行">プロジェクト全体に対して再帰的に実行</h3>
<pre class="shell"><code>$ hlint .</code></pre>
<h3 id="特定のディレクトリ-src-に対して再帰的に実行">特定のディレクトリ (src) に対して再帰的に実行</h3>
<pre class="shell"><code>$ hlint src</code></pre>
<h3 id="複数のディレクトリ-src-test-に対して再帰的に実行">複数のディレクトリ (src, test) に対して再帰的に実行</h3>
<pre class="shell"><code>$ hlint src test</code></pre>
<h3 id="単一のファイル-appmain.hs-にのみ実行">単一のファイル (app/Main.hs) にのみ実行</h3>
<pre class="shell"><code>$ hlint app/Main.hs</code></pre>
<h2 id="hlint-のヒント">HLint のヒント</h2>
<p>以下のように <code>stack new</code> で新規プロジェクトを作ってすぐの状態では <code>HLint</code> は何もヒントを出してくれません。つまり、とても良い状態ということです。</p>
<pre class="shell"><code>$ stacke new test-proj
$ cd test-proj

$ hlint .
No hints</code></pre>
<p>ここで、ファイルを少し修正して <code>HLint</code> に働いてもらいましょう！</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">-- src/Lib.hs</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Lib</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="ot">someFunc ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">someFunc <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  <span class="kw">let</span> x1 <span class="fu">=</span> concat (map toUpper [<span class="ch">&#39;a&#39;</span> <span class="fu">..</span> <span class="ch">&#39;z&#39;</span>])</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">      x2 <span class="fu">=</span> maybe <span class="st">&quot;&quot;</span> id <span class="st">&quot;abc&quot;</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">  putStrLn <span class="st">&quot;someFunc&quot;</span></a></code></pre></div>
<p>上記のコードは以下のようなヒントを2つ提案してくれます。</p>
<pre class="shell"><code>$ hlint .
./src/Lib.hs:7:12: Warning: Use concatMap
Found:
  concat (map toUpper [&#39;a&#39; .. &#39;z&#39;])
Why not:
  concatMap toUpper [&#39;a&#39; .. &#39;z&#39;]

./src/Lib.hs:8:12: Warning: Use fromMaybe
Found:
  maybe &quot;&quot; id
Why not:
  Data.Maybe.fromMaybe &quot;&quot;

2 hints</code></pre>
<p>これは、こんな感じの意味になります。</p>
<table>
<colgroup>
<col style="width: 41%" />
<col style="width: 25%" />
<col style="width: 32%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">ヒントレベル</th>
<th>ヒント</th>
<th>出力の意味</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">警告</td>
<td>Use concatMap</td>
<td><code>concat (map toUpper ['a' .. 'z'])</code> を見つけたけど、どうして <code>concatMap toUpper ['a' .. 'z']</code> と書かないんだい？</td>
</tr>
<tr class="even">
<td style="text-align: center;">警告</td>
<td>Use fromMaybe</td>
<td><code>maybe &quot;&quot; id</code> は <code>Data.Maybe</code> モジュールにある <code>fromMaybe</code> 関数を使えば <code>fromMaybe &quot;&quot;</code> と同じですよ</td>
</tr>
</tbody>
</table>
<p>素晴らしいですね。とてもわかりやすいです。また、<code>--report</code> オプションを利用することで結果を <code>HTML</code> として出力することも可能です。</p>
<pre class="shell"><code>$ hlint . --report</code></pre>
<p>とても素晴らしいのですが、<code>HLint</code> の提案するヒントに賛成できない時はどうしましょう? もし <code>HLint</code> の言うとおりにしかできないのであれば、とても使いづらいツールになってしまいます。</p>
<p>そういった場合のためにルールを無視する方法も用意されています。また、プロジェクト固有のカスタムヒントについても同様に設定方法が用意されています。</p>
<h2 id="hlint-のヒントについて">HLint のヒントについて</h2>
<p>デフォルトで適用されるヒントの一覧は <a href="https://github.com/ndmitchell/hlint/blob/master/data/hlint.yaml">hlint.yaml</a> で確認できます。この中に無いヒントについては、自分でカスタムヒントを追加して対応することになります。</p>
<h3 id="カスタムヒントファイルの生成">カスタムヒントファイルの生成</h3>
<p>まずは、カスタムヒントファイルの雛形を生成するために、プロジェクトのルートで以下のコマンドを実行しましょう。</p>
<pre class="shell"><code>$ hlint --default &gt; .hlint.yaml</code></pre>
<p>中身はこんな感じで、ヒントの書き方について具体例が載っています。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="co"># HLint configuration file</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="co"># https://github.com/ndmitchell/hlint</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="co">##########################</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="co"># This file contains a template configuration file, which is typically</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="co"># placed as .hlint.yaml in the root of your project</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7"></a>
<a class="sourceLine" id="cb12-8" data-line-number="8"></a>
<a class="sourceLine" id="cb12-9" data-line-number="9"><span class="co"># Specify additional command line arguments</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10"><span class="co">#</span></a>
<a class="sourceLine" id="cb12-11" data-line-number="11"><span class="co"># - arguments: [--color, --cpp-simple, -XQuasiQuotes]</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12"></a>
<a class="sourceLine" id="cb12-13" data-line-number="13"></a>
<a class="sourceLine" id="cb12-14" data-line-number="14"><span class="co"># Control which extensions/flags/modules/functions can be used</span></a>
<a class="sourceLine" id="cb12-15" data-line-number="15"><span class="co">#</span></a>
<a class="sourceLine" id="cb12-16" data-line-number="16"><span class="co"># - extensions:</span></a>
<a class="sourceLine" id="cb12-17" data-line-number="17"><span class="co">#   - default: false # all extension are banned by default</span></a>
<a class="sourceLine" id="cb12-18" data-line-number="18"><span class="co">#   - name: [PatternGuards, ViewPatterns] # only these listed extensions can be used</span></a>
<a class="sourceLine" id="cb12-19" data-line-number="19"><span class="co">#   - {name: CPP, within: CrossPlatform} # CPP can only be used in a given module</span></a>
<a class="sourceLine" id="cb12-20" data-line-number="20"><span class="co">#</span></a>
<a class="sourceLine" id="cb12-21" data-line-number="21"><span class="co"># - flags:</span></a>
<a class="sourceLine" id="cb12-22" data-line-number="22"><span class="co">#   - {name: -w, within: []} # -w is allowed nowhere</span></a>
<a class="sourceLine" id="cb12-23" data-line-number="23"><span class="co">#</span></a>
<a class="sourceLine" id="cb12-24" data-line-number="24"><span class="co"># - modules:</span></a>
<a class="sourceLine" id="cb12-25" data-line-number="25"><span class="co">#   - {name: [Data.Set, Data.HashSet], as: Set} # if you import Data.Set qualified, it must be as &#39;Set&#39;</span></a>
<a class="sourceLine" id="cb12-26" data-line-number="26"><span class="co">#   - {name: Control.Arrow, within: []} # Certain modules are banned entirely</span></a>
<a class="sourceLine" id="cb12-27" data-line-number="27"><span class="co">#</span></a>
<a class="sourceLine" id="cb12-28" data-line-number="28"><span class="co"># - functions:</span></a>
<a class="sourceLine" id="cb12-29" data-line-number="29"><span class="co">#   - {name: unsafePerformIO, within: []} # unsafePerformIO can only appear in no modules</span></a>
<a class="sourceLine" id="cb12-30" data-line-number="30"></a>
<a class="sourceLine" id="cb12-31" data-line-number="31"></a>
<a class="sourceLine" id="cb12-32" data-line-number="32"><span class="co"># Add custom hints for this project</span></a>
<a class="sourceLine" id="cb12-33" data-line-number="33"><span class="co">#</span></a>
<a class="sourceLine" id="cb12-34" data-line-number="34"><span class="co"># Will suggest replacing &quot;wibbleMany [myvar]&quot; with &quot;wibbleOne myvar&quot;</span></a>
<a class="sourceLine" id="cb12-35" data-line-number="35"><span class="co"># - error: {lhs: &quot;wibbleMany [x]&quot;, rhs: wibbleOne x}</span></a>
<a class="sourceLine" id="cb12-36" data-line-number="36"></a>
<a class="sourceLine" id="cb12-37" data-line-number="37"></a>
<a class="sourceLine" id="cb12-38" data-line-number="38"><span class="co"># Turn on hints that are off by default</span></a>
<a class="sourceLine" id="cb12-39" data-line-number="39"><span class="co">#</span></a>
<a class="sourceLine" id="cb12-40" data-line-number="40"><span class="co"># Ban &quot;module X(module X) where&quot;, to require a real export list</span></a>
<a class="sourceLine" id="cb12-41" data-line-number="41"><span class="co"># - warn: {name: Use explicit module export list}</span></a>
<a class="sourceLine" id="cb12-42" data-line-number="42"><span class="co">#</span></a>
<a class="sourceLine" id="cb12-43" data-line-number="43"><span class="co"># Replace a $ b $ c with a . b $ c</span></a>
<a class="sourceLine" id="cb12-44" data-line-number="44"><span class="co"># - group: {name: dollar, enabled: true}</span></a>
<a class="sourceLine" id="cb12-45" data-line-number="45"><span class="co">#</span></a>
<a class="sourceLine" id="cb12-46" data-line-number="46"><span class="co"># Generalise map to fmap, ++ to &lt;&gt;</span></a>
<a class="sourceLine" id="cb12-47" data-line-number="47"><span class="co"># - group: {name: generalise, enabled: true}</span></a>
<a class="sourceLine" id="cb12-48" data-line-number="48"></a>
<a class="sourceLine" id="cb12-49" data-line-number="49"></a>
<a class="sourceLine" id="cb12-50" data-line-number="50"><span class="co"># Ignore some builtin hints</span></a>
<a class="sourceLine" id="cb12-51" data-line-number="51"><span class="co"># - ignore: {name: Use let}</span></a>
<a class="sourceLine" id="cb12-52" data-line-number="52"><span class="co"># - ignore: {name: Use const, within: SpecialModule} # Only within certain modules</span></a>
<a class="sourceLine" id="cb12-53" data-line-number="53"></a>
<a class="sourceLine" id="cb12-54" data-line-number="54"></a>
<a class="sourceLine" id="cb12-55" data-line-number="55"><span class="co"># Define some custom infix operators</span></a>
<a class="sourceLine" id="cb12-56" data-line-number="56"><span class="co"># - fixity: infixr 3 ~^#^~</span></a>
<a class="sourceLine" id="cb12-57" data-line-number="57"></a>
<a class="sourceLine" id="cb12-58" data-line-number="58"></a>
<a class="sourceLine" id="cb12-59" data-line-number="59"><span class="co"># To generate a suitable file for HLint do:</span></a>
<a class="sourceLine" id="cb12-60" data-line-number="60"><span class="co"># $ hlint --default &gt; .hlint.yaml</span></a></code></pre></div>
<p><code>HLint</code> はデフォルトヒントが記述されている <code>hlint.yaml</code> と、カスタムヒントが記述されている <code>.hlint.yaml</code> の両方のヒント使って検査を行うため、プロジェクト固有のヒントについては、<code>.hlint.yaml</code> に記述していくことになります。</p>
<h3 id="カスタムヒントの追加">カスタムヒントの追加</h3>
<p>ここでは説明のため以下のような <code>tshow</code> という関数があるとしましょう。この関数は <code>show :: Show a =&gt; a -&gt; String</code> の <code>Text</code> バージョンです。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Text</span> (pack)</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="ot">tshow ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4">tshow <span class="fu">=</span> pack <span class="fu">.</span> show</a></code></pre></div>
<p>目的としてはプロジェクトのコード中で <code>pack . show</code> となっている部分を <code>tshow</code> に直すようにヒントを出させることです。当然ながら現時点では <code>pack . show</code> というコードが使われていたとしても何も起こりません。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="co">-- src/Lib.hs</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Lib</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3"></a>
<a class="sourceLine" id="cb14-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Data.Text</span> (pack)</a>
<a class="sourceLine" id="cb14-5" data-line-number="5"></a>
<a class="sourceLine" id="cb14-6" data-line-number="6"><span class="ot">intToText ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb14-7" data-line-number="7">intToText <span class="fu">=</span> pack <span class="fu">.</span> show</a></code></pre></div>
<pre class="shell"><code>$ hlint .
No hints</code></pre>
<p>それでは <code>.hlint.yaml</code> に <code>tshow = pack . show</code> を検出するためのヒントを追記しましょう。以下の1行を追記するだけです。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">-</span> <span class="fu">error:</span><span class="at"> </span><span class="kw">{</span><span class="fu">lhs:</span><span class="at"> pack (show x)</span><span class="kw">,</span> <span class="fu">rhs:</span><span class="at"> tshow x</span><span class="kw">}</span></a></code></pre></div>
<p><code>lhs</code>, <code>rhs</code> はそれぞれ <code>Left Hand Side (左辺)</code>, <code>Right Hand Side (右辺)</code> の略です。またヒントのレベルは <code>error</code> 以外にも <code>warm</code>, <code>suggest (hint キーワードはただのエイリアスです)</code> も指定できるため、好きなレベルを指定しましょう。(ヒントレベルの使い分けについては <a href="https://github.com/ndmitchell/hlint#what-is-the-difference-between-errorwarningsuggestion">What is the difference between error/warning/suggestion?</a> をご参照ください)</p>
<p>では、実行してみましょう。</p>
<pre class="shell"><code>$ hlint .
./src/Lib.hs:14:13: Error: Use tshow
Found:
  pack . show
Why not:
  tshow

1 hint</code></pre>
<p>無事に <code>Error</code> として <code>tshow</code> のためのヒントが表示されました！</p>
<p>ヒントの修正方法は、先程定義した <code>intToText</code> 関数の実装をヒント通りに書き換えるだけです。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="ot">intToText ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">intToText <span class="fu">=</span> tshow</a></code></pre></div>
<pre class="shell"><code>$ hlint .
No hints</code></pre>
<h3 id="ヒントの定義方法について">ヒントの定義方法について</h3>
<p>さきほど定義したヒントはこのようにポイントフリーで書くこともできます。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">-</span> <span class="fu">error:</span><span class="at"> </span><span class="kw">{</span><span class="fu">lhs:</span><span class="at"> pack . show</span><span class="kw">,</span> <span class="fu">rhs:</span><span class="at"> tshow</span><span class="kw">}</span></a></code></pre></div>
<p>上記のヒント形式で次の内容を解析してみましょう。</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="co">-- src/Lib.hs</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Lib</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3"></a>
<a class="sourceLine" id="cb21-4" data-line-number="4"><span class="kw">import</span> <span class="dt">Data.Text</span> (pack)</a>
<a class="sourceLine" id="cb21-5" data-line-number="5"></a>
<a class="sourceLine" id="cb21-6" data-line-number="6"><span class="ot">intToText ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7">intToText <span class="fu">=</span> pack <span class="fu">.</span> show</a>
<a class="sourceLine" id="cb21-8" data-line-number="8"></a>
<a class="sourceLine" id="cb21-9" data-line-number="9"><span class="ot">intToText2  ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb21-10" data-line-number="10">intToText2 x <span class="fu">=</span> pack <span class="fu">$</span> show x</a></code></pre></div>
<pre class="shell"><code>$ hlint .
./src/Lib.hs:6:13: Error: Use tshow
Found:
  pack . show
Why not:
  tshow

1 hint</code></pre>
<p><code>intToText</code> と <code>intToText2</code> どちらも検出して欲しいですが <code>intToText</code> しか検出できていません。<code>HLint</code> では自動的に η-簡約 (eta-reduction) が行われるため <code>error: {lhs: pack (show x), rhs: tshow x}</code> というように定義しておいた方が良いです。</p>
<h2 id="プロジェクトで利用を禁止している関数を検出する">プロジェクトで利用を禁止している関数を検出する</h2>
<p>プロジェクト内で部分関数 (例: <code>fromJust</code>) を使わせないようにさせたり、<code>undefined</code> が残っていないかなどのチェックをレビュー時に人間が行っていたりしませんか？</p>
<p>人間が介入するということは必ずミスが起こります。人間が気をつければミスは起こらないと思っていたり、精神力でなんとかしようとしている場合は能力不足を疑われても仕方がありません。</p>
<p>また、そのようなつまらない間違い探しのような非クリエイティブな作業に大切な時間を割いてしまうのはとても良くないことです。</p>
<p><code>HLint</code> を使えば、そのような関数を検出することが可能です。実際には <code>関数</code> だけでなく <code>言語拡張</code>, <code>フラグ</code>, <code>モジュール</code> も指定することができます。</p>
<h3 id="関数を指定する方法">関数を指定する方法</h3>
<p><code>.hlint.yaml</code> に以下の内容を追記します。今回は <code>undefined</code> を検出してみたいと思います。</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="co"># .hlint.yaml</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2"><span class="kw">-</span> <span class="fu">functions:</span></a>
<a class="sourceLine" id="cb23-3" data-line-number="3">  <span class="kw">-</span> <span class="kw">{</span><span class="fu">name:</span><span class="at"> undefined</span><span class="kw">,</span> <span class="fu">within:</span><span class="at"> </span><span class="kw">[]}</span></a></code></pre></div>
<p>現状はどこにも使われていないためヒントは表示されません。</p>
<pre class="shell"><code>$ hlint .
No hints</code></pre>
<p>では、以下の関数を追加してみましょう。このように型レベルで設計して、実装を <code>undefined</code> にしておくことは良くあります。</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="co">-- src/Lib.hs</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="ot">doubleToText ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb25-3" data-line-number="3">doubleToText <span class="fu">=</span> undefined</a></code></pre></div>
<p>忘れずに実装してしまえば問題無いのですが、たまには忘れることもあります。しかし、<code>HLint</code> があれば安心です。</p>
<pre class="shell"><code>$ hlint .
./src/Lib.hs:18:16: Warning: Avoid restricted function
Found:
  undefined
Note: may break the code

1 hint</code></pre>
<h2 id="hlint-のヒントを無視する方法">HLint のヒントを無視する方法</h2>
<p><code>HLint</code> のヒントを無視する方法には以下の2種類があります。</p>
<ul>
<li><code>.hlint.yaml</code> ファイルで指定する (<strong>全てのファイル</strong>に影響)</li>
<li>ファイルに直接 <code>{-# ANN -#}</code> アノテーションを記述する (<strong>アノテーションの範囲</strong>にのみ影響)</li>
</ul>
<p>書式がちょっとわかりづらいので、実際に色々試してみましょう。</p>
<h3 id="関数単位で全てのヒントを無視する">関数単位で全てのヒントを無視する</h3>
<p>最初に定義した <code>someFunc</code> 関数はヒントを2つ提案してくれていました。</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="co">-- src/Lib.hs</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Lib</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3"></a>
<a class="sourceLine" id="cb27-4" data-line-number="4"><span class="ot">someFunc ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb27-5" data-line-number="5">someFunc <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb27-6" data-line-number="6">  <span class="kw">let</span> x1 <span class="fu">=</span> concat (map toUpper [<span class="ch">&#39;a&#39;</span> <span class="fu">..</span> <span class="ch">&#39;z&#39;</span>])</a>
<a class="sourceLine" id="cb27-7" data-line-number="7">      x2 <span class="fu">=</span> maybe <span class="st">&quot;&quot;</span> id <span class="st">&quot;abc&quot;</span></a>
<a class="sourceLine" id="cb27-8" data-line-number="8">  putStrLn <span class="st">&quot;someFunc&quot;</span></a></code></pre></div>
<pre class="shell"><code>$ hlint .
./src/Lib.hs:6:12: Warning: Use concatMap
Found:
  concat (map toUpper [&#39;a&#39; .. &#39;z&#39;])
Why not:
  concatMap toUpper [&#39;a&#39; .. &#39;z&#39;]

./src/Lib.hs:7:12: Warning: Use fromMaybe
Found:
  maybe &quot;&quot; id
Why not:
  Data.Maybe.fromMaybe &quot;&quot;

2 hints</code></pre>
<p>提案されているヒントは以下の2つです。</p>
<ul>
<li>Warning: Use <code>concatMap</code></li>
<li>Warning: Use <code>fromMaybe</code></li>
</ul>
<p>とりあえず <code>someFunc</code> のヒントを全て無視するようにしてしまいましょう。</p>
<p>こんな感じで <code>{-# ANN someFunc &quot;HLint: ignore&quot; #-}</code> というアノテーションをつけます。</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="co">-- src/Lib.hs</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Lib</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3"></a>
<a class="sourceLine" id="cb29-4" data-line-number="4"><span class="ot">{-# ANN someFunc &quot;HLint: ignore&quot; #-}</span></a>
<a class="sourceLine" id="cb29-5" data-line-number="5"><span class="ot">someFunc ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb29-6" data-line-number="6">someFunc <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb29-7" data-line-number="7">  <span class="kw">let</span> x1 <span class="fu">=</span> concat (map toUpper [<span class="ch">&#39;a&#39;</span> <span class="fu">..</span> <span class="ch">&#39;z&#39;</span>])</a>
<a class="sourceLine" id="cb29-8" data-line-number="8">      x2 <span class="fu">=</span> maybe <span class="st">&quot;&quot;</span> id <span class="st">&quot;abc&quot;</span></a>
<a class="sourceLine" id="cb29-9" data-line-number="9">  putStrLn <span class="st">&quot;someFunc&quot;</span></a></code></pre></div>
<pre class="shell"><code>$ hlint .
No hints</code></pre>
<p>これで <code>src/Lib.hs</code> に記述されている <code>someFunc</code> 関数のみ <code>HLint</code> のヒントを無視できるようになりました。</p>
<h3 id="ヒントを無視する様々な方法">ヒントを無視する様々な方法</h3>
<p>ヒントレベルは <code>ignore</code> 以外にも <code>suggest</code>, <code>warn</code>, <code>error</code> が利用可能です。これらの値を利用した場合は出力時のヒントレベルが強制的にそのレベルに上書きされます。つまり、ヒントファイルに <code>warn</code> で定義されていたとしても <code>error</code> や <code>ignore</code> として処理されることになります。</p>
<h4 id="関数単位で全てのヒントを無視する方法">関数単位で全てのヒントを無視する方法</h4>
<p><code>ANN</code> のあとに対象の関数名を書きます。</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="ot">{-# ANN someFunc &quot;HLint: ignore&quot; #-}</span></a></code></pre></div>
<h4 id="関数単位で特定のヒントのみを無視する方法">関数単位で特定のヒントのみを無視する方法</h4>
<p><code>HLint: ignore</code> の後にヒント名を書きます。</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="ot">{-# ANN someFunc &quot;HLint: ignore Use fromMaybe&quot; #-}</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2"><span class="ot">{-# ANN someFunc &quot;HLint: ignore Use concatMap&quot; #-}</span></a></code></pre></div>
<h4 id="モジュール単位で無視する方法">モジュール単位で無視する方法</h4>
<p><code>module</code> キーワードを使う場合はアノテーションを <code>import</code> 文の後に設置しないと上手く動かないので、その点のみ注意が必要です。</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="ot">{-# ANN module &quot;HLint: ignore&quot; #-}</span></a>
<a class="sourceLine" id="cb33-2" data-line-number="2"></a>
<a class="sourceLine" id="cb33-3" data-line-number="3"><span class="ot">{-# ANN module &quot;HLint: ignore Use fromMaybe&quot; #-}</span></a>
<a class="sourceLine" id="cb33-4" data-line-number="4"><span class="ot">{-# ANN module &quot;HLint: ignore Use concatMap&quot; #-}</span></a></code></pre></div>
<h3 id="overloadedstrings-言語拡張">OverloadedStrings 言語拡張</h3>
<p>言語拡張の <code>OverloadedStrings</code> を有効化している場合は上手く動かないため、明示的に <code>String</code> の型注釈を指定する必要があります。</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="ot">{-# ANN someFunc (&quot;HLint: ignore&quot; :: String) #-}</span></a></code></pre></div>
<h3 id="ヒントファイルを使って無視する方法">ヒントファイルを使って無視する方法</h3>
<p>プロジェクト全体で無視したいヒントについては <code>.hint.yaml</code> に追記します。</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="co"># .hint.yaml</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2"><span class="kw">-</span> <span class="fu">ignore:</span><span class="at"> </span><span class="kw">{</span><span class="fu">name:</span><span class="at"> Use fromMaybe</span><span class="kw">}</span></a>
<a class="sourceLine" id="cb35-3" data-line-number="3"><span class="kw">-</span> <span class="fu">ignore:</span><span class="at"> </span><span class="kw">{</span><span class="fu">name:</span><span class="at"> Use concatMap</span><span class="kw">}</span></a></code></pre></div>
<p><code>within</code> キーワードでヒントを適用するモジュールを指定できます。</p>
<p>例として <code>Lib</code> モジュールのみを対象とする場合は次のようになります。(この場合は <code>ignore</code> が指定されているので <code>Lib</code> モジュールのみヒントを無視します)</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="co"># .hlint.yaml</span></a>
<a class="sourceLine" id="cb36-2" data-line-number="2"><span class="kw">-</span> <span class="fu">ignore:</span><span class="at"> </span><span class="kw">{</span><span class="fu">name:</span><span class="at"> Use fromMaybe</span><span class="kw">,</span> <span class="fu">within:</span><span class="at"> </span><span class="kw">[</span>Lib<span class="kw">]}</span></a>
<a class="sourceLine" id="cb36-3" data-line-number="3"><span class="kw">-</span> <span class="fu">ignore:</span><span class="at"> </span><span class="kw">{</span><span class="fu">name:</span><span class="at"> Use concatMap</span><span class="kw">,</span> <span class="fu">within:</span><span class="at"> </span><span class="kw">[</span>Lib<span class="kw">]}</span></a></code></pre></div>
<h2 id="ci-を回す">CI を回す！</h2>
<p><code>Haskell</code> のプロジェクトでよく見る <code>CI</code> ツールといえば以下の2つでしょう。</p>
<ul>
<li><a href="https://travis-ci.org/">Travis CI</a></li>
<li><a href="https://circleci.com/">CircleCI 2.0</a></li>
</ul>
<p>個人的には以下の点で <code>CircleCI</code> が好きです。</p>
<ul>
<li>プライベートリポジトリも無料で使える</li>
<li><code>Docker</code>, <code>docker-compose</code> と親和性が高い</li>
</ul>
<p>ここでは <code>HLint</code> の内容にしか言及しませんが、機会があれば <code>CI</code> については別途記事にしたいと思います。</p>
<h3 id="travis-ci">Travis CI</h3>
<p><code>.travis.yml</code> に以下の内容を記述するだけです。</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="co"># .travis.yml</span></a>
<a class="sourceLine" id="cb37-2" data-line-number="2"><span class="fu">sudo:</span><span class="at"> false</span></a>
<a class="sourceLine" id="cb37-3" data-line-number="3"><span class="fu">language:</span><span class="at"> generic</span></a>
<a class="sourceLine" id="cb37-4" data-line-number="4"><span class="fu">jobs:</span></a>
<a class="sourceLine" id="cb37-5" data-line-number="5">  <span class="fu">include:</span></a>
<a class="sourceLine" id="cb37-6" data-line-number="6">    <span class="kw">-</span> <span class="fu">stage:</span><span class="at"> Run hlint</span></a>
<a class="sourceLine" id="cb37-7" data-line-number="7">      <span class="fu">script:</span><span class="at"> curl -sL https://raw.github.com/ndmitchell/hlint/master/misc/travis.sh | sh -s .</span></a></code></pre></div>
<h3 id="circleci-2.0">CircleCI 2.0</h3>
<p><code>.circleci/config.yml</code> に以下の内容を記述するだけです。</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="fu">version:</span><span class="at"> 2</span></a>
<a class="sourceLine" id="cb38-2" data-line-number="2"><span class="fu">jobs:</span></a>
<a class="sourceLine" id="cb38-3" data-line-number="3">  <span class="fu">hlint:</span></a>
<a class="sourceLine" id="cb38-4" data-line-number="4">    <span class="fu">docker:</span></a>
<a class="sourceLine" id="cb38-5" data-line-number="5">      <span class="kw">-</span> <span class="fu">image:</span><span class="at"> ubuntu:16.04</span></a>
<a class="sourceLine" id="cb38-6" data-line-number="6">    <span class="fu">steps:</span></a>
<a class="sourceLine" id="cb38-7" data-line-number="7">      <span class="kw">-</span> checkout</a>
<a class="sourceLine" id="cb38-8" data-line-number="8">      <span class="kw">-</span> <span class="fu">run:</span></a>
<a class="sourceLine" id="cb38-9" data-line-number="9">          <span class="fu">name:</span><span class="at"> Run hlint</span></a>
<a class="sourceLine" id="cb38-10" data-line-number="10">          <span class="fu">command:</span><span class="at"> |</span></a>
<a class="sourceLine" id="cb38-11" data-line-number="11">            apt update</a>
<a class="sourceLine" id="cb38-12" data-line-number="12">            apt install -y curl</a>
<a class="sourceLine" id="cb38-13" data-line-number="13">            <span class="fu">curl -sL https:</span><span class="at">//raw.github.com/ndmitchell/hlint/master/misc/travis.sh | sh -s .</span></a>
<a class="sourceLine" id="cb38-14" data-line-number="14"><span class="fu">workflows:</span></a>
<a class="sourceLine" id="cb38-15" data-line-number="15">  <span class="fu">version:</span><span class="at"> 2</span></a>
<a class="sourceLine" id="cb38-16" data-line-number="16">  <span class="fu">hlint:</span></a>
<a class="sourceLine" id="cb38-17" data-line-number="17">    <span class="fu">jobs:</span></a>
<a class="sourceLine" id="cb38-18" data-line-number="18">      <span class="kw">-</span> hlint</a></code></pre></div>
<h2 id="まとめ">まとめ</h2>
<p>今回は紹介していませんが <code>HLint</code> のヒントを自動的に適用してくれる <a href="https://github.com/mpickering/apply-refact">apply-refact</a> というツールもあります。使い方については各種ドキュメントをご確認ください。</p>
<ul>
<li><a href="https://github.com/ndmitchell/hlint#automatically-applying-hints">Automatically Applying Hints</a></li>
</ul>
<p>今回は <code>Haskell</code> の静的解析ツール <code>HLint</code> について説明を行いました。需要があれば <code>LiquidHaskell</code> などの他の静的解析ツールについても、チュートリアル的な解説記事を書いていきたいところです。</p>]]></summary>
</entry>
<entry>
    <title>Yesod の破壊的変更予定</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018-01-27-Upcoming-Yesod-breaking-changes.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018-01-27-Upcoming-Yesod-breaking-changes.html</id>
    <published>2018-01-27T00:00:00Z</published>
    <updated>2018-01-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Original post: <a href="https://www.yesodweb.com/blog/2018/01/upcoming-yesod-breaking-changes">Upcoming Yesod breaking changes</a></p>
<p>2018年 1月 11日 Michael Snoyman</p>
<p>私が作ったライブラリの破壊的変更点について話をしてきましたが、Yesod をその変更から取り残したくはありませんでした。yesod-core は 2014年からバージョン1.4 で安定しています。しかし、私のパッケージエコシステムにおける <code>MonadUnliftIO</code> の変更は Yesod にも影響してくるでしょう。問題は、どの程度かということです。</p>
<!--more-->
<p>知らない人のために補足しておくと、<code>MonadUnliftIO</code> は <code>monad-control</code> と <code>exceptions</code> にそれぞれ存在する <code>MonadBaseControl</code> と <code>MonadCatch/MonadMask</code> クラスの代替となる型クラスです。私はこれまでこの新しいアプローチのメリットを至る所で言及してきましたが、おそらく一番良い資料は<a href="https://www.fpcomplete.com/blog/2017/07/announcing-new-unliftio-library">リリースアナウンスのブログ記事</a>でしょう。</p>
<p>予定されている Yesod の変更点を簡潔に述べると:</p>
<ul>
<li><code>WidgetT</code> の内部表現を変更する。現在は <code>WriterT</code> として実装されているので変更が必要です。<code>MonadUnliftIO</code> とマッチさせるために、<code>IORef</code> を持つ <code>ReaderT</code> にする必要があります。この変更は内部モジュールにしか影響しないため、私の想像ではかなり小さな変更になります (非破壊的変更と言い換えることもできる)。</li>
<li><code>MonadBaseControl</code> と <code>MonadCatch/MonadMask</code> のインスタンスを削除する。これは厳密には必要ないですが、2つのアドバンテージがあります: 依存関係の数を少なくし、<code>HandlerT</code> の上に <code>StateT</code> を乗せた状態で <code>concurrently</code> を使うような危険な振る舞いを避けることができます。</li>
<li>依存しているライブラリを、変更後の新しいバージョンに切り替える。特に conduit や resourcet など。これも厳密には破壊的変更ではないですが、私は依存関係のメジャーバージョンへのサポートを打ち切ることを半破壊的変更だと捉えています。</li>
<li>破壊的変更に伴う、いくつもの小さなお片付け。いくつかの場所に正格化のためのアノテーションを追加するとか、死んでいる <code>GoogleEmail</code> や <code>BrowserId</code> 等のモジュールの削除などです。</li>
</ul>
<p>これは完全に筋の通った変更で、Yesod 1.5 (2.0) としてリリースします。私が実験しているもう少し大きな変更があるので、それをここで共有しておきます。この変更が Yesod のユーザーにとって価値があるかどうか、フィードバックをお願いしたいです。</p>
<h2 id="トランスフォーマーから離れろ">トランスフォーマーから離れろ!</h2>
<p>以下の説明は、こういう議論ではいつもそうであるように、仕方なく <code>IO</code> に入れなければならないコードについて言及したものです。純粋なコードは今回はパスです。</p>
<p>(実際の変更よりも大きく見えますが) 変更は <a href="https://github.com/yesodweb/yesod/pull/1466">no-transformer ブランチ</a> で確認できます。まぁすぐに嘘だと分かると思いますが、意図を正確に表しています。ここ 1年間のブログ記事の雰囲気と推奨しているベストプラクティスについての私の議論を見れば、次の簡単な主張に帰結します: モダンな Haskell はモナドトランスフォーマーを使いすぎなのです</p>
<p>この主張に対して最も過激な反応をするなら、全てのトランスフォーマーを削除し、全てのコードを <code>IO</code> に入れる、というものになります。私はちょっと妥協して、reader の機能は残す価値があると判断しました。なぜなら、<code>logInfo</code> のような単純な関数に何かを追加で渡すのは、かなりの苦痛だからです。Yesod の核となっている型は <code>HandlerT</code> で、<code>getHomeR :: HandlerT App IO Html</code> のように使われます。内部では、<code>HandlerT</code> は以下のようになっています:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">HandlerT</span> site m a <span class="fu">=</span> <span class="dt">HandlerT</span> (<span class="dt">HandlerData</span> site <span class="ot">-&gt;</span> m a)</a></code></pre></div>
<p>簡単な質問をしましょう: <code>HandlerT</code> は本当にトランスフォーマーである必要があるのでしょうか?</p>
<p>なぜシンプルにこんな風に書かないのでしょうか:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">HandlerFor</span> site a <span class="fu">=</span> <span class="dt">HandlerFor</span> (<span class="dt">HandlerData</span> site <span class="ot">-&gt;</span> <span class="dt">IO</span> a)</a></code></pre></div>
<p><code>m</code> という型引数を <code>IO</code> という具体的なものに変えただけです。どんな場所でもハンドラはベースモナドとして <code>IO</code> を持つ、という前提がすでにあるので、汎用性が無くなるわけではありません。</p>
<p>しかしこの結果得られるものは:</p>
<ul>
<li>少し分かりやすいエラーメッセージ</li>
<li>より少ない型制約。思い浮かぶのは <code>MonadUnliftIO m</code> みたいな</li>
<li>内部で、型族周りの汚い部分をかなりシンプルにできる。</li>
</ul>
<p>ヘルパー型シノニムを導入すれば、多くの後方互換性を得ることができます:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">type</span> <span class="dt">HandlerT</span> site m <span class="fu">=</span> <span class="dt">HandlerFor</span> site</a></code></pre></div>
<p>さらに、Template Haskell によって生成された <code>Handler</code> という型シノニムを使っているなら、新しいバージョンの Yesod は正しいものを生成してくれるでしょう。全体として、これはほんの少しの改善です。この変更によって得られる利益と破壊のコストを天秤にかける必要があります。ただ、まだ折衷案が残っています。</p>
<h2 id="サブサイトを扱う-ええトランスフォーマーです">サブサイトを扱う (ええ、トランスフォーマーです)</h2>
<p>私は 2回嘘をつきました: さっきのブランチはトランスフォーマーを使っています。そして <code>HandlerT</code> は <code>HandlerFor</code> よりも一般的です。いずれの場合もサブサイトをどうにかする必要がありますが、これは歴史的に苦痛を伴う作業です (使う分にはひどすぎることもないです)。実は、今日 <code>HandlerT</code> が存在する唯一の理由に、サブサイトを綺麗に層に分けるやり方で実装しようとした、というものがあります (失敗しましたが)。Yesod を長く使っている人は <code>GHandler</code> という前回のアプローチを覚えているかもしれません。そして、サブサイトを書いたことがあって <code>defaultLayout</code> を使う時に起こる地獄を知っている人は、現在の状況は良くないということに同意してくれると思います。</p>
<p>なので、問題を全て解決するため: サブサイトを書く時、ほとんど全てが普通の handler のコードを書くのと同じです。以下の点が違いますが:</p>
<ul>
<li><code>getYesod</code> を呼ぶ時、マスターサイトの app データを受け取る (例えば、スキャフォールドサイトの <code>App</code>)。サブサイトのデータを入手する方法も必要になります (例えば、<code>yesod-static</code> の <code>Static</code> という値)。</li>
<li><code>getCurrentRoute</code> を呼ぶと、マスターサイトのルートを返してくれます。例えば、<code>yesod-auth</code> の中にいる時、親サイトの取りうる全てのルートを扱いたくはないでしょう。その代わりに、サブサイト自身のルートを知りたいはずです。</li>
<li>URL を生成する時、サブサイトのルートを親サイトのルートに変換する手段が必要になります。</li>
</ul>
<p>今日の Yesod では、これらの違いを <code>HandlerT</code> の中で提供しています。こうすると、ベースケースの <code>m</code> を <code>IO</code> にする時に、やけに複雑になります。その代わりに、新しいブランチでは <code>HandlerFor</code> の上に <code>ReaderT</code> 1層を置き、これら 3つの機能を提供しています。詳しく知りたい方は<a href="https://github.com/yesodweb/yesod/blob/3e06942449cad0b52e218cb7e9f2c06b45b85e69/yesod-core/Yesod/Core/Class/Dispatch.hs#L38">コードを見てください</a>。</p>
<h2 id="何をすべきか">何をすべきか?</h2>
<p>全体的に、私はこの設計をエレガントで、理解しやすく、コードを綺麗にしてくれるものだと思っています。現実問題、昔のものから大きく離れたわけでも大きく改善されたわけでもありませんし、私はトランスフォーマーを無くすような変更の道半ばで進めなくなっています。</p>
<p>近い将来、Yesod には破壊的変更が行われますが、必ずしもこの変更を含む必要はありません。もしこの変更が追加されないのなら、破壊的変更は上で言及した、かなりマイナーなものになるでしょう。この変更が好ましいという一般のコンセンサスが得られたなら、同時に追加した方がいいでしょうね。</p>]]></summary>
</entry>
<entry>
    <title>最近遭遇した stack build 時の ld (pthread, -fPIC) エラー</title>
    <link href="https://haskell.e-bigmoon.com/posts/2018-01-06-stack-ld-errors.html" />
    <id>https://haskell.e-bigmoon.com/posts/2018-01-06-stack-ld-errors.html</id>
    <published>2018-01-06T00:00:00Z</published>
    <updated>2018-01-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>ここ最近、プロジェクトのビルド時に謎のエラーが発生するようになりました。</p>
<p>以下の2種類のエラーに遭遇したので、今後のために記録しておきます。</p>
<ul>
<li><code>pthread link error</code></li>
<li><code>-fPIC error</code></li>
</ul>
<pre class="shell"><code>$ stack --version
Version 1.7.0, Git revision 19e3460496f8fd2c462fb35a5825301e5c3c4eb0 (5527 commits) x86_64 hpack-0.20.0</code></pre>
<!--more-->
<h2 id="pthread-link-error">pthread link error</h2>
<p>このエラーは <code>Hakyll</code> を利用しているサイトをビルドしている時に発生したものです。</p>
<p>関連する <code>issue</code> は以下の通りです。</p>
<ul>
<li><a href="https://github.com/jgm/pandoc/issues/4130">pthread link errors on linux with GHC 8.2 #4130</a></li>
<li><a href="https://github.com/jgm/pandoc-citeproc/issues/311">Error building on Ubuntu 16 #311</a></li>
</ul>
<p><code>issue</code> に掲載されているエラーメッセージですが、以下のように <code>pthread</code> 系のエラーが表示され、結果として <code>gcc failed in phase Linker. (Exit code: 1)</code> となります。</p>
<pre class="shell"><code>    Linking .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/pandoc-citeproc/pandoc-citeproc ...

    /tmp/stack11451/pandoc-citeproc-0.12.1.1/rts/posix/OSThreads.c:137:0: error:
         error: undefined reference to &#39;pthread_create&#39;

    /tmp/stack11451/pandoc-citeproc-0.12.1.1/rts/posix/OSThreads.c:139:0: error:
         error: undefined reference to &#39;pthread_detach&#39;

    /tmp/stack11451/pandoc-citeproc-0.12.1.1/rts/posix/OSThreads.c:141:0: error:
         error: undefined reference to &#39;pthread_setname_np&#39;

    /tmp/stack11451/pandoc-citeproc-0.12.1.1/rts/posix/OSThreads.c:184:0: error:
         error: undefined reference to &#39;pthread_key_create&#39;

    /tmp/stack11451/pandoc-citeproc-0.12.1.1/rts/posix/OSThreads.c:192:0: error:
         error: undefined reference to &#39;pthread_getspecific&#39;

    /tmp/stack11451/pandoc-citeproc-0.12.1.1/rts/posix/OSThreads.c:203:0: error:
         error: undefined reference to &#39;pthread_setspecific&#39;

    /tmp/stack11451/pandoc-citeproc-0.12.1.1/rts/posix/OSThreads.c:212:0: error:
         error: undefined reference to &#39;pthread_key_delete&#39;

    /tmp/stack11451/pandoc-citeproc-0.12.1.1/rts/posix/OSThreads.c:371:0: error:
         error: undefined reference to &#39;pthread_kill&#39;

    /tmp/stack11451/pandoc-citeproc-0.12.1.1/includes/rts/OSThreads.h:59:0: error:
         error: undefined reference to &#39;pthread_mutex_trylock&#39;
    collect2: error: ld returned 1 exit status
    `gcc&#39; failed in phase `Linker&#39;. (Exit code: 1)</code></pre>
<p>修正方法は簡単で <code>package.yaml</code> や <code>cabal</code> ファイルの <code>ghc-options</code> に <code>-threaded</code> を追記するだけです。</p>
<p>具体的にはこんな感じで修正しました。</p>
<ul>
<li><a href="https://github.com/jaspervdj/hakyll/pull/601/files">Added -threaded to ghc-options. pthread link errors on linux with GHC 8.2 #601</a></li>
</ul>
<p>なぜこのエラーが発生したのかはわからないのですが <code>lts-10</code> 系にしたタイミングで遭遇しました。</p>
<h2 id="fpic-error">-fPIC error</h2>
<p><code>Mac</code> では確認できなかったのですが <code>Ubuntu 17.10</code> で以下のエラーに遭遇しました。</p>
<pre class="shell"><code>    /usr/bin/ld: /home/bm12/.stack/programs/x86_64-linux/ghc-8.0.2/lib/ghc-8.0.2/rts/libHSrts_thr.a(Arena.thr_o): relocation R_X86_64_32 against .rodata.str1.1 can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。
    /usr/bin/ld: /home/bm12/.stack/programs/x86_64-linux/ghc-8.0.2/lib/ghc-8.0.2/rts/libCffi.a(closures.o): relocation R_X86_64_32 against .rodata can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。
    /usr/bin/ld: /home/bm12/.stack/programs/x86_64-linux/ghc-8.0.2/lib/ghc-8.0.2/rts/libCffi.a(ffi64.o): relocation R_X86_64_32S against .rodata can not be used when making a shared object。 -fPIC を付けて再コンパイルしてください。
    /usr/bin/ld: 最終リンクに失敗しました: 出力に対応するセクションがありません
    collect2: error: ld returned 1 exit status
    gcc failed in phase Linker. (Exit code: 1)</code></pre>
<p><code>stack</code> の <code>issue</code> でも話題になってました。</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/issues/3518">Stack 1.6 linking issues on Arch Linux #3518</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/2712">Linker error makes it impossible to use a stack-provided ghc #2712</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/3630">Benchmarks can no longer be built with Stack 1.6.1 #3630</a></li>
<li><a href="https://github.com/commercialhaskell/stack/issues/3648">ghc-tinfo6-nopie-8.2.2 requires changes to its settings file to work on Arch Linux #3648</a></li>
</ul>
<p>解決策がまとまり <code>faq</code> に追加されたので、同じエラーで悩んでいる人は一度ご確認ください。</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/pull/3725">faq update: ld errors about recompiling with -fPIC #3725</a></li>
</ul>
<p>解決方法がとても簡単で、以下のコマンドを実行して <code>ghc</code> を再インストールするだけです。</p>
<pre class="shell"><code>$ stack setup --reinstall</code></pre>
<h2 id="まとめ">まとめ</h2>
<p>突然ビルドできなくなることもあるんですね・・・。</p>]]></summary>
</entry>
<entry>
    <title>travis-ci の初回ビルドで OUT OF MEMORY が出た時の対処法</title>
    <link href="https://haskell.e-bigmoon.com/posts/2017-12-31-travis-out-of-memory.html" />
    <id>https://haskell.e-bigmoon.com/posts/2017-12-31-travis-out-of-memory.html</id>
    <published>2017-12-31T00:00:00Z</published>
    <updated>2017-12-31T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p><code>travis-ci</code> の初回ビルド時に以下のようなエラーメッセージが表示されてビルドに失敗してしまうことがあります。</p>
<pre class="shell"><code>The command &quot;stack --no-terminal test --only-dependencies&quot; failed and exited with 1 during .

Your build has been stopped.</code></pre>
<p>結論から言えば、初回ビルド時はキャッシュが働かないため、多くの依存関係をビルドする必要があり、その過程でメモリ不足になってしまっていました。</p>
<p>この問題をどうすれば解決できるか、メモ程度に残しておこうと思います。</p>
<!--more-->
<h2 id="travis.yml">.travis.yml</h2>
<p>今回は以下のような <code>.travis.yml</code> を用意しました。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">{</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="fu">&quot;sudo&quot;:</span><span class="at"> false</span><span class="kw">,</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  <span class="fu">&quot;language&quot;:</span><span class="at"> </span><span class="st">&quot;generic&quot;</span><span class="er">,</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  <span class="fu">&quot;cache&quot;:</span><span class="at"> </span><span class="kw">{</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    <span class="fu">&quot;directories&quot;:</span><span class="at"> </span><span class="kw">[</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">      <span class="st">&quot;$HOME/.stack/&quot;</span><span class="kw">,</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">      <span class="st">&quot;$HOME/.local/bin/&quot;</span><span class="kw">,</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">      <span class="st">&quot;.stack-work/&quot;</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">    <span class="kw">]</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  <span class="kw">}</span><span class="at">,</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">  <span class="fu">&quot;before_install&quot;:</span><span class="at"> </span><span class="kw">[</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">    <span class="st">&quot;mkdir -p ~/.local/bin&quot;</span><span class="kw">,</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13">    <span class="st">&quot;export PATH=$HOME/.local/bin:$PATH&quot;</span><span class="kw">,</span></a>
<a class="sourceLine" id="cb2-14" data-line-number="14">    <span class="st">&quot;travis_retry curl -L https://www.stackage.org/stack/linux-x86_64 | tar xz --wildcards --strip-components=1 -C ~/.local/bin &#39;*/stack&#39;&quot;</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15">  <span class="kw">]</span><span class="at">,</span></a>
<a class="sourceLine" id="cb2-16" data-line-number="16">  <span class="fu">&quot;install&quot;:</span><span class="at"> </span><span class="kw">[</span></a>
<a class="sourceLine" id="cb2-17" data-line-number="17">    <span class="st">&quot;stack --no-terminal test --only-dependencies&quot;</span></a>
<a class="sourceLine" id="cb2-18" data-line-number="18">  <span class="kw">]</span><span class="at">,</span></a>
<a class="sourceLine" id="cb2-19" data-line-number="19">  <span class="fu">&quot;group&quot;:</span><span class="at"> </span><span class="st">&quot;stable&quot;</span><span class="er">,</span></a>
<a class="sourceLine" id="cb2-20" data-line-number="20">  <span class="fu">&quot;dist&quot;:</span><span class="at"> </span><span class="st">&quot;trusty&quot;</span><span class="er">,</span></a>
<a class="sourceLine" id="cb2-21" data-line-number="21">  <span class="fu">&quot;os&quot;:</span><span class="at"> </span><span class="st">&quot;linux&quot;</span></a>
<a class="sourceLine" id="cb2-22" data-line-number="22">}</a></code></pre></div>
<p>問題の行は <code>stack --no-terminal test --only-dependencies</code> です。</p>
<p>この記述は<a href="https://github.com/commercialhaskell/stack/blob/master/doc/travis_ci.md">公式ドキュメント</a>の<a href="https://raw.githubusercontent.com/commercialhaskell/stack/stable/doc/travis-simple.yml">The simple Travis configuration</a> として紹介されています。</p>
<p>基本的には特に気にしなくても良いのですが <code>Hakyll</code> などの依存関係が多いプロジェクトでは <code>OUT OF MEMORY</code> が発生することがあります。</p>
<h2 id="エラーメッセージ">エラーメッセージ</h2>
<ul>
<li>実際の<a href="https://travis-ci.org/wataru86/haskell-blog/builds/323115071">ログ</a></li>
</ul>
<p>ちょっと長いですが、エラー部分のログを載せます。</p>
<pre class="shell"><code>regex-tdfa-1.2.2: copy/register
aeson-1.2.3.0: copy/register
JuicyPixels-3.2.9.1: copy/register
--  While building custom Setup.hs for package Cabal-2.0.1.1 using:
      /home/travis/.stack/setup-exe-cache/x86_64-linux/Cabal-simple_mPHDZzAJ_2.0.1.0_ghc-8.2.2 --builddir=.stack-work/dist/x86_64-linux/Cabal-2.0.1.0 build --ghc-options &quot; -ddump-hi -ddump-to-file -fdiagnostics-color=always&quot;
    Process exited with code: ExitFailure (-9) (THIS MAY INDICATE OUT OF MEMORY)
    Logs have been written to: /home/travis/build/wataru86/haskell-blog/.stack-work/logs/Cabal-2.0.1.1.log
    Configuring Cabal-2.0.1.1...
    Preprocessing library for Cabal-2.0.1.1..
    Building library for Cabal-2.0.1.1..
    [  1 of 168] Compiling Distribution.Compat.Binary ( Distribution/Compat/Binary.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Compat/Binary.o )
    [  2 of 168] Compiling Distribution.Compat.Exception ( Distribution/Compat/Exception.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Compat/Exception.o )
    [  3 of 168] Compiling Distribution.Compat.Internal.TempFile ( Distribution/Compat/Internal/TempFile.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Compat/Internal/TempFile.o )
    [  4 of 168] Compiling Distribution.Compat.Map.Strict ( Distribution/Compat/Map/Strict.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Compat/Map/Strict.o )
    [  5 of 168] Compiling Distribution.Compat.MonadFail ( Distribution/Compat/MonadFail.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Compat/MonadFail.o )
    [  6 of 168] Compiling Distribution.Compat.Semigroup ( Distribution/Compat/Semigroup.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Compat/Semigroup.o )
    [  7 of 168] Compiling Distribution.Compat.Stack ( Distribution/Compat/Stack.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Compat/Stack.o )
    [  8 of 168] Compiling Distribution.Compat.Prelude ( Distribution/Compat/Prelude.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Compat/Prelude.o )
    [  9 of 168] Compiling Distribution.Compat.SnocList ( Distribution/Compat/SnocList.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Compat/SnocList.o )
    [ 10 of 168] Compiling Distribution.Compat.ReadP ( Distribution/Compat/ReadP.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Compat/ReadP.o )
    [ 11 of 168] Compiling Distribution.Compat.Prelude.Internal ( Distribution/Compat/Prelude/Internal.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Compat/Prelude/Internal.o )
    [ 12 of 168] Compiling Distribution.Compat.Graph ( Distribution/Compat/Graph.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Compat/Graph.o )
    [ 13 of 168] Compiling Distribution.Compat.GetShortPathName ( Distribution/Compat/GetShortPathName.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Compat/GetShortPathName.o )
    [ 14 of 168] Compiling Distribution.Compat.DList ( Distribution/Compat/DList.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Compat/DList.o )
    [ 15 of 168] Compiling Distribution.Compat.CopyFile ( Distribution/Compat/CopyFile.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Compat/CopyFile.o )
    [ 16 of 168] Compiling Distribution.Compat.Environment ( Distribution/Compat/Environment.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Compat/Environment.o )
    [ 17 of 168] Compiling Distribution.Compat.CreatePipe ( Distribution/Compat/CreatePipe.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Compat/CreatePipe.o )
    [ 18 of 168] Compiling Distribution.GetOpt ( Distribution/GetOpt.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/GetOpt.o )
    [ 19 of 168] Compiling Distribution.Lex ( Distribution/Lex.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Lex.o )
    [ 20 of 168] Compiling Distribution.PackageDescription.Utils ( Distribution/PackageDescription/Utils.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/PackageDescription/Utils.o )
    [ 21 of 168] Compiling Distribution.ReadE ( Distribution/ReadE.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/ReadE.o )
    [ 22 of 168] Compiling Distribution.Simple.CCompiler ( Distribution/Simple/CCompiler.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Simple/CCompiler.o )
    [ 23 of 168] Compiling Distribution.Simple.PreProcess.Unlit ( Distribution/Simple/PreProcess/Unlit.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Simple/PreProcess/Unlit.o )
    [ 24 of 168] Compiling Distribution.Simple.Program.Internal ( Distribution/Simple/Program/Internal.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Simple/Program/Internal.o )
    [ 25 of 168] Compiling Distribution.TestSuite ( Distribution/TestSuite.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/TestSuite.o )
    [ 26 of 168] Compiling Distribution.Text ( Distribution/Text.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Text.o )
    [ 27 of 168] Compiling Distribution.System ( Distribution/System.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/System.o )
    [ 28 of 168] Compiling Distribution.Types.BuildType ( Distribution/Types/BuildType.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/BuildType.o )
    [ 29 of 168] Compiling Distribution.Types.Condition ( Distribution/Types/Condition.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/Condition.o )
    [ 30 of 168] Compiling Distribution.Types.CondTree ( Distribution/Types/CondTree.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/CondTree.o )
    [ 31 of 168] Compiling Distribution.Types.ExecutableScope ( Distribution/Types/ExecutableScope.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/ExecutableScope.o )
    [ 32 of 168] Compiling Distribution.Types.ForeignLibOption ( Distribution/Types/ForeignLibOption.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/ForeignLibOption.o )
    [ 33 of 168] Compiling Distribution.Types.ForeignLibType ( Distribution/Types/ForeignLibType.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/ForeignLibType.o )
    [ 34 of 168] Compiling Distribution.Types.SourceRepo ( Distribution/Types/SourceRepo.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/SourceRepo.o )
    [ 35 of 168] Compiling Distribution.Utils.Base62 ( Distribution/Utils/Base62.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Utils/Base62.o )
    [ 36 of 168] Compiling Distribution.Utils.MapAccum ( Distribution/Utils/MapAccum.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Utils/MapAccum.o )
    [ 37 of 168] Compiling Distribution.Utils.Progress ( Distribution/Utils/Progress.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Utils/Progress.o )
    [ 38 of 168] Compiling Distribution.Utils.String ( Distribution/Utils/String.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Utils/String.o )
    [ 39 of 168] Compiling Distribution.Utils.ShortText ( Distribution/Utils/ShortText.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Utils/ShortText.o )
    [ 40 of 168] Compiling Distribution.Types.PkgconfigName ( Distribution/Types/PkgconfigName.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/PkgconfigName.o )
    [ 41 of 168] Compiling Distribution.Types.ComponentId ( Distribution/Types/ComponentId.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/ComponentId.o )
    [ 42 of 168] Compiling Distribution.Types.AbiHash ( Distribution/Types/AbiHash.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/AbiHash.o )
    [ 43 of 168] Compiling Distribution.ModuleName ( Distribution/ModuleName.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/ModuleName.o )
    [ 44 of 168] Compiling Distribution.Types.ModuleRenaming ( Distribution/Types/ModuleRenaming.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/ModuleRenaming.o )
    [ 45 of 168] Compiling Distribution.Types.IncludeRenaming ( Distribution/Types/IncludeRenaming.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/IncludeRenaming.o )
    [ 46 of 168] Compiling Distribution.Utils.Generic ( Distribution/Utils/Generic.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Utils/Generic.o )
    [ 47 of 168] Compiling Distribution.Utils.UnionFind ( Distribution/Utils/UnionFind.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Utils/UnionFind.o )
    [ 48 of 168] Compiling Distribution.Verbosity ( Distribution/Verbosity.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Verbosity.o )
    [ 49 of 168] Compiling Distribution.Version ( Distribution/Version.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Version.o )
    [ 50 of 168] Compiling Distribution.Types.TestType ( Distribution/Types/TestType.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/TestType.o )
    [ 51 of 168] Compiling Distribution.Types.TestSuiteInterface ( Distribution/Types/TestSuiteInterface.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/TestSuiteInterface.o )
    [ 52 of 168] Compiling Distribution.Types.PkgconfigDependency ( Distribution/Types/PkgconfigDependency.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/PkgconfigDependency.o )
    [ 53 of 168] Compiling Distribution.Types.BenchmarkType ( Distribution/Types/BenchmarkType.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/BenchmarkType.o )
    [ 54 of 168] Compiling Distribution.Types.BenchmarkInterface ( Distribution/Types/BenchmarkInterface.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/BenchmarkInterface.o )
    [ 55 of 168] Compiling Distribution.License ( Distribution/License.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/License.o )
    [ 56 of 168] Compiling Language.Haskell.Extension ( Language/Haskell/Extension.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Language/Haskell/Extension.o )
    [ 57 of 168] Compiling Distribution.Compiler ( Distribution/Compiler.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Compiler.o )
    [ 58 of 168] Compiling Distribution.PrettyUtils ( Distribution/PrettyUtils.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/PrettyUtils.o )
    [ 59 of 168] Compiling Distribution.ParseUtils ( Distribution/ParseUtils.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/ParseUtils.o )
    [ 60 of 168] Compiling Distribution.Types.PackageName ( Distribution/Types/PackageName.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/PackageName.o )
    [ 61 of 168] Compiling Distribution.Types.UnqualComponentName ( Distribution/Types/UnqualComponentName.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/UnqualComponentName.o )
    [ 62 of 168] Compiling Distribution.Types.ComponentName ( Distribution/Types/ComponentName.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/ComponentName.o )
    [ 63 of 168] Compiling Distribution.Types.PackageId ( Distribution/Types/PackageId.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/PackageId.o )
    [ 64 of 168] Compiling Distribution.Types.UnitId ( Distribution/Types/UnitId.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/UnitId.o )
    [ 65 of 168] Compiling Distribution.Types.Module ( Distribution/Types/Module.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/Module.o )
    [ 66 of 168] Compiling Distribution.Backpack ( Distribution/Backpack.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Backpack.o )
    [ 67 of 168] Compiling Distribution.Backpack.ModSubst ( Distribution/Backpack/ModSubst.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Backpack/ModSubst.o )
    [ 68 of 168] Compiling Distribution.Backpack.FullUnitId ( Distribution/Backpack/FullUnitId.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Backpack/FullUnitId.o )
    [ 69 of 168] Compiling Distribution.Types.ModuleReexport ( Distribution/Types/ModuleReexport.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/ModuleReexport.o )
    [ 70 of 168] Compiling Distribution.Types.Mixin ( Distribution/Types/Mixin.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/Mixin.o )
    [ 71 of 168] Compiling Distribution.Types.ExeDependency ( Distribution/Types/ExeDependency.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/ExeDependency.o )
    [ 72 of 168] Compiling Distribution.Types.Dependency ( Distribution/Types/Dependency.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/Dependency.o )
    [ 73 of 168] Compiling Distribution.Types.SetupBuildInfo ( Distribution/Types/SetupBuildInfo.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/SetupBuildInfo.o )
    [ 74 of 168] Compiling Distribution.Types.DependencyMap ( Distribution/Types/DependencyMap.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/DependencyMap.o )
    [ 75 of 168] Compiling Distribution.Simple.GHC.IPIConvert ( Distribution/Simple/GHC/IPIConvert.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Simple/GHC/IPIConvert.o )
    [ 76 of 168] Compiling Distribution.Backpack.ModuleScope ( Distribution/Backpack/ModuleScope.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Backpack/ModuleScope.o )
    [ 77 of 168] Compiling Distribution.Types.MungedPackageName ( Distribution/Types/MungedPackageName.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/MungedPackageName.o )
    [ 78 of 168] Compiling Distribution.Types.MungedPackageId ( Distribution/Types/MungedPackageId.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/MungedPackageId.o )
    [ 79 of 168] Compiling Distribution.Package ( Distribution/Package.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Package.o )
    [ 80 of 168] Compiling Distribution.Types.AnnotatedId ( Distribution/Types/AnnotatedId.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/AnnotatedId.o )
    [ 81 of 168] Compiling Distribution.Types.ComponentInclude ( Distribution/Types/ComponentInclude.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/ComponentInclude.o )
    [ 82 of 168] Compiling Distribution.Simple.InstallDirs ( Distribution/Simple/InstallDirs.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Simple/InstallDirs.o )
    [ 83 of 168] Compiling Distribution.Types.LegacyExeDependency ( Distribution/Types/LegacyExeDependency.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/LegacyExeDependency.o )
    [ 84 of 168] Compiling Distribution.Types.BuildInfo ( Distribution/Types/BuildInfo.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/BuildInfo.o )
    [ 85 of 168] Compiling Distribution.Types.TestSuite ( Distribution/Types/TestSuite.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/TestSuite.o )
    [ 86 of 168] Compiling Distribution.Types.Library ( Distribution/Types/Library.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/Library.o )
    [ 87 of 168] Compiling Distribution.Types.HookedBuildInfo ( Distribution/Types/HookedBuildInfo.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/HookedBuildInfo.o )
    [ 88 of 168] Compiling Distribution.Types.ForeignLib ( Distribution/Types/ForeignLib.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/ForeignLib.o )
    [ 89 of 168] Compiling Distribution.Types.Executable ( Distribution/Types/Executable.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/Executable.o )
    [ 90 of 168] Compiling Distribution.Types.Benchmark ( Distribution/Types/Benchmark.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/Benchmark.o )
    [ 91 of 168] Compiling Distribution.Types.Component ( Distribution/Types/Component.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/Component.o )
    [ 92 of 168] Compiling Distribution.Types.ComponentRequestedSpec ( Distribution/Types/ComponentRequestedSpec.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/ComponentRequestedSpec.o )
    [ 93 of 168] Compiling Distribution.Types.PackageDescription ( Distribution/Types/PackageDescription.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/PackageDescription.o )
    [ 94 of 168] Compiling Distribution.Types.GenericPackageDescription ( Distribution/Types/GenericPackageDescription.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/GenericPackageDescription.o )
    [ 95 of 168] Compiling Distribution.PackageDescription ( Distribution/PackageDescription.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/PackageDescription.o )
    [ 96 of 168] Compiling Distribution.Simple.BuildToolDepends ( Distribution/Simple/BuildToolDepends.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Simple/BuildToolDepends.o )
    [ 97 of 168] Compiling Distribution.InstalledPackageInfo ( Distribution/InstalledPackageInfo.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/InstalledPackageInfo.o )
    [ 98 of 168] Compiling Distribution.Types.ComponentLocalBuildInfo ( Distribution/Types/ComponentLocalBuildInfo.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/ComponentLocalBuildInfo.o )
    [ 99 of 168] Compiling Distribution.Types.TargetInfo ( Distribution/Types/TargetInfo.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Types/TargetInfo.o )
    [100 of 168] Compiling Distribution.Simple.GHC.IPI642 ( Distribution/Simple/GHC/IPI642.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Simple/GHC/IPI642.o )
    [101 of 168] Compiling Distribution.Backpack.ModuleShape ( Distribution/Backpack/ModuleShape.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Backpack/ModuleShape.o )
    [102 of 168] Compiling Distribution.Backpack.UnifyM ( Distribution/Backpack/UnifyM.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Backpack/UnifyM.o )
    [103 of 168] Compiling Distribution.Backpack.MixLink ( Distribution/Backpack/MixLink.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Backpack/MixLink.o )
    [104 of 168] Compiling Distribution.Backpack.PreExistingComponent ( Distribution/Backpack/PreExistingComponent.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Backpack/PreExistingComponent.o )
    [105 of 168] Compiling Paths_Cabal      ( .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/autogen/Paths_Cabal.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Paths_Cabal.o )
    [106 of 168] Compiling Distribution.Simple.Utils ( Distribution/Simple/Utils.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Simple/Utils.o )
    [107 of 168] Compiling Distribution.Utils.NubList ( Distribution/Utils/NubList.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Utils/NubList.o )
    [108 of 168] Compiling Distribution.Utils.LogProgress ( Distribution/Utils/LogProgress.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Utils/LogProgress.o )
    [109 of 168] Compiling Distribution.Simple.Program.Find ( Distribution/Simple/Program/Find.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Simple/Program/Find.o )
    [110 of 168] Compiling Distribution.Simple.Program.Types ( Distribution/Simple/Program/Types.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Simple/Program/Types.o )
    [111 of 168] Compiling Distribution.Simple.Program.Run ( Distribution/Simple/Program/Run.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Simple/Program/Run.o )
    [112 of 168] Compiling Distribution.Simple.Program.Script ( Distribution/Simple/Program/Script.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Simple/Program/Script.o )
    [113 of 168] Compiling Distribution.Simple.Program.Ld ( Distribution/Simple/Program/Ld.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Simple/Program/Ld.o )
    [114 of 168] Compiling Distribution.Simple.Program.Hpc ( Distribution/Simple/Program/Hpc.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Simple/Program/Hpc.o )
    [115 of 168] Compiling Distribution.Simple.Program.Builtin ( Distribution/Simple/Program/Builtin.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Simple/Program/Builtin.o )
    [116 of 168] Compiling Distribution.Simple.Program.Db ( Distribution/Simple/Program/Db.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Simple/Program/Db.o )
    [117 of 168] Compiling Distribution.Simple.Program ( Distribution/Simple/Program.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Simple/Program.o )
    [118 of 168] Compiling Distribution.Simple.Program.Strip ( Distribution/Simple/Program/Strip.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Simple/Program/Strip.o )
    [119 of 168] Compiling Distribution.Simple.PackageIndex ( Distribution/Simple/PackageIndex.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Simple/PackageIndex.o )
    [120 of 168] Compiling Distribution.Simple.Compiler ( Distribution/Simple/Compiler.hs, .stack-work/dist/x86_64-linux/Cabal-2.0.1.0/build/Distribution/Simple/Compiler.o )
The command &quot;stack --no-terminal build --only-dependencies&quot; failed and exited with 1 during .
Your build has been stopped.</code></pre>
<p>これ、一瞬見ただけだと良くわからないのですが、注目するのは以下の部分です。</p>
<pre class="shell"><code>While building custom Setup.hs for package Cabal-2.0.1.1 using:
      /home/travis/.stack/setup-exe-cache/x86_64-linux/Cabal-simple_mPHDZzAJ_2.0.1.0_ghc-8.2.2 --builddir=.stack-work/dist/x86_64-linux/Cabal-2.0.1.0 build --ghc-options &quot; -ddump-hi -ddump-to-file -fdiagnostics-color=always&quot;
    Process exited with code: ExitFailure (-9) (THIS MAY INDICATE OUT OF MEMORY)</code></pre>
<p>以下の2点が今回のエラーに対処するために必要な情報になります。</p>
<ul>
<li><code>While building custom Setup.hs for package Cabal-2.0.1.1 using</code></li>
<li><code>ExitFailure (-9) (THIS MAY INDICATE OUT OF MEMORY)</code></li>
</ul>
<h2 id="解決策その1--j-1-オプションを利用する">解決策その1 -j 1 オプションを利用する</h2>
<p><code>stack build</code> 時に <code>-j 1</code> オプションを指定することで並列ビルドを抑制することができます。(<code>stack</code> はデフォルトで並列ビルドが有効になってます)</p>
<pre class="shell"><code>$ stack --no-terminal build --only-dependencies -j 1</code></pre>
<p>この方法で解決することもできますが、ビルド時間が増大するというデメリットもあります。</p>
<p>そうすると <code>travis-ci</code> の <code>50分制限</code> にひっかかり、やはりビルドが失敗してしまうのです。こんな感じのエラーが出ます。</p>
<pre class="shell"><code>The job exceeded the maximum time limit for jobs, and has been terminated.</code></pre>
<h2 id="解決策その2-問題のパッケージのみ先にビルドする">解決策その2 問題のパッケージのみ先にビルドする</h2>
<p>過去に同じような <code>issue</code> (<a href="https://github.com/commercialhaskell/stack/issues/859">Building with stack on Travis CI - dependency compilation fails sometimes #859</a>) が立っており、そこに解決策がありました。</p>
<p><code>-j 1</code> を全体に適用するとビルド時間がかかりすぎてしまうので、問題のパッケージのみ <code>-j 1</code> でビルドするという方法です。</p>
<p>先程のエラーメッセージから問題のパッケージを特定することができます。</p>
<pre class="shell"><code>While building custom Setup.hs for package Cabal-2.0.1.1 using</code></pre>
<p>上記メッセージを読むと、悪いのは <code>Cabal</code> だということがわかります。</p>
<p>そのため、以下のように <code>.travis.yml</code> の設定を変更します。</p>
<pre class="shell"><code>stack --no-terminal build -j 1 Cabal
stack --no-terminal test --only-dependencies</code></pre>
<p>この時に <code>stack --no-terminal build -j 1 Cabal --only-dependencies</code> としてしまうとパッケージはビルドされないのでご注意ください。</p>
<p><code>.travis.yml</code> 全体はこうなります。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">{</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  <span class="fu">&quot;sudo&quot;:</span><span class="at"> false</span><span class="kw">,</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="fu">&quot;language&quot;:</span><span class="at"> </span><span class="st">&quot;generic&quot;</span><span class="er">,</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  <span class="fu">&quot;cache&quot;:</span><span class="at"> </span><span class="kw">{</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    <span class="fu">&quot;directories&quot;:</span><span class="at"> </span><span class="kw">[</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">      <span class="st">&quot;$HOME/.stack/&quot;</span><span class="kw">,</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">      <span class="st">&quot;$HOME/.local/bin/&quot;</span><span class="kw">,</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">      <span class="st">&quot;.stack-work/&quot;</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">    <span class="kw">]</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">  <span class="kw">}</span><span class="at">,</span></a>
<a class="sourceLine" id="cb9-11" data-line-number="11">  <span class="fu">&quot;before_install&quot;:</span><span class="at"> </span><span class="kw">[</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12">    <span class="st">&quot;mkdir -p ~/.local/bin&quot;</span><span class="kw">,</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13">    <span class="st">&quot;export PATH=$HOME/.local/bin:$PATH&quot;</span><span class="kw">,</span></a>
<a class="sourceLine" id="cb9-14" data-line-number="14">    <span class="st">&quot;travis_retry curl -L https://www.stackage.org/stack/linux-x86_64 | tar xz --wildcards --strip-components=1 -C ~/.local/bin &#39;*/stack&#39;&quot;</span></a>
<a class="sourceLine" id="cb9-15" data-line-number="15">  <span class="kw">]</span><span class="at">,</span></a>
<a class="sourceLine" id="cb9-16" data-line-number="16">  <span class="fu">&quot;install&quot;:</span><span class="at"> </span><span class="kw">[</span></a>
<a class="sourceLine" id="cb9-17" data-line-number="17">    <span class="st">&quot;stack --no-terminal build -j 1 Cabal&quot;</span><span class="kw">,</span></a>
<a class="sourceLine" id="cb9-18" data-line-number="18">    <span class="st">&quot;stack --no-terminal test --only-dependencies&quot;</span></a>
<a class="sourceLine" id="cb9-19" data-line-number="19">  <span class="kw">]</span><span class="at">,</span></a>
<a class="sourceLine" id="cb9-20" data-line-number="20">  <span class="fu">&quot;group&quot;:</span><span class="at"> </span><span class="st">&quot;stable&quot;</span><span class="er">,</span></a>
<a class="sourceLine" id="cb9-21" data-line-number="21">  <span class="fu">&quot;dist&quot;:</span><span class="at"> </span><span class="st">&quot;trusty&quot;</span><span class="er">,</span></a>
<a class="sourceLine" id="cb9-22" data-line-number="22">  <span class="fu">&quot;os&quot;:</span><span class="at"> </span><span class="st">&quot;linux&quot;</span></a>
<a class="sourceLine" id="cb9-23" data-line-number="23">}</a></code></pre></div>
<h2 id="まとめ">まとめ</h2>
<p><code>travis</code> の <code>OUT OF MEMORY</code> エラーは噂には聞いていましたが、実際に自分が遭遇するのは初めてでした。</p>
<p>対処法としてはエラーの原因となるパッケージのみを <code>-j 1</code> オプションで先にビルドしてしまえば良いということがわかりました。</p>]]></summary>
</entry>
<entry>
    <title>Literate Markdown (markdown-unlit の使い方) について</title>
    <link href="https://haskell.e-bigmoon.com/posts/2017-12-29-Literate-Markdown.html" />
    <id>https://haskell.e-bigmoon.com/posts/2017-12-29-Literate-Markdown.html</id>
    <published>2017-12-29T00:00:00Z</published>
    <updated>2017-12-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>今回は <code>Literate Markdown</code> をご紹介します。(最近見つけて面白そうだったので使ってみました。)</p>
<p>モチベーションとしては <code>Bird</code> 記法や <code>TeX</code> 記法だけではなく、<code>Markdown</code> 記法も使いたいよね！という感じです。</p>
<p>また、<code>HaskelL</code> の文学的 (Literate) プログラミングについては、すでに多くのWeb・書籍等で言及されているため、必要最低限の説明に留めたいと思います。</p>
<p>本記事の内容は以下を参考としています。</p>
<ul>
<li><a href="https://www.haskell.org/definition/haskell2010.pdf">Haskell 2010 Language Report</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/LiterateMarkdown">Literate Markdown</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/FlexibleLiterateExtension">Flexible Literate Haskell File Extensions</a></li>
<li><a href="https://github.com/sol/markdown-unlit">sol/markdown-unlit</a></li>
</ul>
<!--more-->
<h2 id="文芸的プログラミング">文芸的プログラミング</h2>
<p>文芸的プログラミングは <code>GHC</code> 固有の機能ではなく <code>Haskell 2010</code> の仕様 (10.4 Literate comments) で規定されています。</p>
<p>また、拡張子は通常の <code>hs</code> ではなく <code>lhs</code> となります。</p>
<p>スタイルについては <code>Bird</code> 記法と <code>LaTeX</code> 記法があり、好きな方を使うと良いでしょう。</p>
<h3 id="bird-記法">Bird 記法</h3>
<p><code>Brid</code> 記法は先頭に <code>&gt;</code> を入れて表現するスタイルです。</p>
<p><code>&gt;</code> から始まる行が <code>Haskell</code> コードとして認識されます。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="dt">This</span> is a comment<span class="fu">.</span>  <span class="dt">Lines</span> starting with <span class="ch">&#39;&gt;&#39;</span> are the actual code<span class="fu">.</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="fu">&gt;</span> average xs <span class="fu">=</span> sum xs <span class="fu">/</span> length xs</a></code></pre></div>
<h3 id="latex-記法">LaTeX 記法</h3>
<p><code>LaTeX</code> 記法は通常の <code>LaTeX</code> のように <code>\begin{code} - \end{code}</code> のコードブロックで囲まれた部分を <code>Haskell</code> コードとして認識します。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="dt">This</span> is a comment<span class="fu">.</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">\begin{code}</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">average <span class="fu">=</span> sum xs <span class="fu">/</span> length xs</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">\end{code}</a></code></pre></div>
<h2 id="literate-markdown">Literate Markdown</h2>
<p><code>Literate Markdown</code> は2014年頃に議論があったようです。実装も<a href="https://github.com/elliottt/ghc/tree/literate-markdown">提案</a>されていたようですが、現状の <code>GHC</code> には組み込まれていません。</p>
<p>どうしようかなと思っていましたが、色々と調べた結果、<a href="https://github.com/sol/markdown-unlit">sol/markdown-unlit</a> という素晴らしいパッケージを見つけました。</p>
<p>このパッケージを利用することで当初の目的が達成できそうです！</p>
<h2 id="markdown-unlit">markdown-unlit</h2>
<h3 id="インストール">インストール</h3>
<p><code>version 0.5.0</code> を利用したかったので <code>--resolver=nightly</code> としました。</p>
<pre class="shell"><code>$ stack install markdown-unlit --resolver=nightly
$ which markdown-unlit
/home/bm12/.local/bin/markdown-unlit</code></pre>
<h3 id="実際に使ってみる">実際に使ってみる</h3>
<p>以下の内容を <code>test.lhs</code> というファイル名で保存しましょう。</p>
<div class="sourceCode">
<pre class="sourceCode markdown"><code class="sourceCode markdown hljs"># nifty-library: Do nifty things (effortlessly!)

Here is a basic example:

```haskell
main :: IO ()
main = putStrLn "That was easy!"
```
</code></pre>
</div>
<p>この時、拡張子は <code>.lhs</code> となることに注意してください。(<code>.md</code> としたい場合はシンボリックリンクを作成します)</p>
<p>では実行してみます。</p>
<pre class="shell"><code>$ stack ghci --ghc-options=&quot;-pgmL markdown-unlit&quot; test.lhs
[1 of 1] Compiling Main             ( /home/bm12/Desktop/test.lhs, interpreted )
Ok, modules loaded: Main.
Loaded GHCi configuration from /tmp/ghci19999/ghci-script
*Main&gt; main
That was easy!</code></pre>
<p>問題無さそうですね。これで <code>Literate Markdown</code> 形式のファイルを作成することができました。</p>
<p><code>-pgmL markdown-unlit</code> オプションは <code>.ghci</code> ファイルを設定することで省略可能です。</p>
<pre class="shell"><code>$ echo &#39;:set -pgmL markdown-unlit&#39; &gt;&gt; ~/.ghci</code></pre>
<p>もし、読み込み時に <code>*** WARNING: ~/.ghci is writable by someone else, IGNORING!</code> のようなエラーが出る場合は以下のようにして、ファイルのパーミッションを変更します。</p>
<pre class="shell"><code>$ chmod go-w ~/.ghci</code></pre>
<p>これで、基本的な使い方はわかりました。次に実際のプロジェクトにおいてどのように利用されているか確認してみたいと思います。</p>
<h2 id="stack-プロジェクトで-markdown-unlit-を使う">stack プロジェクトで markdown-unlit を使う</h2>
<p>より実践的な例として <code>markdown-unlit</code> を使ってプロジェクトの <code>README.md</code> を <code>Literate Markdown</code> 形式で記述してみましょう。</p>
<p>この手法は実際にいくつかのプロジェクトで利用されています。</p>
<ul>
<li><a href="https://github.com/yesodweb/wai/tree/master/wai#readme">yesodweb/wai</a></li>
<li><a href="https://github.com/tfausak/strive">tfausak/strive</a></li>
<li><a href="https://github.com/sol/attoparsec-parsec#readme">sol/attoparsec-parsec</a></li>
<li><a href="https://github.com/hspec/hspec-expectations#readme">hspec/hspec-expectations</a></li>
</ul>
<h3 id="準備">準備</h3>
<pre class="shell"><code>$ stack new literate-markdown
$ cd literate-markdown</code></pre>
<p><code>LTS-10.1</code> に含まれる <code>markdown-unlit</code> のバージョンは <code>0.4.1</code> ですが、最新版の <code>0.5.0</code> を使いたいので <code>resolver</code> に <code>nightly</code> を指定します。ついでに <code>package.yaml</code> に依存関係を追加しておきます。</p>
<p><code>stack.yaml</code> と <code>package.yaml</code> はそれぞれこんな感じです。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="fu">resolver:</span><span class="at"> nightly-2017-12-28</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="fu">packages:</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="kw">-</span> .</a></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="fu">name:</span><span class="at">                literate-markdown</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="fu">version:</span><span class="at">             0.1.0.0</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="fu">github:</span><span class="at">              </span><span class="st">&quot;waddlaw/literate-markdown&quot;</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="fu">extra-source-files:</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6"><span class="kw">-</span> README.md</a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="kw">-</span> ChangeLog.md</a>
<a class="sourceLine" id="cb9-8" data-line-number="8"></a>
<a class="sourceLine" id="cb9-9" data-line-number="9"><span class="fu">dependencies:</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10"><span class="kw">-</span> base &gt;= 4.7 &amp;&amp; &lt; 5</a>
<a class="sourceLine" id="cb9-11" data-line-number="11"><span class="kw">-</span> markdown-unlit</a></code></pre></div>
<p>とりあえず <code>stack build</code> しておきます。</p>
<pre class="shell"><code>$ stack build</code></pre>
<h3 id="markdown-unlit-の設定">markdown-unlit の設定</h3>
<p>まずは <code>package.yaml</code> に以下の内容を追記します。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="fu">ghc-options:</span><span class="at"> -pgmL markdown-unlit</span></a></code></pre></div>
<p>次に <code>README.md</code> の内容を以下のように変更します。</p>
<div class="sourceCode">
<pre class="sourceCode markdown"><code class="sourceCode markdown hljs"># nifty-library: Do nifty things (effortlessly!)

Here is a basic example:

```haskell
main :: IO ()
main = putStrLn "That was easy!"
```
</code></pre>
</div>
<p>ここが少し面倒ですが、シンボリックリンクを作成します。</p>
<pre class="shell"><code>$ ln -s README.md README.lhs</code></pre>
<h3 id="テストの設定">テストの設定</h3>
<p><code>package.yaml</code> にテストを追加しましょう。以下の内容を追記します。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="fu">tests:</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="fu">readme:</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    <span class="fu">main:</span><span class="at"> README.lhs</span></a></code></pre></div>
<p>これで <code>stack test</code> を実行してみましょう。</p>
<pre class="shell"><code>$ stack test
literate-markdown-0.1.0.0: test (suite: readme)

That was easy!

literate-markdown-0.1.0.0: Test suite readme passed</code></pre>
<p>ちゃんと <code>That was easy!</code> が表示されています。</p>
<h2 id="終わりに">終わりに</h2>
<ul>
<li><code>Haskell</code> で利用可能な文芸的プログラミングについて少しだけ解説しました</li>
<li><code>Markdown</code> 形式で文芸的プログラミングを行うための <code>markdown-unlit</code> について解説しました</li>
</ul>
<p>実際にいくつかのプロジェクトで利用されているように、<code>README.md</code> で <code>main</code> 関数を実行する例がある場合は、この方法を採用してみても良いのではないでしょうか。</p>
<p>本記事で利用したコード: <a href="https://github.com/waddlaw/example-literate-markdown">github</a></p>]]></summary>
</entry>
<entry>
    <title>haddock に Grid Table 記法が追加されました</title>
    <link href="https://haskell.e-bigmoon.com/posts/2017-12-27-haddock-grid-table.html" />
    <id>https://haskell.e-bigmoon.com/posts/2017-12-27-haddock-grid-table.html</id>
    <published>2017-12-27T00:00:00Z</published>
    <updated>2017-12-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<figure>
<img src="/images/2017/12-27/step0.png" alt="Grid Table 記法の紹介" /><figcaption>Grid Table 記法の紹介</figcaption>
</figure>
<!--more-->
<h2 id="はじめに">はじめに</h2>
<p>みなさん <code>haddock</code> を使ってますか？</p>
<p>コメントを残す時に <code>|</code> や <code>^</code> を追加するだけで <code>haddock</code> 形式のコメントを残すことができます。</p>
<p>具体的にはこんな感じです。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co">-- | リストの合計を計算する関数</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">sum<span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">sum <span class="fu">=</span> foldl (<span class="fu">+</span>) <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="kw">data</span> <span class="dt">Person</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  {<span class="ot"> name ::</span> <span class="dt">Text</span> <span class="co">-- ^ フルネーム</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  }</a></code></pre></div>
<p>コメントを <code>haddock</code> 形式にしてあげることで <code>HTML</code> のドキュメントがより充実するので、少ない労力で凄く楽しい気持ちになります。</p>
<p><code>stack</code> を使っている場合はこのようにしてビルドするだけです。</p>
<pre class="shell"><code>$ stack haddock --open</code></pre>
<p>今回、この <code>haddock</code> に <code>Grid Table</code> 記法が追加されたそうなので、その機能についてご紹介したいと思います。</p>
<h2 id="grid-table-記法">Grid Table 記法</h2>
<p>以下の内容を参考としています。</p>
<ul>
<li><a href="https://github.com/haskell/haddock/pull/718">Grid Tables #718</a></li>
<li><a href="https://github.com/haskell/haddock/issues/530">Add markup support for tables #530</a></li>
<li><a href="http://haskell-haddock.readthedocs.io/en/latest/markup.html#grid-tables">Grid Tables</a></li>
</ul>
<h3 id="haddock-の更新">haddock の更新</h3>
<p><code>Grid Table</code> を使うためには <code>haddock-2.18.2</code> 以上である必要があります。</p>
<p>現状 <code>Hackage</code> の最新版が <code>2.18.1</code> なので <code>github</code> の最新版を利用する必要があります。</p>
<pre class="shell"><code>$ haddock --version
Haddock version 2.18.1, (c) Simon Marlow 2006
Ported to use the GHC API by David Waern 2006-2008</code></pre>
<p>ここでは <code>stack</code> を使って最新版をインストールします。(その他の各種ビルド方法については <a href="https://github.com/haskell/haddock#hacking">Readme</a> に詳しく載っているので、そちらをご参照ください)</p>
<pre class="shell"><code>$ git clone https://github.com/haskell/haddock.git
$ cd haddock
$ stack init
$ stack install

$ haddock --version
Haddock version 2.18.2, (c) Simon Marlow 2006
Ported to use the GHC API by David Waern 2006-2008

$ cd ../</code></pre>
<p>これで準備は整いました！</p>
<h3 id="使ってみる">使ってみる</h3>
<p>まずは新規プロジェクトを作って、初期状態で <code>haddock</code> を生成します。</p>
<pre class="shell"><code>$ stack new test-haddock-grid-table
$ cd test-haddock-grid-table
$ stack haddock --open</code></pre>
<p>ブラウザが自動的に立ち上がるので <code>Lib</code> モジュールを見てみましょう。</p>
<figure>
<img src="/images/2017/12-27/step1.png" alt="初期状態で生成されるHTML" /><figcaption>初期状態で生成されるHTML</figcaption>
</figure>
<p><code>someFunc</code> だけの味気ない <code>HTML</code> ですね。<code>haddock</code> コメントを追加して、もう一度確認してみます。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="co">-- src/Lib.hs</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Lib</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    ( someFunc</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    ) <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"></a>
<a class="sourceLine" id="cb6-6" data-line-number="6"><span class="co">-- | haddock test</span></a>
<a class="sourceLine" id="cb6-7" data-line-number="7"><span class="ot">someFunc ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb6-8" data-line-number="8">someFunc <span class="fu">=</span> putStrLn <span class="st">&quot;someFunc&quot;</span></a></code></pre></div>
<pre class="shell"><code>$ stack haddock --open</code></pre>
<figure>
<img src="/images/2017/12-27/step2.png" alt="haddock コメントを少し追加" /><figcaption>haddock コメントを少し追加</figcaption>
</figure>
<p>ちょっと変わりましたね。</p>
<p>では、本題の <code>Grid Table</code> 記法で書いてみます。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">-- src/Lib.hs</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="kw">module</span> <span class="dt">Lib</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    ( someFunc</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    ) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"></a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="co">-- | Table with header.</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="co">--</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"><span class="co">-- +------+--------------+------------------------------------------+</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9"><span class="co">-- | code | message      | description                              |</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10"><span class="co">-- +======+==============+==========================================+</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11"><span class="co">-- | 200  |   @OK@       | operation successful                     |</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12"><span class="co">-- +------+--------------+------------------------------------------+</span></a>
<a class="sourceLine" id="cb8-13" data-line-number="13"><span class="co">-- | 204  | @No Content@ | operation successful, no body returned   |</span></a>
<a class="sourceLine" id="cb8-14" data-line-number="14"><span class="co">-- +------+--------------+------------------------------------------+</span></a>
<a class="sourceLine" id="cb8-15" data-line-number="15"><span class="ot">someFunc ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">someFunc <span class="fu">=</span> putStrLn <span class="st">&quot;someFunc&quot;</span></a></code></pre></div>
<p>ドキュメントを生成してみましょう。</p>
<pre class="shell"><code>$ stack haddock --open</code></pre>
<figure>
<img src="/images/2017/12-27/step3.png" alt="Grid Table の生成に失敗" /><figcaption>Grid Table の生成に失敗</figcaption>
</figure>
<p>失敗しました・・・。</p>
<p>これはどうやら <code>stack</code> が利用している <code>haddock</code> が <code>~/.local/bin</code> にインストールした最新版の <code>haddock</code> を参照していないためです。</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/issues/2922">Allow use of custom haddock binary to generate the documentation #2922</a></li>
<li><a href="https://stackoverflow.com/questions/41628606/how-to-use-a-custom-haddock-executable-to-generate-documentation-with-stack">ow to use a custom haddock executable to generate documentation with stack?</a></li>
</ul>
<p>以下のコマンドで確認することができます。</p>
<pre class="shell"><code>$ stack exec -- which haddock
/home/bm12/.stack/programs/x86_64-linux/ghc-nopie-8.2.2/bin/haddock

$ stack exec -- haddock --version
Haddock version 2.18.1, (c) Simon Marlow 2006
Ported to use the GHC API by David Waern 2006-2008</code></pre>
<p>ここで、<code>stack</code> が参照する <code>haddock</code> プログラムはシンボリックリンクとなっているため、一時的に上書きすることにしました。</p>
<pre class="shell"><code>$ stack path --compiler-bin
/home/bm12/.stack/programs/x86_64-linux/ghc-nopie-8.2.2/bin

$ ln -snf ~/.local/bin/haddock $(stack path --compiler-bin)/</code></pre>
<p>これでやっと <code>Grid Table</code> が使えます！</p>
<pre class="shell"><code>$ stack clean
$ stack haddock --open</code></pre>
<figure>
<img src="/images/2017/12-27/step4.png" alt="Grid Table のレンダリング結果" /><figcaption>Grid Table のレンダリング結果</figcaption>
</figure>
<p>なかなかオシャレな感じです。</p>
<h2 id="後片付け">後片付け</h2>
<p>シンボリックリンクを元に戻しておきましょう。</p>
<pre class="shell"><code>$ ls -l $(stack path --compiler-bin)
合計 32
lrwxrwxrwx 1 bm12 bm12    9 11月 27 00:39 ghc -&gt; ghc-8.2.2*
-rwxr-xr-x 1 bm12 bm12  444 11月 27 00:39 ghc-8.2.2*
lrwxrwxrwx 1 bm12 bm12   10 11月 27 00:39 ghci -&gt; ghci-8.2.2*
-rwxr-xr-x 1 bm12 bm12  108 11月 27 00:39 ghci-8.2.2*
lrwxrwxrwx 1 bm12 bm12   13 11月 27 00:39 ghc-pkg -&gt; ghc-pkg-8.2.2*
-rwxr-xr-x 1 bm12 bm12  476 11月 27 00:39 ghc-pkg-8.2.2*
lrwxrwxrwx 1 bm12 bm12   29 12月 27 14:24 haddock -&gt; /home/bm12/.local/bin/haddock*
-rwxr-xr-x 1 bm12 bm12  435 11月 27 00:39 haddock-ghc-8.2.2*
-rwxr-xr-x 1 bm12 bm12  408 11月 27 00:39 hp2ps*
-rwxr-xr-x 1 bm12 bm12  406 11月 27 00:39 hpc*
-rwxr-xr-x 1 bm12 bm12 1206 11月 27 00:39 hsc2hs*
lrwxrwxrwx 1 bm12 bm12   12 11月 27 00:39 runghc -&gt; runghc-8.2.2*
-rwxr-xr-x 1 bm12 bm12  452 11月 27 00:39 runghc-8.2.2*
lrwxrwxrwx 1 bm12 bm12    6 11月 27 00:39 runhaskell -&gt; runghc*

$ ln -snf $(stack path --compiler-bin)/haddock-ghc-8.2.2 $(stack path --compiler-bin)/haddock
$ cd ../
$ rm -rf test-haddock-grid-table
$ rm -rf haddock
$ rm ~/.local/bin/haddock</code></pre>
<h2 id="終わりに">終わりに</h2>
<p><code>stack</code> の謎の挙動によって若干苦戦しながらも、無事に試してみることができました。</p>
<p><code>--with-haddock</code> のようなオプションが欲しいなぁと感じました・・・。</p>
<p><code>Grid Table</code> についてはデータベース系の操作結果などを例示する際に使えそうです！</p>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>Haskell のパフォーマンスをデバッグする</title>
    <link href="https://haskell.e-bigmoon.com/posts/2017-12-27-Haskell-Performance-Debugging.html" />
    <id>https://haskell.e-bigmoon.com/posts/2017-12-27-Haskell-Performance-Debugging.html</id>
    <published>2017-12-27T00:00:00Z</published>
    <updated>2017-12-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Great original post: <a href="http://www.parsonsmatt.org/2017/12/18/haskell_performance_debugging.html">Haskell Performance Debugging</a>.</p>
<p>2017年 12月 18日 Matt Parsons</p>
<p>誰かが reddit に <a href="https://www.reddit.com/r/haskell/comments/7km60k/optimization_ideas_in_treap_implementation/">Treap の実装が遅い</a> と投稿していました。それを分析して、何が起きているのかを考えてみましょう。</p>
<p>レポジトリは<a href="https://github.com/parsonsmatt/performance-debugging">ここ</a>にあります。</p>
<h2 id="最初の実行">最初の実行</h2>
<p>Cabalプロジェクトを作り、makefile を作ります。そして、最初のプロファイルを取ります。コードとプロファイル結果は GitHub の <code>master</code>ブランチにあります。</p>
<p>実行されているコードやプロファイル結果を見る前に、質問のデータ構造の定義を確認しておきましょう:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Node</span>  v d <span class="fu">=</span> <span class="dt">Node</span> {<span class="ot"> val ::</span> v,<span class="ot"> info ::</span> d,<span class="ot"> prior ::</span> <span class="dt">Int</span> }</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Treap</span> v d <span class="fu">=</span> <span class="dt">Leaf</span> <span class="fu">|</span> <span class="dt">Tree</span> {<span class="ot">node ::</span> <span class="dt">Node</span> v d,<span class="ot"> left ::</span> <span class="dt">Treap</span> v d,<span class="ot"> right ::</span> <span class="dt">Treap</span> v d}</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="kw">deriving</span> <span class="dt">Show</span></a></code></pre></div>
<!--more-->
<p>注釈つきの2分木ですね。 spine と値は、リスト同様に遅延評価されます。</p>
<p>以下が <code>main</code> 関数で、この出力を調べます。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    g <span class="ot">&lt;-</span> getStdGen</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="kw">let</span> nulls <span class="fu">=</span> repeat ()</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">        n <span class="fu">=</span> <span class="dv">100000</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">        rxs <span class="fu">=</span> take n <span class="fu">$</span> randomRs (<span class="dv">1</span>,<span class="dv">100000</span>)<span class="ot"> g  ::</span> [<span class="dt">Int</span>]</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">        nodeList <span class="fu">=</span> feedFold (zip rxs nulls) g buildNode</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">        treap <span class="fu">=</span> insertMany empty nodeList</a>
<a class="sourceLine" id="cb2-8" data-line-number="8"></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">    print <span class="fu">$</span> heightTreap treap</a>
<a class="sourceLine" id="cb2-10" data-line-number="10"></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">    print <span class="fu">$</span> map (\<span class="dt">Node</span>{val <span class="fu">=</span> v} <span class="ot">-&gt;</span> v) <span class="fu">$</span> inOrder treap</a></code></pre></div>
<p>これをプロファイリングしつつビルドして、<code>-p</code> と <code>-s</code> をつけて実行します。これは時間とメモリ確保についてのプロファイリングをしてくれます。 以下が <code>-s</code> の出力です:</p>
<pre><code>   1,691,027,808 bytes allocated in the heap
   1,179,783,328 bytes copied during GC
      42,694,944 bytes maximum residency (25 sample(s))
       8,493,296 bytes maximum slop
             121 MB total memory in use (0 MB lost due to fragmentation)

                                     Tot time (elapsed)  Avg pause  Max pause
  Gen  0      3033 colls,     0 par    0.716s   0.752s     0.0002s    0.0008s
  Gen  1        25 colls,     0 par    0.544s   0.560s     0.0224s    0.0460s

  INIT    time    0.000s  (  0.000s elapsed)
  MUT     time    1.088s  (  1.140s elapsed)
  GC      time    1.260s  (  1.312s elapsed)
  RP      time    0.000s  (  0.000s elapsed)
  PROF    time    0.000s  (  0.000s elapsed)
  EXIT    time    0.000s  (  0.003s elapsed)
  Total   time    2.404s  (  2.455s elapsed)

  %GC     time      52.4%  (53.4% elapsed)

  Alloc rate    1,554,253,500 bytes per MUT second

  Productivity  47.6% of total user, 46.5% of total elapsed</code></pre>
<p>GC に 52% の時間が割かれているのはよろしくないですね。</p>
<p>プロファイル結果によると、かなり大部分の時間を <code>splitTreap</code>関数で消費してしまっているようです。なので、そこで何が起きているのか確認しましょう:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">splitTreap ::</span> (<span class="dt">Ord</span> v) <span class="ot">=&gt;</span> <span class="dt">Treap</span> v d <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> (<span class="dt">Treap</span> v d, <span class="dt">Treap</span> v d)</a>
<a class="sourceLine" id="cb4-2" data-line-number="2">splitTreap <span class="dt">Leaf</span> _ <span class="fu">=</span> (<span class="dt">Leaf</span>, <span class="dt">Leaf</span>)</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">splitTreap (tree <span class="fu">@</span> <span class="dt">Tree</span> {node <span class="fu">=</span> <span class="dt">Node</span> { val <span class="fu">=</span> x }, left <span class="fu">=</span> l, right <span class="fu">=</span> r})   v</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    <span class="fu">|</span> x <span class="fu">&lt;</span> v  <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">        <span class="kw">let</span> (lt, rt) <span class="fu">=</span> splitTreap r v</a>
<a class="sourceLine" id="cb4-6" data-line-number="6">         <span class="kw">in</span> ( <span class="dt">Tree</span> { node <span class="fu">=</span> node tree, left <span class="fu">=</span> l, right <span class="fu">=</span> lt }</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">            , rt</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">            )</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">    <span class="fu">|</span> v <span class="fu">&lt;=</span> x <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">        <span class="kw">let</span> (lt, rt) <span class="fu">=</span> splitTreap l v</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">         <span class="kw">in</span> ( lt</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">            , <span class="dt">Tree</span> { node <span class="fu">=</span> node tree, left <span class="fu">=</span> rt, right <span class="fu">=</span> r}</a>
<a class="sourceLine" id="cb4-13" data-line-number="13">            )</a></code></pre></div>
<p>私には気になる点が2つ見つかりました:</p>
<ul>
<li>タプル</li>
<li>再帰</li>
</ul>
<p>タプルはしばしば、意図しない遅延やスペースリークの原因になります。GHC がタプルのデータ構造を見て、それを完全にアンボックス化し、オーバーヘッドを 0 にできる場合もあります。しかし、それができないときもあります。結果割り当てられまくって、サンクリークが始まります。</p>
<p>再帰は GHC のインライン化能力を完全に上回っており、パフォーマンスを台無しにしてしまいます。<code>map</code> や <code>foldr</code> などはクレバーな最適化を受けることができますが、単純な再帰関数には大抵、インライン化において問題が存在します。</p>
<p>これらが実験を始める前の私の印象です。私のタプルメモリ割り当て仮説を検証するために、ヒープのプロファイリングを行いましょう。<code>-hd</code>フラグを使って確保されたデータコンストラクタを取得します:</p>
<figure>
<img src="http://www.parsonsmatt.org/treap-base-hd.png" alt="-hd フラグを使ったプロファイル" /><figcaption>-hd フラグを使ったプロファイル</figcaption>
</figure>
<p>いい感じですね! さて、このグラフは <code>Tree</code> コンストラクタの割り当て前に、大量のノード、タプル、<code>I#</code> (<code>Int</code> のコンストラクタ) を割り当てていることを示しています。対象の <code>main</code> 関数だと、この挙動は完全に非合理的というわけではありません。</p>
<h2 id="実験1-データ構造を正格化する">実験1: データ構造を正格化する</h2>
<p>このセクション関連のコードは <code>strictify-treap</code> にあります。</p>
<p>データ構造のところどころにバンパターンを差し込んでみました:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Node</span> v d</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Node</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    {<span class="ot"> val ::</span> <span class="fu">!</span>v</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    ,<span class="ot"> info ::</span> d</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    ,<span class="ot"> prior ::</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">    } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="kw">data</span> <span class="dt">Treap</span> v d</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">    <span class="fu">=</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">    <span class="fu">|</span> <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">    {<span class="ot"> node ::</span> <span class="fu">!</span>(<span class="dt">Node</span> v d)</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">    ,<span class="ot"> left ::</span> <span class="dt">Treap</span> v d</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">    ,<span class="ot"> right ::</span> <span class="dt">Treap</span> v d</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">    } <span class="kw">deriving</span> <span class="dt">Show</span></a></code></pre></div>
<p>こうすることで <code>Node</code> 型の <code>val</code> フィールドと <code>prior</code> フィールドが正格になり、<code>Treap</code> 型は <code>node</code> フィールドに正格になります。<code>info</code> フィールドはたいていのコンテナのように、lazy のままにしてあります。データ構造の spine も lazy のままです。</p>
<p><code>-s</code> の出力です:</p>
<pre><code>1,659,050,200 bytes allocated in the heap
   1,144,049,696 bytes copied during GC
      43,890,168 bytes maximum residency (33 sample(s))
       8,508,680 bytes maximum slop
             102 MB total memory in use (0 MB lost due to fragmentation)

                                     Tot time (elapsed)  Avg pause  Max pause
  Gen  0      2905 colls,     0 par    0.676s   0.696s     0.0002s    0.0007s
  Gen  1        33 colls,     0 par    0.544s   0.567s     0.0172s    0.0409s

  INIT    time    0.000s  (  0.000s elapsed)
  MUT     time    0.920s  (  0.996s elapsed)
  GC      time    1.220s  (  1.263s elapsed)
  RP      time    0.000s  (  0.000s elapsed)
  PROF    time    0.000s  (  0.000s elapsed)
  EXIT    time    0.000s  (  0.001s elapsed)
  Total   time    2.196s  (  2.260s elapsed)

  %GC     time      55.6%  (55.9% elapsed)

  Alloc rate    1,803,315,434 bytes per MUT second

  Productivity  44.4% of total user, 44.1% of total elapsed</code></pre>
<p>20MB も使用しているメモリが減っています。これはいいですね。そして全体の使用時間も少なくなっています (2.4秒 vs 2.2秒)。これもいいことです! しかし GC が使っている時間は 55% です。前より悪くなってるじゃなイカ!</p>
<p>以下はヒーププロファイリングの結果です:</p>
<figure>
<img src="http://www.parsonsmatt.org/treap-strict-nodes.png" alt="ヒーププロファイリングの結果" /><figcaption>ヒーププロファイリングの結果</figcaption>
</figure>
<p>大きな違いはありませんが、確かに少し良い結果です。時間と割り当てのプロファイリングは全く違う結果を証明していています。後々、プログラムの実行時間は 2.49秒から 0.97秒になります。</p>
<p>この結果にかなり励まされつつ、木の spine も正格にしようと思います。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Node</span> v d</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">    <span class="fu">=</span> <span class="dt">Node</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    {<span class="ot"> val ::</span> <span class="fu">!</span>v</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    ,<span class="ot"> info ::</span> d</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    ,<span class="ot"> prior ::</span> <span class="fu">!</span><span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">    } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb7-7" data-line-number="7"></a>
<a class="sourceLine" id="cb7-8" data-line-number="8"><span class="kw">data</span> <span class="dt">Treap</span> v d</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">    <span class="fu">=</span> <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">    <span class="fu">|</span> <span class="dt">Tree</span></a>
<a class="sourceLine" id="cb7-11" data-line-number="11">    {<span class="ot"> node ::</span> <span class="fu">!</span>(<span class="dt">Node</span> v d)</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">    ,<span class="ot"> left ::</span> <span class="fu">!</span>(<span class="dt">Treap</span> v d)</a>
<a class="sourceLine" id="cb7-13" data-line-number="13">    ,<span class="ot"> right ::</span> <span class="fu">!</span>(<span class="dt">Treap</span> v d)</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">    } <span class="kw">deriving</span> <span class="dt">Show</span></a></code></pre></div>
<p><code>-s</code> の出力結果によると、合計でまだ 94MB 程度のメモリを使っているようです。</p>
<pre><code>  1,161,437,656 bytes allocated in the heap
     449,893,272 bytes copied during GC
      43,890,328 bytes maximum residency (24 sample(s))
       8,520,808 bytes maximum slop
              94 MB total memory in use (0 MB lost due to fragmentation)

                                     Tot time (elapsed)  Avg pause  Max pause
  Gen  0      2143 colls,     0 par    0.152s   0.166s     0.0001s    0.0006s
  Gen  1        24 colls,     0 par    0.188s   0.203s     0.0085s    0.0272s

  INIT    time    0.000s  (  0.000s elapsed)
  MUT     time    0.556s  (  0.644s elapsed)
  GC      time    0.320s  (  0.345s elapsed)
  RP      time    0.000s  (  0.000s elapsed)
  PROF    time    0.020s  (  0.024s elapsed)
  EXIT    time    0.000s  (  0.000s elapsed)
  Total   time    0.952s  (  0.989s elapsed)

  %GC     time      33.6%  (34.9% elapsed)

  Alloc rate    2,088,916,647 bytes per MUT second

  Productivity  64.3% of total user, 62.6% of total elapsed</code></pre>
<p>これはかなり良い結果です。GC が 33% なのは良くないですが、それでも前よりもだいぶ良い結果です。2.4秒から 0.95秒になりました。これはかなりの改善です。</p>
<p>今度はヒープの出力も見てみましょう:</p>
<figure>
<img src="http://www.parsonsmatt.org/treap-strict-spine.png" alt="ヒープの出力" /><figcaption>ヒープの出力</figcaption>
</figure>
<p>もう少しですね! 大きなメモリの山が生成され、それが回収されています。何かが起きていることの兆候です。タプルコンストラクタに多くの割り当てをしてしまっています。つらいですね。</p>
<h2 id="split-を正格化する">Split を正格化する</h2>
<p>まだ <code>splitTreap</code> という最大の犯罪者がいます。こいつはプログラムの実行時間のほぼ半分を占めています。タプルを割り当て、それを捨てていることはわかっているので、そこにスペースリークがある可能性があります。タプルの中にバンパターンを追加し、結果を見てみます。</p>
<p>これが変更点です:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">splitTreap ::</span> (<span class="dt">Ord</span> v) <span class="ot">=&gt;</span> <span class="dt">Treap</span> v d <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> (<span class="dt">Treap</span> v d, <span class="dt">Treap</span> v d)</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">splitTreap <span class="dt">Leaf</span> _ <span class="fu">=</span> (<span class="dt">Leaf</span>, <span class="dt">Leaf</span>)</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">splitTreap (tree <span class="fu">@</span> <span class="dt">Tree</span> {node <span class="fu">=</span> <span class="dt">Node</span> { val <span class="fu">=</span> x }, left <span class="fu">=</span> l, right <span class="fu">=</span> r})   v</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">    <span class="fu">|</span> x <span class="fu">&lt;</span> v  <span class="fu">=</span> <span class="kw">let</span> (<span class="fu">!</span>lt, <span class="fu">!</span>rt) <span class="fu">=</span> splitTreap r v <span class="kw">in</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">                (   <span class="dt">Tree</span> { node <span class="fu">=</span> node tree, left <span class="fu">=</span> l, right <span class="fu">=</span> lt },</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">                    rt  )</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    <span class="fu">|</span> v <span class="fu">&lt;=</span> x <span class="fu">=</span> <span class="kw">let</span> (<span class="fu">!</span>lt, <span class="fu">!</span>rt) <span class="fu">=</span> splitTreap l v <span class="kw">in</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">                (   lt,</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">                    <span class="dt">Tree</span> { node <span class="fu">=</span> node tree, left <span class="fu">=</span> rt, right <span class="fu">=</span> r}  )</a></code></pre></div>
<p>元のコードがタプルを直ちに破棄して <code>lt</code> と <code>rt</code> 変数を lazy なままにしているのに対して、これらの変数を WHNF に強制しています。</p>
<p>新しい <code>-s</code> の出力結果です:</p>
<pre><code>   1,331,896,120 bytes allocated in the heap
     497,880,136 bytes copied during GC
      43,890,328 bytes maximum residency (25 sample(s))
       8,516,712 bytes maximum slop
              94 MB total memory in use (0 MB lost due to fragmentation)

                                     Tot time (elapsed)  Avg pause  Max pause
  Gen  0      2245 colls,     0 par    0.188s   0.186s     0.0001s    0.0007s
  Gen  1        25 colls,     0 par    0.212s   0.251s     0.0100s    0.0386s

  INIT    time    0.000s  (  0.000s elapsed)
  MUT     time    0.636s  (  0.756s elapsed)
  GC      time    0.360s  (  0.394s elapsed)
  RP      time    0.000s  (  0.000s elapsed)
  PROF    time    0.040s  (  0.043s elapsed)
  EXIT    time    0.000s  (  0.000s elapsed)
  Total   time    1.084s  (  1.151s elapsed)

  %GC     time      33.2%  (34.2% elapsed)

  Alloc rate    2,094,176,289 bytes per MUT second

  Productivity  63.1% of total user, 62.0% of total elapsed</code></pre>
<p>これはさっきの実行からほとんど変わっていません。ヒーププロファイルも変更されませんでした。これらのタプルがどこに割り当てられるのかを見るために、<code>-hc</code> をつけて実行してみます。<code>-hc</code> は実際にどの関数がデータを生成しているのかを記録してくれるので、どこに注目するべきかが分かります。</p>
<figure>
<img src="http://www.parsonsmatt.org/treap-strict-tuple-hc.png" alt="-hc を使ったプロファイル" /><figcaption>-hc を使ったプロファイル</figcaption>
</figure>
<p><strong>あぁナッツ!</strong> <code>splitTreap</code> がほんの少ししかメモリ割り当てがされなくなってるぞ。<code>buildNode</code>, <code>feedFold</code>, <code>insertMany</code> でほとんどの割り当てを行っているみたいです。これは、<code>splitTreap</code> に多くの時間と割り当てをしているという <code>-p</code> オプションの結果に反しているように見えます。</p>
<p>今は <code>insertMany</code> に集中するべきでしょう。</p>
<h2 id="insertmany">insertMany</h2>
<p>このセクションのコードは、GitHub の<code>insert-many</code>ブランチにあります。</p>
<p><code>mergeTreap</code> はなぜかしらカリー化されていましたが:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">mergeTreap ::</span> (<span class="dt">Treap</span> v d, <span class="dt">Treap</span> v d) <span class="ot">-&gt;</span> <span class="dt">Treap</span> v d</a></code></pre></div>
<p>これはうざかったので、上のようにアンカリー化しました。これはパフォーマンスには関係ありません。</p>
<p>ここで、<code>insertMany</code> を実際に見てみます:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">insertMany ::</span> (<span class="dt">Ord</span> v) <span class="ot">=&gt;</span> <span class="dt">Treap</span> v d <span class="ot">-&gt;</span> [<span class="dt">Node</span> v d] <span class="ot">-&gt;</span> <span class="dt">Treap</span> v d</a>
<a class="sourceLine" id="cb12-2" data-line-number="2">insertMany <span class="fu">=</span> foldl insertTreap</a></code></pre></div>
<p>あぁ。<code>foldl</code> がまた来やがりました。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="ot">insertMany ::</span> (<span class="dt">Ord</span> v) <span class="ot">=&gt;</span> <span class="dt">Treap</span> v d <span class="ot">-&gt;</span> [<span class="dt">Node</span> v d] <span class="ot">-&gt;</span> <span class="dt">Treap</span> v d</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">insertMany <span class="fu">=</span> foldl&#39; insertTreap</a></code></pre></div>
<p>さぁ、GHC のアメージングな最適化力とプライムボーイ、どちらが勝つのでしょうか? <code>-s</code> の結果です:</p>
<pre class="plain"><code>   1,115,162,944 bytes allocated in the heap
     245,033,472 bytes copied during GC
      12,088,896 bytes maximum residency (22 sample(s))
         306,112 bytes maximum slop
              32 MB total memory in use (0 MB lost due to fragmentation)

                                     Tot time (elapsed)  Avg pause  Max pause
  Gen  0      2134 colls,     0 par    0.116s   0.128s     0.0001s    0.0003s
  Gen  1        22 colls,     0 par    0.080s   0.105s     0.0048s    0.0136s

  INIT    time    0.000s  (  0.000s elapsed)
  MUT     time    0.596s  (  0.700s elapsed)
  GC      time    0.180s  (  0.216s elapsed)
  RP      time    0.000s  (  0.000s elapsed)
  PROF    time    0.016s  (  0.018s elapsed)
  EXIT    time    0.000s  (  0.001s elapsed)
  Total   time    0.852s  (  0.916s elapsed)

  %GC     time      21.1%  (23.6% elapsed)

  Alloc rate    1,871,078,765 bytes per MUT second

  Productivity  77.0% of total user, 74.4% of total elapsed</code></pre>
<p>良いですね、トータルの使用メモリが 32MB になり、全体の時間は 10分の1 ぐらい減りました。しかも、GC にかかっている時間はたったの 22% です。我々の大勝利です。</p>
<p>ヒープのプロファイル結果を見てみましょう:</p>
<figure>
<img src="http://www.parsonsmatt.org/treap-foldl.png" alt="ヒーププロファイルの結果" /><figcaption>ヒーププロファイルの結果</figcaption>
</figure>
<h2 id="何があっても-foldl-を使わず常に-foldl-を使うべし">何があっても foldl を使わず、常に foldl’ を使うべし</h2>
<p>最初の状態で foldl を foldl’ に変更してみたらどうでしょう?</p>
<p><code>git checkout base</code> を走らせて元に戻し、<code>foldl</code> を <code>foldl'</code> に変更してみました。<code>-s</code> の結果です:</p>
<pre class="plain"><code>1,581,972,168 bytes allocated in the heap
   1,140,799,032 bytes copied during GC
      40,964,944 bytes maximum residency (43 sample(s))
         495,784 bytes maximum slop
             114 MB total memory in use (0 MB lost due to fragmentation)

                                     Tot time (elapsed)  Avg pause  Max pause
  Gen  0      3044 colls,     0 par    0.664s   0.636s     0.0002s    0.0004s
  Gen  1        43 colls,     0 par    0.796s   0.812s     0.0189s    0.0611s

  INIT    time    0.000s  (  0.000s elapsed)
  MUT     time    0.964s  (  1.226s elapsed)
  GC      time    1.336s  (  1.320s elapsed)
  RP      time    0.000s  (  0.000s elapsed)
  PROF    time    0.124s  (  0.128s elapsed)
  EXIT    time    0.000s  (  0.002s elapsed)
  Total   time    2.488s  (  2.548s elapsed)

  %GC     time      53.7%  (51.8% elapsed)

  Alloc rate    1,641,049,966 bytes per MUT second

  Productivity  41.3% of total user, 43.2% of total elapsed</code></pre>
<p>よろしくはないですね。というか、初めよりもちょっと悪くなってます! ヒープのプロファイル結果はどうでしょう?</p>
<figure>
<img src="http://www.parsonsmatt.org/treap-just-foldl.png" alt="ヒーププロファイルの結果" /><figcaption>ヒーププロファイルの結果</figcaption>
</figure>
<p>これもほとんど同じですね! 割り当てはちょっとなめらかになっていますが、顕著な違いでもありません。というわけで、データ構造を正格にせずに、ただ <code>foldl'</code> に変更しても意味がありませんでした。</p>
<h2 id="最終結果">最終結果</h2>
<p>プロファイリングを無効にして、もう一回コードを実行してみます:</p>
<pre class="plain"><code>     650,786,800 bytes allocated in the heap
     132,515,880 bytes copied during GC
       7,278,528 bytes maximum residency (17 sample(s))
         353,296 bytes maximum slop
              21 MB total memory in use (0 MB lost due to fragmentation)

                                     Tot time (elapsed)  Avg pause  Max pause
  Gen  0      1233 colls,     0 par    0.112s   0.100s     0.0001s    0.0004s
  Gen  1        17 colls,     0 par    0.056s   0.056s     0.0033s    0.0122s

  INIT    time    0.000s  (  0.000s elapsed)
  MUT     time    0.212s  (  0.341s elapsed)
  GC      time    0.168s  (  0.156s elapsed)
  EXIT    time    0.000s  (  0.000s elapsed)
  Total   time    0.436s  (  0.497s elapsed)

  %GC     time      38.5%  (31.3% elapsed)

  Alloc rate    3,069,749,056 bytes per MUT second

  Productivity  61.5% of total user, 68.7% of total elapsed</code></pre>
<p>メモリ消費は 21MB, 実行時間は 0.43秒でした。</p>
<h2 id="結論">結論?</h2>
<h3 id="spine-は正格にリーブは-lazy-に">spine は正格に、リーブは lazy に</h3>
<p>データ構造的には、spine は正格に、リーブは lazy にすべきです。データコンストラクタを、ストリームの形で組み立てたり消費したいという強い意思があるなら話は別ですが。</p>
<h3 id="foldl-は絶対に使うな">foldl は絶対に使うな</h3>
<p>まじめに使っちゃダメです。<code>hlint</code> のルールにそうしないように書いてください。コードから排除しましょう。廃止して、<code>Prelude</code> を置き換えるように GHC に提案しましょう。</p>]]></summary>
</entry>
<entry>
    <title>stack v1.6.3 がリリースされました。</title>
    <link href="https://haskell.e-bigmoon.com/posts/2017-12-24-stack163.html" />
    <id>https://haskell.e-bigmoon.com/posts/2017-12-24-stack163.html</id>
    <published>2017-12-24T00:00:00Z</published>
    <updated>2017-12-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="はじめに">はじめに</h2>
<p>以下のコマンドで <code>stack v1.6.3</code> のバイナリが落ちてきます。</p>
<pre class="shell"><code>$ stack upgrade</code></pre>
<h2 id="リリースノート">リリースノート</h2>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/blob/master/ChangeLog.md#v163">Changelog.md</a></li>
</ul>
<p>機能追加は無く、改良とバグフィックスのみです。</p>
<p><code>stack ls</code> コマンドは今回に含まれていないので <code>v1.7.0</code> で追加されそうな感じですね。</p>
<!--more-->
<h3 id="enhancements">Enhancements</h3>
<ul>
<li>In addition to supporting <code>.tar.gz</code> and <code>.zip</code> files as remote archives, plain <code>.tar</code> files are now accepted too. This will additionally help with cases where HTTP servers mistakenly set the transfer encoding to <code>gzip</code>. See <a href="https://github.com/commercialhaskell/stack/issues/3647">#3647</a>.</li>
</ul>
<p>ということで <code>.tar</code> に加えて <code>extra-deps</code> に <code>.tar.gz</code>, <code>.zip</code> 形式が指定できるようになったみたいです。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="fu">extra-deps:</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">-</span> <span class="fu">http:</span><span class="at">//www.mathstat.dal.ca/~selinger/quipper/downloads/quipper-0.8.tgz</span></a></code></pre></div>
<p>僕は使ったこと無いですが、役立ちそう。</p>
<hr />
<ul>
<li>Links to docs.haskellstack.org ignore Stack version patchlevel.</li>
<li>Downloading Docker-compatible stack binary ignores Stack version patchlevel.</li>
</ul>
<p>たぶん <code>stack v1.6.1.1</code> のようなバージョンは無視されるということでしょうか。</p>
<h2 id="bug-fixes">Bug fixes</h2>
<ul>
<li>For versions of Cabal before 1.24, ensure that the dependencies of non-buildable components are part of the build plan to work around an old Cabal bug. See <a href="https://github.com/commercialhaskell/stack/issues/3631">#3631</a>.</li>
</ul>
<p>古めの <code>LTS</code> (issue は lts-6.35 で報告されてる) 使ってる人はこの問題が解決されますのでアップデート推奨と思われます。</p>
<hr />
<ul>
<li>Run the Cabal file checking in the <code>sdist</code> command more reliably by allowing the Cabal library to flatten the <code>GenericPackageDescription</code> itself.</li>
</ul>
<p>よくわかりません。</p>
<hr />
<ul>
<li>The script interpreter’s implicit file arguments are now passed before other arguments. See <a href="Error%20when%20using%20RTS%20options%20with%20the%20Stack%20script%20interpreter%20#3658">#3658</a>. In particular, this makes it possible to pass <code>-- +RTS ... -RTS</code> to specify RTS arguments used when running the script.</li>
</ul>
<p>スクリプトインタプリタの暗黙的なファイル引数を他の引数より先に渡すように修正されたようです。 その結果、以下のような <code>RTS</code> オプションの指定が適切に処理できるようになりました。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">#!/usr/bin/env stack</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="co">{- stack</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="co">  script</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="co">  --resolver lts-6.25</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="co">  --package turtle</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="co">  --</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="co">  +RTS -s -RTS</span></a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="co">-}</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9"></a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="ot">main ::</span> <span class="dt">IO</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11">main <span class="fu">=</span> putStrLn <span class="st">&quot;Hello, world!&quot;</span></a></code></pre></div>
<hr />
<ul>
<li>Don’t ignore the template year parameter in config files, and clarify the surrounding documentation. See <a href="stack%20new%20--%20AesonException%20#2275">#2275</a>.</li>
</ul>
<p><code>config.yaml</code> に <code>year</code> パラメータを指定できるようになったそうです。こんな感じです。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="fu">templates:</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="fu">params:</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">    <span class="fu">author-email:</span><span class="at"> 415fox@gmail.com</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">    <span class="fu">author-name:</span><span class="at"> michael fox</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    <span class="fu">category:</span><span class="at"> Application</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">    <span class="fu">copyright:</span><span class="at"> copytright michael fox 2016</span></a>
<a class="sourceLine" id="cb4-7" data-line-number="7">    <span class="fu">github-username:</span><span class="at"> gitfoxi</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8">    <span class="fu">year:</span><span class="at"> 2016</span></a></code></pre></div>
<p>ドキュメントを見る限り <code>copyright</code> を省略した場合は <code>author-name</code> と <code>year</code> を使って <code>copyright</code> が生成されるようです。 また <code>year</code> を省略した場合は現在の年が設定されるとのことなので、設定しなくても良さそうですね。</p>
<blockquote>
<p>year - if copyright is not specified, year and author-name are used to generate the copyright property in cabal. If year is not specified, it defaults to the current year.</p>
</blockquote>
<p>以上です。</p>]]></summary>
</entry>
<entry>
    <title>VS Code で Ghcid を使う</title>
    <link href="https://haskell.e-bigmoon.com/posts/2017-12-24-Ghcid-with-VS-Code.html" />
    <id>https://haskell.e-bigmoon.com/posts/2017-12-24-Ghcid-with-VS-Code.html</id>
    <published>2017-12-24T00:00:00Z</published>
    <updated>2017-12-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Great original post: <a href="http://neilmitchell.blogspot.jp/2017/11/ghcid-with-vs-code.html">Ghcid with VS Code</a>.</p>
<p>2017年 11月 10日 Neil Mitchell</p>
<p><em>概要: 新しいバージョンの Ghcid と VS Code拡張がリリースされ、よりいい感じに動くようになった。</em></p>
<p><a href="https://hackage.haskell.org/package/ghcid">Ghcid v0.6.8</a> と関連する VS Code拡張 <a href="https://marketplace.visualstudio.com/items?itemName=ndmitchell.haskell-ghcid">haskell-ghcid v0.2.0</a> をリリースしました。 一緒に使うと、Ghcid + VS Code 環境をシンプルなものにしてくれます。</p>
<!--more-->
<h2 id="ghcid-ファイルの読み込み-ghcid">.ghcid ファイルの読み込み (Ghcid)</h2>
<p>Ghcid に、カレントディレクトリに <code>.ghcid</code> ファイルがあった場合はそれを追加の引数としてロードする機能が追加されました。 例えば、Shake レポジトリには <a href="https://github.com/ndmitchell/shake/blob/master/.ghcid">.ghcid</a> ファイルがあって:</p>
<pre><code>-c &quot;ghci -fno-code -ferror-spans&quot;</code></pre>
<p><code>ghcid</code> に、コマンドでこれを解釈させずに (例えば <code>.stack-work</code> があれば <code>stack</code> でこれを解釈させずに) 常に <code>ghci -fno-code -ferror-spans</code> を実行させています。 このコマンドは、<a href="https://github.com/ndmitchell/shake/blob/master/.ghci"><code>.ghci</code> ファイル</a> があって、必要なファイルを全てロードしているのでうまく動いています。 ちなみに <code>-fno-code</code> はコンパイル速度を上げるために、<code>-ferror-spans</code> はエラーのハイライトをより良くするために指定しています。</p>
<h2 id="ghcid-を開始-ghcid-vs-code">ghcid を開始 (Ghcid VS Code)</h2>
<p><code>Start Ghcid</code> アクションという VS Code 拡張の新機能は、新しい <code>ghcid</code> 端末を起動します。 起動した後、出力は一時ファイルに保存され、Problems ペインに表示されます。 この拡張は <code>ghcid</code> を追加の引数なしで実行するため、引数を渡したい場合は <code>.ghcid</code> でこの引数を指定する必要があります。</p>
<p>このような変更をしたのは、VS Code からより少ないキーで <code>ghcid</code> を開始するためです。 以前は、ファイルを開いたり、特別なフラグを追加したり、コマンドの実行などが必要でした。</p>]]></summary>
</entry>
<entry>
    <title>カスタムスナップショットの紹介</title>
    <link href="https://haskell.e-bigmoon.com/posts/2017-12-23-stack161.html" />
    <id>https://haskell.e-bigmoon.com/posts/2017-12-23-stack161.html</id>
    <published>2017-12-23T00:00:00Z</published>
    <updated>2017-12-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>ちょっと前に <a href="https://github.com/commercialhaskell/stack/blob/master/ChangeLog.md#v161">version 1.6.1</a> がリリースされたので、その中の目玉機能でもある <code>カスタムスナップショット</code> を紹介したいと思います。</p>
<!--more-->
<h2 id="news">NEWS</h2>
<p>すでに多くの方がご存知かと思いますが、<code>stack</code> 界隈で大きな出来事が3つありました。</p>
<ul>
<li><code>stack 1.6.1</code> のリリース</li>
<li><code>lts-10.0</code> のリリース</li>
<li><code>stack new</code> で生成されるテンプレートのデフォルトが <code>hpack</code> になった</li>
</ul>
<p>以下の記事は <code>hpack</code> についての記述があるため、stack 初心者におすすめです！</p>
<ul>
<li><a href="https://myuon.github.io/posts/haskell-project-setup/">Haskellプロジェクトを始めるにあたって</a></li>
<li><a href="https://qiita.com/ogata-k/items/2b21326b2b7351bfc28c">Haskellのstackによるプロジェクトについて</a></li>
<li><a href="https://qiita.com/waddlaw/items/49874f4cf9b680e4b015">本気で Haskell したい人向けの Stack チュートリアル</a>
<ul>
<li>僕が作成して、時々加筆修正していますが、量が多くなりすぎたのでどうにかしようと思っています・・・。</li>
<li>タイトルは煽っている感じが少々ありますが、結構真面目です。</li>
</ul></li>
</ul>
<p>ただ、古い記事が全部だめかというとそうでもありません。</p>
<p>細部を自分で補完できれば有用な記事も多くあります。</p>
<ul>
<li><a href="https://qiita.com/tanakh/items/6866d0f570d0547df026">Haskellのビルドツール“stack”の紹介</a></li>
<li><a href="https://qiita.com/igrep/items/da1d8df6d40eb001a561">Stackでやる最速Haskell Hello world! (GHCのインストール付き！)</a></li>
</ul>
<h2 id="custom-snapshots-カスタムスナップショット-について">Custom Snapshots (カスタムスナップショット) について</h2>
<ul>
<li><a href="https://docs.haskellstack.org/en/stable/custom_snapshot/">Custom Snapshots</a></li>
<li><a href="https://www.fpcomplete.com/blog/2017/07/stacks-new-extensible-snapshots">STACK’S NEW EXTENSIBLE SNAPSHOTS.</a></li>
<li><a href="https://github.com/commercialhaskell/stack/pull/3249">Extensible snapshots #3249</a></li>
</ul>
<p>カスタムスナップショットは名前から想像できるように、スナップショットを好きにカスタマイズできる新機能です！</p>
<p>公式のスナップショットは <code>resolver</code> に指定する <code>lts</code> や <code>nightly</code> で始まるものです。</p>
<p>カスタムスナップショットとは関係ないですが、<code>lts</code>, <code>nightly</code> とバージョンを省略すると最新版のスナップショットを指定できるという小技もあります。(<a href="https://github.com/commercialhaskell/stack/issues/3641">Feature request: stack init –latest-nightly #3641</a>)</p>
<pre class="shell"><code>$ stack new sample --resolver=nightly
$ stack new sample --resolver=lts</code></pre>
<h2 id="カスタムスナップショットを作ってみよう">カスタムスナップショットを作ってみよう！</h2>
<p>通常であれば <code>stack new</code> で生成されるプロジェクトの <code>stack.yaml</code> と <code>package.yaml</code> を使いますが、今回は全部ゼロから作って行こうと思います。</p>
<h3 id="カスタムスナップショットの作成">カスタムスナップショットの作成</h3>
<p>まずは <code>my-snapshot.yaml</code> という名前で空のファイルを作ります。</p>
<pre class="shell"><code>$ touch my-snapshot.yaml
$ tree
.
└── my-snapshot.yaml</code></pre>
<p>カスタムスナップショットを定義するためには、まずはベースとなるスナップショットを決める必要があります。</p>
<p>そのため、 <code>my-snapshot.yaml</code> に <code>resolver</code> を追記しましょう。今回は新しくリリースされた <code>lts-10.0</code> を指定します。</p>
<p>また <code>name</code> フィールドで自分のスナップショットに名前をつけます。</p>
<p>この2つが必須のフィールドになります。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="fu">resolver:</span><span class="at"> lts-10.0</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="fu">name:</span><span class="at"> waddlaw-1.0</span></a></code></pre></div>
<p>これで <code>lts-10.0</code> と全く同じカスタムスナップショットを定義することができました。</p>
<p><code>name</code> フィールドは <code>~/.stack/snapshots/</code> 以下に保存されるスナップショットのディレクトリ名の一部として利用されたりします。</p>
<h3 id="stack.yaml-の作成">stack.yaml の作成</h3>
<p>実際に使ってみましょう。まずは <code>stack.yaml</code> を用意します。</p>
<pre class="shell"><code>$ touch stack.yaml

$ tree
.
├── my-snapshot.yaml
└── stack.yaml</code></pre>
<p><code>stack.yaml</code> の <code>resolver</code> に先に作ったカスタムスナップショットを指定します。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="fu">resolver:</span><span class="at"> my-snapshot.yaml</span></a></code></pre></div>
<p>このままでは <code>cabal</code> ファイルが無いため、まだビルドできません。</p>
<h3 id="package.yaml-の作成">package.yaml の作成</h3>
<p><code>package.yaml</code> もゼロから作っていきましょう。</p>
<pre class="shell"><code>$ touch package.yaml

$ tree
.
├── my-snapshot.yaml
├── package.yaml
└── stack.yaml</code></pre>
<p>最小の <code>package.yaml</code> はこんな感じです。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode yaml"><code class="sourceCode yaml"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="fu">name:</span><span class="at"> test-custom-snapshot</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="fu">dependencies:</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="kw">-</span> base</a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="fu">library:</span><span class="at"> </span><span class="kw">{}</span></a></code></pre></div>
<p>ではビルドしてみましょう。</p>
<pre class="shell"><code>$ stack build
...

$ tree
.
├── my-snapshot.yaml
├── package.yaml
├── stack.yaml
└── test-custom-snapshot.cabal</code></pre>
<p>無事に <code>cabal</code> ファイルが生成されていますね。</p>
<h2 id="パッケージの追加">パッケージの追加</h2>
<p>現時点の依存関係を確認してみます。</p>
<pre class="shell"><code>$ stack list-dependencies
base 4.10.1.0
ghc-prim 0.5.1.1
integer-gmp 1.0.1.0
rts 1.0
test-custom-snapshot 0.0.0</code></pre>
<p>まずは、いつも通り何かパッケージを追加してみましょう。</p>
<p>今回は <a href="https://www.stackage.org/package/hakyll-shakespeare">hakyll-shakespeare</a> を追加することにします。<code>hamlet</code> 記法が好きなので <code>hakyll</code> でサイト作る時は個人的にお世話になっているパッケージです。</p>
<p>現時点で <code>lts-10.0</code> に <code>hakyll-shakespeare</code> は含まれていません。</p>
<pre><code>$ cat my-snapshot.yaml
resolver: lts-10.0
name: waddlaw-1.0

packages:
  - hakyll-shakespeare-0.1.0.0.2</code></pre>
<p>こんな感じでカスタムスナップショットに <code>hakyll-shakespeare</code> を指定します。</p>
<p><code>packages</code> フィールドには <code>extra-deps</code> と同じ構文が利用できます。そのため <code>hackage</code> などにアップロードしていないパッケージでも同様に指定可能です。</p>
<p>それでは、ちゃんと追加されるか確認してみます。</p>
<pre class="shell"><code>$ stack build
$ stack list-dependencies | grep hakyll-shakespeare
hakyll-shakespeare 0.1.0.0.2</code></pre>
<p>大丈夫そうですね！</p>
<h2 id="カスタムスナップショットを共有する">カスタムスナップショットを共有する</h2>
<p>ここまでで基本的なカスタムスナップショットの作り方はマスターできたと思います。</p>
<p>しかし、複数のプロジェクトでカスタムスナップショットが利用できなければ、うれしさ半減です。なので、カスタムスナップショットには、そういった仕組みも用意されています。</p>
<p>どこかにカスタムスナップショットをアップロードし、単純に <code>resolver</code> に <code>URL</code> を指定するだけです。</p>
<pre class="shell"><code>$ cat stack.yaml
resolver: https://raw.githubusercontent.com/waddlaw/example-custom-snapshot/master/my-snapshot.yaml</code></pre>
<h3 id="注意点">注意点</h3>
<p>1つ注意しなければならない点として、ローカルに用意するカスタムスナップショットファイルと違い、リモートのファイルについてはイミュータブル (変更されないもの) として処理されるという点です。つまり、 <code>URL</code> にアクセスするのは一度だけということです。</p>
<p>そのため、リモートのファイルを上書き更新したとしても、その内容は既存のプロジェクトには反映されません。</p>
<pre class="shell"><code>$ tree ~/.stack/custom-plan/
/home/bm12/.stack/custom-plan/
└── yaml
    └── tCj-vP1QL-9k.yaml

$ cat ~/.stack/custom-plan/yaml/tCj-vP1QL-9k.yaml
resolver: lts-10.0
name: waddlaw-1.0

packages:
  - hakyll-shakespeare-0.1.0.0.2</code></pre>
<p>なので <code>Stackage</code> 同様にカスタムスナップショットの内容を変更する場合は、その都度新しいスナップショットを作る必要があります。</p>
<h2 id="カスタマイズ可能な設定">カスタマイズ可能な設定</h2>
<p>スナップショットをカスタマイズできる項目は以下の4つです。</p>
<ul>
<li>コンパイラの上書き</li>
<li>除外パッケージの指定</li>
<li>ghc-options の指定</li>
<li>flags の指定</li>
</ul>
<p>具体的な使い方についてはドキュメントをご確認ください。</p>
<ul>
<li><a href="https://github.com/commercialhaskell/stack/blob/master/doc/custom_snapshot.md#using-a-url-instead-of-a-filepath">Custom Snapshots</a></li>
</ul>
<h2 id="まとめ">まとめ</h2>
<p>この機能は <code>Hakyll</code> などの静的サイトジェネレータを良く使う人にとっては、便利なのではないでしょうか。</p>
<p>個人的には、<code>lts-9</code> 系で最新の <code>pandoc</code> と <code>hakyll</code> を使おうとしたとき、数多くの <code>extra-deps</code> を追加する必要があり、そういう場面で便利かなと少し感じました。</p>]]></summary>
</entry>

</feed>
