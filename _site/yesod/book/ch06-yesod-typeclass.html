<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">

  <head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# article: http://ogp.me/ns/article#">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0" />
  <!-- MUST in hex format, may the same as header-color. This color is for android chrome browser. -->
  <meta name="theme-color" content="#5c6bc0">

  <!-- Metadata. -->
  <meta name="keywords" content="haskell,blog,bigmoon" />
  <title>Yesod Typeclass</title>
  <meta name="description" content="BIG MOON">
  <link rel="canonical" href="../../yesod/book/ch06-yesod-typeclass.html">
  <link rel="alternate" type="application/atom+xml" title="Yesod Typeclass" href="../../feed.xml" />
  <link rel="shortcut icon" href="../../images/favicon.ico" />
  <meta name="google-site-verification" content="X2YNboLvzw3_bclXLMvohyJDqj68D06_hPDMukRbgTs" />

  <!-- Stylesheets. -->
  <link rel="stylesheet" href="../../lib/materialize/css/materialize.min.css" />
  <link rel="stylesheet" href="../../css/main.css" />
  <link media="all" rel="stylesheet" type="text/css" href="../../lib/mdi/css/materialdesignicons.min.css" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="../../lib/material-scrolltop/material-scrolltop.css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" />

  <!-- OGP -->
  <meta property="og:title" content="Yesod Typeclass" />
  <meta property="og:type" content="article" />
  <meta property="og:url" content="/yesod/book/ch06-yesod-typeclass.html" />
  <!-- <meta property="og:image" content=" サムネイル画像の URL" /> -->
  <meta property="og:site_name" content="Yesod Typeclass" />
  <meta property="og:description" content="BIG MOON" />

  <meta name="twitter:card" content="summary" />
  <!-- <meta name="twitter:site" content="@[ Twitter ID]" /> -->
  <!-- <meta name="twitter:player" content="@[ Twitter ID]" /> -->

  <noscript>
  <div class="notice-warning noscript">You don't have javascript enabled. Good luck! :(</div>
</noscript>

<!--[if IE]>
  <div class="notice-warning">Oh, you are using Internet Explorer! Good luck... :(</div>
<![endif]-->

</head>


  <body>
    <header class="site-header">
      <nav class="nav-extended indigo lighten-1">
        <div class="nav-wrapper">
  <a href="../../"><span class="site-title">BIGMOON Haskeller's BLOG</span></a>
  <a href="#" data-activates="mobile-navbar" class="button-collapse">
    <i class="mdi mdi-menu white-text"></i>
  </a>

  <ul id="nav-mobile" class="right hide-on-med-and-down">
    <li>
      <a href="../../" class="white-text">
        <i class="mdi mdi-home left indigo-text text-lighten-3"></i>
        Home
      </a>
    </li>
    <li>
      <a href="../../about.html" class="white-text">
        <i class="mdi mdi-account-circle left indigo-text text-lighten-3"></i>
        About
      </a>
    </li>
    <li>
      <a href="../../stack/" class="white-text">
        <i class="mdi mdi-wrench left indigo-text text-lighten-3"></i>
        Stack
      </a>
    </li>
    <li>
      <a href="../../liquidhaskell/" class="white-text">
        <i class="mdi mdi-water left indigo-text text-lighten-3"></i>
        Liquid Haskell
      </a>
    </li>
    <li>
        <a href="../../yesod/" class="white-text">
          <i class="mdi mdi-earth left indigo-text text-lighten-3"></i>
          Yesod
        </a>
      </li>
    <li>
      <a href="../../feed.xml" class="white-text">
        <i class="mdi mdi-rss left indigo-text text-lighten-3"></i>
        Feed
      </a>
    </li>
  </ul>

  <ul class="side-nav" id="mobile-navbar">
    <li>
      <a href="../../" class="waves-effect waves-teal black-text">
        <i class="mdi mdi-home left green-text"></i>
        Home
      </a>
    </li>
    <li>
      <a href="../../about.html" class="navbar-text-colour-mobile">
        <i class="mdi mdi-account-circle left blue-text"></i>
        About
      </a>
    </li>
    <li>
      <a href="../../stack/" class="navbar-text-colour-mobile">
        <i class="mdi mdi-wrench left blue-text"></i>
        Stack
      </a>
    </li>
    <li>
      <a href="../../liquidhaskell/" class="navbar-text-colour-mobile">
        <i class="mdi mdi-water left blue-text"></i>
        LiquidHaskell
      </a>
    </li>
    <li>
      <a href="../../yesod/" class="navbar-text-colour-mobile">
        <i class="mdi mdi-earth left blue-text"></i>
        Yesod
      </a>
    </li>
    <li>
      <a href="../../feed.xml" class="navbar-text-colour-mobile">
        <i class="mdi mdi-rss left red-text"></i>
        Feed
      </a>
    </li>
  </ul>
</div>

      </nav>
    </header>

    <div class="site-container" id="tab-main">
      <div class="wrapper">
        <div class="post-ribbon"></div>

<div class="container page-container">
  <div class="post-page card-panel z-depth-2">
    <div class="post-section">
      <div class="post-heading">
        <h1 class="post-title">Yesod Typeclass</h1>
        
        <span>最終更新日: 2018/03/18</span>
        
      </div>

      <article class="page-content">
        <h2 id="yesod-typeclass">Yesod Typeclass</h2>
<p>あらゆる Yesod アプリケーションは <code>Yesod</code> 型クラスのインスタンスでなければなりません。 これまでのところ、これらのメソッドをデフォルトの実装に頼っていました。 この章では <code>Yesod</code> 型クラスにおける多くのメソッドの意味について探求していきます。</p>
<p><code>Yesod</code> 型クラスはアプリケーションの設定を定義するために利用されます。 全てのアプリケーションには、基本的なデフォルト定義が与えられていますが、より複雑な変更を加えたアプリケーションを構築するためには、たいていこれらメッソドのいくつかを上書きして使います。</p>
<p>“なせレコード型の代わりに型クラスを利用するのか？” という疑問があるかもしれません。 型クラスには、2つの主な利点があります。</p>
<ul>
<li>Yesod 型クラスのメソッドで別のメソッドを呼ぶことがあります。型クラスの場合、これは単純ですが、レコード型の場合には多少複雑になります</li>
<li>もう1つは、構文の単純さです。私たちはデフォルトの実装を提供し、ユーザが必要な機能だけを上書きできるようにしたいのです。型クラスで上書きすることは簡単ですし、構文的にも非常に優れています。また、レコード型には多少のオーバーヘッドがあります</li>
</ul>
<h2 id="rendering-and-parsing-urls">Rendering and Parsing URLs</h2>
<p>既に述べた通り、Yesod は自動的に型安全 URL を HTML ページに挿入可能なテキスト形式の URL にレンダリングできます。 例えば、次のようなルートがあったとしましょう。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1">mkYesod <span class="st">&quot;MyApp&quot;</span> [parseRoutes|</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">/some/path SomePathR GET</a>
<a class="sourceLine" id="cb1-3" data-line-number="3">]</a></code></pre></div>
<p>もし <code>SomePathR</code> を hamlet テンプレートに記述したとき、 Yesod は <code>SomePathR</code> をどのようにレンダリングするのでしょうか？ Yesod は常に絶対 URL を構成しようとします。 これは XML サイトマップや Atom フィードの生成、電子メールの送信などを考慮するためです。 しかし、絶対 URL を作るためには、アプリケーションのドメイン名を知る必要があります。</p>
<p>ドメイン名はユーザのリクエストから得られると考えるかもしれませんが、それ以外にもポート番号についても知る必要が同様にあります。 そして、たとえポート番号をリクエストから取得できたとしても、HTTP または HTTPS のどちらを用いればよいのでしょうか？ さらにそれを知ったとしても、そのような方法はユーザがどのようにリクエストを送信したかに応じて異なる URL が生成されることを意味します。 例えば、ユーザが <code>&quot;example.com&quot;</code> と <code>&quot;www.example.com&quot;</code> にアクセスしたとき、両者で異なる URL が生成されてしまいます。 サーチエンジン最適化の観点で考えると、ひとつの正規化された URL に統一したいでしょう。</p>
<p>最後に Yesod はアプリケーションをどこにホストしているかについて何の仮定もありません。 例えば、大部分は静的なサイト (<a href="http://static.example.com/" class="uri">http://static.example.com/</a>) ですが、 /wiki/ の位置に Yesod 製の Wiki を作りたいとしましょう。 そのとき、どのサブパスから Wiki がホストされているかについて、信頼できる方法でアプリケーションが決定することはできません。 なので、様々な予測をするのではなく、Yesod にアプリケーションのルートを教えます。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Yesod</span> <span class="dt">MyWiki</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    approot <span class="fu">=</span> <span class="dt">ApprootStatic</span> <span class="st">&quot;http://static.example.com/wiki&quot;</span></a></code></pre></div>
<p>末尾のスラッシュがないことに注意してください。 次に Yesod が <code>SomePathR</code> の URL を構成したい場合 <code>SomePathR</code> の相対パスは <code>/some/path</code> であることを決定し、それをアプリケーションのルートに付け加えます。 その結果 <code>http://static.example.com/wiki/some/path</code> ができあがります。</p>
<p><code>approot</code> のデフォルト値は <code>ApprootRelative</code> です。 これは本質的には “何の接頭辞も加えない” ということを意味するため、生成される URL は <code>/some/path</code> になります。 これは、アプリケーション内リンクの一般的なケースとドメインのルートにホストされたアプリケーションにおいては正しく機能します。 しかし、 (電子メールを送る場合のような) 絶対 URL が必要となる場合は <code>ApprootStatic</code> を利用するべきでしょう。</p>
<p><code>ApprootStatic</code> コンストラクタに加え <code>ApprootMaster</code> と <code>ApprootRequest</code> コンストラクタも利用可能です。 <code>Approotmaster</code> はアプリケーションルートをファウンデーション値から決定し、それによって例えば、アプリケーションルートを設定ファイルから読み込むことができます。 <code>ApprootRequest</code> はアプリケーションルートを決めるため、追加的にリクエスト値を利用できるため、ユーザが最初にサイトに対してどんなリクエストをしたかによって、異なるドメイン名にすることができます。</p>
<p>scaffolded サイトはデフォルトで <code>ApprootMaster</code> を使い、アプリケーションルートを <code>APPROOT</code> 環境変数、または設定ファイルから起動時に読み込みます。 そのため、テストまたは製品化ビルドで異なる設定を読み込み、ローカルホストのような1つのドメインをテストし、異なるドメインから受信することが簡単にできます。 そして、これらの値は設定ファイルから変更できます。</p>
<h3 id="joinpath">joinPath</h3>
<p>型安全 UR Lをテキスト値に変えるために Yesod は2つの補助関数を使います。 1つは <code>RenderRoot</code> 型クラスの <code>renderRoute</code> メソッドです。 あらゆる型安全 URL はこの型クラスのインスタンスとなります。 <code>renderRoute</code>は値をパス断片のリストに変換します。 例えば先ほどの <code>SomePathR</code> は <code>[&quot;some&quot;,&quot;path&quot;]</code> に変換されます。</p>
<p>実際には <code>renderRoute</code> はパス断片と、クエリ文字列パラメータのリストを生成します。 <code>rendeRoute</code> のデフォルト定義では、クエリ文字列パラメータは常に空リストですが、型クラスなのでメソッドを上書きして使うこともできます。 注目すべきケースは静的サブサイトであり、これはキャッシュ目的のためにファイルコンテンツのハッシュをクエリ文字列に追加します。</p>
<p>もう一方の関数は Yesod 型クラスの <code>joinPath</code> メソッドです。 この関数は以下の4つの引数を取ります。</p>
<ul>
<li>ファウンデーション値</li>
<li>アプリケーションルート</li>
<li>パス断片のリスト</li>
<li>クエリ文字列パラメータのリスト</li>
</ul>
<p>そして、テキスト形式の URL を返します。 デフォルトの実装では、パス断片を前方に現れるスラッシュで分離し、パス断片の前にアプリケーションルートを付け加え、パス断片の後ろにクエリ文字列を付け加えるというような、処理を行います。</p>
<p>もし、デフォルトの URL レンダリングで問題なければ特に変更する必要はありません。 しかし、末尾のスラッシュを追加するよう URL レンダリングを変えたい時などでは、メソッドを上書きする必要があります。</p>
<h3 id="cleanpath">cleanPath</h3>
<p><code>joinPath</code> の反対は <code>cleanPath</code> です。 これがディスパッチの処理でどのように使われているか見てみましょう。</p>
<ol type="1">
<li>ユーザからリクエストされたパス情報は、一連のパス断片に分割されます</li>
<li>パス断片を <code>cleanPath</code> 関数に渡します</li>
<li>もし <code>cleanPath</code> がリダイレクト (<code>Left</code>レスポンス) を返せば、301レスポンスがクライアントに送られます。そのため、強制的に正規化された URL とすることができます。 (例えば、余分なスラッシュを除去するなど)</li>
<li>その他の場合 <code>cleanPath</code> からのレスポンス (<code>Right</code>) を使って、ディスパッチを試し、もしこれが上手くいけばレスポンスを返します。そうでなければ、404を返します</li>
</ol>
<p>この組み合わせにより、サブサイトによる URL 表示の完全な制御が可能となりますが、マスターサイトが変形した URL を持つことも可能となります。 例を使って、どのようにすれば Yesod が常に末尾のスラッシュを含むようになるか確認してみましょう。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="ot">{-# LANGUAGE OverloadedStrings     #-}</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="ot">{-# LANGUAGE QuasiQuotes           #-}</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="ot">{-# LANGUAGE TemplateHaskell       #-}</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="ot">{-# LANGUAGE TypeFamilies          #-}</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Blaze.ByteString.Builder.Char.Utf8</span> (fromText)</a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="kw">import</span>           <span class="dt">Control.Arrow</span>                      ((***))</a>
<a class="sourceLine" id="cb3-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">Data.Monoid</span>                        (mappend)</a>
<a class="sourceLine" id="cb3-9" data-line-number="9"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span>                          <span class="kw">as</span> <span class="dt">T</span></a>
<a class="sourceLine" id="cb3-10" data-line-number="10"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.Encoding</span>                 <span class="kw">as</span> <span class="dt">TE</span></a>
<a class="sourceLine" id="cb3-11" data-line-number="11"><span class="kw">import</span>           <span class="dt">Network.HTTP.Types</span>                 (encodePath)</a>
<a class="sourceLine" id="cb3-12" data-line-number="12"><span class="kw">import</span>           <span class="dt">Yesod</span></a>
<a class="sourceLine" id="cb3-13" data-line-number="13"></a>
<a class="sourceLine" id="cb3-14" data-line-number="14"><span class="kw">data</span> <span class="dt">Slash</span> <span class="fu">=</span> <span class="dt">Slash</span></a>
<a class="sourceLine" id="cb3-15" data-line-number="15"></a>
<a class="sourceLine" id="cb3-16" data-line-number="16">mkYesod <span class="st">&quot;Slash&quot;</span> [parseRoutes|</a>
<a class="sourceLine" id="cb3-17" data-line-number="17">/ RootR GET</a>
<a class="sourceLine" id="cb3-18" data-line-number="18">/foo FooR GET</a>
<a class="sourceLine" id="cb3-19" data-line-number="19">|]</a>
<a class="sourceLine" id="cb3-20" data-line-number="20"></a>
<a class="sourceLine" id="cb3-21" data-line-number="21"><span class="kw">instance</span> <span class="dt">Yesod</span> <span class="dt">Slash</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-22" data-line-number="22">    joinPath _ ar pieces' qs' <span class="fu">=</span></a>
<a class="sourceLine" id="cb3-23" data-line-number="23">        fromText ar <span class="ot">`mappend`</span> encodePath pieces qs</a>
<a class="sourceLine" id="cb3-24" data-line-number="24">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-25" data-line-number="25">        qs <span class="fu">=</span> map (TE.encodeUtf8 <span class="fu">***</span> go) qs'</a>
<a class="sourceLine" id="cb3-26" data-line-number="26">        go <span class="st">&quot;&quot;</span> <span class="fu">=</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb3-27" data-line-number="27">        go x <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> TE.encodeUtf8 x</a>
<a class="sourceLine" id="cb3-28" data-line-number="28">        pieces <span class="fu">=</span> pieces' <span class="fu">++</span> [<span class="st">&quot;&quot;</span>]</a>
<a class="sourceLine" id="cb3-29" data-line-number="29"></a>
<a class="sourceLine" id="cb3-30" data-line-number="30">    <span class="co">-- We want to keep canonical URLs. Therefore, if the URL is missing a</span></a>
<a class="sourceLine" id="cb3-31" data-line-number="31">    <span class="co">-- trailing slash, redirect. But the empty set of pieces always stays the</span></a>
<a class="sourceLine" id="cb3-32" data-line-number="32">    <span class="co">-- same.</span></a>
<a class="sourceLine" id="cb3-33" data-line-number="33">    cleanPath _ [] <span class="fu">=</span> <span class="dt">Right</span> []</a>
<a class="sourceLine" id="cb3-34" data-line-number="34">    cleanPath _ s</a>
<a class="sourceLine" id="cb3-35" data-line-number="35">        <span class="fu">|</span> dropWhile (not <span class="fu">.</span> T.null) s <span class="fu">==</span> [<span class="st">&quot;&quot;</span>] <span class="fu">=</span> <span class="co">-- the only empty string is the last one</span></a>
<a class="sourceLine" id="cb3-36" data-line-number="36">            <span class="dt">Right</span> <span class="fu">$</span> init s</a>
<a class="sourceLine" id="cb3-37" data-line-number="37">        <span class="co">-- Since joinPath will append the missing trailing slash, we simply</span></a>
<a class="sourceLine" id="cb3-38" data-line-number="38">        <span class="co">-- remove empty pieces.</span></a>
<a class="sourceLine" id="cb3-39" data-line-number="39">        <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="dt">Left</span> <span class="fu">$</span> filter (not <span class="fu">.</span> T.null) s</a>
<a class="sourceLine" id="cb3-40" data-line-number="40"></a>
<a class="sourceLine" id="cb3-41" data-line-number="41"><span class="ot">getRootR ::</span> <span class="dt">Handler</span> <span class="dt">Html</span></a>
<a class="sourceLine" id="cb3-42" data-line-number="42">getRootR <span class="fu">=</span> defaultLayout</a>
<a class="sourceLine" id="cb3-43" data-line-number="43">    [whamlet|</a>
<a class="sourceLine" id="cb3-44" data-line-number="44">        <span class="kw">&lt;p&gt;</span></a>
<a class="sourceLine" id="cb3-45" data-line-number="45">            <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="kw">@{</span><span class="dt">RootR</span><span class="kw">}&gt;</span>RootR</a>
<a class="sourceLine" id="cb3-46" data-line-number="46">        <span class="kw">&lt;p&gt;</span></a>
<a class="sourceLine" id="cb3-47" data-line-number="47">            <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="kw">@{</span><span class="dt">FooR</span><span class="kw">}&gt;</span>FooR</a>
<a class="sourceLine" id="cb3-48" data-line-number="48">    |]</a>
<a class="sourceLine" id="cb3-49" data-line-number="49"></a>
<a class="sourceLine" id="cb3-50" data-line-number="50"><span class="ot">getFooR ::</span> <span class="dt">Handler</span> <span class="dt">Html</span></a>
<a class="sourceLine" id="cb3-51" data-line-number="51">getFooR <span class="fu">=</span> getRootR</a>
<a class="sourceLine" id="cb3-52" data-line-number="52"></a>
<a class="sourceLine" id="cb3-53" data-line-number="53"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-54" data-line-number="54">main <span class="fu">=</span> warp <span class="dv">3000</span> <span class="dt">Slash</span></a></code></pre></div>
<p>まず <code>joinPath</code> の実装を見てください。 これは1つを除いて Yesod のデフォルト実装からほとんど一語一句そのままにコピーされたものです。 異なる部分は、末尾に空文字列を余分に追加した点です。 パス断片を扱う場合、空文字列はさらにスラッシュを追加するため、余分な空文字列を追加することで、末尾のスラッシュを強制できるのです。</p>
<p><code>cleanPath</code> は少しトリッキーです。 まず、前のように空パスをチェックし、もし空パスならそのまま受け渡し、リダイレクトが不要なことを示すために <code>Right</code> を返します。 次の条件式では、起こり得る2つのURL問題を実際にチェックします。</p>
<ul>
<li>ダブルスラッシュがあり、それはパスの中心に空文字列として出現する</li>
<li>末尾のスラッシュが欠けており、空文字列では無い文字列が最後の断片として出現する</li>
</ul>
<p>これらどちらの状況も成り立たないと仮定すると、最後の断片のみが空であり、最後の断片を除き全てに基づいてディスパッチを行うべきです。 また、そうでない場合は正規化された URL にリダイレクトするために、<code>joinPath</code> が全ての空断片を取り除き、末尾にスラッシュを追加してくれます。</p>
<h2 id="defaultlayout">defaultLayout</h2>
<p>大部分のウェブサイトでは、何らかの一般的なテンプレートを全ページに適用させたいことがあります。 <code>defaultLayout</code> は、このために推奨される方法です。 同じくらい簡単に独自の関数を定義し代わりにそれを呼び出すことは可能ですが <code>defaultLayout</code> を上書きすることで、Yesod により生成された全てのページ (エラーページ、認証ページ) が自動的にこのスタイルとなります。</p>
<p>上書きしたい場合は <code>Widget</code> をタイトル、ヘッドタグ、ボディダグに変換するために <code>widgetToPageContent</code> を使い、そして Hamlet テンプレートを <code>Html</code> 値に変換するために <code>withUrlRendeler</code> を使えば良いです。 さらに <code>defaultLayout</code> 内において Lucius テンプレートのようなウィジェットコンポーネントをさらに追加することもできます。 詳細は、前章を確認してください。</p>
<p>scaffolded サイトを使っている場合は <code>templates/default-layout.hamlet</code> と <code>templates/default-layout-wrapper.hamlet</code> を変更します。 前者は大部分の <code>&lt;body&gt;</code> タグのコンテンツを含み、後者は doctype や <code>&lt;head&gt;</code> タグのような残りのHTMLを含みます。</p>
<h3 id="getmessage">getMessage</h3>
<p>まだセッションについては述べていないが、ここで <code>getMessage</code> について言及したいと思います。 ウェブ開発における一般的なパターンは、ひとつのハンドラでメッセージをセットし、別のハンドラで表示することです。 例えば、ユーザがフォームを <code>POST</code> した場合、 “フォーム提出は完了しました” のメッセージとともにリダイレクトさせたいです。 これは一般的に <a href="https://en.wikipedia.org/wiki/Post/Redirect/Get">Post/Redirect/Get</a> として知られています。</p>
<p>これを可能にするために Yesod は次の関数のペアを組み込みで用意しています。 <code>setMessage</code> はメッセージをユーザセッションにセットし <code>getMessage</code> はメッセージを回収します (そして、2回目に現れないよう削除します)。 そのため <code>getMessage</code> の結果を <code>defaultLayout</code> で表示することが推奨されています。 以下の例で確認してみましょう。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">{-# LANGUAGE OverloadedStrings     #-}</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ot">{-# LANGUAGE QuasiQuotes           #-}</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="ot">{-# LANGUAGE TemplateHaskell       #-}</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4"><span class="ot">{-# LANGUAGE TypeFamilies          #-}</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Yesod</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6"><span class="kw">import</span> <span class="dt">Data.Time</span> (getCurrentTime)</a>
<a class="sourceLine" id="cb4-7" data-line-number="7"></a>
<a class="sourceLine" id="cb4-8" data-line-number="8"><span class="kw">data</span> <span class="dt">App</span> <span class="fu">=</span> <span class="dt">App</span></a>
<a class="sourceLine" id="cb4-9" data-line-number="9"></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">mkYesod <span class="st">&quot;App&quot;</span> [parseRoutes|</a>
<a class="sourceLine" id="cb4-11" data-line-number="11">/ HomeR GET</a>
<a class="sourceLine" id="cb4-12" data-line-number="12">|]</a>
<a class="sourceLine" id="cb4-13" data-line-number="13"></a>
<a class="sourceLine" id="cb4-14" data-line-number="14"><span class="kw">instance</span> <span class="dt">Yesod</span> <span class="dt">App</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-15" data-line-number="15">    defaultLayout contents <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-16" data-line-number="16">        <span class="dt">PageContent</span> title headTags bodyTags <span class="ot">&lt;-</span> widgetToPageContent contents</a>
<a class="sourceLine" id="cb4-17" data-line-number="17">        mmsg <span class="ot">&lt;-</span> getMessage</a>
<a class="sourceLine" id="cb4-18" data-line-number="18">        withUrlRenderer [hamlet|</a>
<a class="sourceLine" id="cb4-19" data-line-number="19">            <span class="kw">$</span><span class="er">doctype</span> <span class="er">5</span></a>
<a class="sourceLine" id="cb4-20" data-line-number="20"></a>
<a class="sourceLine" id="cb4-21" data-line-number="21">            <span class="kw">&lt;html&gt;</span></a>
<a class="sourceLine" id="cb4-22" data-line-number="22">                <span class="kw">&lt;head&gt;</span></a>
<a class="sourceLine" id="cb4-23" data-line-number="23">                    <span class="kw">&lt;title&gt;#{</span>title<span class="kw">}</span></a>
<a class="sourceLine" id="cb4-24" data-line-number="24">                    <span class="kw">^{</span>headTags<span class="kw">}</span></a>
<a class="sourceLine" id="cb4-25" data-line-number="25">                <span class="kw">&lt;body&gt;</span></a>
<a class="sourceLine" id="cb4-26" data-line-number="26">                    <span class="kw">$maybe</span> msg <span class="ot">&lt;-</span> mmsg</a>
<a class="sourceLine" id="cb4-27" data-line-number="27">                        <span class="kw">&lt;div </span><span class="er">#message</span><span class="kw">&gt;#{</span>msg<span class="kw">}</span></a>
<a class="sourceLine" id="cb4-28" data-line-number="28">                    <span class="kw">^{</span>bodyTags<span class="kw">}</span></a>
<a class="sourceLine" id="cb4-29" data-line-number="29">        |]</a>
<a class="sourceLine" id="cb4-30" data-line-number="30"></a>
<a class="sourceLine" id="cb4-31" data-line-number="31"><span class="ot">getHomeR ::</span> <span class="dt">Handler</span> <span class="dt">Html</span></a>
<a class="sourceLine" id="cb4-32" data-line-number="32">getHomeR <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-33" data-line-number="33">    now <span class="ot">&lt;-</span> liftIO getCurrentTime</a>
<a class="sourceLine" id="cb4-34" data-line-number="34">    setMessage <span class="fu">$</span> toHtml <span class="fu">$</span> <span class="st">&quot;You previously visited at: &quot;</span> <span class="fu">++</span> show now</a>
<a class="sourceLine" id="cb4-35" data-line-number="35">    defaultLayout [whamlet|<span class="kw">&lt;p&gt;</span>Try refreshing|]</a>
<a class="sourceLine" id="cb4-36" data-line-number="36"></a>
<a class="sourceLine" id="cb4-37" data-line-number="37"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb4-38" data-line-number="38">main <span class="fu">=</span> warp <span class="dv">3000</span> <span class="dt">App</span></a></code></pre></div>
<p><code>getMessage</code>、<code>setMessage</code> については、セッションの章で詳細に触れます。</p>
<h2 id="custom-error-pages">Custom error pages</h2>
<p>プロフェッショナルなウェブサイトの証の1つとして、適切に設計されたエラーページが挙げられます。 Yesod はエラーページを表示するために、自動的に <code>defaultLayout</code> を利用しますが、もっと別の方法もあります。 それが <code>errorHandler</code> メソッドを上書きする方法です。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">{-# LANGUAGE OverloadedStrings     #-}</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="ot">{-# LANGUAGE QuasiQuotes           #-}</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="ot">{-# LANGUAGE TemplateHaskell       #-}</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="ot">{-# LANGUAGE TypeFamilies          #-}</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Yesod</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"><span class="kw">data</span> <span class="dt">App</span> <span class="fu">=</span> <span class="dt">App</span></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">mkYesod <span class="st">&quot;App&quot;</span> [parseRoutes|</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">/ HomeR GET</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">/error ErrorR GET</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">/not-found NotFoundR GET</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">|]</a>
<a class="sourceLine" id="cb5-14" data-line-number="14"></a>
<a class="sourceLine" id="cb5-15" data-line-number="15"><span class="kw">instance</span> <span class="dt">Yesod</span> <span class="dt">App</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-16" data-line-number="16">    errorHandler <span class="dt">NotFound</span> <span class="fu">=</span> fmap toTypedContent <span class="fu">$</span> defaultLayout <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-17" data-line-number="17">        setTitle <span class="st">&quot;Request page not located&quot;</span></a>
<a class="sourceLine" id="cb5-18" data-line-number="18">        toWidget [hamlet|</a>
<a class="sourceLine" id="cb5-19" data-line-number="19"><span class="kw">&lt;h1&gt;</span>Not Found</a>
<a class="sourceLine" id="cb5-20" data-line-number="20"><span class="kw">&lt;p&gt;</span>We apologize for the inconvenience, but the requested page could not be located.</a>
<a class="sourceLine" id="cb5-21" data-line-number="21">|]</a>
<a class="sourceLine" id="cb5-22" data-line-number="22">    errorHandler other <span class="fu">=</span> defaultErrorHandler other</a>
<a class="sourceLine" id="cb5-23" data-line-number="23"></a>
<a class="sourceLine" id="cb5-24" data-line-number="24"><span class="ot">getHomeR ::</span> <span class="dt">Handler</span> <span class="dt">Html</span></a>
<a class="sourceLine" id="cb5-25" data-line-number="25">getHomeR <span class="fu">=</span> defaultLayout</a>
<a class="sourceLine" id="cb5-26" data-line-number="26">    [whamlet|</a>
<a class="sourceLine" id="cb5-27" data-line-number="27">        <span class="kw">&lt;p&gt;</span></a>
<a class="sourceLine" id="cb5-28" data-line-number="28">            <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="kw">@{</span><span class="dt">ErrorR</span><span class="kw">}&gt;</span>Internal server error</a>
<a class="sourceLine" id="cb5-29" data-line-number="29">            <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="kw">@{</span><span class="dt">NotFoundR</span><span class="kw">}&gt;</span>Not found</a>
<a class="sourceLine" id="cb5-30" data-line-number="30">    |]</a>
<a class="sourceLine" id="cb5-31" data-line-number="31"></a>
<a class="sourceLine" id="cb5-32" data-line-number="32"><span class="ot">getErrorR ::</span> <span class="dt">Handler</span> ()</a>
<a class="sourceLine" id="cb5-33" data-line-number="33">getErrorR <span class="fu">=</span> error <span class="st">&quot;This is an error&quot;</span></a>
<a class="sourceLine" id="cb5-34" data-line-number="34"></a>
<a class="sourceLine" id="cb5-35" data-line-number="35"><span class="ot">getNotFoundR ::</span> <span class="dt">Handler</span> ()</a>
<a class="sourceLine" id="cb5-36" data-line-number="36">getNotFoundR <span class="fu">=</span> notFound</a>
<a class="sourceLine" id="cb5-37" data-line-number="37"></a>
<a class="sourceLine" id="cb5-38" data-line-number="38"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb5-39" data-line-number="39">main <span class="fu">=</span> warp <span class="dv">3000</span> <span class="dt">App</span> haskell</a></code></pre></div>
<p>ここでは、カスタマイズした404エラーページを指定します。 それぞれのエラー型に対して、カスタマイズしたハンドラを書きたくない場合は <code>defaultErrorHandler</code> を利用しましょう。 型の制約により <code>fmap toTypeContent</code> でメソッドで始める必要がありますが、典型的なハンドラ関数を書くことができます (<code>TypeContent</code>については、次の章で詳しく説明します)。</p>
<p>実際に、リダイレクトのような特別なレスポンスさえも利用可能です。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">errorHandler <span class="dt">NotFound</span> <span class="fu">=</span> redirect <span class="dt">HomeR</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">errorHandler other <span class="fu">=</span> defaultErrorHandler other</a></code></pre></div>
<p>上記のように行うことはできますが、実際にはこのような実践は推奨しません。 なぜなら、404は404そのものであるべきだからです。</p>
<h2 id="external-css-and-javascript">External CSS and Javascript</h2>
<p>ここで示された機能は scaffolded サイトの中に自動的に含まれるため、これらを自分自身で実装する必要はありません。</p>
<p>Yesod 型クラスにおける、最も強力かつ驚くべきメソッドは <code>addStaticContent</code> です。 ウィジェットは CSS、 Javascript を含む複数のコンポーネントで構成されていることを思い出してください。 CSS/JS は実際にはどのようにしてユーザのブラウザに表示されるのでしょうか？ デフォルトでは、それらはページの <code>&lt;head&gt;</code> の <code>&lt;style&gt;</code>、 <code>&lt;script&gt;</code> タグの中にそれぞれ配置されます。</p>
<p>これは単純かもしれませんが、効率的ではありません。 ページに何も変更が加えられていなくても、全てのページロードは CSS/JS を初めからロードする必要があるためです！ 本当にやりたいことは、このコンテンツを外部ファイルに保存し HTML から参照することです。</p>
<p>ここで <code>addStaticContent</code> が登場します。 この関数はコンテンツのファイル名における拡張子 (<code>css</code>, または <code>js</code>)、 コンテンツの MIME タイプ (<code>text/css</code>, または <code>text/javascript</code>)、 コンテンツ自体の3つの引数を取り、次の３つのうちどれか1つを返します。</p>
<h3 id="nothing">Nothing</h3>
<p>静的ファイルの保存が起こらない場合、このコンテンツを直接 HTML に埋め込みます。 これはデフォルトの挙動です。</p>
<h3 id="just-left-text">Just (Left Text)</h3>
<p>このコンテンツは外部ファイルに保存され、そのファイルを参照するためにテキスト形式のリンクを返します。</p>
<h3 id="just-right-route-a-query">Just (Right (Route a, Query))</h3>
<p>先ほどと同じですが、何らかのクエリ文字列パラメータとともに、型安全URLを返します。</p>
<p><code>Left</code> の結果は、静的ファイルを CDN やメモリバックサーバのような外部サーバに保存したい場合によく使われます。 <code>Right</code> の結果は、より一般的に用いられ、静的サブサイトにおいてよく使われます。 これは、大部分のアプリケーションにおいて推奨され、scaffolded サイトにおいてはデフォルトとなっています。</p>
<p>次のことを不思議に思うかもしれません。 もしこれが推奨される方法だとすれば、なぜデフォルトになっていないのでしょうか？ 問題としては、それは静的サブサイトの存在や、静的ファイルの場所など、普遍的には当てはまらないいくつかの仮定があるからです。</p>
<p>scaffolded された <code>addStaticContent</code> は便利ないくつかの賢い機能を提供します。</p>
<ul>
<li>hjsmin パッケージを用いて、自動的に Javascript ファイルを最小化します</li>
<li>ファイルコンテンツのハッシュに応じて、アウトプットファイルを名付けることができます。これは、古いコンテンツの心配なしに、遠い将来までキャッシュヘッダをセット可能なことを意味します</li>
<li>ファイル名はハッシュに基づいているため、同じ名前のファイルが存在しても、ファイル名を書き直す必要がないことが保証されています。scaffold コードは、自動的にそのようなファイルの存在を確認し、必要でなければ、コストのかかるディスクIOによる書き込みを回避します</li>
</ul>
<h2 id="smarter-static-files">Smarter Static Files</h2>
<p>グーグルは <a href="https://developers.google.com/speed/docs/insights/EnableCompression">静的ファイルを異なるドメインから受信せよ</a> という重要な最適化を推奨しています。 この方法による利点は、メインドメインにセットしたクッキーが静的ファイルを取り出す際に送信されないことで、帯域幅の節約になります。</p>
<p>これを可能にするために <code>urlRenderOverride</code> メソッドがあります。 このメソッドは、通常の URL レンダリングを中断し、何らかのルートに特定の値をセットします。 例えば scaffolding はこのメソッドを次のように定義しています。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">urlRenderOverride y (<span class="dt">StaticR</span> s) <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">    <span class="dt">Just</span> <span class="fu">$</span> uncurry (joinPath y (Settings.staticRoot <span class="fu">$</span> settings y)) <span class="fu">$</span> renderRoute s</a>
<a class="sourceLine" id="cb7-3" data-line-number="3"></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">urlRenderOverride _ _ <span class="fu">=</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>これは、静的ルートが特別な静的ルートから受信されることを意味し、そのルートは異なるドメインになるよう設定可能です。 これは、型安全URLの強力さと柔軟性の重要な例でもあり、たった1行のコードで、全てのハンドラを通して、静的ルートのレンダリングを変更することができてしまうのです。</p>
<h2 id="authenticationauthorization">Authentication/Authorization</h2>
<p>単純なアプリケーションにおいては、それぞれのハンドラ関数の中のパーミッションを確認することは簡単で便利なやり方です。 しかし、それはうまくスケーリングません。 結果的には、より宣言的な方法をとりたいと思うようになるだでしょう。 よくあるシステムでは ACL、特別な設定ファイル、そして多くの意味のわからない呪文を定義するでしょう。 Yesod においては、通常の Haskell を使います。</p>
<h3 id="iswriterequest">isWriteRequest</h3>
<p>現在のリクエストが “読み取り” あるいは “書き込み” 操作であるかどうかを決定します。 デフォルトでは、Yesod は RESTful 原則に従い <code>GET</code>、<code>HEAD</code>、 <code>OPTIONS</code>、 <code>TRACE</code> リクエストは読み取り専用であり、その他は書き込み可能として動作します。</p>
<h3 id="isauthorized">isAuthorized</h3>
<p>ルート (型安全URLなど) と、リクエストが書き込み可能なリクエストかどうかを示す真偽値を取ります。 それは、<code>AuthResult</code>を返し、これは、次の3つの内１つの値を取る。</p>
<ul>
<li>Authorized</li>
<li>AuthenticationRequired</li>
<li>Unauthorized</li>
</ul>
<p>デフォルトでは、あらゆるリクエストに対して <code>Authorized</code> を返します。</p>
<h3 id="authroute">authRoute</h3>
<p><code>isAuthorized</code> が <code>AuthenticationRequired</code> を返す場合、与えられたルートへリダイレクトします。 もし、ルートが与えられていない場合 (デフォルト) は、401 “要認証”　メッセージを返します。</p>
<p>これらのメソッドは yesod-auth パッケージとうまく結びつき、それは scaffolded サイトにおいて、 OpenID, Mozilla Persona、電子メール、ユーザ名、 Twitter のようないくつのもの認証オプションを提供するために利用されます。 より具体的な例については、認証の章において確認します。</p>
<h2 id="some-simple-settings">Some Simple Settings</h2>
<p>Yesod 型クラスにおける全てが複雑である訳ではありません。 中には、単純な関数のメソッドもあるので、どんなものがあるか見てみましょう。</p>
<h3 id="maximumcontentlength">maximumContentLength</h3>
<p>サービス拒否 (DOS) 攻撃を防止するために、Yesod はリクエストのボディサイズを制限する。 あるルート (例えば、ファイルのアップロードページなど) においては、この制限に引っかかる場合があると思います。 それが、この関数の使いどきです。</p>
<h3 id="fileupload">fileUpload</h3>
<p>リクエストのサイズに応じて どのようにアップロードされたファイルを扱うかを決定します。 2つのもっとも一般的な方法は、ファイルをメモリに保存すること、または、一時ファイルに流すことです。 デフォルトでは、小さなリクエストはメモリに保持され、大きなものはディスクに保存されます。</p>
<h3 id="shouldlog">shouldLog</h3>
<p>与えられたログメッセージ (関連づいたソースとレベル込みの) が、ログに送られるべきかどうかを決定します。 これにより、多くのデバッグ情報をアプリケーションに送ることが可能になりますが、常に利用するのではなく、必要な場合のみ使ってください。</p>
<p>最も最新の情報について Yesod 型クラスの Haddock API 文書を確認してください。</p>
<h2 id="まとめ">まとめ</h2>
<p>Yesod 型クラスは、アプリケーションの設定を可能にする多くの上書き可能なメソッドを持ちます。 それらを上書きするかどうかは全て任意であり、適切なデフォルト実装が提供されています。 <code>defaultLayout</code> や <code>getMessage</code> といった Yesod に組み込まれた方法を利用することで、エラーページや認証ページのような Yesod で自動生成されるページを含めて、サイト全体を通し一貫した見た目にすることができます。</p>
<p>この章においては Yesod 型クラスにおける全てのメソッドを取り上げた訳ではありません。 利用可能なメソッドの全リストについては Haddock 文書を参照してください。</p>
      </article>

      <div class="pager">
      
      
      </div>

      <div class="row">
        <div class="col s6 offset-s6" style="position: relative; height: 100px;">
          <div class="fixed-action-btn horizontal" style="position: absolute; display: inline-block; right: 24px;">
  <a class="btn-floating btn-large red">
    <i class="large material-icons">share</i>
  </a>
  <ul>
    <li>
      <a class="btn-floating waves-effect waves-light blue tooltipped" data-position="bottom" data-delay="20" data-tooltip="Share on Twitter" href="https://twitter.com/intent/tweet?text=Yesod Typeclass&url=https://haskell.e-bigmoon.com/yesod/book/ch06-yesod-typeclass.html"><i class="mdi mdi-twitter white-text"></i></a>
    </li>
    <li>
      <a class="btn-floating waves-effect waves-light indigo tooltipped" data-position="bottom" data-delay="20" data-tooltip="Share on Facebook" href="https://facebook.com/sharer.php?u=https://haskell.e-bigmoon.com/yesod/book/ch06-yesod-typeclass.html"><i class="mdi mdi-facebook white-text"></i></a>
    </li>
    <li>
      <a class="btn-floating waves-effect waves-light red tooltipped" data-position="bottom" data-delay="20" data-tooltip="Share on Google+" href="https://plus.google.com/share?url=https://haskell.e-bigmoon.com/yesod/book/ch06-yesod-typeclass.html"><i class="mdi mdi-google-plus white-text"></i></a>
    </li>
  </ul>
</div>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
    </div>

    <footer class="page-footer indigo lighten-1">

  <div class="footer-copyright">

    <div class="container">
      CopyRight © 2018 BIGMOON All Rights Reserved.&nbsp;
      Site proudly generated by <a class="red-text text-accent-1" href="http://jaspervdj.be/hakyll">Hakyll</a>,&nbsp;
      original Jekyll theme by <a class="red-text text-accent-1" href="https://github.com/mumuxme/materialize-jekyll">mumuxme</a>.
    </div>

  </div>

</footer>


    <!-- scrolltop button -->
    <button class="material-scrolltop waves-effect waves-light hide-on-small-only" type="button">
      <i class="mdi mdi-arrow-up-bold small white-text"></i>
    </button>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-19322672-9"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-19322672-9');
    </script>

    <!-- jquery -->
    <script type="text/javascript" src="../../lib/jquery-min.js"></script>
    <!-- materialize -->
    <script src="../../lib/materialize/js/materialize.min.js"></script>
    <!-- <\!-- Material ScrollTop plugin -\-> -->
    <script src="../../lib/material-scrolltop/material-scrolltop.js"></script>
    <!-- main -->
    <script src="../../js/init.js"></script>
    <script src="../../js/main.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/haskell.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>

</html>
