<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">

  <head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# article: http://ogp.me/ns/article#">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0" />
  <!-- MUST in hex format, may the same as header-color. This color is for android chrome browser. -->
  <meta name="theme-color" content="#5c6bc0">

  <!-- Metadata. -->
  <meta name="keywords" content="haskell,blog,bigmoon" />
  <title>Persistent</title>
  <meta name="description" content="BIG MOON">
  <link rel="canonical" href="../../yesod/book/ch10-persistent.html">
  <link rel="alternate" type="application/atom+xml" title="Persistent" href="../../feed.xml" />
  <link rel="shortcut icon" href="../../images/favicon.ico" />
  <meta name="google-site-verification" content="X2YNboLvzw3_bclXLMvohyJDqj68D06_hPDMukRbgTs" />

  <!-- Stylesheets. -->
  <link rel="stylesheet" href="../../lib/materialize/css/materialize.min.css" />
  <link rel="stylesheet" href="../../css/main.css" />
  <link media="all" rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/MaterialDesign-Webfont/3.3.92/css/materialdesignicons.min.css" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="../../lib/material-scrolltop/material-scrolltop.css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/agate.min.css" />
  

  <!-- OGP -->
  <meta property="og:title" content="Persistent" />
  <meta property="og:type" content="article" />
  <meta property="og:url" content="/yesod/book/ch10-persistent.html" />
  <!-- <meta property="og:image" content=" サムネイル画像の URL" /> -->
  <meta property="og:site_name" content="Persistent" />
  <meta property="og:description" content="BIG MOON" />

  <meta name="twitter:card" content="summary" />
  <!-- <meta name="twitter:site" content="@[ Twitter ID]" /> -->
  <!-- <meta name="twitter:player" content="@[ Twitter ID]" /> -->

  <noscript>
  <div class="notice-warning noscript">You don't have javascript enabled. Good luck! :(</div>
</noscript>

<!--[if IE]>
  <div class="notice-warning">Oh, you are using Internet Explorer! Good luck... :(</div>
<![endif]-->

</head>


  <body>
    <header class="site-header">
      <nav class="nav-extended indigo lighten-1">
        <div class="nav-wrapper">
  <a href="../../"><span class="site-title">BIGMOON Haskeller's BLOG</span></a>
  <a href="#" data-activates="mobile-navbar" class="button-collapse">
    <i class="mdi mdi-menu white-text"></i>
  </a>

  <ul id="nav-mobile" class="right hide-on-med-and-down">
    <li>
      <a href="../../" class="white-text">
        <i class="mdi mdi-home left indigo-text text-lighten-3"></i>
        Home
      </a>
    </li>
    <li>
      <a href="../../about.html" class="white-text">
        <i class="mdi mdi-account-circle left indigo-text text-lighten-3"></i>
        About
      </a>
    </li>
    <li>
      <a href="../../books/" class="white-text">
        <i class="mdi mdi-book-open left indigo-text text-lighten-3"></i>
        Books
      </a>
    </li>
    <li>
      <a href="../../stack/" class="white-text">
        <i class="mdi mdi-wrench left indigo-text text-lighten-3"></i>
        Development
      </a>
    </li>
    <li>
      <a href="../../quiz/" class="white-text">
        <i class="mdi mdi-comment-question-outline left indigo-text text-lighten-3"></i>
        Quiz
      </a>
    </li>
    <li>
      <a href="../../libraries/" class="white-text">
        <i class="mdi mdi-package-variant left indigo-text text-lighten-3"></i>
        Libraries
      </a>
    </li>
    <li>
      <a href="../../yesod/" class="white-text">
        <i class="mdi mdi-earth left indigo-text text-lighten-3"></i>
        Yesod
      </a>
    </li>
    <li>
      <a href="../../feed.xml" class="white-text">
        <i class="mdi mdi-rss left indigo-text text-lighten-3"></i>
        Feed
      </a>
    </li>
  </ul>

  <ul class="side-nav" id="mobile-navbar">
    <li>
      <a href="../../" class="waves-effect waves-teal black-text">
        <i class="mdi mdi-home left green-text"></i>
        Home
      </a>
    </li>
    <li>
      <a href="../../about.html" class="navbar-text-colour-mobile">
        <i class="mdi mdi-account-circle left blue-text"></i>
        About
      </a>
    </li>
    <li>
      <a href="../../books/" class="navbar-text-colour-mobile">
        <i class="mdi mdi-book-open left blue-text"></i>
        Books
      </a>
    </li>
    <li>
      <a href="../../stack/" class="navbar-text-colour-mobile">
        <i class="mdi mdi-wrench left blue-text"></i>
        Development
      </a>
    </li>
    <li>
      <a href="../../quiz/" class="navbar-text-colour-mobile">
        <i class="mdi mdi-comment-question-outline left blue-text"></i>
        Quiz
      </a>
    </li>
    <li>
      <a href="../../libraries/" class="navbar-text-colour-mobile">
        <i class="mdi mdi-package-variant left blue-text"></i>
        Libraries
      </a>
    </li>
    <li>
      <a href="../../yesod/" class="navbar-text-colour-mobile">
        <i class="mdi mdi-earth left blue-text"></i>
        Yesod
      </a>
    </li>
  </ul>
</div>

      </nav>
    </header>

    <div class="site-container" id="tab-main">
      <div class="wrapper">
        <div class="post-ribbon"></div>

<div class="container page-container">
  <div class="post-page card-panel z-depth-2">
    <div class="post-section">
      <div class="post-heading">
        <div style="float: right;">
          
          <span>記事公開日: 2018/03/18</span><br>
          
          
          <span>最終更新日: 2018/08/29</span>
          
        </div>
        <h1 class="post-title">Persistent</h1>
      </div>

      <article class="page-content">
        <h2 id="persistent">Persistent</h2>
<p>フォームはユーザとアプリケーションの境界を取り扱いました。 他に扱う必要のある境界はアプリケーションとストレージ間のレイヤです。 SQL データベース、YAML ファイル、バイナリ・ブロブのうち、SQL データベースとバイナリ・ブログのストレージレイヤはアプリケーションのデータ型を自然に理解できないので、何か手助けする必要があります。 Persistent は Haskell で型安全なデータストレージを統一的なデータストアインターフェースで扱うために Yesod で利用されます。</p>
<p>Haskell には多くの異なるデータベースバインディングがあります。 しかし、これらの大部分はスキーマに対する知識をほとんど持っていないため、有益な静的保証を与えることができません。 そのため、データベース依存の API やデータ型をプログラマに強要します。</p>
<p>Haskeller の中にはより革新的な方法を試した人もいます。 強く型付けされた Haskell のデータを容易に保存できる Haskell に特化したデータストアを作ることです。 この選択は特定の領域においては役に立ちますが、ライブラリによって提供されたストレージ技術に縛られるため、他の言語とうまく調和できません。</p>
<p>一方で Persistent は Haskell データ型の型安全性を維持しつつ、データストレージの利用目的ごとに高度にチューニングされた既存のデータベースを選択し、他のプログラム言語と同時に利用でき、安全で生産的なクエリインターフェースの利用が可能になります。</p>
<p>Persistent は型安全、正確さ、宣言的構文をガイドライン原理とします。 ほかの素晴らしい特徴を以下に挙げます。</p>
<ul>
<li>データベースに依存しません。PostgreSQL、 SQLite、 MySQL、 MongoDB と実験的に Redis をサポートしています</li>
<li>柔軟なデータモデリング。Persistent はモデル関係を定義し、それらを型安全な方法で利用できる。デフォルトの型安全 persistent API は join 操作をサポートしないことで、より広範な数のストレージレイヤを使えるようにしています。Join や他の SQL 特有の機能は、生の SQL レイヤを利用することで達成できます (かなり型安全性に乏しいが)。 付加的なライブラリである <a href="https://github.com/bitemyapp/esqueleto">Esqueleto</a> は Persistent データモデルの最上層に構築され、型安全な join や SQL の機能を追加しています。</li>
<li>開発環境のデータベースマイグレーションが自動化できるので、開発スピードがアップします。</li>
</ul>
<p>Persistent は Yesod と上手く機能しますが、単独でもスタンドアローンなライブラリとしてかなり役立ちます。 この章の大部分は単体の Persistent について説明しています。</p>
<h2 id="synopsis">Synopsis</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="ot">{-# LANGUAGE EmptyDataDecls             #-}</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="ot">{-# LANGUAGE FlexibleContexts           #-}</span></span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="ot">{-# LANGUAGE GADTs                      #-}</span></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses      #-}</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="ot">{-# LANGUAGE OverloadedStrings          #-}</span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="ot">{-# LANGUAGE QuasiQuotes                #-}</span></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="ot">{-# LANGUAGE TemplateHaskell            #-}</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="ot">{-# LANGUAGE TypeFamilies               #-}</span></span>
<span id="cb1-10"><a href="#cb1-10"></a><span class="kw">import</span>           <span class="dt">Control.Monad.IO.Class</span>  (liftIO)</span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="kw">import</span>           <span class="dt">Database.Persist</span></span>
<span id="cb1-12"><a href="#cb1-12"></a><span class="kw">import</span>           <span class="dt">Database.Persist.Sqlite</span></span>
<span id="cb1-13"><a href="#cb1-13"></a><span class="kw">import</span>           <span class="dt">Database.Persist.TH</span></span>
<span id="cb1-14"><a href="#cb1-14"></a></span>
<span id="cb1-15"><a href="#cb1-15"></a>share [mkPersist sqlSettings, mkMigrate <span class="st">&quot;migrateAll&quot;</span>] [persistLowerCase|</span>
<span id="cb1-16"><a href="#cb1-16"></a>Person</span>
<span id="cb1-17"><a href="#cb1-17"></a>    name String</span>
<span id="cb1-18"><a href="#cb1-18"></a>    age Int Maybe</span>
<span id="cb1-19"><a href="#cb1-19"></a>    deriving Show</span>
<span id="cb1-20"><a href="#cb1-20"></a>BlogPost</span>
<span id="cb1-21"><a href="#cb1-21"></a>    title String</span>
<span id="cb1-22"><a href="#cb1-22"></a>    authorId PersonId</span>
<span id="cb1-23"><a href="#cb1-23"></a>    deriving Show</span>
<span id="cb1-24"><a href="#cb1-24"></a>|]</span>
<span id="cb1-25"><a href="#cb1-25"></a></span>
<span id="cb1-26"><a href="#cb1-26"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1-27"><a href="#cb1-27"></a>main <span class="ot">=</span> runSqlite <span class="st">&quot;:memory:&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb1-28"><a href="#cb1-28"></a>    runMigration migrateAll</span>
<span id="cb1-29"><a href="#cb1-29"></a></span>
<span id="cb1-30"><a href="#cb1-30"></a>    johnId <span class="ot">&lt;-</span> insert <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;John Doe&quot;</span> <span class="op">$</span> <span class="dt">Just</span> <span class="dv">35</span></span>
<span id="cb1-31"><a href="#cb1-31"></a>    janeId <span class="ot">&lt;-</span> insert <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Jane Doe&quot;</span> <span class="dt">Nothing</span></span>
<span id="cb1-32"><a href="#cb1-32"></a></span>
<span id="cb1-33"><a href="#cb1-33"></a>    insert <span class="op">$</span> <span class="dt">BlogPost</span> <span class="st">&quot;My fr1st p0st&quot;</span> johnId</span>
<span id="cb1-34"><a href="#cb1-34"></a>    insert <span class="op">$</span> <span class="dt">BlogPost</span> <span class="st">&quot;One more for good measure&quot;</span> johnId</span>
<span id="cb1-35"><a href="#cb1-35"></a></span>
<span id="cb1-36"><a href="#cb1-36"></a>    oneJohnPost <span class="ot">&lt;-</span> selectList [<span class="dt">BlogPostAuthorId</span> <span class="op">==.</span> johnId] [<span class="dt">LimitTo</span> <span class="dv">1</span>]</span>
<span id="cb1-37"><a href="#cb1-37"></a>    liftIO <span class="op">$</span> <span class="fu">print</span> (<span class="ot">oneJohnPost ::</span> [<span class="dt">Entity</span> <span class="dt">BlogPost</span>])</span>
<span id="cb1-38"><a href="#cb1-38"></a></span>
<span id="cb1-39"><a href="#cb1-39"></a>    john <span class="ot">&lt;-</span> get johnId</span>
<span id="cb1-40"><a href="#cb1-40"></a>    liftIO <span class="op">$</span> <span class="fu">print</span> (<span class="ot">john ::</span> <span class="dt">Maybe</span> <span class="dt">Person</span>)</span>
<span id="cb1-41"><a href="#cb1-41"></a></span>
<span id="cb1-42"><a href="#cb1-42"></a>    delete janeId</span>
<span id="cb1-43"><a href="#cb1-43"></a>    deleteWhere [<span class="dt">BlogPostAuthorId</span> <span class="op">==.</span> johnId]</span></code></pre></div>
<p>上のスニペットの型注釈はコードのコンパイルには不要ですが、それぞれの値の型がわかるように明示的に追加しました。</p>
<h2 id="solving-the-boundary-issue">Solving the boundary issue</h2>
<p>SQL データベースに人間の情報を保存するとき、テーブルは次のようになるでしょう。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode sql"><code class="sourceCode sql"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> person(<span class="kw">id</span> SERIAL <span class="kw">PRIMARY</span> <span class="kw">KEY</span>, name <span class="dt">VARCHAR</span> <span class="kw">NOT</span> <span class="kw">NULL</span>, age <span class="dt">INTEGER</span>)</span></code></pre></div>
<p>PostgreSQL のようなデータベースを使っているなら、 age フィールドにテキストを絶対に格納しないことが保証されています。 (SQLite では同じことが言えませんが、今はそのことは忘れましょう) このデータベーステーブルを対応させるために、次のような Haskell データ型を作るでしょう。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">data</span> <span class="dt">Person</span> <span class="ot">=</span> <span class="dt">Person</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>    {<span class="ot"> personName ::</span> <span class="dt">Text</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    ,<span class="ot"> personAge  ::</span> <span class="dt">Int</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>    }</span></code></pre></div>
<p>全ては型安全のように見えます。 データベーススキーマは Haskell のデータ型と一致し、データベースによって不適切なデータは決してデータストアの中に入り込まないことが保証され、全てのものが素晴らしいように見えます。 それは、以下の出来事が起きなければの話です。</p>
<ul>
<li>データベースからデータを読み込むと、データベースレイヤは型付けされていない形式でデータを返します</li>
<li>32歳より年上の人を全員探すとき、偶然 SQL 文 に “thirtytwo” と書いてしまったとしましょう。何が起こると思いますか？これは正しくコンパイルされますが、実行時まで問題があることに気づけないでしょう</li>
<li>アルファベット順で初めの10人を探したいとしましょう。SQL でタイピングミスをするまでは大丈夫です。しかし、これも実行時まで見つけれらないでしょう</li>
</ul>
<p>動的言語はこれらの問題を解決するために単体テストを行いますが、間違う可能性のある全てのものに対しテストケースが網羅されていることを確実にする必要があります。 しかし、すでに気づいていると思いますが、それは Yesod のアプローチ法とは合いません。 私たちは可能な限り Haskell の強い型付けの利点を使って、データストレージが例外を投げないようにしたいのです。</p>
<p>従って、次のような疑問が残ります。 どうすれば Haskell の型システムを使ってそれを解決することができるんだろう？</p>
<h3 id="types">Types</h3>
<p>ルーティングの場合のように、型安全なデータアクセスについて本質的に難しいことは何もありません。 それは単に多くの単調で間違いやすいボイラプレートコードが必要になるだけです。 これはたいてい、型システムを使う良いタイミングであることを示しています。 また、退屈な仕事を避けるために Template Haskell を少しだけ使います。</p>
<p><code>PersistValue</code> は Persistent の基本的な構成要素です。 これはデータベースと値を送受信するための直和型で表現されるデータ構造です。</p>
<p>定義は以下のようになっています。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">data</span> <span class="dt">PersistValue</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>    <span class="ot">=</span> <span class="dt">PersistText</span> <span class="dt">Text</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="op">|</span> <span class="dt">PersistByteString</span> <span class="dt">ByteString</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>    <span class="op">|</span> <span class="dt">PersistInt64</span> <span class="dt">Int64</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>    <span class="op">|</span> <span class="dt">PersistDouble</span> <span class="dt">Double</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>    <span class="op">|</span> <span class="dt">PersistRational</span> <span class="dt">Rational</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>    <span class="op">|</span> <span class="dt">PersistBool</span> <span class="dt">Bool</span></span>
<span id="cb4-8"><a href="#cb4-8"></a>    <span class="op">|</span> <span class="dt">PersistDay</span> <span class="dt">Day</span></span>
<span id="cb4-9"><a href="#cb4-9"></a>    <span class="op">|</span> <span class="dt">PersistTimeOfDay</span> <span class="dt">TimeOfDay</span></span>
<span id="cb4-10"><a href="#cb4-10"></a>    <span class="op">|</span> <span class="dt">PersistUTCTime</span> <span class="dt">UTCTime</span></span>
<span id="cb4-11"><a href="#cb4-11"></a>    <span class="op">|</span> <span class="dt">PersistNull</span></span>
<span id="cb4-12"><a href="#cb4-12"></a>    <span class="op">|</span> <span class="dt">PersistList</span> [<span class="dt">PersistValue</span>]</span>
<span id="cb4-13"><a href="#cb4-13"></a>    <span class="op">|</span> <span class="dt">PersistMap</span> [(<span class="dt">Text</span>, <span class="dt">PersistValue</span>)]</span>
<span id="cb4-14"><a href="#cb4-14"></a>    <span class="op">|</span> <span class="dt">PersistObjectId</span> <span class="dt">ByteString</span></span>
<span id="cb4-15"><a href="#cb4-15"></a>    <span class="co">-- ^ Intended especially for MongoDB backend</span></span>
<span id="cb4-16"><a href="#cb4-16"></a>    <span class="op">|</span> <span class="dt">PersistDbSpecific</span> <span class="dt">ByteString</span></span>
<span id="cb4-17"><a href="#cb4-17"></a>    <span class="co">-- ^ Using 'PersistDbSpecific' allows you to use types</span></span>
<span id="cb4-18"><a href="#cb4-18"></a>    <span class="co">-- specific to a particular backend</span></span></code></pre></div>
<p>それぞれの Persistent のバックエンドは、関連する値をデータベースが理解出来る何らかの値へ翻訳する方法を知らなければなりません。 しかし、データ全てを単にこれらの基本的な型で表現しなくてはならないことはばかげています。 次のレイヤは <code>PersistField</code> 型クラスで、これは任意の Haskell データ型と <code>PersistValue</code> との相互変換について定義します。 <code>PersistField</code> は SQL データベースのカラムに対応します。 先ほどの “人間” の例で具体例を確認すると、名前と年齢はそれぞれ <code>PersistField</code> になります。</p>
<p>最後の型クラスはユーザー側のコードを結びつけるための <code>PersistEntity</code> です。 <code>PersistEntity</code> のインスタンスは SQL データベースのテーブルに対応します。 この型クラスは多数の関数や関連する型を定義しています。 Persistent と SQL の対応関係を整理すると次のようにまとめられます。</p>
<table>
<thead>
<tr class="header">
<th>SQL</th>
<th style="text-align: center;">Persistent</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DataTypes (VARCHAR, INTEGERなど)</td>
<td style="text-align: center;">PersistValue</td>
</tr>
<tr class="even">
<td>Column</td>
<td style="text-align: center;">PersistField</td>
</tr>
<tr class="odd">
<td>Table</td>
<td style="text-align: center;">PersistEntity</td>
</tr>
</tbody>
</table>
<h3 id="code-generation">Code Generation</h3>
<p>PersistEntity インスタンスが Haskell データ型と正確に一致することを確実にするために Persistent は両方の責任を持ちます。 エンティティを一度だけ定義すればよいのですから、これは DRY (自身を繰り返さない) の観点から素晴らしいものです。 簡単な例を見てみましょう。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="ot">{-# LANGUAGE GADTs                      #-}</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="ot">{-# LANGUAGE OverloadedStrings          #-}</span></span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="ot">{-# LANGUAGE QuasiQuotes                #-}</span></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="ot">{-# LANGUAGE TemplateHaskell            #-}</span></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="ot">{-# LANGUAGE TypeFamilies               #-}</span></span>
<span id="cb5-7"><a href="#cb5-7"></a><span class="kw">import</span> <span class="dt">Database.Persist</span></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="kw">import</span> <span class="dt">Database.Persist.TH</span></span>
<span id="cb5-9"><a href="#cb5-9"></a><span class="kw">import</span> <span class="dt">Database.Persist.Sqlite</span></span>
<span id="cb5-10"><a href="#cb5-10"></a><span class="kw">import</span> <span class="dt">Control.Monad.IO.Class</span> (liftIO)</span>
<span id="cb5-11"><a href="#cb5-11"></a></span>
<span id="cb5-12"><a href="#cb5-12"></a>mkPersist sqlSettings [persistLowerCase|</span>
<span id="cb5-13"><a href="#cb5-13"></a>Person</span>
<span id="cb5-14"><a href="#cb5-14"></a>    name String</span>
<span id="cb5-15"><a href="#cb5-15"></a>    age Int</span>
<span id="cb5-16"><a href="#cb5-16"></a>    deriving Show</span>
<span id="cb5-17"><a href="#cb5-17"></a>|]</span></code></pre></div>
<p>(ルートを定義するときのように) テンプレート Haskell と準クォートの組み合わせを利用します。 <code>persistLowerCase</code> は空白が意味を持つ構文をエンティティ定義のリストに変換する準クォートです。 “LowerCase” は生成されるテーブル名の形式を意味します。 今回の場合は <code>SomeTable</code> のようなエンティティは SQL テーブルでは <code>some_table</code> となります。 <code>persistentFileWith</code> を使えば、他のファイルにエンティティを定義することもできます。 <code>mkPersist</code> はエンティティリストを取り、次の宣言を定義します。</p>
<ul>
<li>各エンティティにつき、ひとつの Haskell データ型</li>
<li>定義された各データ型に対する <code>PersistEntity</code> インスタンス</li>
</ul>
<p>先ほどの例では、次のようなコードを生成します。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="ot">{-# LANGUAGE TypeFamilies, GeneralizedNewtypeDeriving, OverloadedStrings, GADTs #-}</span></span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="kw">import</span> <span class="dt">Database.Persist</span></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="kw">import</span> <span class="dt">Database.Persist.Sqlite</span></span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="kw">import</span> <span class="dt">Control.Monad.IO.Class</span> (liftIO)</span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb6-6"><a href="#cb6-6"></a></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="kw">data</span> <span class="dt">Person</span> <span class="ot">=</span> <span class="dt">Person</span></span>
<span id="cb6-8"><a href="#cb6-8"></a>    {<span class="ot"> personName ::</span> <span class="op">!</span><span class="dt">String</span></span>
<span id="cb6-9"><a href="#cb6-9"></a>    ,<span class="ot"> personAge ::</span> <span class="op">!</span><span class="dt">Int</span></span>
<span id="cb6-10"><a href="#cb6-10"></a>    }</span>
<span id="cb6-11"><a href="#cb6-11"></a>  <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb6-12"><a href="#cb6-12"></a></span>
<span id="cb6-13"><a href="#cb6-13"></a><span class="kw">type</span> <span class="dt">PersonId</span> <span class="ot">=</span> <span class="dt">Key</span> <span class="dt">Person</span></span>
<span id="cb6-14"><a href="#cb6-14"></a></span>
<span id="cb6-15"><a href="#cb6-15"></a><span class="kw">instance</span> <span class="dt">PersistEntity</span> <span class="dt">Person</span> <span class="kw">where</span></span>
<span id="cb6-16"><a href="#cb6-16"></a>    <span class="kw">newtype</span> <span class="dt">Key</span> <span class="dt">Person</span> <span class="ot">=</span> <span class="dt">PersonKey</span> (<span class="dt">BackendKey</span> <span class="dt">SqlBackend</span>)</span>
<span id="cb6-17"><a href="#cb6-17"></a>        <span class="kw">deriving</span> (<span class="dt">PersistField</span>, <span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Read</span>, <span class="dt">Ord</span>)</span>
<span id="cb6-18"><a href="#cb6-18"></a>    <span class="co">-- A Generalized Algebraic Datatype (GADT).</span></span>
<span id="cb6-19"><a href="#cb6-19"></a>    <span class="co">-- This gives us a type-safe approach to matching fields with</span></span>
<span id="cb6-20"><a href="#cb6-20"></a>    <span class="co">-- their datatypes.</span></span>
<span id="cb6-21"><a href="#cb6-21"></a>    <span class="kw">data</span> <span class="dt">EntityField</span> <span class="dt">Person</span> typ <span class="kw">where</span></span>
<span id="cb6-22"><a href="#cb6-22"></a>        <span class="dt">PersonId</span><span class="ot">   ::</span> <span class="dt">EntityField</span> <span class="dt">Person</span> <span class="dt">PersonId</span></span>
<span id="cb6-23"><a href="#cb6-23"></a>        <span class="dt">PersonName</span><span class="ot"> ::</span> <span class="dt">EntityField</span> <span class="dt">Person</span> <span class="dt">String</span></span>
<span id="cb6-24"><a href="#cb6-24"></a>        <span class="dt">PersonAge</span><span class="ot">  ::</span> <span class="dt">EntityField</span> <span class="dt">Person</span> <span class="dt">Int</span></span>
<span id="cb6-25"><a href="#cb6-25"></a></span>
<span id="cb6-26"><a href="#cb6-26"></a>    <span class="kw">data</span> <span class="dt">Unique</span> <span class="dt">Person</span></span>
<span id="cb6-27"><a href="#cb6-27"></a>    <span class="kw">type</span> <span class="dt">PersistEntityBackend</span> <span class="dt">Person</span> <span class="ot">=</span> <span class="dt">SqlBackend</span></span>
<span id="cb6-28"><a href="#cb6-28"></a></span>
<span id="cb6-29"><a href="#cb6-29"></a>    toPersistFields (<span class="dt">Person</span> name age) <span class="ot">=</span></span>
<span id="cb6-30"><a href="#cb6-30"></a>        [ <span class="dt">SomePersistField</span> name</span>
<span id="cb6-31"><a href="#cb6-31"></a>        , <span class="dt">SomePersistField</span> age</span>
<span id="cb6-32"><a href="#cb6-32"></a>        ]</span>
<span id="cb6-33"><a href="#cb6-33"></a></span>
<span id="cb6-34"><a href="#cb6-34"></a>    fromPersistValues [nameValue, ageValue] <span class="ot">=</span> <span class="dt">Person</span></span>
<span id="cb6-35"><a href="#cb6-35"></a>        <span class="op">&lt;$&gt;</span> fromPersistValue nameValue</span>
<span id="cb6-36"><a href="#cb6-36"></a>        <span class="op">&lt;*&gt;</span> fromPersistValue ageValue</span>
<span id="cb6-37"><a href="#cb6-37"></a>    fromPersistValues _ <span class="ot">=</span> <span class="dt">Left</span> <span class="st">&quot;Invalid fromPersistValues input&quot;</span></span>
<span id="cb6-38"><a href="#cb6-38"></a></span>
<span id="cb6-39"><a href="#cb6-39"></a>    <span class="co">-- Information on each field, used internally to generate SQL statements</span></span>
<span id="cb6-40"><a href="#cb6-40"></a>    persistFieldDef <span class="dt">PersonId</span> <span class="ot">=</span> <span class="dt">FieldDef</span></span>
<span id="cb6-41"><a href="#cb6-41"></a>        (<span class="dt">HaskellName</span> <span class="st">&quot;Id&quot;</span>)</span>
<span id="cb6-42"><a href="#cb6-42"></a>        (<span class="dt">DBName</span> <span class="st">&quot;id&quot;</span>)</span>
<span id="cb6-43"><a href="#cb6-43"></a>        (<span class="dt">FTTypeCon</span> <span class="dt">Nothing</span> <span class="st">&quot;PersonId&quot;</span>)</span>
<span id="cb6-44"><a href="#cb6-44"></a>        <span class="dt">SqlInt64</span></span>
<span id="cb6-45"><a href="#cb6-45"></a>        []</span>
<span id="cb6-46"><a href="#cb6-46"></a>        <span class="dt">True</span></span>
<span id="cb6-47"><a href="#cb6-47"></a>        <span class="dt">NoReference</span></span>
<span id="cb6-48"><a href="#cb6-48"></a>    persistFieldDef <span class="dt">PersonName</span> <span class="ot">=</span> <span class="dt">FieldDef</span></span>
<span id="cb6-49"><a href="#cb6-49"></a>        (<span class="dt">HaskellName</span> <span class="st">&quot;name&quot;</span>)</span>
<span id="cb6-50"><a href="#cb6-50"></a>        (<span class="dt">DBName</span> <span class="st">&quot;name&quot;</span>)</span>
<span id="cb6-51"><a href="#cb6-51"></a>        (<span class="dt">FTTypeCon</span> <span class="dt">Nothing</span> <span class="st">&quot;String&quot;</span>)</span>
<span id="cb6-52"><a href="#cb6-52"></a>        <span class="dt">SqlString</span></span>
<span id="cb6-53"><a href="#cb6-53"></a>        []</span>
<span id="cb6-54"><a href="#cb6-54"></a>        <span class="dt">True</span></span>
<span id="cb6-55"><a href="#cb6-55"></a>        <span class="dt">NoReference</span></span>
<span id="cb6-56"><a href="#cb6-56"></a>    persistFieldDef <span class="dt">PersonAge</span> <span class="ot">=</span> <span class="dt">FieldDef</span></span>
<span id="cb6-57"><a href="#cb6-57"></a>        (<span class="dt">HaskellName</span> <span class="st">&quot;age&quot;</span>)</span>
<span id="cb6-58"><a href="#cb6-58"></a>        (<span class="dt">DBName</span> <span class="st">&quot;age&quot;</span>)</span>
<span id="cb6-59"><a href="#cb6-59"></a>        (<span class="dt">FTTypeCon</span> <span class="dt">Nothing</span> <span class="st">&quot;Int&quot;</span>)</span>
<span id="cb6-60"><a href="#cb6-60"></a>        <span class="dt">SqlInt64</span></span>
<span id="cb6-61"><a href="#cb6-61"></a>        []</span>
<span id="cb6-62"><a href="#cb6-62"></a>        <span class="dt">True</span></span>
<span id="cb6-63"><a href="#cb6-63"></a>        <span class="dt">NoReference</span></span></code></pre></div>
<p>予想通り <code>Person</code> データ型は, もともとのテンプレート Haskell 版で与えた定義とかなり一致しています。 Generalised Algebraic Deta Type (GADT) はフィールド毎に戻り値の型が異なるコンストラクタを与えます。 この GADT はエンティティの型とフィールドの型の両方をエンコードしています。 そのコンストラクタは Persistent 全体を通して利用されます。 例えば、フィルタを適用する際にフィルタする値の型がフィールドに一致するか確認する場合です。 また、このエンティティのデータベースプライマリキーに対応する associated newtype 宣言があります。</p>
<p>Haskell の型と同様に生成された <code>Person</code> データ型を利用することができ、それを他の Persistent 関数に受け渡すことができます。</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a><span class="ot">{-# LANGUAGE EmptyDataDecls             #-}</span></span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="ot">{-# LANGUAGE FlexibleContexts           #-}</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="ot">{-# LANGUAGE GADTs                      #-}</span></span>
<span id="cb7-4"><a href="#cb7-4"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses      #-}</span></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="ot">{-# LANGUAGE OverloadedStrings          #-}</span></span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="ot">{-# LANGUAGE QuasiQuotes                #-}</span></span>
<span id="cb7-8"><a href="#cb7-8"></a><span class="ot">{-# LANGUAGE TemplateHaskell            #-}</span></span>
<span id="cb7-9"><a href="#cb7-9"></a><span class="ot">{-# LANGUAGE TypeFamilies               #-}</span></span>
<span id="cb7-10"><a href="#cb7-10"></a></span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="kw">import</span>           <span class="dt">Control.Monad.IO.Class</span>  (liftIO)</span>
<span id="cb7-12"><a href="#cb7-12"></a><span class="kw">import</span>           <span class="dt">Database.Persist</span></span>
<span id="cb7-13"><a href="#cb7-13"></a><span class="kw">import</span>           <span class="dt">Database.Persist.Sqlite</span></span>
<span id="cb7-14"><a href="#cb7-14"></a><span class="kw">import</span>           <span class="dt">Database.Persist.TH</span></span>
<span id="cb7-15"><a href="#cb7-15"></a><span class="kw">import</span>           <span class="dt">Control.Monad.IO.Unlift</span></span>
<span id="cb7-16"><a href="#cb7-16"></a><span class="kw">import</span>           <span class="dt">Data.Text</span></span>
<span id="cb7-17"><a href="#cb7-17"></a><span class="kw">import</span>           <span class="dt">Control.Monad.Reader</span></span>
<span id="cb7-18"><a href="#cb7-18"></a><span class="kw">import</span>           <span class="dt">Control.Monad.Logger</span></span>
<span id="cb7-19"><a href="#cb7-19"></a><span class="kw">import</span>           <span class="dt">Conduit</span></span>
<span id="cb7-20"><a href="#cb7-20"></a></span>
<span id="cb7-21"><a href="#cb7-21"></a>share [mkPersist sqlSettings, mkSave <span class="st">&quot;entityDefs&quot;</span>] [persistLowerCase|</span>
<span id="cb7-22"><a href="#cb7-22"></a>Person</span>
<span id="cb7-23"><a href="#cb7-23"></a>    name String</span>
<span id="cb7-24"><a href="#cb7-24"></a>    age Int Maybe</span>
<span id="cb7-25"><a href="#cb7-25"></a>    deriving Show</span>
<span id="cb7-26"><a href="#cb7-26"></a>|]</span>
<span id="cb7-27"><a href="#cb7-27"></a></span>
<span id="cb7-28"><a href="#cb7-28"></a><span class="ot">runSqlite' ::</span> (<span class="dt">MonadUnliftIO</span> m) <span class="ot">=&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">ReaderT</span> <span class="dt">SqlBackend</span> (<span class="dt">NoLoggingT</span> (<span class="dt">ResourceT</span> m)) a <span class="ot">-&gt;</span> m a</span>
<span id="cb7-29"><a href="#cb7-29"></a>runSqlite' <span class="ot">=</span> runSqlite</span>
<span id="cb7-30"><a href="#cb7-30"></a></span>
<span id="cb7-31"><a href="#cb7-31"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb7-32"><a href="#cb7-32"></a>main <span class="ot">=</span> runSqlite' <span class="st">&quot;:memory:&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb7-33"><a href="#cb7-33"></a>    michaelId <span class="ot">&lt;-</span> insert <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Michael&quot;</span> <span class="op">$</span> <span class="dt">Just</span> <span class="dv">26</span></span>
<span id="cb7-34"><a href="#cb7-34"></a>    michael <span class="ot">&lt;-</span> get michaelId</span>
<span id="cb7-35"><a href="#cb7-35"></a>    liftIO <span class="op">$</span> <span class="fu">print</span> michael</span></code></pre></div>
<blockquote>
<p>このコードはコンパイルできますが、テーブルが存在しないため実行時エラーとなります。以下でその問題についての対処法を説明します。</p>
</blockquote>
<p>標準的なデータベース接続コードから始めましょう。 この場合、単一コネクション関数を利用しました。 Persistent はコネクションプール関数を備え付けているため、一般的に製品版ではそちらを利用します。</p>
<p>この例では2つの関数が存在します。 <code>insert</code> はデータベースに新しいレコードを生成し、その ID を返します。 Persistent の他の全てのものと同様に ID は型安全です。 これらの ID がどのように機能するかについては後で詳しく説明します。 なので <code>insert $ Person "Michael" 26</code> を呼び出すと <code>PersonId</code> 型の値が返ってきます。</p>
<p>次は <code>Id</code> を使ってデータベースから値を読み込もうとする <code>get</code> 関数について説明します。 Persistent では、間違ったテーブルに対してキーを使ってしまう可能性はありません。 (<code>House</code>のような) 異なるエンティティを <code>PersonId</code> を使って読みこもうとしても、絶対にコンパイルできないからです。</p>
<h3 id="persiststore">PersistStore</h3>
<p>前の例で、一つだけ説明していない関数が残っていました。 <code>runSqlite</code> は正確には何を行って、どんなモナドでデータベースアクションが実行されているのでしょうか？</p>
<p>全てのデータベース操作は <code>PersistStore</code> インスタンスのパラメータが必要です。 その名前からわかるように、各データストア (PostgreSQL、SQLite、MongoDB) は <code>PersistStore</code> のインスタンスです。</p>
<p>この型クラスで <code>PersistValue</code> からデータベース特有の値へのあらゆる変換が起こり、SQL のクエリ生成などが始まります。</p>
<blockquote>
<p>想像できるように <code>PersistStore</code> は安全でしっかりと型付けされたインターフェースを外部の世界に提供します。そこには、間違いが起こってしまうような多くのデータベース操作が存在していますが、このコードを1つの場所で自動的にかつ徹底的にテストすることで、エラーに陥りやすいコードを集約し、できる限りバグが出ないようにできます。</p>
</blockquote>
<p><code>runsqlite</code> は与えられたコネクション文字列を使って単一コネクションを作ります。 今回の例ではインメモリデータベースの利用を表す <code>:memory</code> を使いました。 あらゆる SQL バックエンドは <code>SqlBackend</code> を <code>PersistStore</code> の共通のインスタンスとして使い、それぞれの定義を与えます。 そして <code>runSqlite</code> は <code>runReaderT</code> を使って、アクションに対し <code>SqlBackend</code> 値を環境パラメータとして扱います。</p>
<blockquote>
<p>実際には、<code>PersistUpdate</code> と <code>PersistQuery</code> という別の型クラスもあります。それぞれの型クラスが異なる機能を提供することで、 Persistent で利用可能な全ての高レベルな機能を提供できない (Redisのような) 単純なデータストアをバックエンドに利用することができる。</p>
</blockquote>
<p>ただ1つ注意すべき重要なことは <code>runSqlite</code> の1回の呼び出しの内部で起こるあらゆることが、単一トランザクションで実行されるということです。 これには2つの重要な意味を含んでいます。</p>
<ul>
<li>多くのデータベースで、トランザクションをコミットすることはコストのかかる動作です。複数のステップを単一のトランザクションに入れることでコードを劇的に高速化できます</li>
<li><code>runSqlite</code> の単一呼び出しどこかで例外が投げられた場合、全てのアクションは (バックエンドがロールバックサポートを持つことを想定しています) ロールバックされます</li>
</ul>
<blockquote>
<p>これは、実際には最初に思っていたよりも、とても大きなインパクトを与えます。リダイレクトのような Yesod における多くのショートカット関数は例外を用いて実装されています。もし、 Persistent ブロック内部からこのような呼び出しを行えば、それはトランザクション全体をロールバックしてしまうでしょう</p>
</blockquote>
<h2 id="migration">Migration</h2>
<p>ごめんなさい、これまでのところ少し嘘を付いていました。 少し前の例は実際には機能しません。 それを実行しようとすると、欠損テーブルに関するエラーが発生します。</p>
<p>SQL データベースの苦痛の1つにスキーマの変更管理があります。 明示的に指定すれば、ユーザの代わりに Persistent にこの作業を任せることもできます。 何が起こるか見てみましょう。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="ot">{-# LANGUAGE EmptyDataDecls             #-}</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="ot">{-# LANGUAGE FlexibleContexts           #-}</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="ot">{-# LANGUAGE GADTs                      #-}</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses      #-}</span></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="ot">{-# LANGUAGE OverloadedStrings          #-}</span></span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="ot">{-# LANGUAGE QuasiQuotes                #-}</span></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="ot">{-# LANGUAGE TemplateHaskell            #-}</span></span>
<span id="cb8-9"><a href="#cb8-9"></a><span class="ot">{-# LANGUAGE TypeFamilies               #-}</span></span>
<span id="cb8-10"><a href="#cb8-10"></a></span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="kw">import</span>           <span class="dt">Control.Monad.IO.Class</span>  (liftIO)</span>
<span id="cb8-12"><a href="#cb8-12"></a><span class="kw">import</span>           <span class="dt">Database.Persist</span></span>
<span id="cb8-13"><a href="#cb8-13"></a><span class="kw">import</span>           <span class="dt">Database.Persist.Sqlite</span></span>
<span id="cb8-14"><a href="#cb8-14"></a><span class="kw">import</span>           <span class="dt">Database.Persist.TH</span></span>
<span id="cb8-15"><a href="#cb8-15"></a><span class="kw">import</span>           <span class="dt">Control.Monad.IO.Unlift</span></span>
<span id="cb8-16"><a href="#cb8-16"></a><span class="kw">import</span>           <span class="dt">Data.Text</span></span>
<span id="cb8-17"><a href="#cb8-17"></a><span class="kw">import</span>           <span class="dt">Control.Monad.Reader</span></span>
<span id="cb8-18"><a href="#cb8-18"></a><span class="kw">import</span>           <span class="dt">Control.Monad.Logger</span></span>
<span id="cb8-19"><a href="#cb8-19"></a><span class="kw">import</span>           <span class="dt">Conduit</span></span>
<span id="cb8-20"><a href="#cb8-20"></a></span>
<span id="cb8-21"><a href="#cb8-21"></a>share [mkPersist sqlSettings, mkSave <span class="st">&quot;entityDefs&quot;</span>] [persistLowerCase|</span>
<span id="cb8-22"><a href="#cb8-22"></a>Person</span>
<span id="cb8-23"><a href="#cb8-23"></a>    name String</span>
<span id="cb8-24"><a href="#cb8-24"></a>    age Int Maybe</span>
<span id="cb8-25"><a href="#cb8-25"></a>    deriving Show</span>
<span id="cb8-26"><a href="#cb8-26"></a>|]</span>
<span id="cb8-27"><a href="#cb8-27"></a></span>
<span id="cb8-28"><a href="#cb8-28"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb8-29"><a href="#cb8-29"></a>main <span class="ot">=</span> runSqlite <span class="st">&quot;:memory:&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb8-30"><a href="#cb8-30"></a>    runMigration <span class="op">$</span> migrate entityDefs <span class="op">$</span> entityDef (<span class="dt">Nothing</span><span class="ot"> ::</span> <span class="dt">Maybe</span> <span class="dt">Person</span>)</span>
<span id="cb8-31"><a href="#cb8-31"></a>    michaelId <span class="ot">&lt;-</span> insert <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Michael&quot;</span> <span class="op">$</span> <span class="dt">Just</span> <span class="dv">26</span></span>
<span id="cb8-32"><a href="#cb8-32"></a>    michael <span class="ot">&lt;-</span> get michaelId</span>
<span id="cb8-33"><a href="#cb8-33"></a>    liftIO <span class="op">$</span> <span class="fu">print</span> michael</span></code></pre></div>
<p>先ほどのコードの1箇所をほんの少しだけ変更すれば Persistent は自動的に <code>Person</code> テーブルを作成します。 <code>runMigration</code> と <code>migrate</code> を分割することで複数のテーブルを同時マイグレーションが可能になります。</p>
<blockquote>
<p>注意: 自動データベースマイグレーション機能は開発環境にだけ利用することをおすすめします。プロダクション環境のデータベーススキーマが自動的に変更されてしまうのはめちゃめちゃヤバイと思います。自動化されたマイグレーションは開発スピードを速めるためにあります。そのため、プロダクション環境にデプロイする前に行う人手によるレビューやテストの代わりになるものではありません。</p>
</blockquote>
<p>これは、少しのエンティティであれば気になりませんが、多くのエンティティを扱うようになるとすぐに退屈なものになります。 この退屈な作業を自分で行う代わりに Persistent には <code>mkMigrate</code> という補助関数があります。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="ot">{-# LANGUAGE EmptyDataDecls             #-}</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="ot">{-# LANGUAGE FlexibleContexts           #-}</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="ot">{-# LANGUAGE GADTs                      #-}</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses      #-}</span></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="ot">{-# LANGUAGE OverloadedStrings          #-}</span></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="ot">{-# LANGUAGE QuasiQuotes                #-}</span></span>
<span id="cb9-8"><a href="#cb9-8"></a><span class="ot">{-# LANGUAGE TemplateHaskell            #-}</span></span>
<span id="cb9-9"><a href="#cb9-9"></a><span class="ot">{-# LANGUAGE TypeFamilies               #-}</span></span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="kw">import</span> <span class="dt">Database.Persist</span></span>
<span id="cb9-11"><a href="#cb9-11"></a><span class="kw">import</span> <span class="dt">Database.Persist.Sqlite</span></span>
<span id="cb9-12"><a href="#cb9-12"></a><span class="kw">import</span> <span class="dt">Database.Persist.TH</span></span>
<span id="cb9-13"><a href="#cb9-13"></a></span>
<span id="cb9-14"><a href="#cb9-14"></a>share [mkPersist sqlSettings, mkMigrate <span class="st">&quot;migrateAll&quot;</span>] [persistLowerCase|</span>
<span id="cb9-15"><a href="#cb9-15"></a>Person</span>
<span id="cb9-16"><a href="#cb9-16"></a>    name String</span>
<span id="cb9-17"><a href="#cb9-17"></a>    age Int</span>
<span id="cb9-18"><a href="#cb9-18"></a>    deriving Show</span>
<span id="cb9-19"><a href="#cb9-19"></a>Car</span>
<span id="cb9-20"><a href="#cb9-20"></a>    color String</span>
<span id="cb9-21"><a href="#cb9-21"></a>    make String</span>
<span id="cb9-22"><a href="#cb9-22"></a>    model String</span>
<span id="cb9-23"><a href="#cb9-23"></a>    deriving Show</span>
<span id="cb9-24"><a href="#cb9-24"></a>|]</span>
<span id="cb9-25"><a href="#cb9-25"></a></span>
<span id="cb9-26"><a href="#cb9-26"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb9-27"><a href="#cb9-27"></a>main <span class="ot">=</span> runSqlite <span class="st">&quot;:memory:&quot;</span> <span class="op">$</span> <span class="kw">do</span> runMigration migrateAll</span></code></pre></div>
<p><code>mkMigrate</code> はテンプレート Haskell 関数であり <code>persist</code> ブロックで定義した全てのエンティティに対し <code>migrate</code> を自動的に呼び出します。 <code>share</code> は <code>persist</code> ブロックからの情報を各テンプレート Haskell 関数に渡し結果を連結だけの補助関数です。</p>
<p>Persistent はかなり保守的なルールに従って、マイグレーションを実行します。 データベースからテーブル情報を読み込むことから始まり、SQL データ型を全て定義することで完了します。 そして、それをコードの中で与えられるエンティティ定義と比較します。 以下の場合は自動的にスキーマを入れ替えます。</p>
<ul>
<li>フィールドのデータ型の変更。しかし、データが翻訳できなかった場合は、おそらくデータベースはこの変更に反対します</li>
<li>フィールドの追加。しかし、フィールドが null でなく、初期値も設定されていない (初期値に関しては後で説明します)、そして、データベースに既存のデータが存在する場合, データベースはフィールドの追加を許可しません。</li>
<li>フィールドの not null から null への変更。逆の場合は Persistent はデータベースの承認次第で変換を行おうとします</li>
<li>新規エンティティの追加</li>
</ul>
<p>しかし、中には Persistent が自動的に処理できない場合があります。</p>
<ul>
<li>フィールドまたはエンティティの名前変更。Persistent は “name” が “fullName” に変更されたことを知る方法がありません。それが見ているのは “name” と呼ばれる古いフィールドか “fullName” と呼ばれる新しいフィールドです。</li>
<li>フィールドの削除。これはデータの消失につながるため Persistent はデフォルトでこのアクションを拒否しています(オススメしませんが <code>runMigration</code> の代わりに <code>runMigrationUnsafe</code> を用いることで削除を強制できます)</li>
</ul>
<p><code>runMigration</code> は実行中のマイグレーションを <code>stderr</code> (<code>runMigrationSilent</code> を使えば表示しないことも可能) に表示します。 そして、可能であれば常に <code>ALTER TABLE</code> を使います。 しかし SQlite では <code>ALTER TABLE</code> は非常に限定的な能力しかないため、 Persistent ではあるテーブルから別のテーブルへコピーする方法を仕方なく採用しました。</p>
<p>最後に、マイグレーションを実行する代わりに Persistent でどんなマイグレーションが必要なのかヒントが欲しい時は <code>printMigration</code> 関数を利用しましょう。 この関数は <code>runMigrate</code> が実行するマイグレーションを表示します。 これは Persistent が実行できないようなマイグレーションを行ったり、任意のSQLをマイグレーションに追加したり、どんなマイグレーションが起こったかについてログを出力するために役立つかもしれません。</p>
<h2 id="uniqueness">Uniqueness</h2>
<p>エンティティ内でフィールドを宣言する時に、一意性の制約を追加できます。 良くある例は、ユーザ名の一意性です。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="dt">User</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>    username <span class="dt">Text</span></span>
<span id="cb10-3"><a href="#cb10-3"></a>    <span class="dt">UniqueUsername</span> username</span></code></pre></div>
<p>各フィールド名は小文字で始まる必要がありますが、 Haskell のデータコンストラクタとして表現されるため、一意性の制約は大文字で始まる必要があります。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="ot">{-# LANGUAGE EmptyDataDecls             #-}</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="ot">{-# LANGUAGE FlexibleContexts           #-}</span></span>
<span id="cb11-3"><a href="#cb11-3"></a><span class="ot">{-# LANGUAGE GADTs                      #-}</span></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses      #-}</span></span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="ot">{-# LANGUAGE OverloadedStrings          #-}</span></span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="ot">{-# LANGUAGE QuasiQuotes                #-}</span></span>
<span id="cb11-8"><a href="#cb11-8"></a><span class="ot">{-# LANGUAGE TemplateHaskell            #-}</span></span>
<span id="cb11-9"><a href="#cb11-9"></a><span class="ot">{-# LANGUAGE TypeFamilies               #-}</span></span>
<span id="cb11-10"><a href="#cb11-10"></a><span class="kw">import</span> <span class="dt">Database.Persist</span></span>
<span id="cb11-11"><a href="#cb11-11"></a><span class="kw">import</span> <span class="dt">Database.Persist.Sqlite</span></span>
<span id="cb11-12"><a href="#cb11-12"></a><span class="kw">import</span> <span class="dt">Database.Persist.TH</span></span>
<span id="cb11-13"><a href="#cb11-13"></a><span class="kw">import</span> <span class="dt">Data.Time</span></span>
<span id="cb11-14"><a href="#cb11-14"></a><span class="kw">import</span> <span class="dt">Control.Monad.IO.Class</span> (liftIO)</span>
<span id="cb11-15"><a href="#cb11-15"></a></span>
<span id="cb11-16"><a href="#cb11-16"></a>share [mkPersist sqlSettings, mkMigrate <span class="st">&quot;migrateAll&quot;</span>] [persistLowerCase|</span>
<span id="cb11-17"><a href="#cb11-17"></a>Person</span>
<span id="cb11-18"><a href="#cb11-18"></a>    firstName String</span>
<span id="cb11-19"><a href="#cb11-19"></a>    lastName String</span>
<span id="cb11-20"><a href="#cb11-20"></a>    age Int</span>
<span id="cb11-21"><a href="#cb11-21"></a>    PersonName firstName lastName</span>
<span id="cb11-22"><a href="#cb11-22"></a>    deriving Show</span>
<span id="cb11-23"><a href="#cb11-23"></a>|]</span>
<span id="cb11-24"><a href="#cb11-24"></a></span>
<span id="cb11-25"><a href="#cb11-25"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb11-26"><a href="#cb11-26"></a>main <span class="ot">=</span> runSqlite <span class="st">&quot;:memory:&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb11-27"><a href="#cb11-27"></a>    runMigration migrateAll</span>
<span id="cb11-28"><a href="#cb11-28"></a>    insert <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Michael&quot;</span> <span class="st">&quot;Snoyman&quot;</span> <span class="dv">26</span></span>
<span id="cb11-29"><a href="#cb11-29"></a>    michael <span class="ot">&lt;-</span> getBy <span class="op">$</span> <span class="dt">PersonName</span> <span class="st">&quot;Michael&quot;</span> <span class="st">&quot;Snoyman&quot;</span></span>
<span id="cb11-30"><a href="#cb11-30"></a>    liftIO <span class="op">$</span> <span class="fu">print</span> michael</span></code></pre></div>
<p>フィールドのユニークな組み合わせを宣言するために、新たに1行追加します。 行が大文字で始まるため Persistent はユニークコンストラクタを定義していることを知っています。 続く各単語はこのエンティティにおけるフィールドでなければなりません。</p>
<p>一意性における主な制約は non-null フィールドにのみ適用可能ということです。 その理由は、SQLは標準で一意性が <code>NULL</code> に対してどのように適用されるかについて曖昧だからです。 (例えば <code>NULL=NULL</code> は真なのか偽なのか)。 その曖昧さに加え、大部分の SQL は実際に Haskell のデータ型の期待するものに反する規則を実装しています (例えば PostgreSQL では <code>NULL=NULL</code> は偽ですが、一方で Haskell で <code>Nothing==Nothing</code> は真です)。</p>
<p>さらに、一意性の制約はデータベースレベルでのデータの一貫性について素晴らしい保証を与えるとともに、上記の例の <code>getBy</code> のように Haskell のコードで何らかの特別なクエリを実行するためにも利用されます。 これは <code>Unique</code> 関連型として扱い、上記の例においては、次のような新しいコンストラクタが出てくるでしょう。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="dt">PersonName</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Unique</span> <span class="dt">Person</span></span></code></pre></div>
<blockquote>
<p>MongoDB のバックエンドでは一意性の制約は作られないため、ユニークインデックスをフィールドに指定しなければなりません。</p>
</blockquote>
<h2 id="queries">Queries</h2>
<p>目的に応じてデータベースに問い合わせをするための異なる方法が存在します。 数値 ID に基づいて問い合わせをするものもあれば、フィルタを行うものもあります。 クエリは返す結果の数においても異なります。 検索の中には (検索キーが一意であれば) 1つしか結果を返さないものもあれば、多くの結果を返すものも存在します。</p>
<p>そのため Persistent にはいくつかの異なるクエリ関数が用意されています。 いつも通り、できる限り多くの不変量を型の中にエンコードします。 例えば 0 または 1 の結果しか返さないクエリは <code>Maybe</code> 型を利用し、一方で多くの結果を返すクエリはリストとして返します。</p>
<h3 id="fetching-by-id">Fetching by ID</h3>
<p>Persistent で実行できる最も簡単なクエリは ID に基づいて取得を行うことです。 この値は存在しない場合があるため、その戻り値は <code>Maybe</code> 型となっています。 </p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a>personId <span class="ot">&lt;-</span> insert <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Michael&quot;</span> <span class="st">&quot;Snoyman&quot;</span> <span class="dv">26</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>maybePerson <span class="ot">&lt;-</span> get personId</span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="kw">case</span> maybePerson <span class="kw">of</span></span>
<span id="cb13-4"><a href="#cb13-4"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> liftIO <span class="op">$</span> <span class="fu">putStrLn</span> <span class="st">&quot;Just kidding, not really there&quot;</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>    <span class="dt">Just</span> person <span class="ot">-&gt;</span> liftIO <span class="op">$</span> <span class="fu">print</span> person</span></code></pre></div>
<p>これは <code>/person/5</code> のような URL を与えるサイトにおいて非常に役立ちます。 しかし、このような場合たいてい <code>Maybe</code> についてはあまり気にせずただ値だけが欲しいため、見つからなかった場合は 404 メッセージを返します。 <code>get404</code> 関数 (yesod-persistent パッケージにあります) はまさにそのように動作する関数です。 詳しくは Yesod と統合するときに説明します。</p>
<h3 id="fetching-by-unique-constraint">Fetching by unique constraint</h3>
<p><code>getBy</code> は以下の点を除けば <code>get</code> と同じです。</p>
<ol type="1">
<li>一意性の制約を取ります。つまり、ID の代わりに <code>Unique</code> 値を取ります</li>
<li>値の代わりに <code>Entity</code> を返します。<code>Entity</code> はデータベース ID と値の組み合わせです</li>
</ol>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a>personId <span class="ot">&lt;-</span> insert <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Michael&quot;</span> <span class="st">&quot;Snoyman&quot;</span> <span class="dv">26</span></span>
<span id="cb14-2"><a href="#cb14-2"></a>maybePerson <span class="ot">&lt;-</span> getBy <span class="op">$</span> <span class="dt">PersonName</span> <span class="st">&quot;Michael&quot;</span> <span class="st">&quot;Snoyman&quot;</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="kw">case</span> maybePerson <span class="kw">of</span></span>
<span id="cb14-4"><a href="#cb14-4"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> liftIO <span class="op">$</span> <span class="fu">putStrLn</span> <span class="st">&quot;Just kidding, not really there&quot;</span></span>
<span id="cb14-5"><a href="#cb14-5"></a>    <span class="dt">Just</span> (<span class="dt">Entity</span> personId person) <span class="ot">-&gt;</span> liftIO <span class="op">$</span> <span class="fu">print</span> person</span></code></pre></div>
<p><code>get404</code> と 同様に <code>getBy404</code> 関数もあります。</p>
<h3 id="select-functions">Select functions</h3>
<p>多くの場合、もっと強力なクエリが必要となるでしょう。 例えば、ある年齢以上の人、青い色で利用可能な全ての車、電子メールアドレスの登録が無いユーザ全体などを見つけたい場合です。 このためには選択関数が1つ必要です。</p>
<p>あらゆる選択関数はわずかに結果が異なりますが、似たようなインターフェースとなっています。</p>
<table>
<colgroup>
<col style="width: 38%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr class="header">
<th>関数</th>
<th style="text-align: center;">戻り値</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>selectSource</td>
<td style="text-align: center;"><code>Sorce</code> はデータベースから全ての ID と値を含みます。この関数でストリーミングコードを記述できます。<code>Source</code> はデータのストリームであり <code>conduit</code> パッケージの一部です。この関数を使う前に <a href="https://www.schoolofhaskell.com/user/snoyberg/library-documentation/conduit-overview">School of Haskell conduit tutorial</a> を読むことをオススメします</td>
</tr>
<tr class="even">
<td>selectList</td>
<td style="text-align: center;">データベースから全ての ID と値をリストとして返します</td>
</tr>
<tr class="odd">
<td>selectFirst</td>
<td style="text-align: center;">利用できれば、データベースから最初の ID と値を取り出すだけです</td>
</tr>
<tr class="even">
<td>selectKeys</td>
<td style="text-align: center;"><code>Source</code> として値を含まないキーだけを返します</td>
</tr>
</tbody>
</table>
<p><code>selectList</code> は最も一般的に利用されるため特に詳しく説明します。 <code>selectList</code> が理解できれば、他の関数を理解することも簡単でしょう。</p>
<p><code>selectList</code> は <code>Filter</code> のリストと <code>SelectOpt</code> のリストの2つの引数を取ります。<code>Filter</code> は “等号, より小さい、含む” などの演算に基づいて結果を制限します。 <code>SelectOpt</code> は並び替え、出力行数の制限、結果のオフセットといった3つの異なる機能を制御します。</p>
<blockquote>
<p>ウェブアプリケーションの効率的なページネーションが可能になるため、制限とオフセットの組み合わせは非常に重要です。</p>
</blockquote>
<p>フィルタリングの例に進みんで、それを分析してみましょう。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a>people <span class="ot">&lt;-</span> selectList [<span class="dt">PersonAge</span> <span class="op">&gt;.</span> <span class="dv">25</span>, <span class="dt">PersonAge</span> <span class="op">&lt;=.</span> <span class="dv">30</span>] []</span>
<span id="cb15-2"><a href="#cb15-2"></a>liftIO <span class="op">$</span> <span class="fu">print</span> people</span></code></pre></div>
<p>単純な例なので、３つの点だけ説明すれば大丈夫でしょう。</p>
<ol type="1">
<li><code>PersonAge</code> は関連ファントム型のコンストラクタです。この単語は強そうに聞こえますが、重要なことは一意的に “person” テーブルの “age” カラムが特定され、 <code>age</code> フィールドが <code>Int</code> であることが分かるという点です (そこがファントムの部分です)</li>
<li>Persistent フィルタリング演算子は何種類か用意されています。記法はとても覚えやすく、想定する演算子の最後にピリオドを置くだけです。3つだけ、わかりづらい演算子があるので別途説明します</li>
<li>フィルタのリストは <code>AND</code> で結合されるので、上記の例は “年齢が25より大きく、30以下” を意味します。<code>OR</code> で結合する方法は後で説明します</li>
</ol>
<p>びっくりするような名前の演算子が “ノットイコール” です。 <code>/=</code> はアップデート (後で説明する、分割とセット) に使われるため <code>!=</code> を利用します。 コンパイラが指摘してくれるため、もし間違って使ってしまった場合でも大丈夫です。</p>
<p>“含む”、“含まない” 演算子もあまり直感的ではなく、それぞれ <code>&lt;-.</code> と <code>/&lt;-.</code> になります。 (どちらもピリオドで終わります)</p>
<p>そして <code>OR</code> については <code>||.</code> 演算子を利用します。 以下に例を示します。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a>people <span class="ot">&lt;-</span> selectList</span>
<span id="cb16-2"><a href="#cb16-2"></a>    (       [<span class="dt">PersonAge</span> <span class="op">&gt;.</span> <span class="dv">25</span>, <span class="dt">PersonAge</span> <span class="op">&lt;=.</span> <span class="dv">30</span>]</span>
<span id="cb16-3"><a href="#cb16-3"></a>        <span class="op">||.</span> [<span class="dt">PersonFirstName</span> <span class="op">/&lt;-.</span> [<span class="st">&quot;Adam&quot;</span>, <span class="st">&quot;Bonny&quot;</span>]]</span>
<span id="cb16-4"><a href="#cb16-4"></a>        <span class="op">||.</span> ([<span class="dt">PersonAge</span> <span class="op">==.</span> <span class="dv">50</span>] <span class="op">||.</span> [<span class="dt">PersonAge</span> <span class="op">==.</span> <span class="dv">60</span>])</span>
<span id="cb16-5"><a href="#cb16-5"></a>    )</span>
<span id="cb16-6"><a href="#cb16-6"></a>    []</span>
<span id="cb16-7"><a href="#cb16-7"></a>liftIO <span class="op">$</span> <span class="fu">print</span> people</span></code></pre></div>
<p>この (完全に意味のない) 例は “年齢が 26-30 の人” または “名前が Adam でも Bonny でもない人” または “年齢が50” または “60の人” を見つけます。</p>
<h3 id="selectopt">SelectOpt</h3>
<p>これまで見てきた全 <code>selectList</code> の利用方法では全て第2引数を空リストにしていました。 それはオプションを指定しないため、データベースが望むようにソートし、どの結果も飛ばさずに、全ての結果を返すということを意味します。 <code>SelectOpt</code> はそれら全てを変更するために4つのコンストラクタがあります。</p>
<h4 id="asc">Asc</h4>
<p>昇順で与えられたカラムを並び替えます。 これは <code>PersonAge</code> のようにフィルタリングと同じファントム型を使います。</p>
<h4 id="desc">Desc</h4>
<p><code>Asc</code> と同じですが、降順です。</p>
<h4 id="limitto">LimitTo</h4>
<p><code>Int</code> 引数を取ります。 指定された数まで結果を返します。</p>
<h4 id="offsetby">OffsetBy</h4>
<p><code>Int</code> 引数を取ります。 指定された数だけ結果をスキップします</p>
<p>次のコードは結果をページに分割する関数を定義します。 それは18歳以上で、彼らを (最も年を取っている人を最初とし) 年齢で並び替えた結果を返します。 年齢が同じ人については、名前、苗字のアルファベット順で並び替えます。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a>resultsForPage pageNumber <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb17-2"><a href="#cb17-2"></a>    <span class="kw">let</span> resultsPerPage <span class="ot">=</span> <span class="dv">10</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>    selectList</span>
<span id="cb17-4"><a href="#cb17-4"></a>        [ <span class="dt">PersonAge</span> <span class="op">&gt;=.</span> <span class="dv">18</span></span>
<span id="cb17-5"><a href="#cb17-5"></a>        ]</span>
<span id="cb17-6"><a href="#cb17-6"></a>        [ <span class="dt">Desc</span> <span class="dt">PersonAge</span></span>
<span id="cb17-7"><a href="#cb17-7"></a>        , <span class="dt">Asc</span> <span class="dt">PersonLastName</span></span>
<span id="cb17-8"><a href="#cb17-8"></a>        , <span class="dt">Asc</span> <span class="dt">PersonFirstName</span></span>
<span id="cb17-9"><a href="#cb17-9"></a>        , <span class="dt">LimitTo</span> resultsPerPage</span>
<span id="cb17-10"><a href="#cb17-10"></a>        , <span class="dt">OffsetBy</span> <span class="op">$</span> (pageNumber <span class="op">-</span> <span class="dv">1</span>) <span class="op">*</span> resultsPerPage</span>
<span id="cb17-11"><a href="#cb17-11"></a>        ]</span></code></pre></div>
<h2 id="manipulation">Manipulation</h2>
<p>クエリを学習したことで、やっと本章の半分が終わりました。 これから、データベースに値を追加したり、既存のデータを変更したりする方法を見ていきましょう。</p>
<h3 id="insert">Insert</h3>
<p>データベースのデータを操作できることは良いことです。 しかし、データを操作するためには何をすれば良いでしょうか？ 答えは <code>insert</code> 関数です。 この関数はデータベースに値を与えると ID が返ってきます。</p>
<p>ここで Persistent の理念について少し触れておきましょう。 多くの ORM 解決策ではデータ格納に使われるデータ型が不明瞭です。 データを取得・変更するために定義されたインターフェースを経由する必要があります。 これは Persistent には当てはまらず、全てに通常の代数的データ型が使われています。 そのため、パターンマッチ、カリー化など、様々な素晴らしい利点を得られます。</p>
<p>しかし、できないこともあります。 例えば Haskell のレコードが更新されるごとにデータベースの値を自動的に更新する方法がないことです。 もちろん Haskell における純粋性と不変性の通常の考え方からすれば、このことはいずれにせよあまり重要でないので、気にすることではありません。</p>
<p>しかし、新規利用者が悩まされる1つの問題があります。 なぜ ID と値が完全に独立しているのでしょうか？ ID を値に埋め込むことは、かなり論理的に見えます。 つまり、なぜ</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">data</span> <span class="dt">Person</span> <span class="ot">=</span> <span class="dt">Person</span> {<span class="ot"> name ::</span> <span class="dt">String</span> }</span></code></pre></div>
<p>とする代わりに</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">data</span> <span class="dt">Person</span> <span class="ot">=</span> <span class="dt">Person</span> {<span class="ot"> personId ::</span> <span class="dt">PersonId</span>,<span class="ot"> name ::</span> <span class="dt">String</span> }</span></code></pre></div>
<p>としないのだろうか？ということです。</p>
<p>こうすると、すぐに1つの問題が発生します。 どのように <code>insert</code> を行えば良いのでしょうか？ Person が ID を含む必要があるのであれば ID を挿入によって得ることができますが、挿入は Person が必要となり、終了しないループに陥ります。 これは <code>undefined</code> で解決できますが、それは単に面倒を起こしているだけです。</p>
<p>少しだけ安全にしたら良いと言うかも知れません。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1"></a><span class="kw">data</span> <span class="dt">Person</span> <span class="ot">=</span> <span class="dt">Person</span> {<span class="ot"> personId ::</span> <span class="dt">Maybe</span> <span class="dt">PersonId</span>,<span class="ot"> name ::</span> <span class="dt">String</span> }</span></code></pre></div>
<p><code>insert $ Person undefined "Michael"</code> よりも <code>insert $ Person Nothing "Michael"</code> の方が確実に好まれます。 そして、今の型はずっと単純になったでしょう？ 例えば <code>selectList</code> は <code>[Entity SqlPersist Person]</code> の代わりに、シンプルな <code>[Person]</code> を返します。</p>
<p>問題は “醜さ” が信じがたい程に役に立つということです。 <code>Entity Person</code> とすることで、型レベルで見ればデータベースに存在する値を扱っていることが明確になります。 <code>PersonId</code> を必要とする他のページへのリンクを作りたいとしましょう (後から議論するように、これは良くあることです)。 <code>Entity Person</code> 形式は情報への明確なアクセスが可能になります。 <code>PersonId</code> を <code>Maybe</code> 型を使って <code>Person</code> に埋め込むと、コンパイル時チェックのエラー証明の代わりに、実行時における余分な <code>Just</code> チェックが生じてしまいます。</p>
<p>最後に ID を値に埋め込むと意味論的なミスマッチが発生します。 <code>Person</code> は値です。 (Haskellの文脈においては) 全てのフィールドが同じであれば2人は同一人物です。 ID を値に挿入することでもはや人ではなくデータベースの行について語ることになるのです。 等しさはもはや本当の等しさではなくなってしまいます。 つまり “同じ人” ではなく “同じデータ” となります。</p>
<p>要するに ID を独立して持つことには面倒な点もありますが、全体としてはそれは正しい方法なので、大きな枠組みの中においてはより良いバグの少ないコードにつながります。</p>
<h3 id="update">Update</h3>
<p>このまま更新についても考えてみましょう。 最も簡単な更新の方法は次のようになります。</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">let</span> michael <span class="ot">=</span> <span class="dt">Person</span> <span class="st">&quot;Michael&quot;</span> <span class="dv">26</span></span>
<span id="cb21-2"><a href="#cb21-2"></a>    michaelAfterBirthday <span class="ot">=</span> michael { personAge <span class="ot">=</span> <span class="dv">27</span> }</span></code></pre></div>
<p>これは更新しているように見えますが、実際のところは古い <code>Person</code> 値に基づいて新しい値を作っているだけです。 更新と言うのは Haskell の値の変更のことを言っているのではありません。(Haskell のデータはイミュータブルなので、もちろんそうするべきでもありません)</p>
<p>代わりに、テーブルの行を変更する方法を見ていきます。 最も簡単な方法は <code>update</code> 関数を利用する方法です。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1"></a>personId <span class="ot">&lt;-</span> insert <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Michael&quot;</span> <span class="st">&quot;Snoyman&quot;</span> <span class="dv">26</span></span>
<span id="cb22-2"><a href="#cb22-2"></a>update personId [<span class="dt">PersonAge</span> <span class="op">=.</span> <span class="dv">27</span>]</span></code></pre></div>
<p><code>update</code> は ID と <code>Update</code> のリストを引数に取ります。 最も簡単な更新は代入ですが、例として最もふさわしいとは限りません。 年齢を1だけ増やしたい場合に、現年齢が不明の場合はどうでしょうか？ Persistent では次のようにします。</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1"></a>haveBirthday personId <span class="ot">=</span> update personId [<span class="dt">PersonAge</span> <span class="op">+=.</span> <span class="dv">1</span>]</span></code></pre></div>
<p>また、<code>+=.</code>、 <code>-=.</code>、 <code>*=.</code>、 <code>/=.</code> など、全ての基本的な数学的演算子があります。 当然これらは単一のレコードを更新するために役立ち、さらに、適切な ACID を保証するために重要です。 <code>Person</code> を取り出し、年齢を1つ増やし、新しい値を更新することを考えてみてください。 同時にデータベース上で動作している2つのスレッド/プロセスがあったとしたら、苦痛の世界に直面するでしょう (ヒント:レースコンディション)。</p>
<p>たまには多くの行を1度に更新したい (例えば、全ての従業員の給料を5%上げたい) 時があるでしょう。 そういう場合に便利な <code>updateWhere</code> 関数はフィルターのリストと適用する更新のリストを取ります。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1"></a>updateWhere [<span class="dt">PersonFirstName</span> <span class="op">==.</span> <span class="st">&quot;Michael&quot;</span>] [<span class="dt">PersonAge</span> <span class="op">*=.</span> <span class="dv">2</span>] <span class="co">-- it's been a long day</span></span></code></pre></div>
<p>同じように、データベースの値を全く違う値に置き換えたい時があるかもしれません。 そのためには (驚きの) <code>replace</code> 関数を使います。</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1"></a>personId <span class="ot">&lt;-</span> insert <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Michael&quot;</span> <span class="st">&quot;Snoyman&quot;</span> <span class="dv">26</span></span>
<span id="cb25-2"><a href="#cb25-2"></a>replace personId <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;John&quot;</span> <span class="st">&quot;Doe&quot;</span> <span class="dv">20</span></span></code></pre></div>
<h3 id="delete">Delete</h3>
<p>痛ましいことですが、データを削除しなければならない時があります。 そのために、3つの関数が用意されています。</p>
<h4 id="delete-1">delete</h4>
<p>ID でデータを削除します。</p>
<h4 id="deleteby">deleteBy</h4>
<p>一意性の制約を使って、データ削除します。</p>
<h4 id="deletewhere">deleteWhere</h4>
<p>フィルターを使って、データを削除します。</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1"></a>personId <span class="ot">&lt;-</span> insert <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Michael&quot;</span> <span class="st">&quot;Snoyman&quot;</span> <span class="dv">26</span></span>
<span id="cb26-2"><a href="#cb26-2"></a>delete personId</span>
<span id="cb26-3"><a href="#cb26-3"></a>deleteBy <span class="op">$</span> <span class="dt">PersonName</span> <span class="st">&quot;Michael&quot;</span> <span class="st">&quot;Snoyman&quot;</span></span>
<span id="cb26-4"><a href="#cb26-4"></a>deleteWhere [<span class="dt">PersonFirstName</span> <span class="op">==.</span> <span class="st">&quot;Michael&quot;</span>]</span></code></pre></div>
<p>テーブルの全てのデータを削除するためにも <code>deleteWhere</code> を使います。 どのテーブルを対象にするか GHC にヒントを与えるだけです。</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1"></a>deleteWhere ([]<span class="ot"> ::</span> [<span class="dt">Filter</span> <span class="dt">Person</span>])</span></code></pre></div>
<h2 id="attributes">Attributes</h2>
<p>ここまでの例では <code>persistLowerCase</code> の基本的な構文を見てきました。 エンティティ名の行に続いて、インデントされた2ワード (フィールド名とデータ型) の行が続きます。 Persistent はこれ以外にも、初めの2ワードの後に任意の属性リストを書けばより多くのことを制御できます。</p>
<p>例えば (オプションの) 年齢と彼/彼女がシステムに追加された時間のタイムスタンプで <code>Person</code> エンティティを作りたいとしましょう。 既にデータベースに存在するエンティティについてはタイムスタンプは単に現在の日時を利用する。</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1"></a><span class="ot">{-# LANGUAGE EmptyDataDecls             #-}</span></span>
<span id="cb28-2"><a href="#cb28-2"></a><span class="ot">{-# LANGUAGE FlexibleContexts           #-}</span></span>
<span id="cb28-3"><a href="#cb28-3"></a><span class="ot">{-# LANGUAGE GADTs                      #-}</span></span>
<span id="cb28-4"><a href="#cb28-4"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb28-5"><a href="#cb28-5"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses      #-}</span></span>
<span id="cb28-6"><a href="#cb28-6"></a><span class="ot">{-# LANGUAGE OverloadedStrings          #-}</span></span>
<span id="cb28-7"><a href="#cb28-7"></a><span class="ot">{-# LANGUAGE QuasiQuotes                #-}</span></span>
<span id="cb28-8"><a href="#cb28-8"></a><span class="ot">{-# LANGUAGE TemplateHaskell            #-}</span></span>
<span id="cb28-9"><a href="#cb28-9"></a><span class="ot">{-# LANGUAGE TypeFamilies               #-}</span></span>
<span id="cb28-10"><a href="#cb28-10"></a><span class="kw">import</span> <span class="dt">Database.Persist</span></span>
<span id="cb28-11"><a href="#cb28-11"></a><span class="kw">import</span> <span class="dt">Database.Persist.Sqlite</span></span>
<span id="cb28-12"><a href="#cb28-12"></a><span class="kw">import</span> <span class="dt">Database.Persist.TH</span></span>
<span id="cb28-13"><a href="#cb28-13"></a><span class="kw">import</span> <span class="dt">Data.Time</span></span>
<span id="cb28-14"><a href="#cb28-14"></a><span class="kw">import</span> <span class="dt">Control.Monad.IO.Class</span></span>
<span id="cb28-15"><a href="#cb28-15"></a></span>
<span id="cb28-16"><a href="#cb28-16"></a>share [mkPersist sqlSettings, mkMigrate <span class="st">&quot;migrateAll&quot;</span>] [persistLowerCase|</span>
<span id="cb28-17"><a href="#cb28-17"></a>Person</span>
<span id="cb28-18"><a href="#cb28-18"></a>    name String</span>
<span id="cb28-19"><a href="#cb28-19"></a>    age Int Maybe</span>
<span id="cb28-20"><a href="#cb28-20"></a>    created UTCTime default=CURRENT_TIME</span>
<span id="cb28-21"><a href="#cb28-21"></a>    deriving Show</span>
<span id="cb28-22"><a href="#cb28-22"></a>|]</span>
<span id="cb28-23"><a href="#cb28-23"></a></span>
<span id="cb28-24"><a href="#cb28-24"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb28-25"><a href="#cb28-25"></a>main <span class="ot">=</span> runSqlite <span class="st">&quot;:memory:&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb28-26"><a href="#cb28-26"></a>    time <span class="ot">&lt;-</span> liftIO getCurrentTime</span>
<span id="cb28-27"><a href="#cb28-27"></a>    runMigration migrateAll</span>
<span id="cb28-28"><a href="#cb28-28"></a>    insert <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Michael&quot;</span> (<span class="dt">Just</span> <span class="dv">26</span>) time</span>
<span id="cb28-29"><a href="#cb28-29"></a>    insert <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Greg&quot;</span> <span class="dt">Nothing</span> time</span>
<span id="cb28-30"><a href="#cb28-30"></a>    <span class="fu">return</span> ()</span></code></pre></div>
<p><code>Maybe</code> はフィールドがオプションになるような、単一ワード属性です。 これは Haskell では <code>Maybe</code> でラップされていることを意味し、SQL では NULL を許可します。</p>
<p><code>default</code> 属性はバックエンドに依存し、データベースで理解可能なあらゆる構文が使えます。 今回の例では、データベースに内臓されている <code>CURRENT_TIME</code> 関数を利用しました。 次に、好きなプログラミング言語のフィールドを追加してみましょう。</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1"></a><span class="ot">{-# LANGUAGE EmptyDataDecls             #-}</span></span>
<span id="cb29-2"><a href="#cb29-2"></a><span class="ot">{-# LANGUAGE FlexibleContexts           #-}</span></span>
<span id="cb29-3"><a href="#cb29-3"></a><span class="ot">{-# LANGUAGE GADTs                      #-}</span></span>
<span id="cb29-4"><a href="#cb29-4"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb29-5"><a href="#cb29-5"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses      #-}</span></span>
<span id="cb29-6"><a href="#cb29-6"></a><span class="ot">{-# LANGUAGE OverloadedStrings          #-}</span></span>
<span id="cb29-7"><a href="#cb29-7"></a><span class="ot">{-# LANGUAGE QuasiQuotes                #-}</span></span>
<span id="cb29-8"><a href="#cb29-8"></a><span class="ot">{-# LANGUAGE TemplateHaskell            #-}</span></span>
<span id="cb29-9"><a href="#cb29-9"></a><span class="ot">{-# LANGUAGE TypeFamilies               #-}</span></span>
<span id="cb29-10"><a href="#cb29-10"></a><span class="kw">import</span> <span class="dt">Database.Persist</span></span>
<span id="cb29-11"><a href="#cb29-11"></a><span class="kw">import</span> <span class="dt">Database.Persist.Sqlite</span></span>
<span id="cb29-12"><a href="#cb29-12"></a><span class="kw">import</span> <span class="dt">Database.Persist.TH</span></span>
<span id="cb29-13"><a href="#cb29-13"></a><span class="kw">import</span> <span class="dt">Data.Time</span></span>
<span id="cb29-14"><a href="#cb29-14"></a></span>
<span id="cb29-15"><a href="#cb29-15"></a>share [mkPersist sqlSettings, mkMigrate <span class="st">&quot;migrateAll&quot;</span>] [persistLowerCase|</span>
<span id="cb29-16"><a href="#cb29-16"></a>Person</span>
<span id="cb29-17"><a href="#cb29-17"></a>    name String</span>
<span id="cb29-18"><a href="#cb29-18"></a>    age Int Maybe</span>
<span id="cb29-19"><a href="#cb29-19"></a>    created UTCTime default=CURRENT_TIME</span>
<span id="cb29-20"><a href="#cb29-20"></a>    language String default='Haskell'</span>
<span id="cb29-21"><a href="#cb29-21"></a>    deriving Show</span>
<span id="cb29-22"><a href="#cb29-22"></a>|]</span>
<span id="cb29-23"><a href="#cb29-23"></a></span>
<span id="cb29-24"><a href="#cb29-24"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb29-25"><a href="#cb29-25"></a>main <span class="ot">=</span> runSqlite <span class="st">&quot;:memory:&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb29-26"><a href="#cb29-26"></a>    runMigration migrateAll</span></code></pre></div>
<blockquote>
<p><code>default</code> 属性は Haskell のコード自体にはに全く影響を与えません。全ての値を埋めたいだけです。これは、データベーススキーマと自動マイグレーションにのみ影響します。</p>
</blockquote>
<p>データベースが正しく解釈できるように文字列は単一のクォートで囲む必要があります。 また、 Parsistent は空白を含む場合はダブルクォートを使います。 よって、デフォルトの故郷を El Salvador にしたい時は次のようになります。</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1"></a><span class="ot">{-# LANGUAGE EmptyDataDecls             #-}</span></span>
<span id="cb30-2"><a href="#cb30-2"></a><span class="ot">{-# LANGUAGE FlexibleContexts           #-}</span></span>
<span id="cb30-3"><a href="#cb30-3"></a><span class="ot">{-# LANGUAGE GADTs                      #-}</span></span>
<span id="cb30-4"><a href="#cb30-4"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb30-5"><a href="#cb30-5"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses      #-}</span></span>
<span id="cb30-6"><a href="#cb30-6"></a><span class="ot">{-# LANGUAGE OverloadedStrings          #-}</span></span>
<span id="cb30-7"><a href="#cb30-7"></a><span class="ot">{-# LANGUAGE QuasiQuotes                #-}</span></span>
<span id="cb30-8"><a href="#cb30-8"></a><span class="ot">{-# LANGUAGE TemplateHaskell            #-}</span></span>
<span id="cb30-9"><a href="#cb30-9"></a><span class="ot">{-# LANGUAGE TypeFamilies               #-}</span></span>
<span id="cb30-10"><a href="#cb30-10"></a><span class="kw">import</span> <span class="dt">Database.Persist</span></span>
<span id="cb30-11"><a href="#cb30-11"></a><span class="kw">import</span> <span class="dt">Database.Persist.Sqlite</span></span>
<span id="cb30-12"><a href="#cb30-12"></a><span class="kw">import</span> <span class="dt">Database.Persist.TH</span></span>
<span id="cb30-13"><a href="#cb30-13"></a><span class="kw">import</span> <span class="dt">Data.Time</span></span>
<span id="cb30-14"><a href="#cb30-14"></a></span>
<span id="cb30-15"><a href="#cb30-15"></a>share [mkPersist sqlSettings, mkMigrate <span class="st">&quot;migrateAll&quot;</span>] [persistLowerCase|</span>
<span id="cb30-16"><a href="#cb30-16"></a>Person</span>
<span id="cb30-17"><a href="#cb30-17"></a>    name String</span>
<span id="cb30-18"><a href="#cb30-18"></a>    age Int Maybe</span>
<span id="cb30-19"><a href="#cb30-19"></a>    created UTCTime default=CURRENT_TIME</span>
<span id="cb30-20"><a href="#cb30-20"></a>    language String default='Haskell'</span>
<span id="cb30-21"><a href="#cb30-21"></a>    country String &quot;default='El Salvador'&quot;</span>
<span id="cb30-22"><a href="#cb30-22"></a>    deriving Show</span>
<span id="cb30-23"><a href="#cb30-23"></a>|]</span>
<span id="cb30-24"><a href="#cb30-24"></a></span>
<span id="cb30-25"><a href="#cb30-25"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb30-26"><a href="#cb30-26"></a>main <span class="ot">=</span> runSqlite <span class="st">&quot;:memory:&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb30-27"><a href="#cb30-27"></a>    runMigration migrateAll</span></code></pre></div>
<p>属性で使える1つのトリックは SQL テーブルとカラムで利用される名前を指定できることです。 これは、既存のデータベースを利用する場合に役立ちます。</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1"></a>share [mkPersist sqlSettings, mkMigrate <span class="st">&quot;migrateAll&quot;</span>] [persistLowerCase|</span>
<span id="cb31-2"><a href="#cb31-2"></a>Person sql=the-person-table id=numeric_id</span>
<span id="cb31-3"><a href="#cb31-3"></a>    firstName String sql=first_name</span>
<span id="cb31-4"><a href="#cb31-4"></a>    lastName String sql=fldLastName</span>
<span id="cb31-5"><a href="#cb31-5"></a>    age Int &quot;sql=The Age of the Person&quot;</span>
<span id="cb31-6"><a href="#cb31-6"></a>    PersonName firstName lastName</span>
<span id="cb31-7"><a href="#cb31-7"></a>    deriving Show</span>
<span id="cb31-8"><a href="#cb31-8"></a>|]</span></code></pre></div>
<p>エンティティ定義構文には様々な多くの機能があります。 最新のリストは <a href="https://github.com/yesodweb/persistent/blob/master/docs/Persistent-entity-syntax.md">Persistent documentation</a> を参照してください。</p>
<h2 id="relations">Relations</h2>
<p>Persistent はサポートしている非 SQL データベースと一貫する方法でデータ型の間における参照が可能になります。 今回は ID を関連するエンティティに埋め込んでみましょう。 つまり、1人の人が多くの車を持っているという関係です。</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1"></a><span class="ot">{-# LANGUAGE EmptyDataDecls             #-}</span></span>
<span id="cb32-2"><a href="#cb32-2"></a><span class="ot">{-# LANGUAGE FlexibleContexts           #-}</span></span>
<span id="cb32-3"><a href="#cb32-3"></a><span class="ot">{-# LANGUAGE GADTs                      #-}</span></span>
<span id="cb32-4"><a href="#cb32-4"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb32-5"><a href="#cb32-5"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses      #-}</span></span>
<span id="cb32-6"><a href="#cb32-6"></a><span class="ot">{-# LANGUAGE OverloadedStrings          #-}</span></span>
<span id="cb32-7"><a href="#cb32-7"></a><span class="ot">{-# LANGUAGE QuasiQuotes                #-}</span></span>
<span id="cb32-8"><a href="#cb32-8"></a><span class="ot">{-# LANGUAGE TemplateHaskell            #-}</span></span>
<span id="cb32-9"><a href="#cb32-9"></a><span class="ot">{-# LANGUAGE TypeFamilies               #-}</span></span>
<span id="cb32-10"><a href="#cb32-10"></a><span class="kw">import</span> <span class="dt">Database.Persist</span></span>
<span id="cb32-11"><a href="#cb32-11"></a><span class="kw">import</span> <span class="dt">Database.Persist.Sqlite</span></span>
<span id="cb32-12"><a href="#cb32-12"></a><span class="kw">import</span> <span class="dt">Database.Persist.TH</span></span>
<span id="cb32-13"><a href="#cb32-13"></a><span class="kw">import</span> <span class="dt">Control.Monad.IO.Class</span> (liftIO)</span>
<span id="cb32-14"><a href="#cb32-14"></a><span class="kw">import</span> <span class="dt">Data.Time</span></span>
<span id="cb32-15"><a href="#cb32-15"></a></span>
<span id="cb32-16"><a href="#cb32-16"></a>share [mkPersist sqlSettings, mkMigrate <span class="st">&quot;migrateAll&quot;</span>] [persistLowerCase|</span>
<span id="cb32-17"><a href="#cb32-17"></a>Person</span>
<span id="cb32-18"><a href="#cb32-18"></a>    name String</span>
<span id="cb32-19"><a href="#cb32-19"></a>    deriving Show</span>
<span id="cb32-20"><a href="#cb32-20"></a>Car</span>
<span id="cb32-21"><a href="#cb32-21"></a>    ownerId PersonId</span>
<span id="cb32-22"><a href="#cb32-22"></a>    name String</span>
<span id="cb32-23"><a href="#cb32-23"></a>    deriving Show</span>
<span id="cb32-24"><a href="#cb32-24"></a>|]</span>
<span id="cb32-25"><a href="#cb32-25"></a></span>
<span id="cb32-26"><a href="#cb32-26"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb32-27"><a href="#cb32-27"></a>main <span class="ot">=</span> runSqlite <span class="st">&quot;:memory:&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb32-28"><a href="#cb32-28"></a>    runMigration migrateAll</span>
<span id="cb32-29"><a href="#cb32-29"></a>    bruce <span class="ot">&lt;-</span> insert <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Bruce Wayne&quot;</span></span>
<span id="cb32-30"><a href="#cb32-30"></a>    insert <span class="op">$</span> <span class="dt">Car</span> bruce <span class="st">&quot;Bat Mobile&quot;</span></span>
<span id="cb32-31"><a href="#cb32-31"></a>    insert <span class="op">$</span> <span class="dt">Car</span> bruce <span class="st">&quot;Porsche&quot;</span></span>
<span id="cb32-32"><a href="#cb32-32"></a>    <span class="co">-- this could go on a while</span></span>
<span id="cb32-33"><a href="#cb32-33"></a>    cars <span class="ot">&lt;-</span> selectList [<span class="dt">CarOwnerId</span> <span class="op">==.</span> bruce] []</span>
<span id="cb32-34"><a href="#cb32-34"></a>    liftIO <span class="op">$</span> <span class="fu">print</span> cars</span></code></pre></div>
<p>このテクニックを使えば1対多の関係を定義できます。 多対多の関係を定義するためにはオリジナルのテーブルのそれぞれと1対多の関係を持つ join エンティティが必要となります。 これらに一意性の制約をつけることも良い案です。 例えば、どの人がどの店で買い物をしたかを追跡したい状況をモデル化する場合です。</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1"></a><span class="ot">{-# LANGUAGE EmptyDataDecls             #-}</span></span>
<span id="cb33-2"><a href="#cb33-2"></a><span class="ot">{-# LANGUAGE FlexibleContexts           #-}</span></span>
<span id="cb33-3"><a href="#cb33-3"></a><span class="ot">{-# LANGUAGE GADTs                      #-}</span></span>
<span id="cb33-4"><a href="#cb33-4"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb33-5"><a href="#cb33-5"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses      #-}</span></span>
<span id="cb33-6"><a href="#cb33-6"></a><span class="ot">{-# LANGUAGE OverloadedStrings          #-}</span></span>
<span id="cb33-7"><a href="#cb33-7"></a><span class="ot">{-# LANGUAGE QuasiQuotes                #-}</span></span>
<span id="cb33-8"><a href="#cb33-8"></a><span class="ot">{-# LANGUAGE TemplateHaskell            #-}</span></span>
<span id="cb33-9"><a href="#cb33-9"></a><span class="ot">{-# LANGUAGE TypeFamilies               #-}</span></span>
<span id="cb33-10"><a href="#cb33-10"></a><span class="kw">import</span> <span class="dt">Database.Persist</span></span>
<span id="cb33-11"><a href="#cb33-11"></a><span class="kw">import</span> <span class="dt">Database.Persist.Sqlite</span></span>
<span id="cb33-12"><a href="#cb33-12"></a><span class="kw">import</span> <span class="dt">Database.Persist.TH</span></span>
<span id="cb33-13"><a href="#cb33-13"></a><span class="kw">import</span> <span class="dt">Data.Time</span></span>
<span id="cb33-14"><a href="#cb33-14"></a></span>
<span id="cb33-15"><a href="#cb33-15"></a>share [mkPersist sqlSettings, mkMigrate <span class="st">&quot;migrateAll&quot;</span>] [persistLowerCase|</span>
<span id="cb33-16"><a href="#cb33-16"></a>Person</span>
<span id="cb33-17"><a href="#cb33-17"></a>    name String</span>
<span id="cb33-18"><a href="#cb33-18"></a>Store</span>
<span id="cb33-19"><a href="#cb33-19"></a>    name String</span>
<span id="cb33-20"><a href="#cb33-20"></a>PersonStore</span>
<span id="cb33-21"><a href="#cb33-21"></a>    personId PersonId</span>
<span id="cb33-22"><a href="#cb33-22"></a>    storeId StoreId</span>
<span id="cb33-23"><a href="#cb33-23"></a>    UniquePersonStore personId storeId</span>
<span id="cb33-24"><a href="#cb33-24"></a>|]</span>
<span id="cb33-25"><a href="#cb33-25"></a></span>
<span id="cb33-26"><a href="#cb33-26"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb33-27"><a href="#cb33-27"></a>main <span class="ot">=</span> runSqlite <span class="st">&quot;:memory:&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb33-28"><a href="#cb33-28"></a>    runMigration migrateAll</span>
<span id="cb33-29"><a href="#cb33-29"></a></span>
<span id="cb33-30"><a href="#cb33-30"></a>    bruce <span class="ot">&lt;-</span> insert <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Bruce Wayne&quot;</span></span>
<span id="cb33-31"><a href="#cb33-31"></a>    michael <span class="ot">&lt;-</span> insert <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Michael&quot;</span></span>
<span id="cb33-32"><a href="#cb33-32"></a></span>
<span id="cb33-33"><a href="#cb33-33"></a>    target <span class="ot">&lt;-</span> insert <span class="op">$</span> <span class="dt">Store</span> <span class="st">&quot;Target&quot;</span></span>
<span id="cb33-34"><a href="#cb33-34"></a>    gucci <span class="ot">&lt;-</span> insert <span class="op">$</span> <span class="dt">Store</span> <span class="st">&quot;Gucci&quot;</span></span>
<span id="cb33-35"><a href="#cb33-35"></a>    sevenEleven <span class="ot">&lt;-</span> insert <span class="op">$</span> <span class="dt">Store</span> <span class="st">&quot;7-11&quot;</span></span>
<span id="cb33-36"><a href="#cb33-36"></a></span>
<span id="cb33-37"><a href="#cb33-37"></a>    insert <span class="op">$</span> <span class="dt">PersonStore</span> bruce gucci</span>
<span id="cb33-38"><a href="#cb33-38"></a>    insert <span class="op">$</span> <span class="dt">PersonStore</span> bruce sevenEleven</span>
<span id="cb33-39"><a href="#cb33-39"></a></span>
<span id="cb33-40"><a href="#cb33-40"></a>    insert <span class="op">$</span> <span class="dt">PersonStore</span> michael target</span>
<span id="cb33-41"><a href="#cb33-41"></a>    insert <span class="op">$</span> <span class="dt">PersonStore</span> michael sevenEleven</span>
<span id="cb33-42"><a href="#cb33-42"></a></span>
<span id="cb33-43"><a href="#cb33-43"></a>    <span class="fu">return</span> ()</span></code></pre></div>
<h2 id="closer-look-at-types">Closer look at types</h2>
<p>これまでの所 <code>Person</code> や <code>PersonId</code> について、実際にそれらが何であるかについて説明せずに話を進めてきました。 最も単純な場合 (SQL に限定したシステム) の <code>PersonId</code> は <code>type PersonId = Int64</code> です。 しかし、これは <code>PersonId</code> を型レベルにおいて <code>Person</code> エンティティに結合させるものが何もないことを意味します。 そのため、<code>PersonId</code> を使って <code>Car</code> を偶然取得できるかも知れません。 この関係性をモデル化するためにファントム型使って以下のように定義しました。</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1"></a><span class="kw">newtype</span> <span class="dt">Key</span> entity <span class="ot">=</span> <span class="dt">Key</span> <span class="dt">Int64</span></span>
<span id="cb34-2"><a href="#cb34-2"></a><span class="kw">type</span> <span class="dt">PersonId</span> <span class="ot">=</span> <span class="dt">Key</span> <span class="dt">Person</span></span></code></pre></div>
<p>これは、実際のところ本当に良く機能しますが、ID に <code>Int64</code> を使わないバックエンドが出てくると話は違います。 この問題は理論的な話ではなく、実際に MongoDB は <code>Int64</code> の代わりに <code>ByteSting</code> を使います。 そのため、 <code>Int64</code> と <code>ByteString</code> を含むことができるキーの値が必要になります。 このような時は、直和型が最も役立ちます。</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1"></a><span class="kw">data</span> <span class="dt">Key</span> entity <span class="ot">=</span> <span class="dt">KeyInt</span> <span class="dt">Int64</span> <span class="op">|</span> <span class="dt">KeyByteString</span> <span class="dt">ByteString</span></span></code></pre></div>
<p>しかしこれは、またもや問題を引き起こします。 次に、タイムスタンプを使うバックエンドがあったとすれば <code>Key</code> に別のコンストラクタを追加する必要があります。 こればしばらく続くでしょう。 ただ、幸運なのは任意データを表すための直和型 <code>PersistValue</code> が既に存在していることです。</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1"></a><span class="kw">newtype</span> <span class="dt">Key</span> entity <span class="ot">=</span> <span class="dt">Key</span> <span class="dt">PersistValue</span></span></code></pre></div>
<p>これは (おおよそ) Persistent がバージョン2.0まで使っていた実装です。 しかし、これはデータを捨ててしまうという別の問題を引き起こします。 例えば SQL データベースを扱っている時 (デフォルトが使われると想定すれば) キーの型が <code>Int64</code> になることを知っています。 しかし、型レベルでこのことを断言することはできません。 従って Persistent 2.0からは <code>PersistentEntity</code> クラス内部で関連データ型として定義します。</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1"></a><span class="kw">class</span> <span class="dt">PersistEntity</span> record <span class="kw">where</span></span>
<span id="cb37-2"><a href="#cb37-2"></a>    <span class="kw">data</span> <span class="dt">Key</span> record</span>
<span id="cb37-3"><a href="#cb37-3"></a>    <span class="op">...</span></span></code></pre></div>
<p>SQLバックエンドでカスタムキー型を利用していないとすれば、 <code>Int64</code> が newtype でラップされ、 <code>toSqlKey</code> / <code>fromSqlKey</code> 関数は型安全な変換を代わりに行ってくれます。 また、MongoDB では <code>ByteString</code> でラップされます。</p>
<h3 id="more-complicated-more-generic">More complicated, more generic</h3>
<p>デファルトでは Persistent は特定のデータベースのバックエンドで機能するためにデータ型をハードコードしています。 <code>sqlSettings</code> を使えば <code>SqlBackend</code> 型になります。 しかし、複数のバックエンドを利用する Persistent コードを書くために <code>sqlSettings</code> を <code>sqlSettings { mpsGeneric = True }</code> とすることで、よりジェネリックな型が利用可能になります。</p>
<p>なぜこれが必要か理解するために、関係を考えてみましょう。 ブログとブログポストを表すために、以下のようなエンティティの定義を使います。</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1"></a><span class="dt">Blog</span></span>
<span id="cb38-2"><a href="#cb38-2"></a>    title <span class="dt">Text</span></span>
<span id="cb38-3"><a href="#cb38-3"></a><span class="dt">Post</span></span>
<span id="cb38-4"><a href="#cb38-4"></a>    title <span class="dt">Text</span></span>
<span id="cb38-5"><a href="#cb38-5"></a>    blogId <span class="dt">BlogId</span></span></code></pre></div>
<p><code>BlogId</code> が <code>Key Blog</code> の型シノニムだということはわかっていますが、どうやって <code>Key Blog</code> は定義されるのでしょうか？ <code>Int64</code> は MongoDB では機能しないため利用できません。 また <code>ByteString</code> も SQL データベースで機能しないため使えません。</p>
<p>これを許容するため <code>mpsGeneric</code> が <code>True</code> にセットされれば、結果のデータ型に使用しているデータベースのバックエンドを示すパラメータを含むようになり、キーは正しくエンコードされ、以下のようになるでしょう。</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1"></a><span class="kw">data</span> <span class="dt">BlogGeneric</span> backend <span class="ot">=</span> <span class="dt">Blog</span> {<span class="ot"> blogTitle ::</span> <span class="dt">Text</span> }</span>
<span id="cb39-2"><a href="#cb39-2"></a><span class="kw">data</span> <span class="dt">PostGeneric</span> backend <span class="ot">=</span> <span class="dt">Post</span></span>
<span id="cb39-3"><a href="#cb39-3"></a>    {<span class="ot"> postTitle  ::</span> <span class="dt">Text</span></span>
<span id="cb39-4"><a href="#cb39-4"></a>    ,<span class="ot"> postBlogId ::</span> <span class="dt">Key</span> (<span class="dt">BlogGeneric</span> backend)</span>
<span id="cb39-5"><a href="#cb39-5"></a>    }</span></code></pre></div>
<p>まだ、コンストラクタやレコードが短い名前であることに注目してください。 最後に、通常のコードにわかりやすいインターフェースを与えるために型シノニムを定義します。</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1"></a><span class="kw">type</span> <span class="dt">Blog</span>   <span class="ot">=</span> <span class="dt">BlogGeneric</span> <span class="dt">SqlBackend</span></span>
<span id="cb40-2"><a href="#cb40-2"></a><span class="kw">type</span> <span class="dt">BlogId</span> <span class="ot">=</span> <span class="dt">Key</span> <span class="dt">Blog</span></span>
<span id="cb40-3"><a href="#cb40-3"></a><span class="kw">type</span> <span class="dt">Post</span>   <span class="ot">=</span> <span class="dt">PostGeneric</span> <span class="dt">SqlBackend</span></span>
<span id="cb40-4"><a href="#cb40-4"></a><span class="kw">type</span> <span class="dt">PostId</span> <span class="ot">=</span> <span class="dt">Key</span> <span class="dt">Post</span></span></code></pre></div>
<p><code>SqlBackend</code> は Persistent のどこにもハードコードされていないと言われてしまうかもしれませんが、<code>mkPersist</code> に渡している <code>sqlSettings</code> パラメータは <code>SqlBackend</code> を使うように指示するものです。 Mongo のコードでは、代わりに <code>mongoSettings</code> を利用します。</p>
<p>これは、水面下では非常に複雑ですが、その複雑さはユーザには滅多に現れません。 この章を振り返ってみても、一度も <code>Key</code> や <code>Generic</code> などを直接扱う必要はありませんでした。 複雑さが現れる最も一般的な場所はコンパイラのエラーメッセージです。 そのため、これが存在することを覚えておくことは重要ですが、それが毎日のように影響することはないでしょう。</p>
<h2 id="custom-fields">Custom Fields</h2>
<p>ある時、データストアにカスタムフィールドを定義したくなるでしょう。 最も良くあるケースは雇用状態の列挙などです。 この目的のために Persistent はテンプレート Haskell の補助関数を提供しています。</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1"></a><span class="co">-- @Employment.hs</span></span>
<span id="cb41-2"><a href="#cb41-2"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb41-3"><a href="#cb41-3"></a><span class="kw">module</span> <span class="dt">Employment</span> <span class="kw">where</span></span>
<span id="cb41-4"><a href="#cb41-4"></a></span>
<span id="cb41-5"><a href="#cb41-5"></a><span class="kw">import</span> <span class="dt">Database.Persist.TH</span></span>
<span id="cb41-6"><a href="#cb41-6"></a></span>
<span id="cb41-7"><a href="#cb41-7"></a><span class="kw">data</span> <span class="dt">Employment</span> <span class="ot">=</span> <span class="dt">Employed</span> <span class="op">|</span> <span class="dt">Unemployed</span> <span class="op">|</span> <span class="dt">Retired</span></span>
<span id="cb41-8"><a href="#cb41-8"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Read</span>, <span class="dt">Eq</span>)</span>
<span id="cb41-9"><a href="#cb41-9"></a>derivePersistField <span class="st">&quot;Employment&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1"></a><span class="ot">{-# LANGUAGE EmptyDataDecls             #-}</span></span>
<span id="cb42-2"><a href="#cb42-2"></a><span class="ot">{-# LANGUAGE FlexibleContexts           #-}</span></span>
<span id="cb42-3"><a href="#cb42-3"></a><span class="ot">{-# LANGUAGE GADTs                      #-}</span></span>
<span id="cb42-4"><a href="#cb42-4"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb42-5"><a href="#cb42-5"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses      #-}</span></span>
<span id="cb42-6"><a href="#cb42-6"></a><span class="ot">{-# LANGUAGE OverloadedStrings          #-}</span></span>
<span id="cb42-7"><a href="#cb42-7"></a><span class="ot">{-# LANGUAGE QuasiQuotes                #-}</span></span>
<span id="cb42-8"><a href="#cb42-8"></a><span class="ot">{-# LANGUAGE TemplateHaskell            #-}</span></span>
<span id="cb42-9"><a href="#cb42-9"></a><span class="ot">{-# LANGUAGE TypeFamilies               #-}</span></span>
<span id="cb42-10"><a href="#cb42-10"></a><span class="kw">import</span> <span class="dt">Database.Persist.Sqlite</span></span>
<span id="cb42-11"><a href="#cb42-11"></a><span class="kw">import</span> <span class="dt">Database.Persist.TH</span></span>
<span id="cb42-12"><a href="#cb42-12"></a><span class="kw">import</span> <span class="dt">Employment</span></span>
<span id="cb42-13"><a href="#cb42-13"></a></span>
<span id="cb42-14"><a href="#cb42-14"></a>share [mkPersist sqlSettings, mkMigrate <span class="st">&quot;migrateAll&quot;</span>] [persistLowerCase|</span>
<span id="cb42-15"><a href="#cb42-15"></a>Person</span>
<span id="cb42-16"><a href="#cb42-16"></a>    name String</span>
<span id="cb42-17"><a href="#cb42-17"></a>    employment Employment</span>
<span id="cb42-18"><a href="#cb42-18"></a>|]</span>
<span id="cb42-19"><a href="#cb42-19"></a></span>
<span id="cb42-20"><a href="#cb42-20"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb42-21"><a href="#cb42-21"></a>main <span class="ot">=</span> runSqlite <span class="st">&quot;:memory:&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb42-22"><a href="#cb42-22"></a>    runMigration migrateAll</span>
<span id="cb42-23"><a href="#cb42-23"></a></span>
<span id="cb42-24"><a href="#cb42-24"></a>    insert <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Bruce Wayne&quot;</span> <span class="dt">Retired</span></span>
<span id="cb42-25"><a href="#cb42-25"></a>    insert <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Peter Parker&quot;</span> <span class="dt">Unemployed</span></span>
<span id="cb42-26"><a href="#cb42-26"></a>    insert <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Michael&quot;</span> <span class="dt">Employed</span></span>
<span id="cb42-27"><a href="#cb42-27"></a></span>
<span id="cb42-28"><a href="#cb42-28"></a>    <span class="fu">return</span> ()</span></code></pre></div>
<p><code>derivePersistField</code> は文字列フィールドを使ってデータベースにデータを格納します。 そして、データ型の <code>Show</code> と <code>Read</code> インスタンスを使って相互変換を行います。 これは整数値を使って格納する方法と比較して効率的でないかも知れませんが、ずっと将来性のあるものです。 将来的にコンストラクタを付け加えたとしても、データは有効であり続けるからです。</p>
<blockquote>
<p>今回は定義を2つの別々のモジュールに分割しました。これは GHC のステージ制限を回避するために必要なことです。これは、本質的には、テンプレート Haskell で生成されたコードは多くの場合で作られたモジュールと同じ場所では利用できないことを意味しています。</p>
</blockquote>
<h2 id="persistent-raw-sql">Persistent: Raw SQL</h2>
<p>Persistent パッケージはデータストアへの型安全なインターフェースを提供しています。 インターフェースは SQL にだけ存在する機能に頼ったりせず、極力バックエンドに依存しないようにしています。 経験上、やりたいことの 95% は高レベルのインターフェースを利用して楽に実行できます。 (実際に私のウェブサイトの大部分はもっぱら高レベルのインターフェースを利用しています)</p>
<p>しかし、残りの5%でバックエンド特有の機能を利用する場合があるでしょう。 過去に利用した1つの機能は全文テキスト検索です。 この場合 SQL の “LIKE” 演算子を利用したくなりますが、 Persistent ではモデル化されていません。 名前が “Snoyman” の人を全員取り出しレコードを表示する例をみてみましょう。</p>
<blockquote>
<p>実際のところ Persistent 0.6 に追加された機能を使えば LIKE 演算子を直接通常の構文で表現でき、バックエンド特有の演算子が利用可能になります。しかし, これはかなり良い例なので、気にせず進めましょう。</p>
</blockquote>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1"></a><span class="ot">{-# LANGUAGE EmptyDataDecls             #-}</span></span>
<span id="cb43-2"><a href="#cb43-2"></a><span class="ot">{-# LANGUAGE FlexibleContexts           #-}</span></span>
<span id="cb43-3"><a href="#cb43-3"></a><span class="ot">{-# LANGUAGE GADTs                      #-}</span></span>
<span id="cb43-4"><a href="#cb43-4"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb43-5"><a href="#cb43-5"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses      #-}</span></span>
<span id="cb43-6"><a href="#cb43-6"></a><span class="ot">{-# LANGUAGE OverloadedStrings          #-}</span></span>
<span id="cb43-7"><a href="#cb43-7"></a><span class="ot">{-# LANGUAGE QuasiQuotes                #-}</span></span>
<span id="cb43-8"><a href="#cb43-8"></a><span class="ot">{-# LANGUAGE TemplateHaskell            #-}</span></span>
<span id="cb43-9"><a href="#cb43-9"></a><span class="ot">{-# LANGUAGE TypeFamilies               #-}</span></span>
<span id="cb43-10"><a href="#cb43-10"></a><span class="kw">import</span> <span class="dt">Database.Persist.TH</span></span>
<span id="cb43-11"><a href="#cb43-11"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb43-12"><a href="#cb43-12"></a><span class="kw">import</span> <span class="dt">Database.Persist.Sqlite</span></span>
<span id="cb43-13"><a href="#cb43-13"></a><span class="kw">import</span> <span class="dt">Control.Monad.IO.Class</span> (liftIO)</span>
<span id="cb43-14"><a href="#cb43-14"></a><span class="kw">import</span> <span class="dt">Data.Conduit</span></span>
<span id="cb43-15"><a href="#cb43-15"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Conduit.List</span> <span class="kw">as</span> <span class="dt">CL</span></span>
<span id="cb43-16"><a href="#cb43-16"></a></span>
<span id="cb43-17"><a href="#cb43-17"></a>share [mkPersist sqlSettings, mkMigrate <span class="st">&quot;migrateAll&quot;</span>] [persistLowerCase|</span>
<span id="cb43-18"><a href="#cb43-18"></a>Person</span>
<span id="cb43-19"><a href="#cb43-19"></a>    name Text</span>
<span id="cb43-20"><a href="#cb43-20"></a>|]</span>
<span id="cb43-21"><a href="#cb43-21"></a></span>
<span id="cb43-22"><a href="#cb43-22"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb43-23"><a href="#cb43-23"></a>main <span class="ot">=</span> runSqlite <span class="st">&quot;:memory:&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb43-24"><a href="#cb43-24"></a>    runMigration migrateAll</span>
<span id="cb43-25"><a href="#cb43-25"></a>    insert <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Michael Snoyman&quot;</span></span>
<span id="cb43-26"><a href="#cb43-26"></a>    insert <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Miriam Snoyman&quot;</span></span>
<span id="cb43-27"><a href="#cb43-27"></a>    insert <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Eliezer Snoyman&quot;</span></span>
<span id="cb43-28"><a href="#cb43-28"></a>    insert <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Gavriella Snoyman&quot;</span></span>
<span id="cb43-29"><a href="#cb43-29"></a>    insert <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Greg Weber&quot;</span></span>
<span id="cb43-30"><a href="#cb43-30"></a>    insert <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Rick Richardson&quot;</span></span>
<span id="cb43-31"><a href="#cb43-31"></a></span>
<span id="cb43-32"><a href="#cb43-32"></a>    <span class="co">-- Persistent does not provide the LIKE keyword, but we'd like to get the</span></span>
<span id="cb43-33"><a href="#cb43-33"></a>    <span class="co">-- whole Snoyman family...</span></span>
<span id="cb43-34"><a href="#cb43-34"></a>    <span class="kw">let</span> sql <span class="ot">=</span> <span class="st">&quot;SELECT name FROM Person WHERE name LIKE '%Snoyman'&quot;</span></span>
<span id="cb43-35"><a href="#cb43-35"></a>    rawQuery sql [] <span class="op">$$</span> CL.mapM_ (liftIO <span class="op">.</span> <span class="fu">print</span>)</span></code></pre></div>
<p>自動的なデータ変換を可能にする高レベルサポートもあります。 詳細については Haddock API ドキュメントを参照してください。</p>
<h2 id="integration-with-yesod">Integration with Yesod</h2>
<p>Persistent の力を理解してもらえたと思いますが、どのように Yesod アプリケーションに統合されるのでしょうか？ scaffolding を使っていれば、大部分の作業は既に完了していると思いますが、いつも通り手動で全てのものを作成し、水面下でどのように動いているかを理解します。</p>
<p>yesod-persistent パッケージは Persistent と Yesod を接着するために <code>YesodPersist</code> 型クラスを提供し、<code>runDB</code> メソッドを通して DB への標準的なアクセスが可能となります。 具体列を見てみましょう。</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1"></a><span class="ot">{-# LANGUAGE EmptyDataDecls             #-}</span></span>
<span id="cb44-2"><a href="#cb44-2"></a><span class="ot">{-# LANGUAGE FlexibleContexts           #-}</span></span>
<span id="cb44-3"><a href="#cb44-3"></a><span class="ot">{-# LANGUAGE GADTs                      #-}</span></span>
<span id="cb44-4"><a href="#cb44-4"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb44-5"><a href="#cb44-5"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses      #-}</span></span>
<span id="cb44-6"><a href="#cb44-6"></a><span class="ot">{-# LANGUAGE OverloadedStrings          #-}</span></span>
<span id="cb44-7"><a href="#cb44-7"></a><span class="ot">{-# LANGUAGE QuasiQuotes                #-}</span></span>
<span id="cb44-8"><a href="#cb44-8"></a><span class="ot">{-# LANGUAGE TemplateHaskell            #-}</span></span>
<span id="cb44-9"><a href="#cb44-9"></a><span class="ot">{-# LANGUAGE TypeFamilies               #-}</span></span>
<span id="cb44-10"><a href="#cb44-10"></a><span class="ot">{-# LANGUAGE ViewPatterns               #-}</span></span>
<span id="cb44-11"><a href="#cb44-11"></a><span class="kw">import</span> <span class="dt">Yesod</span></span>
<span id="cb44-12"><a href="#cb44-12"></a><span class="kw">import</span> <span class="dt">Database.Persist.Sqlite</span></span>
<span id="cb44-13"><a href="#cb44-13"></a><span class="kw">import</span> <span class="dt">Control.Monad.Trans.Resource</span> (runResourceT)</span>
<span id="cb44-14"><a href="#cb44-14"></a><span class="kw">import</span> <span class="dt">Control.Monad.Logger</span> (runStderrLoggingT)</span>
<span id="cb44-15"><a href="#cb44-15"></a></span>
<span id="cb44-16"><a href="#cb44-16"></a><span class="co">-- Define our entities as usual</span></span>
<span id="cb44-17"><a href="#cb44-17"></a>share [mkPersist sqlSettings, mkMigrate <span class="st">&quot;migrateAll&quot;</span>] [persistLowerCase|</span>
<span id="cb44-18"><a href="#cb44-18"></a>Person</span>
<span id="cb44-19"><a href="#cb44-19"></a>    firstName String</span>
<span id="cb44-20"><a href="#cb44-20"></a>    lastName String</span>
<span id="cb44-21"><a href="#cb44-21"></a>    age Int</span>
<span id="cb44-22"><a href="#cb44-22"></a>    deriving Show</span>
<span id="cb44-23"><a href="#cb44-23"></a>|]</span>
<span id="cb44-24"><a href="#cb44-24"></a></span>
<span id="cb44-25"><a href="#cb44-25"></a><span class="co">-- We keep our connection pool in the foundation. At program initialization, we</span></span>
<span id="cb44-26"><a href="#cb44-26"></a><span class="co">-- create our initial pool, and each time we need to perform an action we check</span></span>
<span id="cb44-27"><a href="#cb44-27"></a><span class="co">-- out a single connection from the pool.</span></span>
<span id="cb44-28"><a href="#cb44-28"></a><span class="kw">data</span> <span class="dt">PersistTest</span> <span class="ot">=</span> <span class="dt">PersistTest</span> <span class="dt">ConnectionPool</span></span>
<span id="cb44-29"><a href="#cb44-29"></a></span>
<span id="cb44-30"><a href="#cb44-30"></a><span class="co">-- We'll create a single route, to access a person. It's a very common</span></span>
<span id="cb44-31"><a href="#cb44-31"></a><span class="co">-- occurrence to use an Id type in routes.</span></span>
<span id="cb44-32"><a href="#cb44-32"></a>mkYesod <span class="st">&quot;PersistTest&quot;</span> [parseRoutes|</span>
<span id="cb44-33"><a href="#cb44-33"></a>/ HomeR GET</span>
<span id="cb44-34"><a href="#cb44-34"></a>/person/#PersonId PersonR GET</span>
<span id="cb44-35"><a href="#cb44-35"></a>|]</span>
<span id="cb44-36"><a href="#cb44-36"></a></span>
<span id="cb44-37"><a href="#cb44-37"></a><span class="co">-- Nothing special here</span></span>
<span id="cb44-38"><a href="#cb44-38"></a><span class="kw">instance</span> <span class="dt">Yesod</span> <span class="dt">PersistTest</span></span>
<span id="cb44-39"><a href="#cb44-39"></a></span>
<span id="cb44-40"><a href="#cb44-40"></a><span class="co">-- Now we need to define a YesodPersist instance, which will keep track of</span></span>
<span id="cb44-41"><a href="#cb44-41"></a><span class="co">-- which backend we're using and how to run an action.</span></span>
<span id="cb44-42"><a href="#cb44-42"></a><span class="kw">instance</span> <span class="dt">YesodPersist</span> <span class="dt">PersistTest</span> <span class="kw">where</span></span>
<span id="cb44-43"><a href="#cb44-43"></a>    <span class="kw">type</span> <span class="dt">YesodPersistBackend</span> <span class="dt">PersistTest</span> <span class="ot">=</span> <span class="dt">SqlBackend</span></span>
<span id="cb44-44"><a href="#cb44-44"></a></span>
<span id="cb44-45"><a href="#cb44-45"></a>    runDB action <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb44-46"><a href="#cb44-46"></a>        <span class="dt">PersistTest</span> pool <span class="ot">&lt;-</span> getYesod</span>
<span id="cb44-47"><a href="#cb44-47"></a>        runSqlPool action pool</span>
<span id="cb44-48"><a href="#cb44-48"></a></span>
<span id="cb44-49"><a href="#cb44-49"></a><span class="co">-- List all people in the database</span></span>
<span id="cb44-50"><a href="#cb44-50"></a><span class="ot">getHomeR ::</span> <span class="dt">Handler</span> <span class="dt">Html</span></span>
<span id="cb44-51"><a href="#cb44-51"></a>getHomeR <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb44-52"><a href="#cb44-52"></a>    people <span class="ot">&lt;-</span> runDB <span class="op">$</span> selectList [] [<span class="dt">Asc</span> <span class="dt">PersonAge</span>]</span>
<span id="cb44-53"><a href="#cb44-53"></a>    defaultLayout</span>
<span id="cb44-54"><a href="#cb44-54"></a>        [whamlet|</span>
<span id="cb44-55"><a href="#cb44-55"></a>            <span class="kw">&lt;ul&gt;</span></span>
<span id="cb44-56"><a href="#cb44-56"></a>                <span class="kw">$forall</span> <span class="dt">Entity</span> personid person <span class="ot">&lt;-</span> people</span>
<span id="cb44-57"><a href="#cb44-57"></a>                    <span class="kw">&lt;li&gt;</span></span>
<span id="cb44-58"><a href="#cb44-58"></a>                        <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="kw">@{</span><span class="dt">PersonR</span> personid<span class="kw">}&gt;#{</span>personFirstName person<span class="kw">}</span></span>
<span id="cb44-59"><a href="#cb44-59"></a>        |]</span>
<span id="cb44-60"><a href="#cb44-60"></a></span>
<span id="cb44-61"><a href="#cb44-61"></a><span class="co">-- We'll just return the show value of a person, or a 404 if the Person doesn't</span></span>
<span id="cb44-62"><a href="#cb44-62"></a><span class="co">-- exist.</span></span>
<span id="cb44-63"><a href="#cb44-63"></a><span class="ot">getPersonR ::</span> <span class="dt">PersonId</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">String</span></span>
<span id="cb44-64"><a href="#cb44-64"></a>getPersonR personId <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb44-65"><a href="#cb44-65"></a>    person <span class="ot">&lt;-</span> runDB <span class="op">$</span> get404 personId</span>
<span id="cb44-66"><a href="#cb44-66"></a>    <span class="fu">return</span> <span class="op">$</span> <span class="fu">show</span> person</span>
<span id="cb44-67"><a href="#cb44-67"></a></span>
<span id="cb44-68"><a href="#cb44-68"></a><span class="ot">openConnectionCount ::</span> <span class="dt">Int</span></span>
<span id="cb44-69"><a href="#cb44-69"></a>openConnectionCount <span class="ot">=</span> <span class="dv">10</span></span>
<span id="cb44-70"><a href="#cb44-70"></a></span>
<span id="cb44-71"><a href="#cb44-71"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb44-72"><a href="#cb44-72"></a>main <span class="ot">=</span> runStderrLoggingT <span class="op">$</span> withSqlitePool <span class="st">&quot;test.db3&quot;</span> openConnectionCount <span class="op">$</span> \pool <span class="ot">-&gt;</span> liftIO <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb44-73"><a href="#cb44-73"></a>    runResourceT <span class="op">$</span> <span class="fu">flip</span> runSqlPool pool <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb44-74"><a href="#cb44-74"></a>        runMigration migrateAll</span>
<span id="cb44-75"><a href="#cb44-75"></a>        insert <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Michael&quot;</span> <span class="st">&quot;Snoyman&quot;</span> <span class="dv">26</span></span>
<span id="cb44-76"><a href="#cb44-76"></a>    warp <span class="dv">3000</span> <span class="op">$</span> <span class="dt">PersistTest</span> pool</span></code></pre></div>
<p>この例には一般的に利用する際の2つの重要な点があります。 <code>runDB</code> は <code>Handler</code> の内部で DB アクションを実行するために使われます。 <code>runDB</code> の内部で <code>insert</code> や <code>selectList</code> のような、これまで話した関数をどれでもつかうことができます。</p>
<blockquote>
<p><code>runDB</code> の型は <code>YesodDB site a → HandlerT site IO a</code> です。<code>YesodDB</code> は次のように定義されます。</p>
</blockquote>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1"></a><span class="kw">type</span> <span class="dt">YesodDB</span> site <span class="ot">=</span> <span class="dt">ReaderT</span> (<span class="dt">YesodPersistBackend</span> site) (<span class="dt">HandlerT</span> site <span class="dt">IO</span>)</span></code></pre></div>
<blockquote>
<p><code>YesodPersistBackend</code> 関連型の上に構築されるため、現在のサイトに基づいて適切なデータベースのバックエンドを利用します。</p>
</blockquote>
<p>他の新しい機能は <code>get404</code> です。これは <code>get</code> と全く同じように振舞いますが、結果が見つからない場合に <code>Nothing</code> を返す代わりに404エラーメッセージページを返します。 <code>getPersonR</code> 関数は <code>get404</code> が値に基づきレスポンスを返すという、実際の Yesod アプリケーションで良く見る手法です。</p>
<h2 id="more-complex-sql">More complex SQL</h2>
<p>Persistent はバックエンドに依存しません。 この方法のメリットは、コードが異なるバックエンド型の間を自由に行き来できることです。 デメリットはバックエンド特有の機能を見失うことです。 最も大きなものは SQL の join サポートです。</p>
<p>幸運にも Felipe Lessa と Chris Allen のおかげで、この問題は解決できる。 <a href="https://github.com/bitemyapp/esqueleto">Esqueleto</a> ライブラリは既存の Persistent 基盤を使って、型安全な SQL クエリの記述をサポートしてくれます。 Esqueleto の Haddock は利用方法の良い導入となるでしょう。 また Persistent の概念を多く使っているため Persistent の知識の大部分が Esqueleto でも利用できるでしょう。</p>
<p>Esqueleto 利用する簡単な例は SQL Join の章を参照してください。</p>
<h2 id="something-besides-sqlite">Something besides SQLite</h2>
<p>この章の例を単純にするため SQLite バックエンドを利用してきました。 最後に、一番はじめの例を PostgreSQL でも動くように書き直したコードを以下に示します。</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1"></a><span class="ot">{-# LANGUAGE EmptyDataDecls             #-}</span></span>
<span id="cb46-2"><a href="#cb46-2"></a><span class="ot">{-# LANGUAGE FlexibleContexts           #-}</span></span>
<span id="cb46-3"><a href="#cb46-3"></a><span class="ot">{-# LANGUAGE GADTs                      #-}</span></span>
<span id="cb46-4"><a href="#cb46-4"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb46-5"><a href="#cb46-5"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses      #-}</span></span>
<span id="cb46-6"><a href="#cb46-6"></a><span class="ot">{-# LANGUAGE OverloadedStrings          #-}</span></span>
<span id="cb46-7"><a href="#cb46-7"></a><span class="ot">{-# LANGUAGE QuasiQuotes                #-}</span></span>
<span id="cb46-8"><a href="#cb46-8"></a><span class="ot">{-# LANGUAGE TemplateHaskell            #-}</span></span>
<span id="cb46-9"><a href="#cb46-9"></a><span class="ot">{-# LANGUAGE TypeFamilies               #-}</span></span>
<span id="cb46-10"><a href="#cb46-10"></a><span class="kw">import</span>           <span class="dt">Control.Monad.IO.Class</span>  (liftIO)</span>
<span id="cb46-11"><a href="#cb46-11"></a><span class="kw">import</span>           <span class="dt">Control.Monad.Logger</span>    (runStderrLoggingT)</span>
<span id="cb46-12"><a href="#cb46-12"></a><span class="kw">import</span>           <span class="dt">Database.Persist</span></span>
<span id="cb46-13"><a href="#cb46-13"></a><span class="kw">import</span>           <span class="dt">Database.Persist.Postgresql</span></span>
<span id="cb46-14"><a href="#cb46-14"></a><span class="kw">import</span>           <span class="dt">Database.Persist.TH</span></span>
<span id="cb46-15"><a href="#cb46-15"></a></span>
<span id="cb46-16"><a href="#cb46-16"></a>share [mkPersist sqlSettings, mkMigrate <span class="st">&quot;migrateAll&quot;</span>] [persistLowerCase|</span>
<span id="cb46-17"><a href="#cb46-17"></a>Person</span>
<span id="cb46-18"><a href="#cb46-18"></a>    name String</span>
<span id="cb46-19"><a href="#cb46-19"></a>    age Int Maybe</span>
<span id="cb46-20"><a href="#cb46-20"></a>    deriving Show</span>
<span id="cb46-21"><a href="#cb46-21"></a>BlogPost</span>
<span id="cb46-22"><a href="#cb46-22"></a>    title String</span>
<span id="cb46-23"><a href="#cb46-23"></a>    authorId PersonId</span>
<span id="cb46-24"><a href="#cb46-24"></a>    deriving Show</span>
<span id="cb46-25"><a href="#cb46-25"></a>|]</span>
<span id="cb46-26"><a href="#cb46-26"></a></span>
<span id="cb46-27"><a href="#cb46-27"></a>connStr <span class="ot">=</span> <span class="st">&quot;host=localhost dbname=test user=test password=test port=5432&quot;</span></span>
<span id="cb46-28"><a href="#cb46-28"></a></span>
<span id="cb46-29"><a href="#cb46-29"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb46-30"><a href="#cb46-30"></a>main <span class="ot">=</span> runStderrLoggingT <span class="op">$</span> withPostgresqlPool connStr <span class="dv">10</span> <span class="op">$</span> \pool <span class="ot">-&gt;</span> liftIO <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb46-31"><a href="#cb46-31"></a>    <span class="fu">flip</span> runSqlPersistMPool pool <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb46-32"><a href="#cb46-32"></a>        runMigration migrateAll</span>
<span id="cb46-33"><a href="#cb46-33"></a></span>
<span id="cb46-34"><a href="#cb46-34"></a>        johnId <span class="ot">&lt;-</span> insert <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;John Doe&quot;</span> <span class="op">$</span> <span class="dt">Just</span> <span class="dv">35</span></span>
<span id="cb46-35"><a href="#cb46-35"></a>        janeId <span class="ot">&lt;-</span> insert <span class="op">$</span> <span class="dt">Person</span> <span class="st">&quot;Jane Doe&quot;</span> <span class="dt">Nothing</span></span>
<span id="cb46-36"><a href="#cb46-36"></a></span>
<span id="cb46-37"><a href="#cb46-37"></a>        insert <span class="op">$</span> <span class="dt">BlogPost</span> <span class="st">&quot;My fr1st p0st&quot;</span> johnId</span>
<span id="cb46-38"><a href="#cb46-38"></a>        insert <span class="op">$</span> <span class="dt">BlogPost</span> <span class="st">&quot;One more for good measure&quot;</span> johnId</span>
<span id="cb46-39"><a href="#cb46-39"></a></span>
<span id="cb46-40"><a href="#cb46-40"></a>        oneJohnPost <span class="ot">&lt;-</span> selectList [<span class="dt">BlogPostAuthorId</span> <span class="op">==.</span> johnId] [<span class="dt">LimitTo</span> <span class="dv">1</span>]</span>
<span id="cb46-41"><a href="#cb46-41"></a>        liftIO <span class="op">$</span> <span class="fu">print</span> (<span class="ot">oneJohnPost ::</span> [<span class="dt">Entity</span> <span class="dt">BlogPost</span>])</span>
<span id="cb46-42"><a href="#cb46-42"></a></span>
<span id="cb46-43"><a href="#cb46-43"></a>        john <span class="ot">&lt;-</span> get johnId</span>
<span id="cb46-44"><a href="#cb46-44"></a>        liftIO <span class="op">$</span> <span class="fu">print</span> (<span class="ot">john ::</span> <span class="dt">Maybe</span> <span class="dt">Person</span>)</span>
<span id="cb46-45"><a href="#cb46-45"></a></span>
<span id="cb46-46"><a href="#cb46-46"></a>        delete janeId</span>
<span id="cb46-47"><a href="#cb46-47"></a>        deleteWhere [<span class="dt">BlogPostAuthorId</span> <span class="op">==.</span> johnId]</span></code></pre></div>
<h2 id="summary">Summary</h2>
<p>Persistent は Haskell の型安全性をデータアクセスレイヤに適用します。 間違いやすい型のないデータアクセスのためのボイラプレートコードを手動で書く代わりに、Persistent はその作業を自動化してくれます。</p>
<p>ゴールは、ほとんどの場合に必要な全てのものを提供することです。 より強力なものが必要な時は Persistent が表面下のデータストアへの直接的なアクセスを提供し、書きたければ5通りの join を書くことができます。</p>
<p>Persistent は一般的な Yesod のワークフローに直接的に統合します。 <code>yesod-persistent</code> のような補助パッケージだけが素晴らしいレイヤを提供するだけでなく、<code>yesod-form</code> や <code>yesod-auth</code> のようなパッケージもまた Persistent の機能を向上させてくれます。</p>
<p>エンティティの構文やデータベースコネクション等に関するより詳しい情報は https://github.com/yesodweb/persistent/tree/master/docs を参照してください。</p>
      </article>

      <div class="pager">
      
      
      </div>

      <div class="row">
        <div class="col s6 offset-s6" style="position: relative; height: 100px;">
          <div class="fixed-action-btn horizontal" style="position: absolute; display: inline-block; right: 24px;">
  <a class="btn-floating btn-large red">
    <i class="large material-icons">share</i>
  </a>
  <ul>
    <li>
      <a class="btn-floating waves-effect waves-light blue tooltipped" data-position="bottom" data-delay="20" data-tooltip="Share on Twitter" href="https://twitter.com/intent/tweet?text=Persistent&url=https://haskell.e-bigmoon.com/yesod/book/ch10-persistent.html"><i class="mdi mdi-twitter white-text"></i></a>
    </li>
    <li>
      <a class="btn-floating waves-effect waves-light indigo tooltipped" data-position="bottom" data-delay="20" data-tooltip="Share on Facebook" href="https://facebook.com/sharer.php?u=https://haskell.e-bigmoon.com/yesod/book/ch10-persistent.html"><i class="mdi mdi-facebook white-text"></i></a>
    </li>
  </ul>
</div>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
    </div>

    <footer class="page-footer indigo lighten-1">
  <div class="footer-copyright">
    <div class="container">
      © 2017-2020 BIGMOON&nbsp;
      Site proudly generated by <a class="red-text text-accent-1" href="http://jaspervdj.be/hakyll">Hakyll</a>,&nbsp;
      original Jekyll theme by <a class="red-text text-accent-1" href="https://github.com/mumuxme/materialize-jekyll">mumuxme</a>.
    </div>
  </div>
</footer>


    <!-- scrolltop button -->
    <button class="material-scrolltop waves-effect waves-light hide-on-small-only" type="button">
      <i class="mdi mdi-arrow-up-bold small white-text"></i>
    </button>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-19322672-9"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-19322672-9');
    </script>

    <!-- jquery -->
    <script type="text/javascript" src="../../lib/jquery-min.js"></script>
    <!-- materialize -->
    <script src="../../lib/materialize/js/materialize.min.js"></script>
    <!-- <\!-- Material ScrollTop plugin -\-> -->
    <script src="../../lib/material-scrolltop/material-scrolltop.js"></script>
    <!-- main -->
    <script src="../../js/init.js"></script>
    <script src="../../js/main.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/haskell.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/yaml.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/shell.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/bash.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>

</html>
