<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">

  <head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# article: http://ogp.me/ns/article#">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0" />
  <!-- MUST in hex format, may the same as header-color. This color is for android chrome browser. -->
  <meta name="theme-color" content="#5c6bc0">

  <!-- Metadata. -->
  <meta name="keywords" content="haskell,blog,bigmoon" />
  <title>Routing and Handlers</title>
  <meta name="description" content="BIG MOON">
  <link rel="canonical" href="../../yesod/book/ch07-routing-and-handlers.html">
  <link rel="alternate" type="application/atom+xml" title="Routing and Handlers" href="../../feed.xml" />
  <link rel="shortcut icon" href="../../images/favicon.ico" />
  <meta name="google-site-verification" content="X2YNboLvzw3_bclXLMvohyJDqj68D06_hPDMukRbgTs" />

  <!-- Stylesheets. -->
  <link rel="stylesheet" href="../../lib/materialize/css/materialize.min.css" />
  <link rel="stylesheet" href="../../css/main.css" />
  <link media="all" rel="stylesheet" type="text/css" href="../../lib/mdi/css/materialdesignicons.min.css" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="../../lib/material-scrolltop/material-scrolltop.css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" />

  <!-- OGP -->
  <meta property="og:title" content="Routing and Handlers" />
  <meta property="og:type" content="article" />
  <meta property="og:url" content="/yesod/book/ch07-routing-and-handlers.html" />
  <!-- <meta property="og:image" content=" サムネイル画像の URL" /> -->
  <meta property="og:site_name" content="Routing and Handlers" />
  <meta property="og:description" content="BIG MOON" />

  <meta name="twitter:card" content="summary" />
  <!-- <meta name="twitter:site" content="@[ Twitter ID]" /> -->
  <!-- <meta name="twitter:player" content="@[ Twitter ID]" /> -->

  <noscript>
  <div class="notice-warning noscript">You don't have javascript enabled. Good luck! :(</div>
</noscript>

<!--[if IE]>
  <div class="notice-warning">Oh, you are using Internet Explorer! Good luck... :(</div>
<![endif]-->

</head>


  <body>
    <header class="site-header">
      <nav class="nav-extended indigo lighten-1">
        <div class="nav-wrapper">
  <a href="../../"><span class="site-title">BIGMOON Haskeller's BLOG</span></a>
  <a href="#" data-activates="mobile-navbar" class="button-collapse">
    <i class="mdi mdi-menu white-text"></i>
  </a>

  <ul id="nav-mobile" class="right hide-on-med-and-down">
    <li>
      <a href="../../" class="white-text">
        <i class="mdi mdi-home left indigo-text text-lighten-3"></i>
        Home
      </a>
    </li>
    <li>
      <a href="../../about.html" class="white-text">
        <i class="mdi mdi-account-circle left indigo-text text-lighten-3"></i>
        About
      </a>
    </li>
    <li>
      <a href="../../stack/" class="white-text">
        <i class="mdi mdi-wrench left indigo-text text-lighten-3"></i>
        Development
      </a>
    </li>
    <li>
      <a href="../../quiz/index.html" class="white-text">
        <i class="mdi mdi-comment-question-outline left indigo-text text-lighten-3"></i>
        Quiz
      </a>
    </li>
    <li>
      <a href="../../libraries/" class="white-text">
        <i class="mdi mdi-package-variant left indigo-text text-lighten-3"></i>
        Libraries
      </a>
    </li>
    <li>
        <a href="../../yesod/" class="white-text">
          <i class="mdi mdi-earth left indigo-text text-lighten-3"></i>
          Yesod
        </a>
      </li>
    <li>
      <a href="../../feed.xml" class="white-text">
        <i class="mdi mdi-rss left indigo-text text-lighten-3"></i>
        Feed
      </a>
    </li>
  </ul>

  <ul class="side-nav" id="mobile-navbar">
    <li>
      <a href="../../" class="waves-effect waves-teal black-text">
        <i class="mdi mdi-home left green-text"></i>
        Home
      </a>
    </li>
    <li>
      <a href="../../about.html" class="navbar-text-colour-mobile">
        <i class="mdi mdi-account-circle left blue-text"></i>
        About
      </a>
    </li>
    <li>
      <a href="../../stack/" class="navbar-text-colour-mobile">
        <i class="mdi mdi-wrench left blue-text"></i>
        Development
      </a>
    </li>
    <li>
      <a href="../../quiz/" class="navbar-text-colour-mobile">
        <i class="mdi mdi-comment-question-outline left blue-text"></i>
        Quiz
      </a>
    </li>
    <li>
      <a href="../../libraries/" class="navbar-text-colour-mobile">
        <i class="mdi mdi-package-variant left blue-text"></i>
        Libraries
      </a>
    </li>
    <li>
      <a href="../../yesod/" class="navbar-text-colour-mobile">
        <i class="mdi mdi-earth left blue-text"></i>
        Yesod
      </a>
    </li>
  </ul>
</div>

      </nav>
    </header>

    <div class="site-container" id="tab-main">
      <div class="wrapper">
        <div class="post-ribbon"></div>

<div class="container page-container">
  <div class="post-page card-panel z-depth-2">
    <div class="post-section">
      <div class="post-heading">
        <h1 class="post-title">Routing and Handlers</h1>
        
        <span>最終更新日: 2018/04/07</span>
        
      </div>

      <article class="page-content">
        <h2 id="routing-and-handlers">Routing and Handlers</h2>
<p>Yesod をモデル-ビュー-コントローラフレームワークとして見れば、ルーティングとハンドラはコントローラに対応します。 次の2つは他のウェブ開発環境において利用される2つのルーティング方法です。</p>
<ul>
<li>名称に基づいてディスパッチする方法。例えば PHP や ASP はこの方法で動作します</li>
<li>正規表現に基づいたルートのパースを行うような、中央ルート処理関数を持つ方法。Django や Rails はこの方法を採用しています。</li>
</ul>
<p>Yesod は原則的には後者の技術に近いのですが、実際には大きな違いが存在するします。 Yesod は正規表現を利用する代わりに、ルートの断片に基づいてマッチングを行います。 また片方向のルート-ハンドラのマッピングを使う代わりに, Yesod は中間データ型 (ルートデータ型, あるいは型安全URLと呼ばれる) と 双方向の変換関数を生成します。</p>
<p>このようなより発展的なシステムを手動でコーディングすることは、冗長でありかつエラーを起こしやすいです。</p>
<p>そのため Yesod はルートに特化したドメイン特化言語 (DSL) を定義し、この DSL を Haskell コードに変換するためのテンプレート Haskell 関数を提供します。 この章ではルーティング宣言に関する構文を説明し、コード生成がどのように行われるかを確認します。 そして、ルーティングとハンドラ間の相互作用について説明します。</p>
<h2 id="route-syntax">Route Syntax</h2>
<p>Yesod のアプローチはルート宣言を既存の構文に無理やり埋め込むのではなく、ルートのためだけに設計された簡潔な構文を利用することです。 これは、コードの読み書きを簡単にするだけでなく Yesod の経験が全く無い場合でも、アプリケーションのサイトマップのように、十分に理解しやすいという利点があります。</p>
<p>この構文の基本的な例は以下の通りです。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="fu">/</span>             <span class="dt">HomeR</span>     <span class="dt">GET</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="fu">/</span>blog         <span class="dt">BlogR</span>     <span class="dt">GET</span> <span class="dt">POST</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="fu">/</span>blog<span class="fu">/#</span><span class="dt">BlogId</span> <span class="dt">BlogPostR</span> <span class="dt">GET</span> <span class="dt">POST</span></a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="fu">/</span>static       <span class="dt">StaticR</span>   <span class="dt">Static</span> getStatic</a></code></pre></div>
<p>これから、ルート宣言において何が起こっているかについて詳細を完全に説明します。</p>
<h3 id="pieces">Pieces</h3>
<p>Yesod がリクエストを得たときに最初に行うことの1つは、リクエストされたパスを断片に分割することです。 断片は全てのフォワードスラッシュ部分でトークン化されます。 例えば以下のようにです。</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1">toPieces <span class="st">&quot;/&quot;</span> <span class="fu">=</span> []</a>
<a class="sourceLine" id="cb2-2" title="2">toPieces <span class="st">&quot;/foo/bar/baz/&quot;</span> <span class="fu">=</span> [<span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>, <span class="st">&quot;baz&quot;</span>, <span class="st">&quot;&quot;</span>]</a></code></pre></div>
<p>末尾スラッシュや2重スラッシュ (“/foo//bar//”) のような問題のある状況が起こり得ることに気づくでしょう。 Yesod は正規化された URL を持つことを推奨します。 もしユーザが末尾スラッシュあるいは2重スラッシュ付きでURLをリクエストすれば、それらは自動的に正規化された URL にリダイレクトされます。 その結果、1つのリソースにつき1つの URL だけ持つことが保証されるため、検索順位に良い影響を与えます。</p>
<p>これが意味することは、URL の正確な構造に悩む必要がないということです。 パス断片を安全なものとして考えることができ、Yesod が自動的にスラッシュの挿入を制御し、問題の生じ得る文字をエスケープしてくれます。</p>
<p>ところでどのようにパスが断片に分割され再結合されるか詳細な制御方法について知りたい場合は Yesod 型クラスの章における <code>cleanPath</code> や <code>joinPath</code> メソッドを再確認してみると良いでしょう。</p>
<h3 id="types-of-pieces">Types of Pieces</h3>
<p>ルートを宣言する場合、処理に当たって3種類の型が存在します。</p>
<h4 id="static">Static</h4>
<p>これは URL と正確に一致する必要のある通常の文字列です。</p>
<h4 id="dynamic-single">Dynamic Single</h4>
<p>これは単一の断片 (2つのスラッシュの間の) ですが、ユーザが入力した値を表し、ページリクエストに対し付属的なユーザ入力を受け取るための主要な方法です。 これらの断片は hash (#) で始まり、そのあとにデータ型が続き、それは <code>PathPiece</code> のインスタンスでなければなりません。</p>
<h4 id="dynamic-multi">Dynamic multi</h4>
<p>Dynamic Single と同じですが、URL 断片を複数受け取ることができます。 また、リソースパターンでは常に断片が最後に来る必要があります。 それはデータ型に続いてアスタリスク (*) を 指定し、さらにデータ型は <code>PathMultiPiece</code> のインスタンスでなければなりません。 複数の断片は他の2つと比べて少し変わっていますが、静的表現のファイル構造や任意の階層を持つ wiki のような機能を実装するためにとても重要です。</p>
<p>Yesod 1.4 から dynamic multi を指定するために <code>+</code> が追加されました。 これは、C プロセッサでは <code>/*</code> 文字を組み合わせることで混乱が生じ得るため、とても重要です。</p>
<p>これから一度は書くような標準的なリソースパターンを見てみましょう。 一番簡単なものは、アプリケーションルートを <code>/</code> にするものです。同じように FAQ を <code>/page/faq</code> としたりする場合もあるでしょう。</p>
<p>例えばフィボナッチウェブサイトを作りたいと思ったら URL を <code>/fib/#Int</code> のように構築するでしょう。 しかし、これにはちょっとした問題があります。 我々はマイナスの値やゼロがアプリケーションに入力されたくありません。 幸運なことに型システムはこれをしっかりと防いでくれます。</p>
<pre class="haskekkl"><code>newtype Natural = Natural Int
instance PathPiece Natural where
    toPathPiece (Natural i) = T.pack $ show i
    fromPathPiece s =
        case reads $ T.unpack s of
            (i, &quot;&quot;):_
                | i &lt; 1 -&gt; Nothing
                | otherwise -&gt; Just $ Natural i
            [] -&gt; Nothing</code></pre>
<p>1行目は不適切な入力を避けるために Int 型を単純な nwetype ラッパーで定義する。</p>
<p><code>PathPiece</code> は2つのメソッドをもつ型クラスであることがわかります。 <code>toPathPiece</code> は <code>Text</code> に変換する以上のことは何も行いません。 <code>fromPathPiece</code> は <code>Text</code> をデータ型に変換しよう試みますが、この変換が不可能な場合は <code>Nothing</code> を返します。 このデータ型を使うことでハンドラ関数に自然数のみが与えられることを保証することができるため、型システムを使って境界問題に対抗することが可能となりました。</p>
<p>現実世界のアプリケーションにおいては、内部的にアプリケーション上有効でない　<code>Natural</code>　値を決して偶然的に作らないよう保証したいでしょう。 そのようにするためには <a href="https://wiki.haskell.org/Smart_constructors">smart constructors</a> のような方法があります。 今回の例の目的とは少し違うので、コードに余分な情報を加えないことにします。</p>
<p><code>PathMultiPiece</code> を定義することも同じくらい簡単です。 例えば、少なくとも2つ以上の階層をもつ Wiki を作りたいので、次のようなデータ型を定義しましょう。</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">data</span> <span class="dt">Page</span> <span class="fu">=</span> <span class="dt">Page</span> <span class="dt">Text</span> <span class="dt">Text</span> [<span class="dt">Text</span>] <span class="co">-- 2 or more</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">instance</span> <span class="dt">PathMultiPiece</span> <span class="dt">Page</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-3" title="3">    toPathMultiPiece (<span class="dt">Page</span> x y z) <span class="fu">=</span> x <span class="fu">:</span> y <span class="fu">:</span> z</a>
<a class="sourceLine" id="cb4-4" title="4">    fromPathMultiPiece (x<span class="fu">:</span>y<span class="fu">:</span>z) <span class="fu">=</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="dt">Page</span> x y z</a>
<a class="sourceLine" id="cb4-5" title="5">    fromPathMultiPiece _ <span class="fu">=</span> <span class="dt">Nothing</span></a></code></pre></div>
<h3 id="overlap-checking">Overlap checking</h3>
<p>Yesod はどの2つのルートも互いに重複する可能性のないことを標準で保証している。 そこで例えば次のようなルートを考えてみましょう。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="fu">/</span>foo<span class="fu">/</span>bar   <span class="dt">Foo1R</span> <span class="dt">GET</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="fu">/</span>foo<span class="fu">/#</span><span class="dt">Text</span> <span class="dt">Foo2R</span> <span class="dt">GET</span></a></code></pre></div>
<p><code>/foo/bar</code> が両方のルートに一致してしまうため、このルート宣言は重複しているものとして拒否されます。 しかし、重複を許したいと思うような2つのケースがあります。</p>
<ol type="1">
<li>データ型の定義から重複が決して起こらないことがわかっている場合。例えば、上の <code>Text</code> を <code>Int</code> で置き換えたとすると、存在するルートで重複するものが無いことはすぐにわかる。しかし、Yesod は今のところそのような分析はできません。</li>
<li>アプリケーションがどのように作動するかについて特別な知識を持っているため、そのような状況が決して起こらないとわかっているとき。例えば、 <code>Foo2R</code> ルートがパラメータ<code>bar</code> を受け取ることが絶対にできない場合などです。</li>
</ol>
<p>エクスクラメーションマークをルートの始まりに追加することで重複チェックをオフにすることができます。 例えば次のコードは問題なく Yesod で動作します。</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="fu">/</span>foo<span class="fu">/</span>bar    <span class="dt">Foo1R</span> <span class="dt">GET</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="fu">!/</span>foo<span class="fu">/#</span><span class="dt">Int</span>  <span class="dt">Foo2R</span> <span class="dt">GET</span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="fu">!/</span>foo<span class="fu">/#</span><span class="dt">Text</span> <span class="dt">Foo3R</span> <span class="dt">GET</span></a></code></pre></div>
<p><code>#</code>、 <code>*</code>、<code>+</code> 文字の後のように、エクスクラメーションマークをどのパス断片の始めに置いても大丈夫ですが、新しい構文のほうが目的が明確なためより好まれます。</p>
<p>重複するルートが生ずる問題はわかりにくさです。 上の例では <code>foo/bar</code> は <code>Foo1R</code> と <code>Foo3R</code> のどちらにルーティングするべきでしょうか？ また <code>/foo/42</code> は <code>Foo2R</code> と <code>Foo3R</code> のどちらにルーティングするべきでしょうか？ Yesod の規則は単純で、最初のルートが優先されます。</p>
<h3 id="resource-name">Resource name</h3>
<p>それぞれのリソースパターンは関連した名前を持っています。 その名前はアプリケーションと結びついた型安全URLデータ型のためのコンストラクタとなるため、大文字で始まらなければなりません。 慣習として、これらのリソース名はすべて大文字の R としています。 これは強要するものは何もなく、それは単に共通の小技みたいなものです。</p>
<p>コンストラクタの正確な定義はそれが結びついているリソースパターンに依存しています。 単一断片あるいは複数断片で用いられるどのデータ型であっても、それがデータ型の引数となります。 これはアプリケーションにおいて型安全 URL 値と有効な URL の間における1対1の関係があります。</p>
<p>これは、すべての値が機能するページであることを意味するのではなく、単に有効な可能性のある URL であることを意味します。 例えば <code>PersonR &quot;Michael&quot;</code> という値はデータベースに Michael がなければ有効なページにはたどり着かないでしょう。</p>
<p>ここで実例を挙げましょう。 <code>PersonR</code> という名前の <code>/person/#Text</code>、 <code>YearR</code> という名前の <code>/year/#Int</code>、 <code>FaqR</code> という名前の <code>/page/faq</code> というリソースパターンがあれば、だいたい次のようなルートデータ型になるであろう.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">data</span> <span class="dt">MyRoute</span> <span class="fu">=</span> <span class="dt">PersonR</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb7-2" title="2">             <span class="fu">|</span> <span class="dt">YearR</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-3" title="3">             <span class="fu">|</span> <span class="dt">FaqR</span></a></code></pre></div>
<p>ユーザが <code>year/2009</code> をリクエストすれば Yesod はそれを <code>YearR 2009</code> に変換します。 <code>person/Michael</code> は <code>PersonR &quot;Michael&quot;</code> となり、 <code>page/faq</code> は <code>FaqR</code> なります。 一方で <code>/year/two-thousand-nine</code>、 <code>/person/michael/snoyman</code>、 <code>/page/FAQ</code> はコードを見なくても404エラーになることがわかります。</p>
<h3 id="handler-specification">Handler specification</h3>
<p>リソースを宣言する際の最終問題はそれらがどのように処理されるかです。 Yesod には次の3つの選択肢があります。</p>
<ul>
<li>与えられたルートにおけるすべてのリクエストメソッドのためのシングルハンドラ関数</li>
<li>与えられたルートにおけるそれぞれのリクエストメソッドのためのセパレートハンドラ関数。その他のリクエストメソッドは 405 Method Not Allowed を返す</li>
<li>サブサイトに受け流す</li>
</ul>
<p>はじめの2つは簡単に使えます。 シングルハンドラ関数は <code>/page/faq FaqR</code> のようなリソースパターンとリソース名が1行で書かれています。 この場合、ハンドラ関数は <code>handleFaqR</code> と命名されなければなりません。</p>
<p>それぞれのリクエストメソッドに対応するためのセパレートハンドラも同じ書き方ですが、リクエストメソッドのリストが必要になります。 例えば <code>/person/#String PersonR GET POST DELETE</code> というようにです。 この場合、 <code>getPersonR</code>、<code>postPersonR</code>、 <code>deletePersonR</code> という3つのハンドラ関数を定義する必要があります。</p>
<p>サブサイトは非常に素晴らしいのですが Yesod のかなり複雑な話題です。 サブサイトの書き方については後にしますが、それらを使うことはそれほど難しくありません。 最も一般的なサブサイトは静的サブサイトで、それはアプリケーションのために静的ファイルを提供します。 <code>/static</code> から静的ファイルを受け取るためには次のようなリソース行が必要となります。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="fu">/</span>static <span class="dt">StaticR</span> <span class="dt">Static</span> getStatic</a></code></pre></div>
<p>この行では <code>/static</code> は単にURL構造のどこから静的ファイルを受け取るかということを言っています。 static という言葉自体には何も魔法の力はなく <code>/my/nondynamic/files</code> などに簡単に変更できます。</p>
<p>次の単語である <code>StaticR</code> はリソース名です。 次の2つの単語はサブサイトを使っていることを指定するものです。 <code>Static</code> はサブサイトのファウンデーションデータ型で、 <code>getStatic</code> はマスターファウンデーションデータ型から <code>Static</code> 値を取り出すための関数です。</p>
<p>今はサブサイトの詳細にはあまり深入りしないようにしましょう。 scaffolded サイトの章で、静的サブサイトについての詳細を確認します。</p>
<h2 id="dispatch">Dispatch</h2>
<p>一度ルートを特定すれば Yesod は URL ディスパッチに関するあらゆる厄介な詳細を引き受けてくれます。 そのためには、確実に適切なハンドラ関数を与えていさえすれば良いのです。 サブサイトのルートに関してはハンドラ関数を書く必要はありませんが、他の2つに関しては書く必要があります。 命名規則については既に説明しました (<code>MyHandlerR GET</code> は <code>getMyHandlerR</code>、 <code>MyOtherHandlerR</code> は <code>handleMyOtherHandlerR</code> となる)。 これで書く必要のある関数が分かったので、次は型注釈がどのようになるべきかについて理解していきましょう。</p>
<h3 id="return-type">Return Type</h3>
<p>簡単なハンドラ関数を見てみましょう。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1">mkYesod <span class="st">&quot;Simple&quot;</span> [parseRoutes|</a>
<a class="sourceLine" id="cb9-2" title="2">/ HomeR GET</a>
<a class="sourceLine" id="cb9-3" title="3">|]</a>
<a class="sourceLine" id="cb9-4" title="4"></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="ot">getHomeR ::</span> <span class="dt">Handler</span> <span class="dt">Html</span></a>
<a class="sourceLine" id="cb9-6" title="6">getHomeR <span class="fu">=</span> defaultLayout [whamlet|<span class="kw">&lt;h1&gt;</span>This is simple|]</a></code></pre></div>
<p>この戻り値の型には2つの要素 <code>Handler</code>、 <code>Html</code> があります。 これらについてより詳細に分析してみましょう。</p>
<h4 id="handler-monad">Handler monad</h4>
<p><code>widget</code> 型のように <code>Handler</code> データ型は Yesod のどのライブラリにおいても定義されていません。 代わりにライブラリはデータ型を与えます。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">data</span> <span class="dt">HandlerT</span> site m a</a></code></pre></div>
<p><code>WidgetT</code> と同様に3つの引数を持ちます。 <code>m</code>はベースモナド、 <code>a</code>はモナド値、 <code>site</code> はファウンデーションデータ型です。 各アプリケーションは <code>site</code> をそのアプリケーションのファウンデーションデータ型、 <code>m</code> を <code>IO</code> というような <code>Handler</code> シノニムを定義します。 もしファウンデーションが <code>MyApp</code> であれば、つまり次のようになるでしょう。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">type</span> <span class="dt">Handler</span> <span class="fu">=</span> <span class="dt">HandlerT</span> <span class="dt">MyApp</span> <span class="dt">IO</span></a></code></pre></div>
<p>サブサイトを書く時に下地のモナドを変更することがありますが、そうでない場合は <code>IO</code> を使います。</p>
<p><code>HandlerT</code> モナドはユーザリクエスト情報 (例: クエリ文字列パラメータ) へのアクセス方法の提供や、レスポンス (例: レスポンスのヘッダ) を変更できるようにしたり、他にも多くのことができます。 Yesod ソースコードの大半がこのモナドとなっているでしょう。</p>
<p>さらに <code>MonadHandler</code> と呼ばれる型クラスがあります。 <code>HandlerT</code> と <code>WidgetT</code> はこの型クラスのインスタンスとなっているため、両方のモナドでは共通の関数が数多く使われています。 もし API 文章の中に <code>MonadHandler</code> があれば、その関数は <code>Handler</code> 関数で使うことができる関数だということを思い出してください。</p>
<h3 id="html">Html</h3>
<p>この型について驚くべきことは何もありません。 この関数は <code>Html</code> データ型で表される HTML コンテンツを返します。 しかし、それが HTML レスポンスのみしか返せないのであれば Yesod は明らかに役に立ちません。 CSS、Javascript、JSON、画像、そしてより多くのものをレスポンスとして返したいのです。 その際、どんなデータ型を返してあげれば良いのだろうか？という疑問が生じると思います。</p>
<p>レスポンスを生成するためには、2つの情報を知る必要があります。 それはコンテンツタイプ (例えば <code>text/html</code>、 <code>image/png</code>) と、バイト列へのシリアライズ化の方法です。 これは <code>TypedContent</code> データ型で表現されます。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">data</span> <span class="dt">TypedContent</span> <span class="fu">=</span> <span class="dt">TypedContent</span> <span class="fu">!</span><span class="dt">ContentType</span> <span class="fu">!</span><span class="dt">Content</span></a></code></pre></div>
<p>また任意のデータ型を <code>TypedContent</code> に変換できる型クラスがあります。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">class</span> <span class="dt">ToTypedContent</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-2" title="2"><span class="ot">    toTypedContent ::</span> a <span class="ot">-&gt;</span> <span class="dt">TypedContent</span></a></code></pre></div>
<p><code>Html</code>、<code>Value</code> (JSON を表す。aeson パッケージが提供している)、<code>Text</code>、 <code>()</code> (空レスポンスを表す) など、よく利用する多くのデータ型は、この型クラスのインスタンスになっています。</p>
<h2 id="arguments">Arguments</h2>
<p>先ほどの例に戻りましょう。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1">mkYesod <span class="st">&quot;Simple&quot;</span> [parseRoutes|</a>
<a class="sourceLine" id="cb14-2" title="2">/ HomeR GET</a>
<a class="sourceLine" id="cb14-3" title="3">|]</a>
<a class="sourceLine" id="cb14-4" title="4"></a>
<a class="sourceLine" id="cb14-5" title="5"><span class="ot">getHomeR ::</span> <span class="dt">Handler</span> <span class="dt">Html</span></a>
<a class="sourceLine" id="cb14-6" title="6">getHomeR <span class="fu">=</span> defaultLayout [whamlet|<span class="kw">&lt;h1&gt;</span>This is simple|]</a></code></pre></div>
<p>あらゆるルートがこの <code>HomeR</code> ほど単純ではありません。 例えば、前に見た <code>PersonR</code> のルートをもう一度確認してみましょう。 person の名前はハンドラ関数に渡す必要があります。 このやり方は率直でとてもわかりやすいものです。 以下に例を示します。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb15-2" title="2"><span class="ot">{-# LANGUAGE QuasiQuotes       #-}</span></a>
<a class="sourceLine" id="cb15-3" title="3"><span class="ot">{-# LANGUAGE TemplateHaskell   #-}</span></a>
<a class="sourceLine" id="cb15-4" title="4"><span class="ot">{-# LANGUAGE TypeFamilies      #-}</span></a>
<a class="sourceLine" id="cb15-5" title="5"><span class="ot">{-# LANGUAGE ViewPatterns      #-}</span></a>
<a class="sourceLine" id="cb15-6" title="6"><span class="kw">import</span>           <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb15-7" title="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></a>
<a class="sourceLine" id="cb15-8" title="8"><span class="kw">import</span>           <span class="dt">Yesod</span></a>
<a class="sourceLine" id="cb15-9" title="9"></a>
<a class="sourceLine" id="cb15-10" title="10"><span class="kw">data</span> <span class="dt">App</span> <span class="fu">=</span> <span class="dt">App</span></a>
<a class="sourceLine" id="cb15-11" title="11"><span class="kw">instance</span> <span class="dt">Yesod</span> <span class="dt">App</span></a>
<a class="sourceLine" id="cb15-12" title="12"></a>
<a class="sourceLine" id="cb15-13" title="13">mkYesod <span class="st">&quot;App&quot;</span> [parseRoutes|</a>
<a class="sourceLine" id="cb15-14" title="14">/person/#Text PersonR GET</a>
<a class="sourceLine" id="cb15-15" title="15">/year/#Integer/month/#Text/day/#Int DateR</a>
<a class="sourceLine" id="cb15-16" title="16">/wiki/*Texts WikiR GET</a>
<a class="sourceLine" id="cb15-17" title="17">|]</a>
<a class="sourceLine" id="cb15-18" title="18"></a>
<a class="sourceLine" id="cb15-19" title="19"><span class="ot">getPersonR ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Html</span></a>
<a class="sourceLine" id="cb15-20" title="20">getPersonR name <span class="fu">=</span> defaultLayout [whamlet|<span class="kw">&lt;h1&gt;</span>Hello <span class="kw">#{</span>name<span class="kw">}</span>!|]</a>
<a class="sourceLine" id="cb15-21" title="21"></a>
<a class="sourceLine" id="cb15-22" title="22"><span class="ot">handleDateR ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Text</span> <span class="co">-- text/plain</span></a>
<a class="sourceLine" id="cb15-23" title="23">handleDateR year month day <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-24" title="24">    <span class="fu">return</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb15-25" title="25">        T.concat [month, <span class="st">&quot; &quot;</span>, T.pack <span class="fu">$</span> <span class="fu">show</span> day, <span class="st">&quot;, &quot;</span>, T.pack <span class="fu">$</span> <span class="fu">show</span> year]</a>
<a class="sourceLine" id="cb15-26" title="26"></a>
<a class="sourceLine" id="cb15-27" title="27"><span class="ot">getWikiR ::</span> [<span class="dt">Text</span>] <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb15-28" title="28">getWikiR <span class="fu">=</span> <span class="fu">return</span> <span class="fu">.</span> T.unwords</a>
<a class="sourceLine" id="cb15-29" title="29"></a>
<a class="sourceLine" id="cb15-30" title="30"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb15-31" title="31">main <span class="fu">=</span> warp <span class="dv">3000</span> <span class="dt">App</span></a></code></pre></div>
<p>引数は各ルートで dynamic pieces の型の値を指定された順番で持ちます。 また、 戻り値として <code>Html</code> と <code>Text</code> のどちらも利用可能なことに注意してください。</p>
<h2 id="the-handler-functions">The Handler functions</h2>
<p>大部分のコードは <code>Handler</code> モナドにあるため、それをより理解するために時間を費やすことは重要です。 この章の残りでは <code>Handler</code> モナドにある最も一般的な関数について手短に紹介します。 セッション関数についてはセッションの章で解説するため、今回は特に説明しません。</p>
<h3 id="application-information">Application Information</h3>
<p>アプリケーション全体の情報を返し、個々のリクエストについては何の情報も返さない関数が数多くあります。 それらをいくつか紹介します。</p>
<h4 id="getyesod">getYesod</h4>
<p>アプリケーションのファウンデーション値を返します。 もし, ファウンデーションに設定値を保存していれば、この関数を多用することになるでしょう。 (一応 <code>Control.Monad.Reader</code> の <code>ask</code> を使うこともできる。 <code>getYesod</code> は単にその型を特殊化したものです。)</p>
<h4 id="geturlrender">getUrlRender</h4>
<p>URLレンダリング関数を返し、それは型安全URLを <code>Text</code> に変換します。 Hamlet を使えば Yesod が代わりにこの関数を呼び出してくれますが、直接呼び出す必要もたまにはあります。</p>
<h4 id="geturlrenderparams">getUrlRenderParams</h4>
<p><code>getUrlRender</code> の異なるバージョンです。 型安全 URL とクエリ文字列パラメータのリストを <code>Text</code> に変換します。 この関数は必要なすべてのパーセントエンコーディングを行います。</p>
<h3 id="リクエスト情報">リクエスト情報</h3>
<p>現在のリクエストで欲しい情報はリクエストされたパス、クエリ文字列パラメータ、そして <code>POST</code> されたフォームデータが一般的です。 リクエエストされたパスは既に説明したようにルーティングで取り扱われます。 他の2つはフォームモジュールを使って適切に取り扱います。</p>
<p>また、時々データを生の形で得る必要があります。 このために Yesod では <code>YesodRequest</code> データ型とそれを回収するための <code>getRequest</code> 関数が使えます。 これにより GET パラメーターの完全なリスト、クッキー、優先言語へのアクセスが可能になります。 さらに <code>lookupGetParam</code>、 <code>lookupCookie</code>、 <code>language</code> のような探索のための便利な関数があります。 POST パラメータへの生アクセスに関しては <code>runRequestBody</code> を利用しましょう。 リクエストヘッダのようにさらに多くの生データが必要な場合 <code>waiRequest</code> を使って Web Application Interface(WAI) リクエスト値にアクセスできます。 より詳細については付録の WAI を参照してください。</p>
<h3 id="short-circuiting">Short Circuiting</h3>
<p>即座にハンドラ関数の処理を終了し、結果をユーザに返します。</p>
<h4 id="redirect">redirect</h4>
<p>リダイレクトレスポンスをユーザ (303レスポンス) に送ります。 違うレスポンスコード (例えば、パーマネント301リダイレクト) にしたい場合は <code>redirectionWith</code> を利用します。</p>
<p>Yesod は HTTP/1.1 クライアントには 303 レスポンス、そして HTTP/1.0 クライアントには 302 レスポンスを返します。 このひどい実装は HTTP の仕様によるものです。</p>
<h4 id="notfound">notFound</h4>
<p>404 レスポンスを返します。 ユーザが存在しないデータベース値をリクエストした場合によく利用します。</p>
<h4 id="permissiondenied">permissionDenied</h4>
<p>特定のエラーメッセージとともに403レスポンスを返します。</p>
<h4 id="invalidargs">invalidArgs</h4>
<p>有効でない引数のリストと一緒に400レスポンスを返します。</p>
<h4 id="sendfile">sendFile</h4>
<p>特定のコンテンツ型を持つファイルシステムからファイルを送信します。 これは下地の WAI ハンドラがこれを <code>sendfile</code> システムコールに最適化できるため、静的ファイルを送る方法として好まれます。 静的ファイルを送るための <code>readFile</code> は必要ありません。</p>
<h4 id="sendresponse">sendResponse</h4>
<p>200ステータスコードと共に通常のレスポンスを返します。 即座にレスポンスが返るため、深くネストしたコードから抜け出す必要があるときに便利です。 また <code>ToTypedContent</code> の任意のインスタンスが利用できます。</p>
<h4 id="sendwairesponse">sendWaiResponse</h4>
<p>低レベルにおいて生の WAI レスポンスを送りたい場合に利用します。 これはストリーミングレスポンスやサーバーが送るイベントのような技術を作りたい場合に利用します。</p>
<h3 id="response-headers">Response Headers</h3>
<h4 id="setcookie">setCookie</h4>
<p>クライアントにクッキーをセットします。 この関数は有効期限を取る代わりに、分単位でクッキーの期間を取ります。 次のリクエストまでは <code>lookupCookie</code> を使っても、このクッキーは見えないことを覚えておいてください。</p>
<h4 id="deletcookie">deletCookie</h4>
<p>クライアントにクッキーを消去するように伝えます。 これもまた <code>lookupCookie</code> を使っても、次のリクエストまで変更は反映されません。</p>
<h4 id="setheader-現在は-addheader">setHeader (現在は addHeader)</h4>
<p>任意のレスポンスヘッダを設定する。</p>
<h4 id="setlanguage">setLanguage</h4>
<p>ユーザの優先言語を設定する。 これは <code>language</code> 関数の結果として出現する。</p>
<h4 id="cacheseconds">cacheSeconds</h4>
<p>何秒間このレスポンスをキャッシュするかを制御する Cache−Control ヘッダを設定します。 これは <a href="http://www.varnish-cache.org/">vanish on your server</a> を用いている場合に特に利用価値があります。</p>
<h4 id="neverexpires">neverExpires</h4>
<p>Expires ヘッダを2037年に設定します。 これはリクエストパスがそれと関連したハッシュ値を持っている場合のように、有効期限が決して切れないコンテンツと共に用いられます。</p>
<h4 id="alreadyexpired">alreadyExpired</h4>
<p>Expires ヘッダを過去に設定します。</p>
<h4 id="expiresat">expiresAt</h4>
<p>Expires ヘッダを特定の日/時間に設定します。</p>
<h2 id="io-and-debugging">I/O and debugging</h2>
<p><code>HeaderT</code> と <code>WidgetT</code> モナドトランスフォーマは両方とも多くの型クラスのインスタンスとなっています。 ここで重要な型クラスは <code>MonadIO</code> と <code>MonadLogger</code> です。 <code>MonadIO</code> によってファイルからの読み込みのようなハンドラ内における任意の <code>IO</code> アクションが可能となります。 使い方としては、呼び出しの先頭に <code>liftIO</code> を追加するだけで良いです。</p>
<p><code>MonadLogger</code> は内蔵されたログシステムを追加します。 どのメッセージがログに記録されるか、どこにログが記録されるかを含み、システムをカスタマイズするための多くの方法があります。 デフォルトではログは標準出力、開発においてはすべてのメッセージ、製品版においては警告とエラーがログに記録されます。</p>
<p>しばしばログを行ってるとき、ソースコードのどこでログが行われているか知りたいかもしれません。 このために <code>MonadLogger</code> は自動的にソースコードの位置をログメッセージに挿入するいくつもの便利なテンプレート Haskell 関数を提供しています。 これらの関数は <code>$logDebug</code>、 <code>$logInfo</code>、 <code>$logWarn</code>、 <code>$logError</code> です。 これらの関数を理解する例を見て見ましょう。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb16-2" title="2"><span class="ot">{-# LANGUAGE QuasiQuotes       #-}</span></a>
<a class="sourceLine" id="cb16-3" title="3"><span class="ot">{-# LANGUAGE TemplateHaskell   #-}</span></a>
<a class="sourceLine" id="cb16-4" title="4"><span class="ot">{-# LANGUAGE TypeFamilies      #-}</span></a>
<a class="sourceLine" id="cb16-5" title="5"><span class="kw">import</span>           <span class="dt">Control.Exception</span> (<span class="dt">IOException</span>, try)</a>
<a class="sourceLine" id="cb16-6" title="6"><span class="kw">import</span>           <span class="dt">Control.Monad</span>     (when)</a>
<a class="sourceLine" id="cb16-7" title="7"><span class="kw">import</span>           <span class="dt">Yesod</span></a>
<a class="sourceLine" id="cb16-8" title="8"></a>
<a class="sourceLine" id="cb16-9" title="9"><span class="kw">data</span> <span class="dt">App</span> <span class="fu">=</span> <span class="dt">App</span></a>
<a class="sourceLine" id="cb16-10" title="10"><span class="kw">instance</span> <span class="dt">Yesod</span> <span class="dt">App</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-11" title="11">    <span class="co">-- This function controls which messages are logged</span></a>
<a class="sourceLine" id="cb16-12" title="12">    shouldLogIO <span class="dt">App</span> src level <span class="fu">=</span> <span class="fu">return</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb16-13" title="13">        <span class="dt">True</span> <span class="co">-- good for development</span></a>
<a class="sourceLine" id="cb16-14" title="14">        <span class="co">-- level == LevelWarn || level == LevelError -- good for production</span></a>
<a class="sourceLine" id="cb16-15" title="15"></a>
<a class="sourceLine" id="cb16-16" title="16">mkYesod <span class="st">&quot;App&quot;</span> [parseRoutes|</a>
<a class="sourceLine" id="cb16-17" title="17">/ HomeR GET</a>
<a class="sourceLine" id="cb16-18" title="18">|]</a>
<a class="sourceLine" id="cb16-19" title="19"></a>
<a class="sourceLine" id="cb16-20" title="20"><span class="ot">getHomeR ::</span> <span class="dt">Handler</span> <span class="dt">Html</span></a>
<a class="sourceLine" id="cb16-21" title="21">getHomeR <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-22" title="22">    <span class="fu">$</span>logDebug <span class="st">&quot;Trying to read data file&quot;</span></a>
<a class="sourceLine" id="cb16-23" title="23">    edata <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> try <span class="fu">$</span> <span class="fu">readFile</span> <span class="st">&quot;datafile.txt&quot;</span></a>
<a class="sourceLine" id="cb16-24" title="24">    <span class="kw">case</span><span class="ot"> edata ::</span> <span class="dt">Either</span> <span class="dt">IOException</span> <span class="dt">String</span> <span class="kw">of</span></a>
<a class="sourceLine" id="cb16-25" title="25">        <span class="dt">Left</span> e <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-26" title="26">            <span class="fu">$</span>logError <span class="fu">$</span> <span class="st">&quot;Could not read datafile.txt&quot;</span></a>
<a class="sourceLine" id="cb16-27" title="27">            defaultLayout [whamlet|An error occurred|]</a>
<a class="sourceLine" id="cb16-28" title="28">        <span class="dt">Right</span> str <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-29" title="29">            <span class="fu">$</span>logInfo <span class="st">&quot;Reading of data file succeeded&quot;</span></a>
<a class="sourceLine" id="cb16-30" title="30">            <span class="kw">let</span> ls <span class="fu">=</span> <span class="fu">lines</span> str</a>
<a class="sourceLine" id="cb16-31" title="31">            when (<span class="fu">length</span> ls <span class="fu">&lt;</span> <span class="dv">5</span>) <span class="fu">$</span> <span class="fu">$</span>logWarn <span class="st">&quot;Less than 5 lines of data&quot;</span></a>
<a class="sourceLine" id="cb16-32" title="32">            defaultLayout</a>
<a class="sourceLine" id="cb16-33" title="33">                [whamlet|</a>
<a class="sourceLine" id="cb16-34" title="34">                    <span class="kw">&lt;ol&gt;</span></a>
<a class="sourceLine" id="cb16-35" title="35">                        <span class="kw">$forall</span> l <span class="ot">&lt;-</span> ls</a>
<a class="sourceLine" id="cb16-36" title="36">                            <span class="kw">&lt;li&gt;#{</span>l<span class="kw">}</span></a>
<a class="sourceLine" id="cb16-37" title="37">                |]</a>
<a class="sourceLine" id="cb16-38" title="38"></a>
<a class="sourceLine" id="cb16-39" title="39"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb16-40" title="40">main <span class="fu">=</span> warp <span class="dv">3000</span> <span class="dt">App</span></a></code></pre></div>
<h2 id="query-string-and-hash-hragments">Query string and hash hragments</h2>
<p><code>redirect</code> のように URL のようなものに対して機能するいくつもの関数を見てきました。 これらの関数はすべて型安全 URL と共に機能しますが、他にはどのようなものと機能するのでしょうか？ <code>RedirectUrl</code> と呼ばれる型クラスがあり、それはある型をテキスト形式の URL に変換するメソッドを備えます。 これは型安全URL、テキスト形式のURL、そして2つの特別なインスタンスを含みます。</p>
<ol type="1">
<li>URLとクエリ文字列パラメータのキー/値ペアのリストのタプル</li>
<li>ハッシュ断片を URL の最後に追加するために使われる <code>Fragment</code> データ型</li>
</ol>
<p>これら2つのインスタンスによって、付加的な情報を型安全URLに加えることができます。 これらがどのように使われるかについて、例を見てみましょう。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb17-2" title="2"><span class="ot">{-# LANGUAGE QuasiQuotes       #-}</span></a>
<a class="sourceLine" id="cb17-3" title="3"><span class="ot">{-# LANGUAGE TemplateHaskell   #-}</span></a>
<a class="sourceLine" id="cb17-4" title="4"><span class="ot">{-# LANGUAGE TypeFamilies      #-}</span></a>
<a class="sourceLine" id="cb17-5" title="5"><span class="kw">import</span>           <span class="dt">Data.Text</span>        (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb17-6" title="6"><span class="kw">import</span>           <span class="dt">Yesod</span></a>
<a class="sourceLine" id="cb17-7" title="7"></a>
<a class="sourceLine" id="cb17-8" title="8"><span class="kw">data</span> <span class="dt">App</span> <span class="fu">=</span> <span class="dt">App</span></a>
<a class="sourceLine" id="cb17-9" title="9"></a>
<a class="sourceLine" id="cb17-10" title="10">mkYesod <span class="st">&quot;App&quot;</span> [parseRoutes|</a>
<a class="sourceLine" id="cb17-11" title="11">/      HomeR  GET</a>
<a class="sourceLine" id="cb17-12" title="12">/link1 Link1R GET</a>
<a class="sourceLine" id="cb17-13" title="13">/link2 Link2R GET</a>
<a class="sourceLine" id="cb17-14" title="14">/link3 Link3R GET</a>
<a class="sourceLine" id="cb17-15" title="15">/link4 Link4R GET</a>
<a class="sourceLine" id="cb17-16" title="16">|]</a>
<a class="sourceLine" id="cb17-17" title="17"></a>
<a class="sourceLine" id="cb17-18" title="18"><span class="kw">instance</span> <span class="dt">Yesod</span> <span class="dt">App</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-19" title="19"></a>
<a class="sourceLine" id="cb17-20" title="20"><span class="ot">getHomeR ::</span> <span class="dt">Handler</span> <span class="dt">Html</span></a>
<a class="sourceLine" id="cb17-21" title="21">getHomeR <span class="fu">=</span> defaultLayout <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb17-22" title="22">    setTitle <span class="st">&quot;Redirects&quot;</span></a>
<a class="sourceLine" id="cb17-23" title="23">    [whamlet|</a>
<a class="sourceLine" id="cb17-24" title="24">        <span class="kw">&lt;p&gt;</span></a>
<a class="sourceLine" id="cb17-25" title="25">            <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="kw">@{</span><span class="dt">Link1R</span><span class="kw">}&gt;</span>Click to start the redirect chain!</a>
<a class="sourceLine" id="cb17-26" title="26">    |]</a>
<a class="sourceLine" id="cb17-27" title="27"></a>
<a class="sourceLine" id="cb17-28" title="28">getLink1R, getLink2R,<span class="ot"> getLink3R ::</span> <span class="dt">Handler</span> ()</a>
<a class="sourceLine" id="cb17-29" title="29">getLink1R <span class="fu">=</span> redirect <span class="dt">Link2R</span> <span class="co">-- /link2</span></a>
<a class="sourceLine" id="cb17-30" title="30">getLink2R <span class="fu">=</span> redirect (<span class="dt">Link3R</span>, [(<span class="st">&quot;foo&quot;</span>, <span class="st">&quot;bar&quot;</span>)]) <span class="co">-- /link3?foo=bar</span></a>
<a class="sourceLine" id="cb17-31" title="31">getLink3R <span class="fu">=</span> redirect <span class="fu">$</span> <span class="dt">Link4R</span> <span class="fu">:#:</span> (<span class="st">&quot;baz&quot;</span><span class="ot"> ::</span> <span class="dt">Text</span>) <span class="co">-- /link4#baz</span></a>
<a class="sourceLine" id="cb17-32" title="32"></a>
<a class="sourceLine" id="cb17-33" title="33"><span class="ot">getLink4R ::</span> <span class="dt">Handler</span> <span class="dt">Html</span></a>
<a class="sourceLine" id="cb17-34" title="34">getLink4R <span class="fu">=</span> defaultLayout</a>
<a class="sourceLine" id="cb17-35" title="35">    [whamlet|</a>
<a class="sourceLine" id="cb17-36" title="36">        <span class="kw">&lt;p&gt;</span>You made it!</a>
<a class="sourceLine" id="cb17-37" title="37">    |]</a>
<a class="sourceLine" id="cb17-38" title="38"></a>
<a class="sourceLine" id="cb17-39" title="39"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb17-40" title="40">main <span class="fu">=</span> warp <span class="dv">3000</span> <span class="dt">App</span></a></code></pre></div>
<p>もちろん Hamletテンプレートにおいてはハッシュを直接 URL の後に追加できるのでこれは多くの場合不要です。</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1"><span class="fu">&lt;</span>a href<span class="fu">=@</span>{<span class="dt">Link1R</span>}<span class="fu">#</span>somehash<span class="fu">&gt;</span><span class="dt">Link</span> to hash</a></code></pre></div>
<h2 id="summary">Summary</h2>
<p>ルーティングとディスパッチは間違いなく Yesod のコアです。 型安全URLはここから定義され、大部分のコードは <code>Handler</code> モナド内部に記述されます。 この章では Yesod において最も重要な中心的概念について説明しました。 したがって、それを適切に理解することが重要です。</p>
<p>この章ではまた、後に扱ういくつものより複雑な Yesod に関するトピックについても触れました。 しかし、ここまでで学んだ知識だけでもかなり洗練されたウェブアプリケーションを書くことが可能なはずです。</p>
      </article>

      <div class="pager">
      
      
      </div>

      <div class="row">
        <div class="col s6 offset-s6" style="position: relative; height: 100px;">
          <div class="fixed-action-btn horizontal" style="position: absolute; display: inline-block; right: 24px;">
  <a class="btn-floating btn-large red">
    <i class="large material-icons">share</i>
  </a>
  <ul>
    <li>
      <a class="btn-floating waves-effect waves-light blue tooltipped" data-position="bottom" data-delay="20" data-tooltip="Share on Twitter" href="https://twitter.com/intent/tweet?text=Routing and Handlers&url=https://haskell.e-bigmoon.com/yesod/book/ch07-routing-and-handlers.html"><i class="mdi mdi-twitter white-text"></i></a>
    </li>
    <li>
      <a class="btn-floating waves-effect waves-light indigo tooltipped" data-position="bottom" data-delay="20" data-tooltip="Share on Facebook" href="https://facebook.com/sharer.php?u=https://haskell.e-bigmoon.com/yesod/book/ch07-routing-and-handlers.html"><i class="mdi mdi-facebook white-text"></i></a>
    </li>
    <li>
      <a class="btn-floating waves-effect waves-light red tooltipped" data-position="bottom" data-delay="20" data-tooltip="Share on Google+" href="https://plus.google.com/share?url=https://haskell.e-bigmoon.com/yesod/book/ch07-routing-and-handlers.html"><i class="mdi mdi-google-plus white-text"></i></a>
    </li>
  </ul>
</div>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
    </div>

    <footer class="page-footer indigo lighten-1">

  <div class="footer-copyright">

    <div class="container">
      CopyRight © 2018 BIGMOON All Rights Reserved.&nbsp;
      Site proudly generated by <a class="red-text text-accent-1" href="http://jaspervdj.be/hakyll">Hakyll</a>,&nbsp;
      original Jekyll theme by <a class="red-text text-accent-1" href="https://github.com/mumuxme/materialize-jekyll">mumuxme</a>.
    </div>

  </div>

</footer>


    <!-- scrolltop button -->
    <button class="material-scrolltop waves-effect waves-light hide-on-small-only" type="button">
      <i class="mdi mdi-arrow-up-bold small white-text"></i>
    </button>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-19322672-9"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-19322672-9');
    </script>

    <!-- jquery -->
    <script type="text/javascript" src="../../lib/jquery-min.js"></script>
    <!-- materialize -->
    <script src="../../lib/materialize/js/materialize.min.js"></script>
    <!-- <\!-- Material ScrollTop plugin -\-> -->
    <script src="../../lib/material-scrolltop/material-scrolltop.js"></script>
    <!-- main -->
    <script src="../../js/init.js"></script>
    <script src="../../js/main.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/haskell.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>

</html>
