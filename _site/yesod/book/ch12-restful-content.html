<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">

  <head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# article: http://ogp.me/ns/article#">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0" />
  <!-- MUST in hex format, may the same as header-color. This color is for android chrome browser. -->
  <meta name="theme-color" content="#5c6bc0">

  <!-- Metadata. -->
  <meta name="keywords" content="haskell,blog,bigmoon" />
  <title>ch12-restful-content</title>
  <meta name="description" content="BIG MOON">
  <link rel="canonical" href="../../yesod/book/ch12-restful-content.html">
  <link rel="alternate" type="application/atom+xml" title="ch12-restful-content" href="../../feed.xml" />
  <link rel="shortcut icon" href="../../images/favicon.ico" />
  <meta name="google-site-verification" content="X2YNboLvzw3_bclXLMvohyJDqj68D06_hPDMukRbgTs" />

  <!-- Stylesheets. -->
  <link rel="stylesheet" href="../../lib/materialize/css/materialize.min.css" />
  <link rel="stylesheet" href="../../css/main.css" />
  <link media="all" rel="stylesheet" type="text/css" href="../../lib/mdi/css/materialdesignicons.min.css" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="stylesheet" href="../../lib/material-scrolltop/material-scrolltop.css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" />

  <!-- OGP -->
  <meta property="og:title" content="ch12-restful-content" />
  <meta property="og:type" content="article" />
  <meta property="og:url" content="/yesod/book/ch12-restful-content.html" />
  <!-- <meta property="og:image" content=" サムネイル画像の URL" /> -->
  <meta property="og:site_name" content="ch12-restful-content" />
  <meta property="og:description" content="BIG MOON" />

  <meta name="twitter:card" content="summary" />
  <!-- <meta name="twitter:site" content="@[ Twitter ID]" /> -->
  <!-- <meta name="twitter:player" content="@[ Twitter ID]" /> -->

  <noscript>
  <div class="notice-warning noscript">You don't have javascript enabled. Good luck! :(</div>
</noscript>

<!--[if IE]>
  <div class="notice-warning">Oh, you are using Internet Explorer! Good luck... :(</div>
<![endif]-->

</head>


  <body>
    <header class="site-header">
      <nav class="nav-extended indigo lighten-1">
        <div class="nav-wrapper">
  <a href="../../"><span class="site-title">BIGMOON Haskeller's BLOG</span></a>
  <a href="#" data-activates="mobile-navbar" class="button-collapse">
    <i class="mdi mdi-menu white-text"></i>
  </a>

  <ul id="nav-mobile" class="right hide-on-med-and-down">
    <li>
      <a href="../../" class="white-text">
        <i class="mdi mdi-home left indigo-text text-lighten-3"></i>
        Home
      </a>
    </li>
    <li>
      <a href="../../about.html" class="white-text">
        <i class="mdi mdi-account-circle left indigo-text text-lighten-3"></i>
        About
      </a>
    </li>
    <li>
      <a href="../../stack/" class="white-text">
        <i class="mdi mdi-wrench left indigo-text text-lighten-3"></i>
        Development
      </a>
    </li>
    <li>
      <a href="../../quiz/index.html" class="white-text">
        <i class="mdi mdi-comment-question-outline left indigo-text text-lighten-3"></i>
        Quiz
      </a>
    </li>
    <li>
      <a href="../../libraries/" class="white-text">
        <i class="mdi mdi-package-variant left indigo-text text-lighten-3"></i>
        Libraries
      </a>
    </li>
    <li>
        <a href="../../yesod/" class="white-text">
          <i class="mdi mdi-earth left indigo-text text-lighten-3"></i>
          Yesod
        </a>
      </li>
    <li>
      <a href="../../feed.xml" class="white-text">
        <i class="mdi mdi-rss left indigo-text text-lighten-3"></i>
        Feed
      </a>
    </li>
  </ul>

  <ul class="side-nav" id="mobile-navbar">
    <li>
      <a href="../../" class="waves-effect waves-teal black-text">
        <i class="mdi mdi-home left green-text"></i>
        Home
      </a>
    </li>
    <li>
      <a href="../../about.html" class="navbar-text-colour-mobile">
        <i class="mdi mdi-account-circle left blue-text"></i>
        About
      </a>
    </li>
    <li>
      <a href="../../stack/" class="navbar-text-colour-mobile">
        <i class="mdi mdi-wrench left blue-text"></i>
        Development
      </a>
    </li>
    <li>
      <a href="../../quiz/" class="navbar-text-colour-mobile">
        <i class="mdi mdi-comment-question-outline left blue-text"></i>
        Quiz
      </a>
    </li>
    <li>
      <a href="../../libraries/" class="navbar-text-colour-mobile">
        <i class="mdi mdi-package-variant left blue-text"></i>
        Libraries
      </a>
    </li>
    <li>
      <a href="../../yesod/" class="navbar-text-colour-mobile">
        <i class="mdi mdi-earth left blue-text"></i>
        Yesod
      </a>
    </li>
  </ul>
</div>

      </nav>
    </header>

    <div class="site-container" id="tab-main">
      <div class="wrapper">
        <div class="post-ribbon"></div>

<div class="container page-container">
  <div class="post-page card-panel z-depth-2">
    <div class="post-section">
      <div class="post-heading">
        <h1 class="post-title">ch12-restful-content</h1>
        
      </div>

      <article class="page-content">
        <h1 id="restful-content">RESTful Content</h1>
<p>Webの初期における話の一つに, どのようにサーチエンジンがウェブサイト全体を見渡していたかというものがある. まだ動的なウェブサイトが新しい概念であった頃は, 開発者は<code>GET</code>と<code>POST</code>リクエストの違いを認識していなかった. その結果, <code>GET</code>メソッドでアクセスされ, ページを消すようなページが作られた. サーチエンジンがこのようなサイトをスクリーニングするようになると, そのようなサイトは消去されてしまうようになった.</p>
<p>もしこれらの開発者がHTTP仕様に適切にしたがっていれば, このようなことは起こらなかったであろう. <code>GET</code>リクエストは, 副作用を起こさないことになっている(ご存知のように, それはサイトを消去することなどである). 最近, Web開発において, RESTとしても知られている, Representational State Transferを適切に採用する動きがある. この章では, YesodにおけるRESTfulな側面と, それらを用いてどのようにして, より堅牢なウェブアプリケーションを作ることができるか, について説明する.</p>
<h2 id="リクエストメソッド">リクエストメソッド</h2>
<p>多くのウェブフレームワークにおいては, 1つのリソースにつき, 1つのハンドラ関数を作る. Yesodにおいては, 異なるリクエストメソッドについて, 異なるハンドラ関数を作ることがデフォルトとなっている. ウェブサイトを構築するにあたり扱われる, もっとも一般的な2つのリクエストメソッドは, <code>GET</code>と<code>POST</code>である. これらは, HTMLにおいて, もっともよくサポートされているメソッドである. 何故ならば, ウェブフォームがサポートしている唯一のメソッドであるためである. しかし, RESTfulなAPIを作るにあたり, 他のメソッドも有益である.</p>
<p>技術的に言うと, どんな好きなメソッドでも用いることは可能である. しかし, HTTP仕様を遵守することが, 強く勧められる. これらの中で, もっとも一般的なものは次のようである:</p>
<h3 id="get"><code>GET</code></h3>
<p>Read-onlyリクエスト. サーバ側に全く変化が起こらないことを想定しており, <code>GET</code>リクエストを何回呼び出しても同じ結果になるはずで, 現在時刻や任意に割り振られた結果は除かれる.</p>
<h3 id="post">POST</h3>
<p>一般的に変化を起こすリクエストである. <code>POST</code>リクエストはユーザによって2度提出されるべきではない. 一般的な例としては, ある銀行口座から別のところへ基金を送金することが挙げられる.</p>
<h3 id="put">PUT</h3>
<p>サーバに新しいリソースを割り当てるか, 既存のものを交換する. このメソッドは何度呼ばれても安全である.</p>
<h3 id="patch">PATCH</h3>
<p>サーバ上のリソースを部分的に更新する. リソースの1つまはたそれ以上のリソースをアップデートしたい場合, このメソッドが好まれる.</p>
<h3 id="delete">DELETE</h3>
<p>文字通りである: サーバ上のリソースを削除する. 何度呼び出しても問題ない.</p>
<p>ある程度, これはHaskellの哲学に非常によく適合する: <code>GET</code>リクエストは純粋関数に類似しており, 副作用を持たない. 実践的には, <code>GET</code>関数はおそらく<code>IO</code>を行なっており, データベースから情報を取り出したり, ユーザの操作を記録したりしている.</p>
<p>各リクエストメソッドに対しハンドラ関数を定義する構文についての詳細は, ルーティングとハンドラの章を参照しなさい.</p>
<h2 id="表現">表現</h2>
<p>次のようなHaskellデータ型と値があったとしよう.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span> {<span class="ot"> name ::</span> <span class="dt">String</span>,<span class="ot"> age ::</span> <span class="dt">Int</span> }</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">michael <span class="fu">=</span> <span class="dt">Person</span> <span class="st">&quot;Michael&quot;</span> <span class="dv">25</span></a></code></pre></div>
<p>このデータはHTMLでは次のように表せる:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode html"><code class="sourceCode html"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">&lt;table&gt;</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    <span class="kw">&lt;tr&gt;</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">        <span class="kw">&lt;th&gt;</span>Name<span class="kw">&lt;/th&gt;</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">        <span class="kw">&lt;td&gt;</span>Michael<span class="kw">&lt;/td&gt;</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">    <span class="kw">&lt;/tr&gt;</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">    <span class="kw">&lt;tr&gt;</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">        <span class="kw">&lt;th&gt;</span>Age<span class="kw">&lt;/th&gt;</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8">        <span class="kw">&lt;td&gt;</span>25<span class="kw">&lt;/td&gt;</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">    <span class="kw">&lt;/tr&gt;</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="kw">&lt;/table&gt;</span></a></code></pre></div>
<p>または, JSONを用いて次のように表せる:</p>
<pre><code>{&quot;name&quot;:&quot;Michael&quot;,&quot;age&quot;:25}</code></pre>
<p>さらに, XMLを用いると,</p>
<pre><code>&lt;person&gt;
    &lt;name&gt;Michael&lt;/name&gt;
    &lt;age&gt;25&lt;/age&gt;
&lt;/person&gt;</code></pre>
<p>しばしば, ウェブアプリケーションは異なるURLを用いて, これらの表現を獲得する; おそらく, <code>/person/michael.html</code>, <code>/person/michael.json</code>などであろう. Yesodは各リソースにつき1つのURLというRESTful原則に従う. よって, Yesodにおいては, これら全ては<code>/person/michael</code>でアクセス可能である.</p>
<p>そこで疑問となるのは, どの表現を用いるかを決定する方法である. 答えとなるのは, HTTP<code>ACccept</code>ヘッダである: それは, クライアントが期待しているコンテンツタイプの優先リストを与える. Yesodは関数のペアを持つことで, 直接ヘッダをパーズする詳細を取り除き, 代わりに, より高レベルの表現で扱えるようにする. 最後の文をコードでより具体化しよう.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="ot">{-# LANGUAGE QuasiQuotes       #-}</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3"><span class="ot">{-# LANGUAGE TemplateHaskell   #-}</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="ot">{-# LANGUAGE TypeFamilies      #-}</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Yesod</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="kw">data</span> <span class="dt">App</span> <span class="fu">=</span> <span class="dt">App</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9"></a>
<a class="sourceLine" id="cb5-10" data-line-number="10">mkYesod <span class="st">&quot;App&quot;</span> [parseRoutes|</a>
<a class="sourceLine" id="cb5-11" data-line-number="11">/ HomeR GET</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">|]</a>
<a class="sourceLine" id="cb5-13" data-line-number="13"></a>
<a class="sourceLine" id="cb5-14" data-line-number="14"><span class="kw">instance</span> <span class="dt">Yesod</span> <span class="dt">App</span></a>
<a class="sourceLine" id="cb5-15" data-line-number="15"></a>
<a class="sourceLine" id="cb5-16" data-line-number="16"><span class="ot">getHomeR ::</span> <span class="dt">Handler</span> <span class="dt">TypedContent</span></a>
<a class="sourceLine" id="cb5-17" data-line-number="17">getHomeR <span class="fu">=</span> selectRep <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-18" data-line-number="18">    provideRep <span class="fu">$</span> return</a>
<a class="sourceLine" id="cb5-19" data-line-number="19">        [shamlet|</a>
<a class="sourceLine" id="cb5-20" data-line-number="20">            <span class="kw">&lt;p&gt;</span>Hello, my name is <span class="kw">#{</span>name<span class="kw">}</span> and I am <span class="kw">#{</span>age<span class="kw">}</span> years old.</a>
<a class="sourceLine" id="cb5-21" data-line-number="21">        |]</a>
<a class="sourceLine" id="cb5-22" data-line-number="22">    provideRep <span class="fu">$</span> return <span class="fu">$</span> object</a>
<a class="sourceLine" id="cb5-23" data-line-number="23">        [ <span class="st">&quot;name&quot;</span> <span class="fu">.=</span> name</a>
<a class="sourceLine" id="cb5-24" data-line-number="24">        , <span class="st">&quot;age&quot;</span> <span class="fu">.=</span> age</a>
<a class="sourceLine" id="cb5-25" data-line-number="25">        ]</a>
<a class="sourceLine" id="cb5-26" data-line-number="26">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-27" data-line-number="27">    name <span class="fu">=</span> <span class="st">&quot;Michael&quot;</span><span class="ot"> ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb5-28" data-line-number="28">    age <span class="fu">=</span> <span class="dv">28</span><span class="ot"> ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-29" data-line-number="29"></a>
<a class="sourceLine" id="cb5-30" data-line-number="30"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb5-31" data-line-number="31">main <span class="fu">=</span> warp <span class="dv">3000</span> <span class="dt">App</span></a></code></pre></div>
<p><code>selectRep</code>関数は, “今まさに可能な表現を与えます”と言っている. 各<code>provideRep</code>の呼び出しは, 代わりの表現を与える. YesodはHaskellの型を用いて, 各表現におけるMIMEタイプを決定している. <code>shamlet</code>(すなわち, simple Hamlet)は<code>Html</code>値を作り, Yesodは関連するMIMEタイプは<code>text/html</code>であると決定できる. 同様に, <code>object</code>はJSON値を生成し, MIMEタイプは<code>application/json</code>であることを示唆する. <code>TypedContent</code>はYesodにより与えられたデータ型であり, 付属MIMEタイプを持つ生コンテンツのためにある.</p>
<p>これを試すために, 次の異なる<code>curl</code>コマンドを走らせてみなさい.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ex">curl</span> http://localhost:3000 --header <span class="st">&quot;accept: application/json&quot;</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ex">curl</span> http://localhost:3000 --header <span class="st">&quot;accept: text/html&quot;</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="ex">curl</span> http://localhost:3000</a></code></pre></div>
<p>Acceptヘッダ値に基づいてどのようにレスポンスが変化しただとうか. また, ヘッダを省略すると, HTMLレスポンスがデフォルトで表示される. ここでの規則は, もしAcceptヘッダが存在しなければ, 最初の表現が用いられることである. もし, Acceptヘッダが存在するが, 当てはまるものがなければ, “406アクセス不可能”レスポンスが返される.</p>
<p>デフォルトでは, Yesodは便利なミドルウェアを提供し, それは, クエリ文字列パラメータを用いてAcceptヘッダを設定する. これは, ブラウザからテストを行うことを容易にする. これを試すために, <a href="http://localhost:3000/?_accept=application/json">http://localhost:3000/?<code>_</code>accept=application/json</a>を訪問せよ.</p>
<h2 id="jsonの利便性">JSONの利便性</h2>
<p>今日においてJSONはウェブアプリケーションにおいて, 非常に一般的に用いられるフォーマットであるため, JSON表現を与えるような組込のヘルパ関数が存在する. これらは, 素晴らしい<code>aeson</code>ライブラリで構成されるため, そのライブラリの機能についての簡単な説明から始めよう.</p>
<p><code>aeson</code>は, コアのデータ型である<code>Value</code>を持っており, それは, あらゆる有効なJSON値を表す. それはまた, <code>ToJSON</code>と<code>FromJSON</code>の2つの型クラスを与え, それぞれJSON値へ, JSON値から, のマーシャリングを自動化する. 目的としては, 現在<code>ToJson</code>に興味がある. これまでに繰り返し出てきた<code>Person</code>データ型を用いて<code>ToJSON</code>インスタンスを作る簡単な例を見てみよう.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">{-# LANGUAGE RecordWildCards   #-}</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="kw">import</span>           <span class="dt">Data.Aeson</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">as</span> <span class="dt">L</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Data.Text</span>                  (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6"></a>
<a class="sourceLine" id="cb7-7" data-line-number="7"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">    {<span class="ot"> name ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb7-9" data-line-number="9">    ,<span class="ot"> age  ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">    }</a>
<a class="sourceLine" id="cb7-11" data-line-number="11"></a>
<a class="sourceLine" id="cb7-12" data-line-number="12"><span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Person</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13">    toJSON <span class="dt">Person</span> {<span class="fu">..</span>} <span class="fu">=</span> object</a>
<a class="sourceLine" id="cb7-14" data-line-number="14">        [ <span class="st">&quot;name&quot;</span> <span class="fu">.=</span> name</a>
<a class="sourceLine" id="cb7-15" data-line-number="15">        , <span class="st">&quot;age&quot;</span>  <span class="fu">.=</span> age</a>
<a class="sourceLine" id="cb7-16" data-line-number="16">        ]</a>
<a class="sourceLine" id="cb7-17" data-line-number="17"></a>
<a class="sourceLine" id="cb7-18" data-line-number="18"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-19" data-line-number="19">main <span class="fu">=</span> L.putStrLn <span class="fu">$</span> encode <span class="fu">$</span> <span class="dt">Person</span> <span class="st">&quot;Michael&quot;</span> <span class="dv">28</span></a></code></pre></div>
<p><code>aeson</code>については, これ以上深入りしないようにしよう. なぜなら, <a href="https://www.fpcomplete.com/haskell">Haddock文書</a>がすでにライブラリを上手く紹介しているためである. これまでに示したことは, 便利関数を理解するためには十分である.</p>
<p><code>Person</code>データ型と, 対応する値があり, 現在のページを表示するためにそれを用いたいとしよう. そのために, <code>returnJson</code>関数を用いる.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ot">{-# LANGUAGE QuasiQuotes       #-}</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="ot">{-# LANGUAGE RecordWildCards   #-}</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="ot">{-# LANGUAGE TemplateHaskell   #-}</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="ot">{-# LANGUAGE TypeFamilies      #-}</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="kw">import</span>           <span class="dt">Yesod</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"></a>
<a class="sourceLine" id="cb8-9" data-line-number="9"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">    {<span class="ot"> name ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11">    ,<span class="ot"> age  ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb8-13" data-line-number="13"></a>
<a class="sourceLine" id="cb8-14" data-line-number="14"><span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Person</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-15" data-line-number="15">    toJSON <span class="dt">Person</span> {<span class="fu">..</span>} <span class="fu">=</span> object</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">        [ <span class="st">&quot;name&quot;</span> <span class="fu">.=</span> name</a>
<a class="sourceLine" id="cb8-17" data-line-number="17">        , <span class="st">&quot;age&quot;</span>  <span class="fu">.=</span> age</a>
<a class="sourceLine" id="cb8-18" data-line-number="18">        ]</a>
<a class="sourceLine" id="cb8-19" data-line-number="19"></a>
<a class="sourceLine" id="cb8-20" data-line-number="20"><span class="kw">data</span> <span class="dt">App</span> <span class="fu">=</span> <span class="dt">App</span></a>
<a class="sourceLine" id="cb8-21" data-line-number="21"></a>
<a class="sourceLine" id="cb8-22" data-line-number="22">mkYesod <span class="st">&quot;App&quot;</span> [parseRoutes|</a>
<a class="sourceLine" id="cb8-23" data-line-number="23">/ HomeR GET</a>
<a class="sourceLine" id="cb8-24" data-line-number="24">|]</a>
<a class="sourceLine" id="cb8-25" data-line-number="25"></a>
<a class="sourceLine" id="cb8-26" data-line-number="26"><span class="kw">instance</span> <span class="dt">Yesod</span> <span class="dt">App</span></a>
<a class="sourceLine" id="cb8-27" data-line-number="27"></a>
<a class="sourceLine" id="cb8-28" data-line-number="28"><span class="ot">getHomeR ::</span> <span class="dt">Handler</span> <span class="dt">Value</span></a>
<a class="sourceLine" id="cb8-29" data-line-number="29">getHomeR <span class="fu">=</span> returnJson <span class="fu">$</span> <span class="dt">Person</span> <span class="st">&quot;Michael&quot;</span> <span class="dv">28</span></a>
<a class="sourceLine" id="cb8-30" data-line-number="30"></a>
<a class="sourceLine" id="cb8-31" data-line-number="31"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb8-32" data-line-number="32">main <span class="fu">=</span> warp <span class="dv">3000</span> <span class="dt">App</span></a></code></pre></div>
<p><code>returnJson</code>は実際には, 自明な関数である; それは<code>return . toJSON</code>として実装される. しかし, それにより物事が少し便利になる. 同様に, JSON値を<code>selectRep</code>内部での表現として与えたい場合, <code>provideJson</code>を用いることができる.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="ot">{-# LANGUAGE QuasiQuotes       #-}</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="ot">{-# LANGUAGE RecordWildCards   #-}</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="ot">{-# LANGUAGE TemplateHaskell   #-}</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="ot">{-# LANGUAGE TypeFamilies      #-}</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="kw">import</span>           <span class="dt">Yesod</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8"></a>
<a class="sourceLine" id="cb9-9" data-line-number="9"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">    {<span class="ot"> name ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb9-11" data-line-number="11">    ,<span class="ot"> age  ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb9-13" data-line-number="13"></a>
<a class="sourceLine" id="cb9-14" data-line-number="14"><span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Person</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-15" data-line-number="15">    toJSON <span class="dt">Person</span> {<span class="fu">..</span>} <span class="fu">=</span> object</a>
<a class="sourceLine" id="cb9-16" data-line-number="16">        [ <span class="st">&quot;name&quot;</span> <span class="fu">.=</span> name</a>
<a class="sourceLine" id="cb9-17" data-line-number="17">        , <span class="st">&quot;age&quot;</span>  <span class="fu">.=</span> age</a>
<a class="sourceLine" id="cb9-18" data-line-number="18">        ]</a>
<a class="sourceLine" id="cb9-19" data-line-number="19"></a>
<a class="sourceLine" id="cb9-20" data-line-number="20"><span class="kw">data</span> <span class="dt">App</span> <span class="fu">=</span> <span class="dt">App</span></a>
<a class="sourceLine" id="cb9-21" data-line-number="21"></a>
<a class="sourceLine" id="cb9-22" data-line-number="22">mkYesod <span class="st">&quot;App&quot;</span> [parseRoutes|</a>
<a class="sourceLine" id="cb9-23" data-line-number="23">/ HomeR GET</a>
<a class="sourceLine" id="cb9-24" data-line-number="24">|]</a>
<a class="sourceLine" id="cb9-25" data-line-number="25"></a>
<a class="sourceLine" id="cb9-26" data-line-number="26"><span class="kw">instance</span> <span class="dt">Yesod</span> <span class="dt">App</span></a>
<a class="sourceLine" id="cb9-27" data-line-number="27"></a>
<a class="sourceLine" id="cb9-28" data-line-number="28"><span class="ot">getHomeR ::</span> <span class="dt">Handler</span> <span class="dt">TypedContent</span></a>
<a class="sourceLine" id="cb9-29" data-line-number="29">getHomeR <span class="fu">=</span> selectRep <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-30" data-line-number="30">    provideRep <span class="fu">$</span> return</a>
<a class="sourceLine" id="cb9-31" data-line-number="31">        [shamlet|</a>
<a class="sourceLine" id="cb9-32" data-line-number="32">            <span class="kw">&lt;p&gt;</span>Hello, my name is <span class="kw">#{</span>name<span class="kw">}</span> and I am <span class="kw">#{</span>age<span class="kw">}</span> years old.</a>
<a class="sourceLine" id="cb9-33" data-line-number="33">        |]</a>
<a class="sourceLine" id="cb9-34" data-line-number="34">    provideJson person</a>
<a class="sourceLine" id="cb9-35" data-line-number="35">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-36" data-line-number="36">    person<span class="fu">@</span><span class="dt">Person</span> {<span class="fu">..</span>} <span class="fu">=</span> <span class="dt">Person</span> <span class="st">&quot;Michael&quot;</span> <span class="dv">28</span></a>
<a class="sourceLine" id="cb9-37" data-line-number="37"></a>
<a class="sourceLine" id="cb9-38" data-line-number="38"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb9-39" data-line-number="39">main <span class="fu">=</span> warp <span class="dv">3000</span> <span class="dt">App</span></a></code></pre></div>
<p><code>provideJson</code>は同様に自明であり, この場合<code>provideRep . returnJson</code>で実装される.</p>
<h2 id="新しいデータ型">新しいデータ型</h2>
<p>Haskellの<code>Show</code>インスタンスを用いて新しいデータフォーマットを思いついたとしよう. それを“Haskell Show”と呼び, <code>text/haskell-show</code>のMIMEタイプを与えよう. そして, この表現をウェブアプリケーションに含めたいとしよう. それはどのように行えばいいのか? 最初の試みとして, <code>TypedContent</code>データ型を直接用いよう.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ot">{-# LANGUAGE QuasiQuotes       #-}</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="ot">{-# LANGUAGE TemplateHaskell   #-}</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="ot">{-# LANGUAGE TypeFamilies      #-}</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="kw">import</span>           <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb10-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Yesod</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"></a>
<a class="sourceLine" id="cb10-8" data-line-number="8"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9">    {<span class="ot"> name ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb10-10" data-line-number="10">    ,<span class="ot"> age  ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb10-11" data-line-number="11">    }</a>
<a class="sourceLine" id="cb10-12" data-line-number="12">    <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb10-13" data-line-number="13"></a>
<a class="sourceLine" id="cb10-14" data-line-number="14"><span class="kw">data</span> <span class="dt">App</span> <span class="fu">=</span> <span class="dt">App</span></a>
<a class="sourceLine" id="cb10-15" data-line-number="15"></a>
<a class="sourceLine" id="cb10-16" data-line-number="16">mkYesod <span class="st">&quot;App&quot;</span> [parseRoutes|</a>
<a class="sourceLine" id="cb10-17" data-line-number="17">/ HomeR GET</a>
<a class="sourceLine" id="cb10-18" data-line-number="18">|]</a>
<a class="sourceLine" id="cb10-19" data-line-number="19"></a>
<a class="sourceLine" id="cb10-20" data-line-number="20"><span class="kw">instance</span> <span class="dt">Yesod</span> <span class="dt">App</span></a>
<a class="sourceLine" id="cb10-21" data-line-number="21"></a>
<a class="sourceLine" id="cb10-22" data-line-number="22"><span class="ot">mimeType ::</span> <span class="dt">ContentType</span></a>
<a class="sourceLine" id="cb10-23" data-line-number="23">mimeType <span class="fu">=</span> <span class="st">&quot;text/haskell-show&quot;</span></a>
<a class="sourceLine" id="cb10-24" data-line-number="24"></a>
<a class="sourceLine" id="cb10-25" data-line-number="25"><span class="ot">getHomeR ::</span> <span class="dt">Handler</span> <span class="dt">TypedContent</span></a>
<a class="sourceLine" id="cb10-26" data-line-number="26">getHomeR <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-27" data-line-number="27">    return <span class="fu">$</span> <span class="dt">TypedContent</span> mimeType <span class="fu">$</span> toContent <span class="fu">$</span> show person</a>
<a class="sourceLine" id="cb10-28" data-line-number="28">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-29" data-line-number="29">    person <span class="fu">=</span> <span class="dt">Person</span> <span class="st">&quot;Michael&quot;</span> <span class="dv">28</span></a>
<a class="sourceLine" id="cb10-30" data-line-number="30"></a>
<a class="sourceLine" id="cb10-31" data-line-number="31"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb10-32" data-line-number="32">main <span class="fu">=</span> warp <span class="dv">3000</span> <span class="dt">App</span></a></code></pre></div>
<p>ここでは, 多少注意すべき重要な点がある.</p>
<ul>
<li><p><code>toContent</code>関数を用いた. これは, いくつものデータ型を通信上に送信される準備ができた生データに変換するための, 型クラス関数である. この場合, <code>String</code>のインスタンスを用い, それはUTF8のエンコーディングを持つ. インスタンスを持つ一般的なデータ型としては, 他に<code>Text</code>, <code>ByteString</code>, <code>Html</code>, やaesonの<code>Value</code>などがある.</p></li>
<li><p><code>TypedContent</code>コンストラクタを直接用いている. これは, 2つの引数を取る: MIMEタイプと, 生コンテンツである. また, <code>ContentType</code>は, 単にstrict <code>ByteString</code>の型エイリアスである.</p></li>
</ul>
<p>これまではいいでしょうか, しかし, <code>getHomeR</code>の型注釈の情報量が少なすぎることは悩ましいことである. また, <code>getHomeR</code>の実装は, かなりボイラブレートに見える. これよりも, “Haskell Show”データ型 を表現するデータ型を持ち, このような値を作るための簡単な方法を与えたい. これを試してみよう.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="ot">{-# LANGUAGE OverloadedStrings         #-}</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="ot">{-# LANGUAGE QuasiQuotes               #-}</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="ot">{-# LANGUAGE TemplateHaskell           #-}</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5"><span class="ot">{-# LANGUAGE TypeFamilies              #-}</span></a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="kw">import</span>           <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb11-7" data-line-number="7"><span class="kw">import</span>           <span class="dt">Yesod</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8"></a>
<a class="sourceLine" id="cb11-9" data-line-number="9"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10">    {<span class="ot"> name ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb11-11" data-line-number="11">    ,<span class="ot"> age  ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb11-12" data-line-number="12">    }</a>
<a class="sourceLine" id="cb11-13" data-line-number="13">    <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb11-14" data-line-number="14"></a>
<a class="sourceLine" id="cb11-15" data-line-number="15"><span class="kw">data</span> <span class="dt">App</span> <span class="fu">=</span> <span class="dt">App</span></a>
<a class="sourceLine" id="cb11-16" data-line-number="16"></a>
<a class="sourceLine" id="cb11-17" data-line-number="17">mkYesod <span class="st">&quot;App&quot;</span> [parseRoutes|</a>
<a class="sourceLine" id="cb11-18" data-line-number="18">/ HomeR GET</a>
<a class="sourceLine" id="cb11-19" data-line-number="19">|]</a>
<a class="sourceLine" id="cb11-20" data-line-number="20"></a>
<a class="sourceLine" id="cb11-21" data-line-number="21"><span class="kw">instance</span> <span class="dt">Yesod</span> <span class="dt">App</span></a>
<a class="sourceLine" id="cb11-22" data-line-number="22"></a>
<a class="sourceLine" id="cb11-23" data-line-number="23"><span class="ot">mimeType ::</span> <span class="dt">ContentType</span></a>
<a class="sourceLine" id="cb11-24" data-line-number="24">mimeType <span class="fu">=</span> <span class="st">&quot;text/haskell-show&quot;</span></a>
<a class="sourceLine" id="cb11-25" data-line-number="25"></a>
<a class="sourceLine" id="cb11-26" data-line-number="26"><span class="kw">data</span> <span class="dt">HaskellShow</span> <span class="fu">=</span> forall a<span class="fu">.</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">HaskellShow</span> a</a>
<a class="sourceLine" id="cb11-27" data-line-number="27"></a>
<a class="sourceLine" id="cb11-28" data-line-number="28"><span class="kw">instance</span> <span class="dt">ToContent</span> <span class="dt">HaskellShow</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-29" data-line-number="29">    toContent (<span class="dt">HaskellShow</span> x) <span class="fu">=</span> toContent <span class="fu">$</span> show x</a>
<a class="sourceLine" id="cb11-30" data-line-number="30"><span class="kw">instance</span> <span class="dt">ToTypedContent</span> <span class="dt">HaskellShow</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-31" data-line-number="31">    toTypedContent <span class="fu">=</span> <span class="dt">TypedContent</span> mimeType <span class="fu">.</span> toContent</a>
<a class="sourceLine" id="cb11-32" data-line-number="32"></a>
<a class="sourceLine" id="cb11-33" data-line-number="33"><span class="ot">getHomeR ::</span> <span class="dt">Handler</span> <span class="dt">HaskellShow</span></a>
<a class="sourceLine" id="cb11-34" data-line-number="34">getHomeR <span class="fu">=</span></a>
<a class="sourceLine" id="cb11-35" data-line-number="35">    return <span class="fu">$</span> <span class="dt">HaskellShow</span> person</a>
<a class="sourceLine" id="cb11-36" data-line-number="36">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-37" data-line-number="37">    person <span class="fu">=</span> <span class="dt">Person</span> <span class="st">&quot;Michael&quot;</span> <span class="dv">28</span></a>
<a class="sourceLine" id="cb11-38" data-line-number="38"></a>
<a class="sourceLine" id="cb11-39" data-line-number="39"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb11-40" data-line-number="40">main <span class="fu">=</span> warp <span class="dv">3000</span> <span class="dt">App</span></a></code></pre></div>
<p>ここでのトリックは, 2つの型クラスにある. 以前述べたように, <code>ToContent</code>はどのように値を生レスポンスに変換するかについて言っている. 今回の場合, もとの値を<code>show</code>することで, <code>String</code>を得, <code>String</code>を生コンテントに変換したい. しばしば, <code>ToContent</code>のインスタンスはこのように相互依存している.</p>
<p><code>ToTypedContent</code>は内部的にYesodが用いており, ハンドラ関数の結果に基づき呼び出される. ご覧の通り実装はかなりシンプルであり, 単にMIMEタイプを述べ, <code>toContent</code>を呼び出してるだけである.</p>
<p>最後に, これをもう少し複雑にし, <code>selectRep</code>と上手く連携させてみよう.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="ot">{-# LANGUAGE OverloadedStrings         #-}</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3"><span class="ot">{-# LANGUAGE QuasiQuotes               #-}</span></a>
<a class="sourceLine" id="cb12-4" data-line-number="4"><span class="ot">{-# LANGUAGE RecordWildCards           #-}</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="ot">{-# LANGUAGE TemplateHaskell           #-}</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="ot">{-# LANGUAGE TypeFamilies              #-}</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7"><span class="kw">import</span>           <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</a>
<a class="sourceLine" id="cb12-8" data-line-number="8"><span class="kw">import</span>           <span class="dt">Yesod</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9"></a>
<a class="sourceLine" id="cb12-10" data-line-number="10"><span class="kw">data</span> <span class="dt">Person</span> <span class="fu">=</span> <span class="dt">Person</span></a>
<a class="sourceLine" id="cb12-11" data-line-number="11">    {<span class="ot"> name ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">    ,<span class="ot"> age  ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">    }</a>
<a class="sourceLine" id="cb12-14" data-line-number="14">    <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb12-15" data-line-number="15"></a>
<a class="sourceLine" id="cb12-16" data-line-number="16"><span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Person</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-17" data-line-number="17">    toJSON <span class="dt">Person</span> {<span class="fu">..</span>} <span class="fu">=</span> object</a>
<a class="sourceLine" id="cb12-18" data-line-number="18">        [ <span class="st">&quot;name&quot;</span> <span class="fu">.=</span> name</a>
<a class="sourceLine" id="cb12-19" data-line-number="19">        , <span class="st">&quot;age&quot;</span>  <span class="fu">.=</span> age</a>
<a class="sourceLine" id="cb12-20" data-line-number="20">        ]</a>
<a class="sourceLine" id="cb12-21" data-line-number="21"></a>
<a class="sourceLine" id="cb12-22" data-line-number="22"><span class="kw">data</span> <span class="dt">App</span> <span class="fu">=</span> <span class="dt">App</span></a>
<a class="sourceLine" id="cb12-23" data-line-number="23"></a>
<a class="sourceLine" id="cb12-24" data-line-number="24">mkYesod <span class="st">&quot;App&quot;</span> [parseRoutes|</a>
<a class="sourceLine" id="cb12-25" data-line-number="25">/ HomeR GET</a>
<a class="sourceLine" id="cb12-26" data-line-number="26">|]</a>
<a class="sourceLine" id="cb12-27" data-line-number="27"></a>
<a class="sourceLine" id="cb12-28" data-line-number="28"><span class="kw">instance</span> <span class="dt">Yesod</span> <span class="dt">App</span></a>
<a class="sourceLine" id="cb12-29" data-line-number="29"></a>
<a class="sourceLine" id="cb12-30" data-line-number="30"><span class="ot">mimeType ::</span> <span class="dt">ContentType</span></a>
<a class="sourceLine" id="cb12-31" data-line-number="31">mimeType <span class="fu">=</span> <span class="st">&quot;text/haskell-show&quot;</span></a>
<a class="sourceLine" id="cb12-32" data-line-number="32"></a>
<a class="sourceLine" id="cb12-33" data-line-number="33"><span class="kw">data</span> <span class="dt">HaskellShow</span> <span class="fu">=</span> forall a<span class="fu">.</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">HaskellShow</span> a</a>
<a class="sourceLine" id="cb12-34" data-line-number="34"></a>
<a class="sourceLine" id="cb12-35" data-line-number="35"><span class="kw">instance</span> <span class="dt">ToContent</span> <span class="dt">HaskellShow</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-36" data-line-number="36">    toContent (<span class="dt">HaskellShow</span> x) <span class="fu">=</span> toContent <span class="fu">$</span> show x</a>
<a class="sourceLine" id="cb12-37" data-line-number="37"><span class="kw">instance</span> <span class="dt">ToTypedContent</span> <span class="dt">HaskellShow</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-38" data-line-number="38">    toTypedContent <span class="fu">=</span> <span class="dt">TypedContent</span> mimeType <span class="fu">.</span> toContent</a>
<a class="sourceLine" id="cb12-39" data-line-number="39"><span class="kw">instance</span> <span class="dt">HasContentType</span> <span class="dt">HaskellShow</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-40" data-line-number="40">    getContentType _ <span class="fu">=</span> mimeType</a>
<a class="sourceLine" id="cb12-41" data-line-number="41"></a>
<a class="sourceLine" id="cb12-42" data-line-number="42"><span class="ot">getHomeR ::</span> <span class="dt">Handler</span> <span class="dt">TypedContent</span></a>
<a class="sourceLine" id="cb12-43" data-line-number="43">getHomeR <span class="fu">=</span> selectRep <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-44" data-line-number="44">    provideRep <span class="fu">$</span> return <span class="fu">$</span> <span class="dt">HaskellShow</span> person</a>
<a class="sourceLine" id="cb12-45" data-line-number="45">    provideJson person</a>
<a class="sourceLine" id="cb12-46" data-line-number="46">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-47" data-line-number="47">    person <span class="fu">=</span> <span class="dt">Person</span> <span class="st">&quot;Michael&quot;</span> <span class="dv">28</span></a>
<a class="sourceLine" id="cb12-48" data-line-number="48"></a>
<a class="sourceLine" id="cb12-49" data-line-number="49"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb12-50" data-line-number="50">main <span class="fu">=</span> warp <span class="dv">3000</span> <span class="dt">App</span></a></code></pre></div>
<p>ここで追加した重要な点は, <code>HasContentType</code>インスタンスである. これは, 冗長に見えるかもしれないが, 重要な役割を担う. 表現を作る前に, 起こりうる表現のMIME型を決定できる必要があるのである. <code>ToTypedContent</code>は具体的な値にのみ機能するため, 値を作る前には用いることができない. <code>getContentType</code>は代わりにプロキシー値を取り, 具体的なものを与えずとも型を示すことができる.</p>
<div class="yesod-book-notice">
もし, <code>HasContentType</code>インスタンスを持たない値に対し表現を与えたい場合, <code>provideRepType</code>を用いることができ, それは, MIME型が存在していることを明確に宣言することを必要とする.
<div>

<h2 id="他のリクエストヘッダ">他のリクエストヘッダ</h2>
<p>利用可能なリクエストヘッダは数多く存在する. その内のいくつかは, サーバとクライアント間でのデータの移動にのみ関与し, アプリケーションには全く影響を与えない. 例えば, <code>Accept-Encoding</code>はサーバにどの圧縮スキームをクライアントが理解できるかを示し, <code>Host</code>はどの仮想ホストを用いるかについて示す.</p>
<p>他のヘッダはアプリケーションに関与するが, Yesodによって自動的に読まれる. 例えば, <code>Accept-Language</code>ヘッダは, どの人間の言語(英語, スペイン語, ドイツ語, スイス系ドイツ語)をクライアントが求めるかを特定する. このヘッダをどのように用いるかについては, i18nの章を見なさい.</p>
<h2 id="まとめ">まとめ</h2>
<p>YesodはRESTの次の原則に従う:</p>
<ul>
<li><p>適切なリクエストメソッドを用いる.</p></li>
<li><p>各リソースは確実に1つのURLを持つ.</p></li>
<li><p>同じURLでデータを複数の方法で表現することを許容する.</p></li>
<li><p>リクエストヘッダを調べ, クライアントが求めることについてのさらなる情報を得る.</p></li>
</ul>
<p>これらは, Yesodを用いてウェブサイトを構築するだけでなく, APIを作ることも容易にする. 実際に, <code>selectRep</code>/<code>provideRep</code>のような技術を用いることで, ユーザフレンドリなHTMLページと, マシンフレンドリなJSONページを同じURLで用いることが可能になる.</p>
      </article>

      <div class="pager">
      
      
      </div>

      <div class="row">
        <div class="col s6 offset-s6" style="position: relative; height: 100px;">
          <div class="fixed-action-btn horizontal" style="position: absolute; display: inline-block; right: 24px;">
  <a class="btn-floating btn-large red">
    <i class="large material-icons">share</i>
  </a>
  <ul>
    <li>
      <a class="btn-floating waves-effect waves-light blue tooltipped" data-position="bottom" data-delay="20" data-tooltip="Share on Twitter" href="https://twitter.com/intent/tweet?text=ch12-restful-content&url=https://haskell.e-bigmoon.com/yesod/book/ch12-restful-content.html"><i class="mdi mdi-twitter white-text"></i></a>
    </li>
    <li>
      <a class="btn-floating waves-effect waves-light indigo tooltipped" data-position="bottom" data-delay="20" data-tooltip="Share on Facebook" href="https://facebook.com/sharer.php?u=https://haskell.e-bigmoon.com/yesod/book/ch12-restful-content.html"><i class="mdi mdi-facebook white-text"></i></a>
    </li>
    <li>
      <a class="btn-floating waves-effect waves-light red tooltipped" data-position="bottom" data-delay="20" data-tooltip="Share on Google+" href="https://plus.google.com/share?url=https://haskell.e-bigmoon.com/yesod/book/ch12-restful-content.html"><i class="mdi mdi-google-plus white-text"></i></a>
    </li>
  </ul>
</div>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
    </div>

    <footer class="page-footer indigo lighten-1">

  <div class="footer-copyright">

    <div class="container">
      CopyRight © 2018 BIGMOON All Rights Reserved.&nbsp;
      Site proudly generated by <a class="red-text text-accent-1" href="http://jaspervdj.be/hakyll">Hakyll</a>,&nbsp;
      original Jekyll theme by <a class="red-text text-accent-1" href="https://github.com/mumuxme/materialize-jekyll">mumuxme</a>.
    </div>

  </div>

</footer>


    <!-- scrolltop button -->
    <button class="material-scrolltop waves-effect waves-light hide-on-small-only" type="button">
      <i class="mdi mdi-arrow-up-bold small white-text"></i>
    </button>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-19322672-9"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-19322672-9');
    </script>

    <!-- jquery -->
    <script type="text/javascript" src="../../lib/jquery-min.js"></script>
    <!-- materialize -->
    <script src="../../lib/materialize/js/materialize.min.js"></script>
    <!-- <\!-- Material ScrollTop plugin -\-> -->
    <script src="../../lib/material-scrolltop/material-scrolltop.js"></script>
    <!-- main -->
    <script src="../../js/init.js"></script>
    <script src="../../js/main.js"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/haskell.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>

</html>
