---
title: scaffoldingとサイトテンプレート
date: 2019/01/20
---

今や小さなサンプルプログラムを実行することに飽きて, 本物のサイトを書く準備ができているでしょう. ならば, あなたは正しい章にいることでしょう. Yesodライブラリ全体が手元にあったとしても, 製品レベルのサイト設定を獲得するためには, いまだ多くの通過すべきステップがある:

- 設定ファイルのパーシング
- シグナル処理 (*nix)
- より効率的な静的ファイルの配信
- よいファイルレイアウト

scaffoldedサイトはYesodにおける多くの最善の方法の組み合わせであり, サイトにおいてすぐに使うことができる骨格に組み合わせられている. それはあらゆるサイトにおいて推奨される. この章では, scaffoldingの全体構造, 使い方, 自明でない側面について説明する. 

多くの部分で, この章はサンプルコードを含んでいないでしょう. 実際のscaffoldedサイトに沿って進めることが推奨される. 

<div class=yesod-book-notice>
scaffoldedサイトの性質により, それはYesodにおける最も流動的なコンポーネントであり, バージョン毎に変化しうるものである. この章の情報がわずかに古い可能性がある. 
</div>

## どのようにscaffoldするか

Yesod-binパッケージは(利便性のためyesodと呼ばれる)実行ファイルをインストールする. この実行ファイルはいくつかのコマンドを与える(`stack exec -- yesod --help`を実行し, その一覧が得られる). scaffoldingを生成するためのコマンドは, `stack new my-project yesod-postgres`である. これは, postgresデータベースをバックエンドにもつscaffoldingサイトを`my-project`という名前のディレクトリに生成する. `stack templates`コマンドを用いれば, 他に利用可能なテンプレートを見ることができる. 

(`stack templates`コマンドにおける)様々な利用可能なテンプレートの鍵となる違いは, データベースのバックエンドである. ここではいくつかの選択肢があり, SQLやMongoDBバックエンドとともに, データベースのサポートを持たない"yesod-simple"テンプレートが含まれる. yesod-simpleテンプレートはまた, いくつかの追加依存関係を持たず, 無駄なくサイト全体を作ることができる. この章の残りでは, データベースバックエンドの1つを持つscaffoldingサイトに焦点を当てる. yesod-simpleバックエンドとはわずかな違いしかない. 

ファイルを作った後, プロジェクト内にコマンドラインツールをインストールしなさい: `stack build yesod-bin cabal-install` そして, ディレクトリ内で`stack build`を実行せよ. 特に, この与えられたコマンドは足りない依存関係がビルドされ, インストールされるのを保証している. 

最後に, `stack exec -- yesod devel`を用い, 開発サイトを立ち上げなさい. このサイトはコードを変更する毎に自動的に再ビルドし, リロードする. 

## ファイル構造

scaffoldedサイトは完全にカバル化されたHaskellパッケージとしてビルドされる. ソースファイルの他に, 設定ファイル, テンプレート, 静的ファイルが同様に生成される. 

### cabalファイル

直接`stack`を使うにせよ, 間接的に`stack exec -- yesod devel`を使うにせよ, コードをビルドする際には, 常にcabalファイルが経由される. ファイルを開いたのならば, ライブラリと実行ファイルの両方のブロックが存在することが分かるであろう. もし, `library-only`フラグが有効であれば, 実行ファイルのブロックはビルドされない. `yesod devel`はこのようにアプリケーションを呼び出す. そうでなければ, 実行ファイルはビルドされる. 

`library-only`フラグは`yesod-devel`によってのみ使われるべきである; 決して明示的に`cabal`ファイルに書き込むべきではない. 他にもフラグがあり, `dev`はcabalファイルが実行ファイルをビルドするのを許可するが, 同じような機能をlibrary-onlyフラグとして有効にしている. 例えば, 最適化なしや, Shakespeareテンプレート関数の再ロード版などである.

一般的に, 次のようにビルドする.

- 開発の際は, もっぱら`yesod devel`を使いなさい.

- 製品ビルドを行う場合, `stack clean && stack build`を実行しなさい. これにより最適化された実行ファイルが`dist`フォルダに生成される. (`yesod keter`コマンドもまた使用可能である.)

`NoImplicitPrelude`拡張子を見て, 驚くかもしれない. サイトは自身のモジュールである`Import`を含む. これは, Pleludeに対し多少の変更を行い, Yesodを少し便利に使えるようにしたものである. そのため, `NoImplicitPrelude`拡張子を有効にしてある. 

留意すべき最後の点としては, exposed-moduleリストである. もし, アプリケーションに対し何かモジュールを追加する場合, このリストをアップデートし, yesod-develが正しく機能するようにしなければならない. 残念なことに, このアップデートを忘れたとしてもCabalもGHCも警告を与えず, 代わりにyesod develから非常にわかりにくいエラーメッセージが表示される. 

### ルートとエンティティ

この本においてはしばしば, "簡便性のため, routes/entitiesを準クォートを用いて宣言する. 製品版サイトにおいては, 外部ファイルを用いるべきである."のようなコメントを目にしてきたであろう. scaffoldingはそのような外部ファイルを用いる.

ルートは`config/routes`で定義され, エンティティは`config/model`で定義される. それらは, この本を通して見てきた準クォーティングのように, 準クォートと全く同じ構文を持つ. そして, `yesod devel`はこれらのファイルが変更された際, 自動的に適切なモジュールの再コンパイルを行うことを知っている. 

`model`ファイルは`Model.hs`により参照される. このファイルにおいて何でも好きなように宣言できるが, ここでは, そのガイドラインを示す:

- エンティティにおいて用いられるデータ型は, `persistFileWith`の呼び出しの前に, `model.hs`においてインポートされ, 宣言されなければならない. 

- ヘルパユーティリティは`Import.hs`で宣言されるか, あるいは, もしモデル中心の構成であれば, `Model`
フォルダのファイルにおいて宣言され, `Import.hs`にインポートされる必要がある.

### ファウンデーションとアプリケーションモジュール

この本を通して用いてきた`mkYesod`関数は, いくつかの宣言を行う. 

- ルート型

- ルートレンダリング関数

- ディスパッチ関数

ディスパッチ関数はあらゆるハンドラ関数を参照し, それ故, それら全ては同じファイルにディスパッチ関数として定義される必要があるか, ディスパッチ関数を含むモジュールにインポートされる必要がある. 

一方, ハンドラ関数はほぼ確実にルート型を参照する. 従って, それらはルート型が定義されたのと同じファイルにあるか, そのファイルをイポートする必要がある. もし, このロジックに従うなら, アプリケーション全体が本質的に1つのファイルにあることになる!

明らかにこれは望んでいることではない. よって, `mkYesod`を用いる代わりに, scaffoldingサイトはその関数を分割したものを用いる. `Foundation`は, `mkYesodData`を呼び出し, それはルート型とレンダリング関数を呼び出す. それはディスパッチ関数を宣言しないため, ハンドラ関数はスコープにある必要はない. `Import.hs`は`Foundaton.hs`をインポートし, あらゆるハンドラモジュールは`Import.hs`をインポートする. 

`Applications.hs`では, `mkYesodDispatch`を呼び出し, ディスパッチ関数を作る. これが機能するためには, 全てのハンドラ関数がスコープにある必要があるため, 確実に, 作ろうとする新しいハンドラモジュールのインポート宣言を追加する必要がある. 

それ以外では, `Application.hs`は非常に単純である. それは, 2つの主要な関数を与える: `getApplicationDev`は`yesod devel`により用いられ, アプリケーションを立ち上げる. `makeApplication`は実行ファイルを立ち上げるために用いられる. 

`Foundation.hs`はずっと楽しいものである. それは:

- ファウンデーションデータ型を宣言する

- `Yesod`, `YesodAuth`や, `YesodPersist`のようないくつものインスタンスを宣言する

- メッセージファイルをインポートする. `mkMessage`で始まる行を探すと, それはメッセージを含むフォルダ(`message/`)と, デフォルト言語(英語は`en`)を指定していることが分かるであろう

これはファウンデーションに, `YesodAuthEmail`や`YesodBreadcrumbs`のような追加インスタンスを付け加えるためのファイルである.

`Yesod`型クラスの特別な実装について議論する際に, またこのファイルを見直すであろう.

### Import

`Import`モジュールはいくつかの共通に繰り返すパターンから生まれた. 

- あらゆるハンドラで用いられるヘルパ関数(`<> = mappend`演算子のような)を定義したい.

- 常に, 同じ5つのインポート宣言(`Data.Text, Control.Applicative`, etc)を各ハンドラモジュールに追加する.

- `Prelude`から出ている悪い関数(`head, readFile`, ...)を決して使わないようにしたい.

<div class=yesod-book-notice>
はい, 悪という言葉は誇張かもしれない. もし, 私がこれらの関数を悪いというのを疑問に思うなら: `head`は部分関数であり, 空リストに対し例外を投げる, また, `readFile`はlazy I/Oを用いるため, ファイルハンドルが迅速にクローズされない. また, `readFile`は`Text`の代わりに`String`を用いる. 
</div>

その解決策は, `NoInplicitPrelude`言語拡張を用い, `Prelude`の必要な部分を再エクスポートし, 他に欲しいものを全て追加し, 同様に独自の関数を定義し, そして, このファイルをすべてのハンドラでインポートすることである. 

<div class=yesod-book-notice>
この章が出版されたある時点で, scaffoldedサイトが`classy-prelude-yesod`のような, 代わりのpreludeに移行する可能性があり得る. `Import`がここで定義されたようなものとかなり違ったものに見えても, 驚かないようにしなさい. 
<div>

### Handler modules

ハンドラモジュールは`Handler`フォルダに入るべきである. サイトのテンプレートは, 次の1つのモジュールを含むべきである: `Handler/Home.hs`. ハンドラ関数をどのように個々に分割するかはあなた次第であるが, おおまかなやり方としては, 次のようになる:

- 同じルートの異なるメソッドは同じファイルに入るべきである, 例えば, `getBlogR`と`postBlogR`などである.

- 関連するルートは, たいてい同じファイルに入る, 例えば, `getPeopleR`と`getPersonR`などである.

もちろん, それは完全にあなた次第である. 新しいハンドラファイルを追加するとき, 次のことを必ずするようにしなさい:

- バージョンコントロールに追加する(バージョンコントロールは使っていますよね).

- cabalファイルに追加する.

- `Application.hs`ファイルに追加する.

- トップにモジュール宣言を行い, `import Import`行をその下に追加する.

最後の3つのステップを自動化するために, `stack exec-yesod add-handler`コマンドを使うことができる.

### widgetFile

ページ特有のCSSやJavascriptを含めたいと思うのは非常に一般的である. Hamletファイルを参照する毎に, それらのLuciusやJuliusファイルを手動で含めるのを忘れないでいることを強いられるのは望まないだろう. このために, サイトテンプレートは`widgetFile`関数を提供する.

次のようなハンドラ関数があるとする:

`getHomeR = defaultLayout $(widgetFile "homepage")`

Yesodは次のようなファイルを探す:

- templates/homepage.hamlet

- templates/homepage.lucius

- templates/homepage.cassius

- templates/homepage.julius

もしこれらのファイルが存在すれば, それらは自動的に結果に含まれる.

<div class=yesod-book-notice>
これが機能する特性により, もしアプリケーションを`yesod devel`で立ち上げ, その後, 新しいファイル(例えば, `templates/homepage.julius`)を作成した場合, `widgetFile`を呼び出すファイルが再コンパイルされるまで, この中身は含まれない. このような場合, `yesod devel`に再コンパイルさせるために, そのファイルを強制的に保存しなければならない.
</div>

### defautLayput

まず最初にカスタマイズしたもいものの1つは, サイトの見栄えである. 実際にレイアウトは2つのファイルに分割される. 

- `templates/default-layout-wrapper.hamlet`は, 単なるページの基本外殻を含む. ファイルはWidgetではなく, プレーンなHamletとして解釈され, したがって, 他のwidgetを参照したり, i18n文字列を埋め込んだり, 外部CSS/JSを追加したりできない. 

- `templates/default-layout.hamlet`は, 大部分のページを追加する場所である. `widget`値をページに含むことを忘れてはいけない, なぜならばそれはページ毎のコンテンツを含むためである. このファイルはWidgetとして解釈される.

また, default-layoutは`widgetFile`関数を用いて含まれるため, `default-layout.*`で名付けられたLucius, Cassiusや, Juliusファイルも同様に自動的に含まれる.

### Static files

scaffoldedサイトは自動的にstaticファイルのサブサイトを含み, 現在のビルドの間変化しないファイルを提供するのに最適化されている. これが意味することは次のようである:

- 静的ファイルの識別子が生成されると(例えば, `static/mylogo.png`はmylogo_pngになる), クエリ文字列パラメータとしてファイルコンテンツのハッシュが付与される. これら全てはコンパイル時に起こる. 

- `yesod-static`が静的ファイルを提供する時, 遠い将来のexpirationヘッダをセットし, コンテントのハッシュに基づき, etagを含む. 

- `mylogo_png`へのリンクを含む際は常に, レンダリングはクエリ文字列パラメータを含む. もし, ロゴを変更する場合, 再コンパイルしてアプリケーションを立ち上げれば, クエリ文字列は変化するため, ユーザがキャッシュされたコピーを無視し, 新しいバージョンをダウンロードするようにする.

さらに, `Setting.hs`ファイルに特別な静的ルートをセットし, 異なるドメイン名から提供できるようにできる. これは静的ファイルリクエストに対しクッキーの送信を要しないという利点を持ち, また, CDNやAmazon S3サービスにホストすることで, 静的ファイルのオフロードを可能にする. より詳細については, ファイルのコメントを見よ.

他の最適化は, widgetに含まれるCSSやJavascriptはHTMLの中には含まれないことである. 代わりに, それらの中身は外部ファイルに書かれ, リンクが与えられる. このファイルは同様にコンテンツのハッシュに基づき命名される, すなはち次を意味する;

1. キャッシュが正しく機能する

2. Yesodは, 同じハッシュのファイルが存在すれば, CSS/Javascriptのファイルの中身を書くといった高くつくディスク書き込みを避けることができる.

最後に, すべてのJavascriptはhjsminを通し. 自動的に最小化される.

## 結論 

この章の目的はscaffoldedサイトに存在するすべての行を説明することではなく, それがどのように機能するかについて概観することである. よりそれに親しむための最良の方法は, そこに飛び込みYesodサイトを書き始めることである. 