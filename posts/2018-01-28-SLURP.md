---
title: SLURP (翻訳)
author: Michael Snoyman
translator: pythonissam
tags: Michael Snoyman's blog, 翻訳
---

## SLURP

Great original post: [SLURP](https://www.snoyman.com/blog/2018/01/slurp)

すでにコミュニティの多くの人々が SLURP の提案を見ていると思います。何人かの人たちに私の意見を聞かれたり、私が議論に参加しないことについて、まぁいろいろな意見をもらいました。この議題を私が避けてきた理由を今ここで書かせてください。著者はその提案をリリース前に教えてくれましたが、その時はサポートしないことを伝えました。私はまた、失礼にならないような形で SLURP へのコメントを控えていることも伝えました。残念ながら、その結果2つのことが起こりました。

- 人によっては、とても良くない影響を与えてしまいました。
- "fork" という用語の使い方の誤解、そして残念ながら開発者はその間違いを訂正していません。

つまりまとめると: 提案は私のものではなく、変更を頼んだわけでも、誰かの頭に銃を向けているわけでもありません。この説明は間違っています。他に出すことができるコメントはいくらでもありますが、正直価値はないでしょう。

間違ってはいないことは、私は日常的に多くの人や Haskell のコミュニティやエコシステムマネジメントチームと直面している問題についてコミュニケーションを取っています。仕事で幅広いユーザーと交流し、不満を聞けばそれを誰かに伝えます。私も不満を持つことがあって、それを誰かに聞いてもらいます。この不満の中には、全てが同じようなものを指しているものもあります。

私が公開できる情報というのは限られています。なぜなら、私に寄せられるかなり多くのコメントが、公にされることを嫌うようなプライベートなメールで書かれているからです。そして経験上、私のことを嘘つきだと誹謗中傷する人たちがいることも分かっています。この絶え間ない誹謗中傷を理由に発言を避けてきましたが、私はここに残しておくべきだと決断しました。わかったのは次の2つのことです。

- 私のやること成すこと全てが悪だと信じている人は、私が何か根拠を持っていてもそれを見ようとはしません。
- 私が悪魔ではないという可能性を否定しない人は、もしかしたら私の声明をその通りに受け取ってくれるかもしれないということです。

以前の私は、アーキテクチャとエコシステム開発についてオープンに議論していました。これはオープンソースコミュニティを作る唯一無二の方法だと私は信じています。Stack 対 cabal の時代の緊張が最も高まったときに、多くの人がオープンな議論に異論を唱えたため、私はより静かなコミュニケーションのチャネルに移ることにしました。これはとても残念なことだったと感じています。私はエコシステムの計画についてもっとオープンに、声高に議論をしたいと思っています。他の人たちが簡単に情報にたどり着けるようにしたいと思っています。私は閉じた扉の裏側で全てを議論することを強く反対します。オープンな議論が再開できるかどうかはいずれわかることでしょう。

## "fork" ってなに?

SLURP に関する議論の大部分が SLURP そのものとはなんの関係もないことは明らかですが、fork に関するコメントは関係があります。作者がドキュメントの中で fork という言葉を使うつもりだったのなら、私はまず、それを公式に発表することを期待したでしょう。これから、Stackage と Stack の世界で使われている fork という言葉の意味について、私が知っていることをお話しようと思います。その話が本当に作者たちの意図を反映しているのかどうか、それは作者たちの発言を待って確認するしかありません。

ここでいう "fork" という用語は、「何かソフトウェアのプロジェクトを取ってきて、ソースコードを他の場所にホストして、別名で開発を続ける」といった文字通りの意味で使われているわけではありません (私の定義ですが)。この用語は、より一般的な分割を指しています。例えば、Stack はコードなんて何も共有していないのに、多くの人に cabal-install の fork だと言われています (もちろん、Cabal みたいな下地となるライブラリは共有していますが)。

誰もが以下の点について固執しているので、明確に言及しておきましょう: 皆が皆 Hackage の直接の競争相手を作りたいと考えているような会話には、金輪際関わっていません。ゼロです。私が知っている人で、こういうことをしたい人はいません。私もしたくありません。今日の Stackage と Stack は Hackage あってこそのものです。そして私の知人で、この構図を変えたい人は誰一人としていません。Hackage をコントロールしたいなどと考えている人はいないのです。

Hackage の "fork" というと、論理的にそういう結論に至るかもしれません。が、私はこの考えが間違っていると断言することができます。

さて、 "fork" のような何かに繋がるかもしれない、具体的な頭痛のタネについて言及させてください。

<!--more-->

# Hackage のリビジョン
多くの人が、Hackage のリビジョンについて嫌悪感を公言しています。私は嫌いです。そして他の大多数の人よりも、嫌悪感を抱くに足る理由を持っています: 私は数週間から数ヶ月ほどの自分の人生を使って、いくつかのツールにリビジョンをサポートさせたことがあります。この凄惨な歴史を辿ることもできますが、価値はないでしょう: プログラマの戦記になるだけです。それよりも今に向き合いましょう。

Stack 1.6 に関して、私はついに、リビジョンピンを完全にサポートすることに成功しました。Stackage は既に長い間リビジョンピンを保持し続けています。Stackage はいくつかのパッケージを、リビジョンを無視しているものとしてリストアップする機能を持っています。

今聞かれたら、私はリビジョンが悪いアイディアで、無効にすべきだと答えるでしょう。そして、依存関係の解決に関する問題について、より良い解決方法があると依然として答えるでしょう (これらについては、過去に長々と議論したことがあります)。同時に、そのコストは下がっています。ユーザーが extra-deps に特定のリビジョンを付けていないこと、そして Hackage におけるリビジョンのルールが緩すぎることについては実際、いまだに心配です。これについて懸念を抱いていることは確かですが、私の中の優先順位的に一番上に来るものでもありません。

ところが他の人は違う考えを持っているようです。私は Hackage Truestee が強制的に cabalファイルを編集することについて腹を立てている多くの個人を知っています。彼らに反対することはありませんが、この話題に情熱を持っているわけでもありません。コミュニティのリーダーとの会話の中で、私はこの区別を明確に強調しました (少なくともそうしようとはしました)。

リビジョンに関する最大の懸念は、それの持つ社会的な影響です。すなわち、誰か別のものが自分のビルドの安定性を担うということです。これまでに何度も言及してきましたが、社会的緊張の原因の最たるものに、ビルドがいきなり止まったので上流の開発者に文句を言う、というものがあります。これは大惨事への第一歩で、PVP (Package Versioning Policy) + 依存解決という手法が取る基本的な流れです。代わりに、固定ビルドプランに焦点を当てたツールが必要です。私はこれを何年も主張してきました。結局、上流を説得することができなかったので Stack を大々的に作りました。

まとめると: リビジョンとはフォークのような何かなのでしょうか? 違います。

# キュレーション
数週間前、私はこんなツイートをしました:



Stackage の元のデザインは、標準の Linuxデストリビューションモデルに準拠していました。Hackage は私たちの上流でしたが、バージョンの境界が大きく壊れるのを防ぐために一連のパッチを整備し、あまりありませんでしたが時折 (たとえそうでも、正直覚えていませんが)、バグを修正するためにソースを編集したりしました。

2014年に Stackage を cabal と Haskell のプラットフォームに組み込む計画 (GPS Haskell のコードネームで開発していました。それが地面から飛び立つことは一度もありませんでしたが) について議論をしたとき、cabal, Hackage, そして Haskell Platform のメンテナーに、ローカルの変更を Stackage が整備しないことを要求されました。なので私はその機能を削除したのですが、それは私たちが今までいた世界の話です。

Adding that back is on the table. 次に理由を説明します。これはフォークと捉えることができて、ソフトフォークと呼ぶ人もいるかもしれません。これは正直なところ Stackage に追加し直したい機能ではありません。一連のパッチを整備するのは重労働なので。しかし、多くのコミュニティがこの作業を必要としています。私がこのことを理解しているように、Nix も理解しています。もしもこれをフォークと言うのなら、私たちのエコシステムに広く浸透しているフォークなんでしょう。

このキュレーションで扱う理由としては、新しい依存パッケージのバージョンに対応した、新しいバージョンを更新するのが遅いパッケージを避けるため、というものがあります。Stackage のパッケージメンテナーにとって、誰か他の人がその上限に満足しないからといって、自分のパッケージのバージョンを下げるのはかなりイライラするものがあるでしょう。キュレーションはこの辺の問題を何とかできるかもしれません。私はこれをおまけの特典のように考えていますが、必要なものではないです。

しかし、cabal-install界隈では問題になっていないが、Stackage や Stack界で問題を引き起こしているパッケージをどうにかする、というもっと重要な理由があります。ここ数ヶ月の間に何回も問題が起こるまで、私は本当の問題だとは意識していませんでした。[例えばこんな例があります](https://github.com/haskell-hvr/cassava/pull/155)

私はこの記事で、作者の誰かに何かを要求するつもりはありません。でも私は結局、これらの類の問題に多くの自分の時間を費やして対処してきています。これが現実です。私の友達や同僚は、緊急リリースポイントを切ったり、様々な持ち越し作業に巻き込まれています。即座に、Stack の何かを Cabal のライブラリの仕様に明記されているべきだが文書化されていないような何かのために変更しなければならないような状況。私の人生をここで浪費したくはありません。

Hackage は cabal-install を壊さないために、既に大きな苦労をしています。多くの人が、^>= 演算子の導入ががどのように Stack 1.5 を壊したのか聞いたことがあるのではないでしょうか。しかし実は、この演算子の導入は cabal-install 1.24 も壊していたのです。この事実を知っている人がいないのは、[Hackage がこれらのファイルを古いバージョンの cabal-install から隠すような措置を導入した](https://github.com/haskell/cabal/issues/4624)からです。このキュレーションのアイディアは、Stack の破壊に対応する術を Stackage に対して提供するものです。Hackage も同じ方法で cabal-install へのダメージに対処するでしょう。

そして、私は同じ類の処置を、Hackage から Stack へしてもらえないかとお願いしました。このお願いは、優先的な処置を求める声に後押しされています。この記事の読者は、各々の判断で自分がどう感じるか考えてください。

まとめると: 私は Stackage に上流のパッケージのパッチを当てられるようにしようとしています。私はこれをフォークではなくキュレーションだと考えています。他の人はフォークという言葉を使うかもしれませんが。

# Hackage へのアップロードを避ける
まず、これは私の好みですが、私のパッケージは Hackage に上げ続けたいと考えています。conduit や yesod, その他鋭意 Hackage でメンテ中の 80 を超えるパッケージの更新をやめるつもりも、そうしたいという願望もありません。そうは言っても、全員が全員同じように感じているわけではありません。

現在、Stackage は正に Hackage の下流になっています。最初にパッケージが Hackage にアップロードされない限り、そのパッケージを Stackage に入れることはできません。この状況は終わりを告げようとしています。およそ、現状を変えようとしているグループは以下の 3パターンに分けられるようです:

- 少なくとも一部の PVP支持者は、PVP に従わないパッケージ作成者に対して、そのパッケージを Hackage にアップロードしないように要請 (要求) しています。これは私が幾度となく指摘してきたように、Hackage公式のガイドラインと完全に矛盾しています。それにも関わらず、彼らはしつこく同じ趣旨の発言を続けています。

- PVP に反対する人の中には、基本的に 1 の状況が理由で、Hackage にアップロードしたくない、という人もいます。PVP の遵守という観点で、たくさんの張りつめた議論がありました。これを避けるための最も簡単な方法が、Hackage にアップロードしない、というものでした。私はこういった事情があって、Hackage や Stackage にコードをリリースしない人たちを知っています。しぶしぶこうしている人もいます。がその全員が同じ理由で Hackage を避けたがっています。

- 技術的に、中央レポジトリに手作業で tarball をアップロードするようなモデルは、時代遅れになってきていると感じる人もいます。そういった人たちは、タグやリリースブランチを使って自動化された、Gitベースのリリースに基づいたワークフローを考えています。これによる社会的な影響は何もなく、どちらかと言うと Hackage が現在サポートしていない、技術的に違うものを探してみたいという願望です。

1番目の状況は、私の大きな頭痛の種でした。私は Hackage管理のガイドラインと Hackage のルールを変更して、彼らの言動 (Hackage にアップロードしないように私的なメールで要求したり、個人や企業に対して、PVP に従っていないことを公に批判したり) について明確に禁止するようにお願いしてきました。実際、私が思うに、このお願いは究極的には SLURP に結びつくものです。私は変更しなければフォークするぞと脅したりしたでしょうか? あー、そう思いたいならそれでもいいでしょう。私は Hackage を使うのをやめようと言い続けてきました。完全にです。私はこの Hackage の使い方が許可されるように、公式のポリシーに対して変更を求めました。

現状を見たらわかりますが、Hackage のポリシーにそんな変更はされませんでした。私は 2 と 3 のグループに対して何を思うのか、言及していませんでしたね。しかし 3 の主張からもわかるように、Hackage とは別の代替パッケージレポジトリをホストしたりするのは全くもって意味がありません。なので、私はまたここで保証します。最も文字通りの Hackage の fork は、私も私が話しかけているあなたも誰も望んでいないものになるでしょう。

また他の選択肢は、Stackage に Hackage に加え、Gitレポジトリから直接パッケージをプルできるようにする、というものです。これは先に挙げた 問題1 に対するワークアラウンドとして議論されています。あることを主張して、一度離れてもう一度それを主張するようになる... なんてことはありません。私はむしろ、Hackage が全員からパッケージのアップロードを受け付けることを明確にすることを望んでいますし、それと比べれば Stackage を別のソースに対して解放するような要求は少なくなります (3番目のグループは純粋に技術的な観点から実験したいと思っているようですが)。

私は銃で誰かの頭を狙っているでしょうか? それはあなたが決めることです。これは最も私が思っていることに近い話です。

まとめると: これは潜在的な fork に最も近いもので、Gitレポジトリが Hackage の代替のソースとして許可されたらこうなります。

# まとめ
私は上記の問題を解決するための努力をするにあたって、複数の人と長く非公開な議論をしてきました。先ほども話したように、私はいつも公の場で行われる議論が好きです。SLURP の提案がどうなったかを鑑み、私はやはり解放的な議論はより良いという立場を取ろうと思います。"fork" という言葉を使って、とても多くの人を怖がらせてしまったことは申し訳なく思っています。本当に怖がっていた人に対して、私は鬼のようなことをしてしまっていたようです: 説明に 2日間待たせてしまい、申し訳ありませんでした。
